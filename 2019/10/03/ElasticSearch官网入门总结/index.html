<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="ElasticSearch 入门总结"/>




  <meta name="keywords" content="ElasticSearch, Corn1ng's Blog" />










  <link rel="alternate" href="/default" title="Corn1ng's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="https://corn1ng.github.io/2019/10/03/ElasticSearch官网入门总结/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> ElasticSearch 入门总结 - Corn1ng's Blog </title>\
    <style type="text/css">
    .content-wrapper:{top:200px;}
    .footer:{top:200px;}
    </style>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Corn1ng's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Corn1ng's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>
      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          ElasticSearch 入门总结
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-10-03
        </span>
        
          <div class="post-category">
            
              <a href="/categories/中间件/">中间件</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ElasticSearch-官网入门总结"><span class="toc-text">ElasticSearch 官网入门总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据的输入输出"><span class="toc-text">数据的输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#索引文档"><span class="toc-text">索引文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#取回一个文档"><span class="toc-text">取回一个文档</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#返回文档的一部分"><span class="toc-text">返回文档的一部分</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#检查文档是否存在"><span class="toc-text">检查文档是否存在</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更新整个文档"><span class="toc-text">更新整个文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建新文档"><span class="toc-text">创建新文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除文档"><span class="toc-text">删除文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文档的部分更新"><span class="toc-text">文档的部分更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#取回多个文档"><span class="toc-text">取回多个文档</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#搜索"><span class="toc-text">搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#空搜索"><span class="toc-text">空搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多索引-多类型"><span class="toc-text">多索引 多类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分页"><span class="toc-text">分页</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#映射和分析"><span class="toc-text">映射和分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#精确值-amp-全文"><span class="toc-text">精确值&amp;全文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分析与分析器"><span class="toc-text">分析与分析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#映射"><span class="toc-text">映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义域映射"><span class="toc-text">自定义域映射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#index"><span class="toc-text">index</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请求体查询"><span class="toc-text">请求体查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#查询表达式"><span class="toc-text">查询表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查询语句的结构"><span class="toc-text">查询语句的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查询与过滤"><span class="toc-text">查询与过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最重要的查询"><span class="toc-text">最重要的查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#短语搜索"><span class="toc-text">短语搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组合多查询"><span class="toc-text">组合多查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constant-score-查询"><span class="toc-text">constant_score 查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#验证查询"><span class="toc-text">验证查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#按照字段的值排序"><span class="toc-text">按照字段的值排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多级排序"><span class="toc-text">多级排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多值字段的排序"><span class="toc-text">多值字段的排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引管理"><span class="toc-text">索引管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#索引设置"><span class="toc-text">索引设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置分析器"><span class="toc-text">配置分析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义分析器"><span class="toc-text">自定义分析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类型与映射"><span class="toc-text">类型与映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根对象"><span class="toc-text">根对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#属性-属性的三个最重要的设置"><span class="toc-text">属性 属性的三个最重要的设置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态映射"><span class="toc-text">动态映射</span></a></li></ol></li></ol></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <h2 id="ElasticSearch-官网入门总结"><a href="#ElasticSearch-官网入门总结" class="headerlink" title="ElasticSearch 官网入门总结"></a>ElasticSearch 官网入门总结</h2><p>Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene基础之上。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库–无论是开源还是私有。</p>
<h3 id="数据的输入输出"><a href="#数据的输入输出" class="headerlink" title="数据的输入输出"></a>数据的输入输出</h3><h4 id="索引文档"><a href="#索引文档" class="headerlink" title="索引文档"></a>索引文档</h4><p>通过使用index API，文档可以被索引。</p>
<ul>
<li>使用自定义的ID</li>
</ul>
<p>如果你的文档有一个自然的标识符 （例如，一个 <code>user_account</code> 字段或其他标识文档的值），你应该使用如下方式的 <code>index</code> API 并提供你自己 <code>_id</code> ：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"field"</span>: <span class="string">"value"</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自增ID</li>
</ul>
<p>如果你的数据没有自然的 ID， Elasticsearch 可以帮我们自动生成 ID 。 请求的结构调整为： 不再使用 <code>PUT</code> 谓词(“使用这个 URL 存储这个文档”)， <strong>而是使用 <code>POST</code> 谓词</strong>(“存储文档在这个 URL 命名空间下”)。现在该 URL 只需包含 <code>_index</code> 和 <code>_type</code> 。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"My second blog entry"</span>,</span><br><span class="line">  <span class="attr">"text"</span>:  <span class="string">"Still trying this out..."</span>,</span><br><span class="line">  <span class="attr">"date"</span>:  <span class="string">"2014/01/01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="取回一个文档"><a href="#取回一个文档" class="headerlink" title="取回一个文档"></a>取回一个文档</h4><p>为了从 Elasticsearch 中检索出文档，我们仍然使用相同的 <code>_index</code> , <code>_type</code> , 和 <code>_id</code> ，但是 HTTP 谓词更改为 <code>GET</code> 。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/123?pretty</span><br></pre></td></tr></table></figure>
<h5 id="返回文档的一部分"><a href="#返回文档的一部分" class="headerlink" title="返回文档的一部分"></a>返回文档的一部分</h5><p>默认情况下， <code>GET</code> 请求会返回整个文档，这个文档正如存储在 <code>_source</code> 字段中的一样。但是也许你只对其中的 <code>title</code> 字段感兴趣。单个字段能用 <code>_source</code> 参数请求得到，多个字段也能使用逗号分隔的列表来指定。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/123?_source=title,text</span><br></pre></td></tr></table></figure>
<h4 id="检查文档是否存在"><a href="#检查文档是否存在" class="headerlink" title="检查文档是否存在"></a>检查文档是否存在</h4><p>如果只想检查一个文档是否存在–根本不想关心内容—那么用 <code>HEAD</code> 方法来代替 <code>GET</code> 方法。 <code>HEAD</code> 请求没有返回体，只返回一个 HTTP 请求报头：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XHEAD http:<span class="comment">//localhost:9200/website/blog/123</span></span><br></pre></td></tr></table></figure>
<p>如果文档存在， Elasticsearch 将返回一个 <code>200 ok</code> 的状态码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: text/plain; charset=UTF<span class="number">-8</span></span><br><span class="line">Content-Length: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>若文档不存在， Elasticsearch 将返回一个 <code>404 Not Found</code> 的状态码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XHEAD http:<span class="comment">//localhost:9200/website/blog/124</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">404</span> Not Found</span><br><span class="line">Content-Type: text/plain; charset=UTF<span class="number">-8</span></span><br><span class="line">Content-Length: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="更新整个文档"><a href="#更新整个文档" class="headerlink" title="更新整个文档"></a>更新整个文档</h4><p>同样使用PUT 即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/<span class="number">123</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"My first blog entry"</span>,</span><br><span class="line">  <span class="string">"text"</span>:  <span class="string">"I am starting to get the hang of this..."</span>,</span><br><span class="line">  <span class="string">"date"</span>:  <span class="string">"2014/01/02"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在响应体中，我们能看到 Elasticsearch 已经增加了 <code>_version</code> 字段值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_index"</span> :   <span class="string">"website"</span>,</span><br><span class="line">  <span class="string">"_type"</span> :    <span class="string">"blog"</span>,</span><br><span class="line">  <span class="string">"_id"</span> :      <span class="string">"123"</span>,</span><br><span class="line">  <span class="string">"_version"</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="string">"created"</span>:   <span class="literal">false</span>  <span class="comment">// false 表示相同的索引，类型和ID的文档已经存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内部，Elasticsearch 已将旧文档标记为已删除，并增加一个全新的文档。 尽管你不能再对旧版本的文档进行访问，但它并不会立即消失。</p>
<h4 id="创建新文档"><a href="#创建新文档" class="headerlink" title="创建新文档"></a>创建新文档</h4><p>当我们索引一个文档，怎么确认我们正在创建一个完全新的文档，而不是覆盖现有的呢？ <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 的组合可以唯一标识一个文档。所以，<strong>确保创建一个新文档的最简单办法是，使用索引请求的 <code>POST</code> 形式让 Elasticsearch 自动生成唯一 <code>_id</code> :</strong></p>
<h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /website/blog/<span class="number">123</span></span><br></pre></td></tr></table></figure>
<h4 id="文档的部分更新"><a href="#文档的部分更新" class="headerlink" title="文档的部分更新"></a>文档的部分更新</h4><p>使用update API 还可以部分更新文档。<strong>文档是不可变的</strong>：他们不能被修改，只能被替换。 <code>update</code> API 必须遵循同样的规则。 从外部来看，我们在一个文档的某个位置进行部分更新。然而在内部， <code>update</code> API 简单使用与之前描述相同的 <strong>检索-修改-重建索引</strong> 的处理过程。 区别在于这个过程发生在分片内部，这样就避免了多次请求的网络开销。通过减少检索和重建索引步骤之间的时间，我们也减少了其他进程的变更带来冲突的可能性。</p>
<p><code>update</code> 请求最简单的一种形式是接收文档的一部分作为 <code>doc</code> 的参数， 它只是与现有的文档进行合并。对象被合并到一起，覆盖现有的字段，增加新的字段。 例如，我们增加字段 <code>tags</code> 和 <code>views</code> 到我们的博客文章。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/<span class="number">1</span>/_update</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"doc"</span> : &#123;</span><br><span class="line">      <span class="string">"tags"</span> : [ <span class="string">"testing"</span> ],</span><br><span class="line">      <span class="string">"views"</span>: <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="取回多个文档"><a href="#取回多个文档" class="headerlink" title="取回多个文档"></a>取回多个文档</h4><p>如果你需要从 Elasticsearch 检索很多文档，那么使用 <em>multi-get</em> 或者 <code>mget</code> API 来将这些检索请求放在一个请求中，将比逐个文档请求更快地检索到全部文档。</p>
<p><code>mget</code> API 要求有一个 <code>docs</code> 数组作为参数，每个元素包含需要检索文档的元数据， 包括 <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 。如果你想检索一个或者多个特定的字段，那么你可以通过 <code>_source</code> 参数来指定这些字段的名字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"docs"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">"_index"</span> : <span class="string">"website"</span>,</span><br><span class="line">         <span class="string">"_type"</span> :  <span class="string">"blog"</span>,</span><br><span class="line">         <span class="string">"_id"</span> :    <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">"_index"</span> : <span class="string">"website"</span>,</span><br><span class="line">         <span class="string">"_type"</span> :  <span class="string">"pageviews"</span>,</span><br><span class="line">         <span class="string">"_id"</span> :    <span class="number">1</span>,</span><br><span class="line">         <span class="string">"_source"</span>: <span class="string">"views"</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>搜索（search） 可以做到：</p>
<ul>
<li>在类似于 <code>gender</code> 或者 <code>age</code> 这样的字段 上使用结构化查询，<code>join_date</code> 这样的字段上使用排序，就像SQL的结构化查询一样。</li>
<li>全文检索，找出所有匹配关键字的文档并按照<em>相关性（relevance）</em> 排序后返回结果。</li>
<li>以上二者兼而有之。</li>
</ul>
<p>很多搜索都是开箱即用的，为了充分挖掘 Elasticsearch 的潜力，需要理解以下三个概念：</p>
<ul>
<li><p><em>映射（Mapping）</em></p>
<p>描述数据在每个字段内如何存储</p>
</li>
<li><p><em>分析（Analysis）</em></p>
<p>全文是如何处理使之可以被搜索的</p>
</li>
<li><p><em>领域特定查询语言（Query DSL）</em></p>
<p>Elasticsearch 中强大灵活的查询语言</p>
</li>
</ul>
<h4 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h4><p>最基础的形式是没有指定任何查询的空搜索 ，它简单地返回集群中所有索引下的所有文档：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">GET /search</span><br><span class="line">---------------------------------</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"hits"</span> : &#123;</span><br><span class="line">      <span class="attr">"total"</span> :       <span class="number">14</span>,</span><br><span class="line">      <span class="attr">"hits"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"_index"</span>:   <span class="string">"us"</span>,</span><br><span class="line">          <span class="attr">"_type"</span>:    <span class="string">"tweet"</span>,</span><br><span class="line">          <span class="attr">"_id"</span>:      <span class="string">"7"</span>,</span><br><span class="line">          <span class="attr">"_score"</span>:   <span class="number">1</span>,</span><br><span class="line">          <span class="attr">"_source"</span>: &#123;</span><br><span class="line">             <span class="attr">"date"</span>:    <span class="string">"2014-09-17"</span>,</span><br><span class="line">             <span class="attr">"name"</span>:    <span class="string">"John Smith"</span>,</span><br><span class="line">             <span class="attr">"tweet"</span>:   <span class="string">"The Query DSL is really powerful and flexible"</span>,</span><br><span class="line">             <span class="attr">"user_id"</span>: <span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">        ... <span class="number">9</span> RESULTS REMOVED ...</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"max_score"</span> :   <span class="number">1</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"took"</span> :           <span class="number">4</span>,</span><br><span class="line">   <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">      <span class="attr">"failed"</span> :      <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"successful"</span> :  <span class="number">10</span>,</span><br><span class="line">      <span class="attr">"total"</span> :       <span class="number">10</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"timed_out"</span> :      <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果中最重要的部分是hits,它包含total字段来表示匹配到的文档总数，并且一个hits数组包含所查询结果的前十个文档。在 <code>hits</code> 数组中每个结果包含文档的 <code>_index</code> 、 <code>_type</code> 、 <code>_id</code> ，加上 <code>_source</code> 字段。这意味着我们可以直接从返回的搜索结果中使用整个文档。每个结果还有一个 <code>_score</code> ，它衡量了文档与查询的匹配程度。默认情况下，首先返回最相关的文档结果，就是说，返回的文档是按照 <code>_score</code> 降序排列的。</p>
<p>took字段告诉执行整个搜索请求耗费了多少毫秒。shards部分告诉我们在查询中参与分片的总数，以及这些分片成功了多少失败了多少。<code>timed_out</code> 值告诉查询是否超时。</p>
<h4 id="多索引-多类型"><a href="#多索引-多类型" class="headerlink" title="多索引 多类型"></a>多索引 多类型</h4><p>经常的情况下，在一个或多个特殊的索引并且在一个或者多个特殊的类型中进行搜索。可以通过在URL中指定特殊的索引和类型达到这种效果，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/_search</span><br><span class="line">在所有的索引中搜索所有的类型</span><br><span class="line">/gb/_search</span><br><span class="line">在 gb 索引中搜索所有的类型</span><br><span class="line">/gb,us/_search</span><br><span class="line">在 gb 和 us 索引中搜索所有的文档</span><br><span class="line">/g*,u*/_search</span><br><span class="line">在任何以 g 或者 u 开头的索引中搜索所有的类型</span><br><span class="line">/gb/user/_search</span><br><span class="line">在 gb 索引中搜索 user 类型</span><br><span class="line">/gb,us/user,tweet/_search</span><br><span class="line">在 gb 和 us 索引中搜索 user 和 tweet 类型</span><br><span class="line">/_all/user,tweet/_search</span><br><span class="line">在所有的索引中搜索 user 和 tweet 类型</span><br></pre></td></tr></table></figure>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>Elasticsearch 接受 <code>from</code> 和 <code>size</code> 参数：</p>
<p><code>size</code>显示应该返回的结果数量，默认是 10     <code>from</code>显示应该跳过的初始结果数量，默认是 0</p>
<p>如果每页展示 5 条结果，可以用下面方式请求得到 1 到 3 页的结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?size=5</span><br><span class="line">GET /_search?size=5&amp;from=5</span><br><span class="line">GET /_search?size=5&amp;from=10</span><br></pre></td></tr></table></figure>
<h3 id="映射和分析"><a href="#映射和分析" class="headerlink" title="映射和分析"></a>映射和分析</h3><h4 id="精确值-amp-全文"><a href="#精确值-amp-全文" class="headerlink" title="精确值&amp;全文"></a>精确值&amp;全文</h4><p>Elasticsearch中的数据可以概括的分为两类：<strong>精确值和全文</strong>。</p>
<p><em>精确值</em> 如它们听起来那样精确。例如日期或者用户 ID，但字符串也可以表示精确值，例如用户名或邮箱地址。对于精确值来讲，<code>Foo</code> 和 <code>foo</code> 是不同的，<code>2014</code> 和 <code>2014-09-15</code> 也是不同的。</p>
<p><em>全文</em> 是指文本数据（通常以人类容易识别的语言书写），例如一个推文的内容或一封邮件的内容。</p>
<p>我们很少对全文类型的域做精确匹配。相反，我们希望在文本类型的域中搜索。不仅如此，我们还希望搜索能够理解我们的 <em>意图</em> ：例如搜索UK 也会返回包含United Kindom 的文档等。</p>
<p>这需要分析器的帮助。</p>
<h4 id="分析与分析器"><a href="#分析与分析器" class="headerlink" title="分析与分析器"></a>分析与分析器</h4><p><em>分析</em> 包含下面的过程：</p>
<ul>
<li>首先，将一块文本分成适合于倒排索引的独立的 <em>词条</em> ，</li>
<li>之后，将这些词条统一化为标准格式以提高它们的“可搜索性”，或者 <em>recall</em></li>
</ul>
<p>分析器执行上面的工作。 <em>分析器</em> 实际上是将三个功能封装到了一个包里：</p>
<ul>
<li><p>字符过滤器</p>
<p>首先，字符串按顺序通过每个 <em>字符过滤器</em> 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 <code>&amp;</code> 转化成 <code>and</code>。</p>
</li>
<li><p>分词器</p>
<p>其次，字符串被 <em>分词器</em> 分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。</p>
</li>
<li><p>Token 过滤器</p>
<p>最后，词条按顺序通过每个 <em>token 过滤器</em> 。这个过程可能会改变词条（例如，小写化 <code>Quick</code> ），删除词条（例如， 像 <code>a</code>， <code>and</code>， <code>the</code> 等无用词），或者增加词条（例如，像 <code>jump</code> 和 <code>leap</code> 这种同义词）。</p>
</li>
</ul>
<hr>
<p>什么时候使用分析器？？？</p>
<p><strong>当我们 <em>索引</em> 一个文档，它的全文域被分析成词条以用来创建倒排索引。 但是，当我们在全文域 <em>搜索</em> 的时候，我们需要将查询字符串通过 <em>相同的分析过程</em> ，以保证我们搜索的词条格式与索引中的词条格式一致。</strong></p>
<p><strong>全文查询，理解每个域是如何定义的，因此它们可以做正确的事：</strong></p>
<ul>
<li><strong>当你查询一个 <em>全文</em> 域时， 会对查询字符串应用相同的分析器，以产生正确的搜索词条列表。</strong></li>
<li><strong>当你查询一个 <em>精确值</em> 域时，不会分析查询字符串，而是搜索你指定的精确值。</strong></li>
</ul>
<p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/analysis-intro.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/analysis-intro.html</a></p>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>为了能够将时间域视为时间，数字域视为数字，字符串域视为全文或精确值字符串， Elasticsearch 需要知道每个域中数据的类型。这个信息<strong>包含在映射</strong>中。</p>
<p>Elasticsearch 支持 如下简单域类型：</p>
<ul>
<li>字符串: <code>string</code></li>
<li>整数 : <code>byte</code>, <code>short</code>, <code>integer</code>, <code>long</code></li>
<li>浮点数: <code>float</code>, <code>double</code></li>
<li>布尔型: <code>boolean</code></li>
<li>日期: <code>date</code></li>
</ul>
<p>当你索引一个包含新域的文档–之前未曾出现– Elasticsearch 会使用 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/dynamic-mapping.html" target="_blank" rel="noopener"><em>动态映射</em></a> ，通过JSON中基本数据类型，尝试猜测域类型，使用如下规则.</p>
<p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191008104600.png" alt=""></p>
<p>通过 <code>/_mapping</code> ，我们可以查看 Elasticsearch 在一个或多个索引中的一个或多个类型的映射 。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//取得索引 gb 中类型 tweet 的映射</span><br><span class="line">GET /gb/_mapping/tweet</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"gb"</span>: &#123;</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">         <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">               <span class="attr">"date"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">                  <span class="attr">"format"</span>: <span class="string">"strict_date_optional_time||epoch_millis"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"name"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"user_id"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义域映射"><a href="#自定义域映射" class="headerlink" title="自定义域映射"></a>自定义域映射</h4><p>尽管在很多情况下基本域数据类型 已经够用，但你经常需要为单独域自定义映射 ，特别是字符串域。自定义映射允许你执行下面的操作：</p>
<ul>
<li>全文字符串域和精确值字符串域的区别</li>
<li>使用特定语言分析器</li>
<li>优化域以适应部分匹配</li>
<li>指定自定义数据格式</li>
<li>还有更多</li>
</ul>
<p>域最重要的属性是 <code>type</code> 。对于不是 <code>string</code> 的域，一般只需要设置 <code>type</code> 。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"number_of_clicks"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"integer"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认， <code>string</code> 类型域会被认为包含全文。就是说，它们的值在索引前，会通过 一个分析器，针对于这个域的查询在搜索前也会经过一个分析器。</p>
<p><code>string</code> 域映射的两个最重要 属性是 <code>index</code> 和 <code>analyzer</code> 。</p>
<h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><p><code>index</code> 属性控制怎样索引字符串。它可以是下面三个值：</p>
<ul>
<li><p><code>analyzed</code></p>
<p>首先分析字符串，然后索引它。换句话说，以全文索引这个域。</p>
</li>
<li><p><code>not_analyzed</code></p>
<p>  索引这个域，所以它能够被搜索，但索引的是精确值。不会对它进行分析。</p>
</li>
<li><p><code>no</code></p>
<p>不索引这个域。这个域不会被搜索到。</p>
</li>
</ul>
<p><code>string</code> 域 <code>index</code> 属性默认是 <code>analyzed</code> 。如果我们想映射这个字段为一个精确值，我们需要设置它为 <code>not_analyzed</code> ：</p>
<h3 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h3><h4 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h4><p>查询表达式(Query DSL)是一种非常灵活又富有表现力的 查询语言。 Elasticsearch 使用它可以以简单的 JSON 接口来展现 Lucene 功能的绝大部分。在应用中，应该用它来编写查询语句。它可以使你的查询语句更灵活、更精确、易读和易调试。</p>
<p>要使用这种查询表达式，只需将查询语句传递给 <code>query</code> 参数：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: YOUR_QUERY_HERE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询语句的结构"><a href="#查询语句的结构" class="headerlink" title="查询语句的结构"></a>查询语句的结构</h4><p>一个查询语句的典型结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    QUERY_NAME: &#123;</span><br><span class="line">        ARGUMENT: VALUE,</span><br><span class="line">        ARGUMENT: VALUE,...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是针对某个字段，那么它的结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    QUERY_NAME: &#123;</span><br><span class="line">        FIELD_NAME: &#123;</span><br><span class="line">            ARGUMENT: VALUE,</span><br><span class="line">            ARGUMENT: VALUE,...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------</span><br><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"match"</span>: &#123;           <span class="comment">/////// QUERY NAME</span></span><br><span class="line">            <span class="string">"tweet"</span>: <span class="string">"elasticsearch"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>查询语句(Query clauses)</em> 就像一些简单的组合块 ，这些组合块可以彼此之间合并组成更复杂的查询。这些语句可以是如下形式：</p>
<ul>
<li><em>叶子语句（Leaf clauses）</em> (就像 <code>match</code> 语句) 被用于将查询字符串和一个字段（或者多个字段）对比。</li>
<li><em>复合(Compound)</em> 语句 主要用于 合并其它查询语句。 比如，一个 <code>bool</code> 语句 允许在你需要的时候组合其它语句，无论是 <code>must</code> 匹配、 <code>must_not</code> 匹配还是 <code>should</code> 匹配，同时它可以包含不评分的过滤器（filters） 。</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tweet"</span>: <span class="string">"elasticsearch"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>:  <span class="string">"mary"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>:   &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tweet"</span>: <span class="string">"full text"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"filter"</span>:   &#123; <span class="attr">"range"</span>: &#123; <span class="attr">"age"</span> : &#123; <span class="attr">"gt"</span> : <span class="number">30</span> &#125;&#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询与过滤"><a href="#查询与过滤" class="headerlink" title="查询与过滤"></a>查询与过滤</h4><p>Elasticsearch 使用的查询语言（DSL） 拥有一套查询组件，这些组件可以以无限组合的方式进行搭配。这套组件可以在以下两种情况下使用：过滤情况（filtering context）和查询情况（query context）。</p>
<p>当使用于 <em>过滤情况</em> 时，查询被设置成一个“不评分”或者“过滤”查询。即，这个查询只是简单的问一个问题：“这篇文档是否匹配？”。回答也是非常的简单，yes 或者 no ，二者必居其一。</p>
<p>当使用于 <em>查询情况</em> 时，查询就变成了一个“评分”的查询。和不评分的查询类似，也要去判断这个文档是否匹配，同时它还需要判断这个文档匹配的有_多好_（匹配程度如何）。 此查询的典型用法是用于查找以下文档。</p>
<ul>
<li>查找与 <code>full text search</code> 这个词语最佳匹配的文档</li>
<li>包含 <code>run</code> 这个词，也能匹配 <code>runs</code> 、 <code>running</code> 、 <code>jog</code> 或者 <code>sprint</code></li>
<li>包含 <code>quick</code> 、 <code>brown</code> 和 <code>fox</code> 这几个词 — 词之间离的越近，文档相关性越高</li>
<li>标有 <code>lucene</code> 、 <code>search</code> 或者 <code>java</code> 标签 — 标签越多，相关性越高</li>
</ul>
<p>一个评分查询计算每一个文档与此查询的 <em>相关程度</em>，同时将这个相关程度分配给表示相关性的字段 <code>_score</code>，并且按照相关性对匹配到的文档进行排序。这种相关性的概念是非常适合全文搜索的情况，因为全文搜索几乎没有完全 “正确” 的答案。</p>
<p><strong>在性能方面，过滤查询要比评分查询快的多，同时，评分查询还不缓存。因此过滤（filtering）的目标是减少那些需要通过评分查询（scoring queries）进行检查的文档。</strong></p>
<p>通常的规则是，使用 查询（query）语句来进行 <em>全文</em> 搜索或者其它任何需要影响 <em>相关性得分</em> 的搜索。除此以外的情况都使用过滤（filters)。</p>
<h4 id="最重要的查询"><a href="#最重要的查询" class="headerlink" title="最重要的查询"></a>最重要的查询</h4><ul>
<li>match_all</li>
</ul>
<p><code>match_all</code> 查询简单的匹配所有文档。在没有指定查询方式时，它是默认的查询：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"match_all"</span>: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>match</li>
</ul>
<p>无论你在任何字段上进行的是全文搜索还是精确查询，<code>match</code> 查询是你可用的标准查询。</p>
<p>如果你在一个全文字段上使用 <code>match</code> 查询，在执行查询前，它将用正确的分析器去分析查询字符串：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tweet"</span>: <span class="string">"About Search"</span> &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如果在一个精确值的字段上使用它， 例如数字、日期、布尔或者一个 <code>not_analyzed</code> 字符串字段，那么它将会精确匹配给定的值。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"age"</span>:    <span class="number">26</span>           &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"date"</span>:   <span class="string">"2014-09-01"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"public"</span>: <span class="literal">true</span>         &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>:    <span class="string">"full_text"</span>  &#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>multi_match</li>
</ul>
<p><code>multi_match</code> 查询可以在多个字段上执行相同的 <code>match</code> 查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">        <span class="attr">"query"</span>:    <span class="string">"full text search"</span>,</span><br><span class="line">        "fields":   [ "title", "body" ]  //在title ,body两个字段上搜索</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>range</li>
</ul>
<p><code>range</code> 查询找出那些落在指定区间内的数字或者时间。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"range"</span>: &#123;</span><br><span class="line">        <span class="attr">"age"</span>: &#123;</span><br><span class="line">            <span class="attr">"gte"</span>:  <span class="number">20</span>,</span><br><span class="line">            <span class="attr">"lt"</span>:   <span class="number">30</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line">gt大于   gte大于等于   lt小于  lte小于等于</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>term</strong></li>
</ul>
<p><code>term</code> 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些 <code>not_analyzed</code> 的字符串。<code>term</code> 查询对于输入的文本<strong>不分析</strong> ，所以它将给定的值进行精确查询。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"term"</span>: &#123; <span class="attr">"age"</span>:    <span class="number">26</span>           &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"term"</span>: &#123; <span class="attr">"date"</span>:   <span class="string">"2014-09-01"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"term"</span>: &#123; <span class="attr">"public"</span>: <span class="literal">true</span>         &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"term"</span>: &#123; <span class="attr">"tag"</span>:    <span class="string">"full_text"</span>  &#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>terms</li>
</ul>
<p><code>terms</code> 查询和 <code>term</code> 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"terms"</span>: &#123; <span class="attr">"tag"</span>: [ <span class="string">"search"</span>, <span class="string">"full_text"</span>, <span class="string">"nosql"</span> ] &#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Exists 和missing</li>
</ul>
<p><code>exists</code> 查询和 <code>missing</code> 查询被用于查找那些指定字段中有值 (<code>exists</code>) 或无值 (<code>missing</code>) 的文档。这与SQL中的 <code>IS_NULL</code> (<code>missing</code>) 和 <code>NOT IS_NULL</code> (<code>exists</code>) 在本质上具有共性。</p>
<h4 id="短语搜索"><a href="#短语搜索" class="headerlink" title="短语搜索"></a>短语搜索</h4><p>找出一个属性中的独立单词是没有问题的，但有时候想要精确匹配一系列单词或者<em>短语</em> 。 比如， 我们想执行这样一个查询，仅匹配同时包含 “rock” <em>和</em> “climbing” ，<em>并且</em> 二者以短语 “rock climbing” 的形式紧挨着的雇员记录。</p>
<p>为此对 <code>match</code> 查询稍作调整，使用一个叫做 <code>match_phrase</code> 的查询。返回的就只有同时满足rock 和climbing 连着的记录了。</p>
<h4 id="组合多查询"><a href="#组合多查询" class="headerlink" title="组合多查询"></a>组合多查询</h4><p>现实的查询需要在多个字段上查询多种多样的文本，并且根据一系列的标准来过滤。为了构建类似的高级查询，需要一种能够将多查询组合成单一查询的查询方法。这就是bool查询。这种查询将多查询组合在一起，成为用户自己想要的布尔查询。它接收下面的参数：</p>
<ul>
<li>must 文档<strong>必须</strong>匹配这些条件才能被包含进来。</li>
<li>must_not 文档<strong>必须</strong>不匹配这些条件才能被包含进来。</li>
<li>should 如果满足这些语句中的任意语句，将增加_score， 否则，无任何影响，主要用于修正每个文档的相关性得分。</li>
<li>filter <strong>必须匹配</strong>,但它以不评分，过滤模式来进行，这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果没有 must 语句，那么至少需要能够匹配其中的一条 should 语句。但，如果存在至少一条 must 语句，则对 should 语句的匹配没有要求。</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>:   <span class="string">"spam"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>: <span class="string">"starred"</span> &#125;&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"filter"</span>: &#123;</span><br><span class="line">          <span class="attr">"range"</span>: &#123; <span class="attr">"date"</span>: &#123; <span class="attr">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你需要通过多个不同的标准来过滤你的文档，<code>bool</code> 查询本身也可以被用做不评分的查询。简单地将它放置到 <code>filter</code> 语句中并在内部构建布尔逻辑。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>:   <span class="string">"spam"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>: <span class="string">"starred"</span> &#125;&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"filter"</span>: &#123;</span><br><span class="line">          <span class="attr">"bool"</span>: &#123;</span><br><span class="line">              <span class="attr">"must"</span>: [</span><br><span class="line">                  &#123; <span class="attr">"range"</span>: &#123; <span class="attr">"date"</span>: &#123; <span class="attr">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125;&#125;,</span><br><span class="line">                  &#123; <span class="attr">"range"</span>: &#123; <span class="attr">"price"</span>: &#123; <span class="attr">"lte"</span>: <span class="number">29.99</span> &#125;&#125;&#125;</span><br><span class="line">              ],</span><br><span class="line">              <span class="attr">"must_not"</span>: [</span><br><span class="line">                  &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"category"</span>: <span class="string">"ebooks"</span> &#125;&#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="constant-score-查询"><a href="#constant-score-查询" class="headerlink" title="constant_score 查询"></a>constant_score 查询</h4><p>尽管没有 <code>bool</code> 查询使用这么频繁，<code>constant_score</code> 查询也是一种有用的查询工具。它将一个不变的常量评分应用于所有匹配的文档。它被经常用于只需要执行一个 filter 而没有其它查询（例如，评分查询）的情况下。</p>
<p><strong>可以使用它来取代只有 filter 语句的 <code>bool</code> 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"constant_score"</span>:   &#123;</span><br><span class="line">        <span class="attr">"filter"</span>: &#123;</span><br><span class="line">            <span class="attr">"term"</span>: &#123; <span class="attr">"category"</span>: <span class="string">"ebooks"</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="验证查询"><a href="#验证查询" class="headerlink" title="验证查询"></a>验证查询</h4><p>查询可以写的非常复杂，通过validate-query API可以用来验证查询是否合法。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/tweet/_validate/query</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span>: &#123;</span><br><span class="line">      <span class="attr">"tweet"</span> : &#123;</span><br><span class="line">         <span class="attr">"match"</span> : <span class="string">"really powerful"</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"valid"</span> :         <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">    <span class="attr">"total"</span> :       <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successful"</span> :  <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span> :      <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了找出 查询不合法的原因，可以将 <code>explain</code> 参数 加到查询字符串中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/tweet/_validate/query?explain</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>为了按照相关性来排序，需要将相关性表示为一个数值，在ES中，相关性得分由一个浮点数进行表示，并在搜索结果中通过<code>_score</code>参数返回，默认排序是<code>_score</code>降序。</p>
<h4 id="按照字段的值排序"><a href="#按照字段的值排序" class="headerlink" title="按照字段的值排序"></a>按照字段的值排序</h4><p>通过时间来对 tweets 进行排序是有意义的，最新的 tweets 排在最前。 我们可以使用 <code>sort</code> 参数进行实现。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"filter"</span> : &#123; <span class="attr">"term"</span> : &#123; <span class="attr">"user_id"</span> : <span class="number">1</span> &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: &#123; <span class="attr">"date"</span>: &#123; <span class="attr">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h4><p>假定我们想要结合使用 <code>date</code> 和 <code>_score</code> 进行查询，并且匹配的结果首先按照日期排序，然后按照相关性排序。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"must"</span>:   &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tweet"</span>: <span class="string">"manage text search"</span> &#125;&#125;,</span><br><span class="line">            <span class="attr">"filter"</span> : &#123; <span class="attr">"term"</span> : &#123; <span class="attr">"user_id"</span> : <span class="number">2</span> &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: [</span><br><span class="line">        &#123; <span class="attr">"date"</span>:   &#123; <span class="attr">"order"</span>: <span class="string">"desc"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"_score"</span>: &#123; <span class="attr">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>排序条件的顺序是很重要的。结果首先按第一个条件排序，仅当结果集的第一个 <code>sort</code> 值完全相同时才会按照第二个条件进行排序，以此类推。</p>
<p>多级排序并不一定包含 <code>_score</code> 。可以根据一些不同的字段进行排序， 如地理距离或是脚本计算的特定值。</p>
<h4 id="多值字段的排序"><a href="#多值字段的排序" class="headerlink" title="多值字段的排序"></a>多值字段的排序</h4><p>一种情形是字段有多个值的排序， 需要记住这些值并没有固有的顺序；一个多值的字段仅仅是多个值的包装，这时应该选择哪个进行排序呢？</p>
<p>对于数字或日期，你可以将多值字段减为单值，这可以通过使用 <code>min</code> 、 <code>max</code> 、 <code>avg</code> 或是 <code>sum</code> <em>排序模式</em> 。 例如你可以按照每个 <code>date</code> 字段中的最早日期进行排序，通过以下方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"sort"</span>: &#123;</span><br><span class="line">    <span class="string">"dates"</span>: &#123;</span><br><span class="line">        <span class="string">"order"</span>: <span class="string">"asc"</span>,</span><br><span class="line">        <span class="string">"mode"</span>:  <span class="string">"min"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><p>之前创建的索引都是默认的配置，新的字段通过动态映射的方式被添加到类型映射，现在我们需要对这个建立索引的过程做更多的控制，想要确保这个索引有数量适中的主分片，并且在我们索引任何数据 <em>之前</em> ，分析器和映射已经被建立好。</p>
<p>为了达到这个目的，需要手动创建索引，在请求体里面传入设置或类型映射，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    "settings": &#123; ... any settings ... &#125;,</span><br><span class="line">    "mappings": &#123;</span><br><span class="line">        "type_one": &#123; ... any mappings ... &#125;,</span><br><span class="line">        "type_two": &#123; ... any mappings ... &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="索引设置"><a href="#索引设置" class="headerlink" title="索引设置"></a>索引设置</h4><p>通过修改配置来自定义索引行为。</p>
<p>下面是两个最重要的设置：</p>
<ul>
<li><p><code>number_of_shards</code></p>
<p>每个索引的主分片数，默认值是 <code>5</code> 。这个配置在索引创建后不能修改。</p>
</li>
<li><p><code>number_of_replicas</code></p>
<p>每个主分片的副本数，默认值是 <code>1</code> 。对于活动的索引库，这个配置可以随时修改。</p>
</li>
</ul>
<p>例如创建一个只有一个主分片，没有副本的小索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_temp_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;number_of_shards&quot; :   1,</span><br><span class="line">        &quot;number_of_replicas&quot; : 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置分析器"><a href="#配置分析器" class="headerlink" title="配置分析器"></a>配置分析器</h4><p>第三个重要的索引设置是analysis部分，用来配置已存在的分析器或针对你的索引创建新的自定义分析器。standred分析器是用于全文字段的默认分析器，用于将全文字符串转换为适合搜索的倒排索引。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /spanish_docs</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"analysis"</span>: &#123;</span><br><span class="line">            <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="string">"es_std"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:      <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="string">"stopwords"</span>: <span class="string">"_spanish_"</span></span><br><span class="line">                &#125; <span class="comment">// 创建一个叫做es_std的分析器。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义分析器"><a href="#自定义分析器" class="headerlink" title="自定义分析器"></a>自定义分析器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"analysis"</span>: &#123;</span><br><span class="line">            <span class="string">"char_filter"</span>: &#123;</span><br><span class="line">                <span class="string">"&amp;_to_and"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:       <span class="string">"mapping"</span>,</span><br><span class="line">                    <span class="string">"mappings"</span>: [ <span class="string">"&amp;=&gt; and "</span>]</span><br><span class="line">            &#125;&#125;,</span><br><span class="line">            <span class="string">"filter"</span>: &#123;</span><br><span class="line">                <span class="string">"my_stopwords"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:       <span class="string">"stop"</span>,</span><br><span class="line">                    <span class="string">"stopwords"</span>: [ <span class="string">"the"</span>, <span class="string">"a"</span> ]</span><br><span class="line">            &#125;&#125;,</span><br><span class="line">            <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="string">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:         <span class="string">"custom"</span>,</span><br><span class="line">                    <span class="string">"char_filter"</span>:  [ <span class="string">"html_strip"</span>, <span class="string">"&amp;_to_and"</span> ],</span><br><span class="line">                    <span class="string">"tokenizer"</span>:    <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="string">"filter"</span>:       [ <span class="string">"lowercase"</span>, <span class="string">"my_stopwords"</span> ]</span><br><span class="line">            &#125;&#125;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型与映射"><a href="#类型与映射" class="headerlink" title="类型与映射"></a>类型与映射</h4><p>类型在ES中表示一类相似的文档，类型由<strong>名称</strong>和<strong>映射</strong>组成。映射，就像Schema,描述了文档可能具有的字段或属性，每个字段的数据类型以及Lucene是如何索引和存储这些字段的。</p>
<p>类型可以很好的抽象划分相似但是不相同的数据，但是由于Lucene的处理方式，类型的使用有些限制。</p>
<p>在 Lucene 中，一个文档由一组简单的键值对组成。 每个字段都可以有多个值，但至少要有一个值。 类似的，一个字符串可以通过分析过程转化为多个值。Lucene 不关心这些值是字符串、数字或日期–所有的值都被当做 <em>不透明字节</em> 。</p>
<p><strong>当我们在 Lucene 中索引一个文档时，每个字段的值都被添加到相关字段的倒排索引中。你也可以将未处理的原始数据 <em>存储</em> 起来，以便这些原始数据在之后也可以被检索到。</strong></p>
<h4 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h4><p>映射的最高一层被称为根对象，包含下面几项</p>
<ul>
<li>一个 <em>properties</em> 节点，列出了文档中可能包含的每个字段的映射</li>
<li>各种元数据字段，它们都以一个下划线开头，例如 <code>_type</code> 、 <code>_id</code> 和 <code>_source</code></li>
<li>设置项，控制如何动态处理新的字段，例如 <code>analyzer</code> 、 <code>dynamic_date_formats</code> 和 <code>dynamic_templates</code></li>
<li>其他设置，可以同时应用在根对象和其他 <code>object</code> 类型的字段上，例如 <code>enabled</code> 、 <code>dynamic</code> 和 <code>include_in_all</code></li>
</ul>
<h5 id="属性-属性的三个最重要的设置"><a href="#属性-属性的三个最重要的设置" class="headerlink" title="属性 属性的三个最重要的设置"></a>属性 属性的三个最重要的设置</h5><ul>
<li>type</li>
</ul>
<p>字段的数据类型，例如 <code>string</code> 或 <code>date</code></p>
<ul>
<li>index</li>
</ul>
<p>字段是否应当被当成全文来搜索（ <code>analyzed</code> ），或被当成一个准确的值（ <code>not_analyzed</code> ），还是完全不可被搜索（ <code>no</code> ）</p>
<ul>
<li>analyzer</li>
</ul>
<p>确定在索引和搜索时全文字段使用的 <code>analyzer</code></p>
<h4 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h4><p>当ES遇到文档中以前未遇到的字段，用动态映射来确定字段的数据类型并自动把新的字段添加到类型映射。</p>
<p>当 Elasticsearch 遇到文档中以前 未遇到的字段，它用 dynamic mapping来确定字段的数据类型并自动把新的字段添加到类型映射。</p>
<p>有时这是想要的行为有时又不希望这样。通常没有人知道以后会有什么新字段加到文档，但是又希望这些字段被自动的索引。也许你只想忽略它们。如果Elasticsearch是作为重要的数据存储，可能就会期望遇到新字段就会抛出异常，这样能及时发现问题。</p>
<p>幸运的是可以用 <code>dynamic</code> 配置来控制这种行为 ，可接受的选项如下：</p>
<ul>
<li><p><code>true</code></p>
<p>动态添加新的字段–缺省</p>
</li>
<li><p><code>false</code></p>
<p>忽略新的字段</p>
</li>
<li><p><code>strict</code></p>
<p>如果遇到新字段抛出异常</p>
</li>
</ul>
<p>配置参数 <code>dynamic</code> 可以用在根 <code>object</code> 或任何 <code>object</code> 类型的字段上。你可以将 <code>dynamic</code> 的默认值设置为 <code>strict</code> , 而只在指定的内部对象中开启它, 例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"my_type"</span>: &#123;</span><br><span class="line">            <span class="string">"dynamic"</span>:      <span class="string">"strict"</span>,   <span class="comment">//1</span></span><br><span class="line">            <span class="string">"properties"</span>: &#123;</span><br><span class="line">                <span class="string">"title"</span>:  &#123; <span class="string">"type"</span>: <span class="string">"string"</span>&#125;,</span><br><span class="line">                <span class="string">"stash"</span>:  &#123;</span><br><span class="line">                    <span class="string">"type"</span>:     <span class="string">"object"</span>,</span><br><span class="line">                    <span class="string">"dynamic"</span>:  <span class="literal">true</span>    <span class="comment">//2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1如果遇到新字段，对象my_type 抛出异常</p>
<p>2 内部对象 stash 遇到新字段会动态创建新字段。</p>
<p>使用上述动态映射， 你可以给 <code>stash</code> 对象添加新的可检索的字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"title"</span>:   <span class="string">"This doc adds a new field"</span>,</span><br><span class="line">    <span class="string">"stash"</span>: &#123; <span class="string">"new_field"</span>: <span class="string">"Success!"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是对根节点对象 <code>my_type</code> 进行同样的操作会失败：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"title"</span>:     <span class="string">"This throws a StrictDynamicMappingException"</span>,</span><br><span class="line">    <span class="string">"new_field"</span>: <span class="string">"Fail!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 <code>dynamic</code> 设置为 <code>false</code> 一点儿也不会改变 <code>_source</code> 的字段内容。 <code>_source</code> 仍然包含被索引的整个JSON文档。只是新的字段不会被加到映射中也不可搜索。</p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="https://corn1ng.github.io">corn1ng</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="https://corn1ng.github.io/2019/10/03/ElasticSearch官网入门总结/">https://corn1ng.github.io/2019/10/03/ElasticSearch官网入门总结/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/ElasticSearch/">ElasticSearch</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/10/03/git 工作总结/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Git 工作总结</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2019/10/02/kafka （二）/">
        <span class="next-text nav-default">Kafka 分区与压缩算法</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:wangkangning1@foxmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="http://github.com/corn1ng" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://www.instagram.com/brett0427/" class="iconfont icon-instagram" title="instagram"></a>
        
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">corn1ng</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

    
    <script type="text/javascript"
    color="0,0,255" opacity='0.99' zIndex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
    
  </body>
</html>
