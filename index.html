<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Gotta Make A Change"/>













  <link rel="alternate" href="/default" title="Corn1ng's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="https://corn1ng.github.io/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> Corn1ng's Blog </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Corn1ng's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Corn1ng's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/25/字符编码/">字符编码</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-25
        </span>
        
          <div class="post-category">
            
              <a href="/categories/计算机基础/">计算机基础</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><h4 id="为何需要字符编码"><a href="#为何需要字符编码" class="headerlink" title="为何需要字符编码"></a>为何需要字符编码</h4><p>所有的信息都必须表示为一个二进制的字符串，每一个二进制位(bit)有0或者1两种状态。那么在存储时，字符A到底对应什么二进制字符串呢，这时就需要一个规则，这个规则可以将字符映射到唯一一个二进制字符串，这就是编码。</p>
<h4 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h4><p>美国定制的一种编码，一共规定了128个字符的编码，只有7位，所以只占用了一个字节的后面7位，最前面的1位统一为0，总共才有128个字符编码，一个字节都没有用完，于是，开始利用最高位，利用最高位进行编码的方式就称为非ASCII编码，如ISO-8859-1编码。</p>
<p>常见的ASCII码有：</p>
<p><code>0是空字符</code> <code>48是数字0</code> <code>65是大写字母A</code> <code>97是小写字母a</code></p>
<h4 id="ISO-8859-1"><a href="#ISO-8859-1" class="headerlink" title="ISO-8859-1"></a>ISO-8859-1</h4><p>是在 ASCII 码基础上又制定了一些标准用来扩展ASCII编码，即 <code>00000000(0)~01111111(127)</code> 与ASCII的编码一样，对 <code>10000000(128)~11111111(255)</code>这一段进行了编码，如将字符§编码成 10100111(167)。ISO-8859-1编码也是单字节编码，最多能够表示256个字符。Latin1是ISO-8859-1的别名，有些环境下写作Latin-1。但是，即使能够表示256个字符，对中文而言，还是太少了，一个字节肯定不够，必须用多个字节表示。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用 ISO8859-1编码来表示。而且在很多协议上，默认使用该编码。</p>
<h4 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h4><p>GB2312其对所收录字符进行了”分区”处理，共94个区，区从1（十进制）开始，一直到94（十进制），每区含有94个位，位从1（十进制）开始，一直到94（十进制），共8836（94 * 94）个码位，这种表示方式也称为区位码，GB2312是双字节编码，其中高字节表示区，低字节表示位。各区具体说明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01-09区收录除汉字外的682个字符，有164个空位（9 * 94 - 682）。</span><br><span class="line">10-15区为空白区，没有使用。</span><br><span class="line">16-55区收录3755个一级汉字（简体），按拼音排序。</span><br><span class="line">56-87区收录3008个二级汉字（简体），按部首/笔画排序。</span><br><span class="line">88-94区为空白区，没有使用。</span><br></pre></td></tr></table></figure>
<p>　　那么根据区位码如何算出GBK2312编码呢？区位码的表示范围为0101 - 9494（包含了空的区位码）。<a href="http://www.qqxiuzi.cn/zh/hanzi-gb2312-bianma.php" target="_blank" rel="noopener">点击这里</a>，查看中GB2312编码区位码。之后只需要按照如下规则进行转化即可。</p>
<p>　　1. 将区（十进制）转化为十六进制。</p>
<p>　　2. 将转化的十六进制加上A0，得到GB2312编码的高字节。</p>
<p>　　3. 将位（十进制）转化为十六进制。</p>
<p>　　4. 将转化的十六进制加上A0，得到GB2312编码的低字节。</p>
<p>　　5. 组合区和位，区在高字节，位在低字节。</p>
<p>　　6. 得到GB2312编码。</p>
<p>GB2312用两个字节编码，采用分区编码，总共编码的中文个数为6763（3755 + 3008）。这些汉字只是最常用的汉字，已经覆盖中国大陆99.75%的使用频率。但是，还有一些汉字在GB2312中没有被编码，如’镕’字，在GB2312中就没有被编码，这样就导致了问题，随之就出现了主流的GBK编码。</p>
<h4 id="BIG5"><a href="#BIG5" class="headerlink" title="BIG5"></a>BIG5</h4><p>BIG5采用双字节编码，使用两个字节来表示一个字符。高位字节使用了0x81-0xFE，低位字节使用了0x40-0x7E，及0xA1-0xFE。该编码是繁体中文字符集编码标准，共收录13060个中文字，其中有二字为重复编码，即“兀、兀”（A461及C94A)和“嗀、嗀”(DCD1及DDFC)。具体的分区如下：　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8140-A0FE 保留给使用者自定义字符（造字区）</span><br><span class="line">A140-A3BF 标点符号、希腊字母及特殊符号。其中在A259-A261，收录了度量衡单位用字：兙兛兞兝兡兣嗧瓩糎。</span><br><span class="line">A3C0-A3FE 保留。此区没有开放作造字区用。</span><br><span class="line">A440-C67E 常用汉字，先按笔划再按部首排序。</span><br><span class="line">C6A1-F9DC 其它汉字。</span><br><span class="line">F9DD-F9FE 制表符。</span><br></pre></td></tr></table></figure>
<p><a href="http://www.qqxiuzi.cn/zh/hanzi-big5-bianma.php" target="_blank" rel="noopener">点击这里</a>，查看BIG5编码。注意，BIG5编码与GBK编码没有什么关系。</p>
<h4 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h4><p>GBK编码扩展了GB2312，完全兼容GB2312编码（如’李’字的GBK、GB2312编码均为C0EE），但其不兼容BIG5编码（’長’字的BIG5编码为AAF8，GBK编码为E94C，’李’字的BIG5编码为A7F5 不等于C0EE），即如果使用GB2312编码，使用GBK解码是完全正常的，但是如果使用BIG5编码，使用GBK解码，会出现乱码。相比于GB2312编码，GBK编码了更多汉字，如’镕’字。GBK编码依然采用双字节编码方案，其编码范围：8140－FEFE，剔除xx7F码位，共23940个码位。能表示 21003 个汉字。<a href="http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php" target="_blank" rel="noopener">点击这里</a>，查看GBK编码。<a href="http://www.qqxiuzi.cn/bianma/zifuji.php" target="_blank" rel="noopener">点击这里</a>，可以查询中文的其他编码。在GBK之后又出现了GB18030编码，但是没有形成主流，故不做介绍，至此，中文编码的问题已经讲解完成。那么问题又来了，大陆网民与在海峡两岸网民交流时，若都使用GBK编码，则没有问题，若一方使用GBK编码，一方使用BIG5编码，那么就会出现乱码问题，这是在海峡两岸网民交流，如果漂洋过海进行交流呢？那就更容易出现乱码问题，这时候我们可能想，要是有一套全世界都通用的编码就好了，那就是Unicode。</p>
<h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>Unicode是指一张表，里面包含了可能出现的所有字符，每个字符对应一个数字，这个数字称为码点(Code Point)，如字符’H’的码点为72（十进制），字符’李’的码点为26446（十进制）。Unicode表包含了1114112个码点，即从000000（十六进制） - 10FFFF（十六进制）。地球上所有字符都可以在Unicode表中找到对应的唯一码点。<a href="http://unicode-table.com/cn/" target="_blank" rel="noopener">点击这里</a>，查询字符对应的码点。Unicode将码空间划分为17个平面，从00 - 10（十六进制，最高两位），即从0 - 16（十进制），每个平面有65536个码点（2^16），其中最重要的是第一个Unicode平面(码位从0000 - FFFF)，包含了最常用的字符，该平面被称为基本多语言平面（Basic Multilingual Plane），缩写为BMP，其他平面称为辅助平面(Supplementary Planes)，在基本多文种平面內， 从D800到DFFF之间的码位区段是永久保留不映射到字符的， 因此UTF-16编码巧妙的利用了这保留下来的码位来对辅助平面内的字符进行编码，这点后面进行讲解。Unicode只是一个符号集，只规定的字符所对应的码点，并没有指定如何存储，如何进行存储出现了不同的编码方案，关于Unicode编码方案主要有两条主线：UCS和UTF。UTF主线由Unicode Consortium进行维护管理，UCS主线由ISO/IEC进行维护管理。</p>
<ul>
<li>UCS</li>
</ul>
<p>　　UCS全称为”Universal Character Set”，在UCS中主要有UCS-2和UCS-4。</p>
<p>　　1. UCS-2</p>
<p>　　UCS-2是定长字节的，固定使用2个字节进行编码，从0000（十六进制）- FFFF（十六进制）的码位范围，对应第一个Unicode平面。采用BOM(Byte Order Mark)机制，该机制作用如下：1. 确定字节流采用的是大端序还是小端序。2. 确定字节流的Unicode编码方案。</p>
<p>　　2. UCS-4</p>
<p>　　UCS-4是定长字节的，固定使用4个字节进行编码。也采用了BOM机制。</p>
<ul>
<li>UTF</li>
</ul>
<p>　　UTF全称为”Unicode Transformation Format”，在UTF中主要有UTF-8，UTF-16和UTF-32。</p>
<p>　　1. UTF-8</p>
<p>　　UTF-8是一种变长编码方式，使用1-4个字节进行编码。UTF-8完全兼容ASCII，<strong>对于ASCII中的字符，UTF-8采用的编码值跟ASCII完全一致</strong>。UTF-8是Unicode一种具体的编码实现。UTF-8是在互联网上使用最广的一种Unicode的编码规则，因为这种编码有利于节约网络流量（因为变长编码，而非统一长度编码）。关于Unicode码点如何转化为UTF-8编码，可以参照如下规则：</p>
<p>　　① 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。</p>
<p>　　② 对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
<p>　　总结的编码规则如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　　　  Unicode符号范围　　                 | 　　UTF-8编码方式</span><br><span class="line">　　　　     (十六进制) (十进制)　　　　        | 　　（二进制）</span><br><span class="line">　　----------------------------------------------------------------------------------------------------</span><br><span class="line">　　  0000 0000-0000 007F (0-127)           | 　　 0xxxxxxx</span><br><span class="line">　　  0000 0080-0000 07FF (128-2047)        | 　　 110xxxxx 10xxxxxx</span><br><span class="line">　　  0000 0800-0000 FFFF (2048-65535)      | 　   1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">　　  0001 0000-0010 FFFF (65536-1114111)   | 　　 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>
<p>　　说明：字符’A’的Unicode码点为65（十进制），根据上表，在第一行范围，则字符’A’的UTF-8编码为01000001，中文字符’李’的Unicode码点为26446（十进制），二进制为01100111 01001110，十六进制为674E。根据上表，在第三行范围，则将’李’二进制代码从低位到高位依次填入x中，不足的填入0。得到UTF-8编码为11100110 10011101 10001110，即E69D8E（十六进制）。</p>
<p>　　由上述编码规则可知，0000 0000 - 0000 FFFF（第一行到第三行）为Unicode第一个平面（基本多语言平面），而0001 0000 - 10 FFFF（第四行）为Unicode其他平面（辅助平面）。在基本多语言平面对应了绝大多数常用的字符。对于大于65535（十进制）的码点，即在辅助平面上的码点，需要使用4个字节来进行UTF-8编码。</p>
<p>　　2. UTF-16</p>
<p>　　UTF-8是不定长的编码，使用1、2、3、4个字节编码，而UTF-16则只使用2或4个字节编码。UTF-16也是Unicode一种具体的编码实现。关于Unicode如何转化为UTf-16编码规则如下</p>
<p>　　① 若Unicode码点在第一平面（BPM）中，则使用2个字节进行编码。 </p>
<p>　　② 若Unicode码点在其他平面（辅助平面），则使用4个字节进行编码。</p>
<p>　　关于辅助平面的码点编码更详细解析如下：辅助平面码点被编码为一对16比特（四个字节）长的码元, 称之为代理对(surrogate pair), 第一部分称为高位代理(high surrogate)或前导代理(lead surrogates)，码位范围为：D800-DBFF. 第二部分称为低位代理(low surrogate)或后尾代理(trail surrogates)， 码位范围为：DC00-DFFF。注意，高位代理的码位从D800到DBFF，而低位代理的码位从DC00到DFFF，总共恰好为D800-DFFF，这部分码点在第一平面内是保留的，不映射到任何字符，所以UTF-16编码巧妙的利用了这点来进行码点在辅助平面内的4字节编码。</p>
<p>　　说明：字符’A’的Unicode码点为65（十进制），十六进制表示为41，在第一平面。根据规则，UTF-16采用2个字节进行编码。那么问题又来了，知道了采用两个字节编码，并且我们也知道计算机是以字节为单位进行存储，这两个字节应该表示为00 41(十六进制)？或者是41 00（十六进制）呢？这就引出了一个问题，需要用到之前提及的BOM机制来解决。</p>
<p>　　表示为00 41意味着采用了大端序（Big endian），而表示为41 00意味着采用了小端序。那么计算机如何知道存储的字符信息采用了大端序还是小端虚呢？这就需要加入一些控制信息，具体是采用大端序，则在文件前加入FE FF，采用小端序，则在文件前加入FF FE。这样，当计算开始读取时发现前两个字节为FE FF，就表示之后的信息采用的是小端序，反之，则是大端序。</p>
<p>　　字符 <img src="https://images2015.cnblogs.com/blog/616953/201603/616953-20160325091936011-35053941.png" alt="img">（无法显示，只能截图显示），其Unicode码点为65902（十进制），十六进制为1016E，很显然，已经超出了第一平面（BMP）所能表示的范围。其在辅助平面内，根据规则，UTF-16采用4个字节进行编码。然而其编码不是简单扩展为4个字节（00 01 01 6E），而是采用如下规则进行计算。</p>
<p>　　① 使用Unicode码位减去100000（十六进制），得到的值扩展20位（因为Unicode最大为10 FF FF（十六进制），减去1 00 00（十六进制）后，得到的结果最大为0FFF FF（十六进制），即为20位，不足20位的，在高位加一个0，扩展至20位即可）。</p>
<p>　　② 将步骤一得到的20位，按照高十位和低十位进行分割。</p>
<p>　　③ 将步骤二的高十位扩展至2个字节，再加上D800（十六进制），得到高位代理或前导代理。取值范围是D800 - 0xDBFF。</p>
<p>　　④ 将步骤二的低十位扩展至2个字节，再加上DC00（十六进制），得到低位代理或后尾代理。取值范围是DC00 - 0xDFFF。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/leesf456/p/5317574.html" target="_blank" rel="noopener">https://www.cnblogs.com/leesf456/p/5317574.html</a></p>
</blockquote>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/24/RestTemplate 使用指南/">RestTemplate 使用指南</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-24
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
              <a href="/categories/Java/微服务/">微服务</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="RestTemplate-使用指南"><a href="#RestTemplate-使用指南" class="headerlink" title="RestTemplate 使用指南"></a>RestTemplate 使用指南</h2><p>RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率。</p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><h4 id="获取JSON字符串"><a href="#获取JSON字符串" class="headerlink" title="获取JSON字符串"></a>获取JSON字符串</h4><p>使用<code>getForEntity()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">String fooResourceUrl = <span class="string">"http://localhost:8080/spring-rest/foos"</span>;</span><br><span class="line">ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(fooResourceUrl + <span class="string">"/1"</span>, String.class);</span><br><span class="line">assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));</span><br></pre></td></tr></table></figure>
<p>通过<code>getForEntity()</code>我们可以获取到完整的<code>HTTP response</code>，因此可以通过检测状态码来判断请求是否真正执行成功。也可以通过<code>getBody()</code>方法获取返回的具体内容，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">JsonNode root = mapper.readTree(response.getBody());</span><br><span class="line">JsonNode name = root.path(<span class="string">"name"</span>);</span><br><span class="line">assertThat(name.asText(), notNullValue());</span><br></pre></td></tr></table></figure>
<h4 id="获取POJO对象"><a href="#获取POJO对象" class="headerlink" title="获取POJO对象"></a>获取POJO对象</h4><p>直接将请求映射为一个POJO对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 这里省略了getters和setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = restTemplate.getForObject(userResourceUrl + <span class="string">"/1"</span>, User.class);</span><br></pre></td></tr></table></figure>
<h3 id="获取Headers"><a href="#获取Headers" class="headerlink" title="获取Headers"></a>获取Headers</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpHeaders httpHeaders = restTemplate.headForHeaders(fooResourceUrl);</span><br></pre></td></tr></table></figure>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p><code>RestTemplate</code>提供了三个API用来创建资源，它们分别是<code>postForLocation()</code>、 <code>postForObject()</code>和<code>postForEntity()</code>。<code>postForLocation()</code>返回新创建资源的URI，<code>postForObject()</code>则返回新创建的资源本身。</p>
<h4 id="postForObject方法"><a href="#postForObject方法" class="headerlink" title="postForObject方法"></a>postForObject方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClientHttpRequestFactory requestFactory = getClientHttpRequestFactory();</span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate(requestFactory);</span><br><span class="line">HttpEntity&lt;Foo&gt; request = <span class="keyword">new</span> HttpEntity&lt;&gt;(<span class="keyword">new</span> Foo(<span class="string">"bar"</span>));</span><br><span class="line">Foo foo = restTemplate.postForObject(fooResourceUrl, request, Foo.class);</span><br></pre></td></tr></table></figure>
<h4 id="postForLocation-方法"><a href="#postForLocation-方法" class="headerlink" title="postForLocation 方法"></a>postForLocation 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpEntity&lt;Foo&gt; request = <span class="keyword">new</span> HttpEntity&lt;&gt;(<span class="keyword">new</span> Foo(<span class="string">"bar"</span>));</span><br><span class="line">URI location = restTemplate.postForLocation(fooResourceUrl, request);</span><br></pre></td></tr></table></figure>
<h4 id="exchange方法"><a href="#exchange方法" class="headerlink" title="exchange方法"></a>exchange方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">HttpEntity&lt;User&gt; request = <span class="keyword">new</span> HttpEntity&lt;&gt;(<span class="keyword">new</span> User(<span class="string">"CD826"</span>));</span><br><span class="line">ResponseEntity&lt;User&gt; response = restTemplate.exchange(userResourceUrl, HttpMethod.POST, request, User.class);  </span><br><span class="line">User user = response.getBody();</span><br></pre></td></tr></table></figure>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User updatedInstance = <span class="keyword">new</span> User(<span class="string">"newName"</span>);</span><br><span class="line">updatedInstance.setId(createResponse.getBody().getId());</span><br><span class="line">String resourceUrl = userResourceUrl + <span class="string">'/'</span> + createResponse.getBody().getId();</span><br><span class="line">HttpEntity&lt;User&gt; requestUpdate = <span class="keyword">new</span> HttpEntity&lt;&gt;(updatedInstance, headers);</span><br><span class="line">template.exchange(resourceUrl, HttpMethod.PUT, requestUpdate, Void.class);</span><br></pre></td></tr></table></figure>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String entityUrl = fooResourceUrl + <span class="string">"/"</span> + existingResource.getId();</span><br><span class="line">restTemplate.delete(entityUrl);</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/23/Java8之StreamAPI & Optional/">Java8之StreamAPI & Optional</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-23
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Java8之StreamAPI-amp-Optional"><a href="#Java8之StreamAPI-amp-Optional" class="headerlink" title="Java8之StreamAPI &amp; Optional"></a>Java8之StreamAPI &amp; Optional</h2><h3 id="流的基本概念"><a href="#流的基本概念" class="headerlink" title="流的基本概念"></a>流的基本概念</h3><h4 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h4><p>流是Java8引入的全新概念，它用来处理集合中的数据，暂且可以把它理解为一种高级集合。</p>
<p>集合操作一般十分麻烦，若要对集合进行筛选，投影，则需要写大量的代码，而流以声明的形式操作集合，就像SQL语句，只需要告诉流需要对集合进行什么操作，它就会自动进行操作，并将执行结果返回。</p>
<p>因此，流的集合操作对代码编写者来说是透明的，只需要向流下达命令，就会自动把结果返回，操作过程完全由Java处理，因此可以根据当前的硬件环境选择最优的方法处理。</p>
<h4 id="流的特点"><a href="#流的特点" class="headerlink" title="流的特点"></a>流的特点</h4><ul>
<li>只能遍历一次</li>
</ul>
<p>可以把流想象成一条流水线，流水线的源头是我们的数据源，数据源中的元素依次被输送到流水线上，然后可以在流水线上对元素进行各种操作。一旦元素走到了流水线的另一头，那么这些元素就被消费掉了。这时就只能重新获取一个流重新遍历一遍。</p>
<ul>
<li>采用内部迭代方式</li>
</ul>
<p>若要对集合进行处理，则需我们手写处理代码，这就叫做外部迭代。而要对流进行处理，我们只需告诉流我们需要什么结果，处理过程由流自行完成，这就称为内部迭代。</p>
<h4 id="流的操作种类"><a href="#流的操作种类" class="headerlink" title="流的操作种类"></a>流的操作种类</h4><p>分两种，分别中间操作和终端操作。</p>
<ul>
<li><p>中间操作</p>
<p>当数据源中的数据上了流水线后，这个过程对数据进行的所有操作都称为中间操作。中间操作仍然会返回一个流对象，因此多个中间操作可以串联起来形成一个流水线。</p>
</li>
<li><p>终端操作</p>
<p>当所有中间操作完成后，若要将数据从流水线上拿下来，则需要进行终端操作。终端操作将返回一个执行结果，就是需要的数据。</p>
</li>
</ul>
<h4 id="流的操作过程"><a href="#流的操作过程" class="headerlink" title="流的操作过程"></a>流的操作过程</h4><p>三步，1准备一个数据源 2执行中间操作（中间操作可以有多个，串联起来形成流水线）3执行终端操作（执行终端操作后本次流程结束，获得一个执行结果）</p>
<h3 id="流的使用"><a href="#流的使用" class="headerlink" title="流的使用"></a>流的使用</h3><h4 id="1获取流"><a href="#1获取流" class="headerlink" title="1获取流"></a>1获取流</h4><p>在使用流之前，首先需要拥有一个数据源，并通过StreamAPI提供的一些方法获取该数据源的流对象。数据源可以有多种形式：</p>
<ol>
<li>集合</li>
</ol>
<p>这种数据源比较常用，通过<code>stream()</code>方法即可获取流对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; list =<span class="keyword">new</span> ArrayList&lt;person&gt;();</span><br><span class="line">Stream&lt;Person&gt; stream =list.stream();</span><br></pre></td></tr></table></figure>
<p>2 数组</p>
<p>通过Arrays类提供的静态函数stream()获取数组的流对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names =&#123;<span class="string">"chaimm"</span>,<span class="string">"peter"</span>,<span class="string">"john"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream =Arrays.stream(names);</span><br></pre></td></tr></table></figure>
<p>3.值</p>
<p>直接将几个值变成流对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream =Stream.of(<span class="string">"chaium"</span>,<span class="string">"peter"</span>,<span class="string">"john"</span>);</span><br></pre></td></tr></table></figure>
<p>4.文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Stream lines = Files.lines(Paths.get(“文件路径名”),Charset.defaultCharset()))&#123; </span><br><span class="line"><span class="comment">//可对lines做一些操作 </span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2筛选filter"><a href="#2筛选filter" class="headerlink" title="2筛选filter"></a>2筛选filter</h4><p>filter函数接收一个Lambda表达式作为参数，该表达式返回boolean，在执行过程中，流将元素逐一输送给filter，并筛选出执行结果为true的元素。<br>如，筛选出所有学生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result = list.stream()</span><br><span class="line">                    .filter(Person::isStudent)</span><br><span class="line">                    .collect(toList());</span><br></pre></td></tr></table></figure>
<h4 id="3去重distinct"><a href="#3去重distinct" class="headerlink" title="3去重distinct"></a>3去重distinct</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result =list.stream().distinct().collect(toList());</span><br></pre></td></tr></table></figure>
<h4 id="4截取"><a href="#4截取" class="headerlink" title="4截取"></a>4截取</h4><p>截取流的前N个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result =list.stream().limit(<span class="number">3</span>).collect(toList());</span><br></pre></td></tr></table></figure>
<h4 id="5-跳过"><a href="#5-跳过" class="headerlink" title="5 跳过"></a>5 跳过</h4><p>跳过流的前N个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result =list.stream().skip(<span class="number">3</span>).collect(toList());</span><br></pre></td></tr></table></figure>
<h4 id="6-映射"><a href="#6-映射" class="headerlink" title="6 映射"></a>6 映射</h4><p>对流中的每个元素执行一个函数，使得元素转换成另一种类型输出，流会将每一个元素输送给map函数，并执行map中的lamdba表达式，最后将执行结果存入一个新的流中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result =list.stream().map(Person::getName).collect(toList());</span><br></pre></td></tr></table></figure>
<h4 id="7-是否匹配任一元素"><a href="#7-是否匹配任一元素" class="headerlink" title="7 是否匹配任一元素"></a>7 是否匹配任一元素</h4><p>anymatch用于判断流中是否存在至少一个元素满足指定的条件，这个判断条件通过Lambda表达式传递给anyMatch，执行结果为boolean类型。<br>如，判断list中是否有学生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = list.stream()</span><br><span class="line">            .anyMatch(Person::isStudent);</span><br></pre></td></tr></table></figure>
<h4 id="8-是否匹配所有元素"><a href="#8-是否匹配所有元素" class="headerlink" title="8 是否匹配所有元素"></a>8 是否匹配所有元素</h4><p>allMatch用于判断流中的所有元素是否都满足指定条件，这个判断条件通过Lambda表达式传递给anyMatch，执行结果为boolean类型。<br>如，判断是否所有人都是学生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = list.stream()</span><br><span class="line">            .allMatch(Person::isStudent);</span><br></pre></td></tr></table></figure>
<h4 id="9-是否未匹配所有元素"><a href="#9-是否未匹配所有元素" class="headerlink" title="9 是否未匹配所有元素"></a>9 是否未匹配所有元素</h4><p>noneMatch与allMatch恰恰相反，它用于判断流中的所有元素是否都不满足指定条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = list.stream()</span><br><span class="line">            .noneMatch(Person::isStudent);</span><br></pre></td></tr></table></figure>
<h4 id="10-获取任一元素findAny"><a href="#10-获取任一元素findAny" class="headerlink" title="10 获取任一元素findAny"></a>10 获取任一元素findAny</h4><p>findAny能够从流中随便选一个元素出来，它返回一个Optional类型的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Person&gt; person = list.stream()</span><br><span class="line">                                    .findAny();</span><br></pre></td></tr></table></figure>
<h5 id="Optional介绍"><a href="#Optional介绍" class="headerlink" title="Optional介绍"></a>Optional介绍</h5><p>Optional是Java8新加入的一个容器，这个容器只存1个或0个元素，它用于防止出现NullpointException，它提供如下方法：</p>
<ul>
<li>isPresent()<br>判断容器中是否有值。</li>
<li>ifPresent(Consume lambda)<br>容器若不为空则执行括号中的Lambda表达式。</li>
<li>T get()<br>获取容器中的元素，若容器为空则抛出NoSuchElement异常。</li>
<li>T orElse(T other)<br>获取容器中的元素，若容器为空则返回括号中的默认值。</li>
</ul>
<h4 id="11-获取第一个元素findFirst"><a href="#11-获取第一个元素findFirst" class="headerlink" title="11 获取第一个元素findFirst"></a>11 获取第一个元素findFirst</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Person&gt; person = list.stream()</span><br><span class="line">                                    .findFirst();</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/21/基于Java类的配置/">基于Java类的配置</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-21
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="基于Java类的配置"><a href="#基于Java类的配置" class="headerlink" title="基于Java类的配置"></a>基于Java类的配置</h2><p>基于Java配置选项，可以编写大多数的Spring不用配置XML，但有几个基于Java的注释的帮助下解释。</p>
<h4 id="Configuration-amp-Bean-注解"><a href="#Configuration-amp-Bean-注解" class="headerlink" title="@Configuration &amp; @Bean 注解:"></a>@Configuration &amp; @Bean 注解:</h4><p>带有 <strong>@Configuration</strong> 的注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源(<strong>相当于XML中的beans</strong>)。<strong>@Bean</strong> 注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。最简单可行的 @Configuration 类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> HelloWorld <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码等价于以下的XML配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"com.tutorialspoint.HelloWorld"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这里，带有 @Bean 注解的方法名称作为 bean 的 ID，它创建并返回实际的 bean。你的配置类可以声明多个 @Bean。一旦定义了配置类，你就可以使用 <em>AnnotationConfigApplicationContext</em> 来加载并把他们提供给 Spring 容器，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ApplicationContext ctx = </span><br><span class="line">   <span class="keyword">new</span> AnnotationConfigApplicationContext(HelloWorldConfig.class); </span><br><span class="line">   HelloWorld helloWorld = ctx.getBean(HelloWorld.class);<span class="comment">//返回类型是真正的Bean。</span></span><br><span class="line">   helloWorld.setMessage(<span class="string">"Hello World!"</span>);</span><br><span class="line">   helloWorld.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以加载各种配置类，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   AnnotationConfigApplicationContext ctx = </span><br><span class="line">   <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">   ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">   ctx.register(AdditionalConfig.class);</span><br><span class="line">   ctx.refresh();</span><br><span class="line">   MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">   myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><code>HelloWorldConfig.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> HelloWorld <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>HelloWorld.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String message;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message  = message;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Your Message : "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainApp.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ApplicationContext ctx = </span><br><span class="line">      <span class="keyword">new</span> AnnotationConfigApplicationContext(HelloWorldConfig.class);</span><br><span class="line">      HelloWorld helloWorld = ctx.getBean(HelloWorld.class);</span><br><span class="line">      helloWorld.setMessage(<span class="string">"Hello World!"</span>);</span><br><span class="line">      helloWorld.getMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦你完成了创建所有的源文件并添加所需的额外的库后，我们就可以运行该应用程序。你应该注意这里不需要配置文件。如果你的应用程序一切都正常，将输出以下信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your Message : Hello World!</span><br></pre></td></tr></table></figure>
<h4 id="注入Bean的依赖性"><a href="#注入Bean的依赖性" class="headerlink" title="注入Bean的依赖性"></a>注入Bean的依赖性</h4><p>当 @Beans 依赖对方时，表达这种依赖性非常简单，只要有一个 bean 方法调用另一个，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Foo(bar());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Bar <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Bar();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Import-注解"><a href="#Import-注解" class="headerlink" title="@Import 注解:"></a>@Import 注解:</h4><p><strong>@import</strong> 注解允许从另一个配置类中加载 @Bean 定义。考虑 ConfigA 类，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigA</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> A(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在另一个 Bean 声明中导入上述 Bean 声明，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(ConfigA.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigB</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> B <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> A(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当实例化上下文时，不需要同时指定 ConfigA.class 和 ConfigB.class，只有 ConfigB 类需要提供，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ApplicationContext ctx = </span><br><span class="line">   <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigB.class);</span><br><span class="line">   <span class="comment">// now both beans A and B will be available...</span></span><br><span class="line">   A a = ctx.getBean(A.class);</span><br><span class="line">   B b = ctx.getBean(B.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h4><p>@Bean 注解支持指定任意的初始化和销毁的回调方法，就像在 bean 元素中 Spring 的 XML 的初始化方法和销毁方法的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// initialization logic</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// destruction logic</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>, destroyMethod = <span class="string">"cleanup"</span> )</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定 Bean 的范围：</p>
<p>默认范围是单实例，但是你可以重写带有 @Scope 注解的该方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/17/缓存穿透与缓存雪崩/">缓存穿透与缓存雪崩</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-17
        </span>
        
          <div class="post-category">
            
              <a href="/categories/分布式/">分布式</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="缓存穿透与缓存雪崩"><a href="#缓存穿透与缓存雪崩" class="headerlink" title="缓存穿透与缓存雪崩"></a>缓存穿透与缓存雪崩</h2><p>设计一个缓存系统，不得不考虑的问题就是缓存穿透，缓存击穿与失效时的雪崩效应。</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/16/Maven 总结/">Maven 总结</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-16
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Maven-总结"><a href="#Maven-总结" class="headerlink" title="Maven 总结"></a>Maven 总结</h2><h4 id="Maven-是什么？"><a href="#Maven-是什么？" class="headerlink" title="Maven 是什么？"></a>Maven 是什么？</h4><p>Maven 是一个项目管理和整合工具。Maven 为开发者提供了一套完整的构建生命周期框架。开发团队几乎不用花多少时间就能够自动完成工程的基础构建配置，因为 Maven 使用了一个标准的目录结构和一个默认的构建生命周期。</p>
<p>在有多个开发团队环境的情况下，Maven 能够在很短的时间内使得每项工作都按照标准进行。因为大部分的工程配置操作都非常简单并且可复用，在创建报告、检查、构建和测试自动配置时，Maven 可以让开发者的工作变得更简单。</p>
<p>Maven 能够帮助开发者完成以下工作：构建，文档生成，报告，依赖，SCMs，发布，分发，邮件列表。</p>
<p>总的来说，Maven 简化了工程的构建过程，并对其标准化。它无缝衔接了编译、发布、文档生成、团队合作和其他任务。Maven 提高了重用性，负责了大部分构建相关的任务。</p>
<h4 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h4><p>POM 代表工程对象模型。它是使用 Maven 工作时的基本组建，是一个 xml 文件。它被放在工程根目录下，文件命名为 pom.xml。POM 包含了关于工程和各种配置细节的信息，Maven 使用这些信息构建工程。所有的 POM 文件需要 <strong>project</strong> 元素和三个必须的字段：<strong>groupId, artifactId,version</strong>。在仓库中的工程标识为 <strong>groupId:artifactId:version</strong></p>
<p>groupid代表工程组的标识，一个组织中唯一。artifactid是工程的标识，通常是工程的名称。version 是工程的版本号。</p>
<h4 id="构建生命周期"><a href="#构建生命周期" class="headerlink" title="构建生命周期"></a>构建生命周期</h4><p>构建生命周期是一组阶段的序列（sequence of phases），每个阶段定义了目标被执行的顺序。这里的阶段是生命周期的一部分。举例说明，一个典型的 Maven 构建生命周期是由以下几个阶段的序列组成的。</p>
<ul>
<li><strong>验证（validate）</strong> - 验证项目是否正确，所有必要的信息可用</li>
<li><strong>编译（compile）</strong> - 编译项目的源代码</li>
<li><strong>测试（test）</strong> - 使用合适的单元测试框架测试编译的源代码。这些测试不应该要求代码被打包或部署</li>
<li><strong>打包（package）</strong> - 采用编译的代码，并以其可分配格式（如JAR）进行打包。</li>
<li><strong>验证（verify）</strong> - 对集成测试的结果执行任何检查，以确保满足质量标准</li>
<li><strong>安装（install）</strong> - 将软件包安装到本地存储库中，用作本地其他项目的依赖项</li>
<li><strong>部署（deploy）</strong> - 在构建环境中完成，将最终的包复制到远程存储库以与其他开发人员和项目共享。</li>
</ul>
<h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>在 Maven 的术语中，仓库是一个位置（place），例如目录，可以存储所有的工程 jar 文件、library jar 文件、插件或任何其他的工程指定的文件。Maven 仓库有三种类型：本地(local),中央(central),远程(remote)</p>
<h5 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h5><p>Maven 本地仓库是机器上的一个文件夹。它在你第一次运行任何 maven 命令的时候创建。</p>
<p>Maven 本地仓库保存你的工程的所有依赖（library jar、plugin jar 等）。当你运行一次 Maven 构建，Maven 会自动下载所有依赖的 jar 文件到本地仓库中。它避免了每次构建时都引用存放在远程机器上的依赖文件。Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。</p>
<h5 id="中央仓库"><a href="#中央仓库" class="headerlink" title="中央仓库"></a>中央仓库</h5><p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。中央仓库的关键概念：这个仓库由 Maven 社区管理。不需要配置。需要通过网络才能访问。</p>
<h5 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h5><p>如果 Maven 在中央仓库中也找不到依赖的库文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p>
<h4 id="Maven的搜索顺序"><a href="#Maven的搜索顺序" class="headerlink" title="Maven的搜索顺序"></a>Maven的搜索顺序</h4><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p>
<ul>
<li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li>
<li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中已被将来引用。</li>
<li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li>
<li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库已被将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li>
</ul>
<h4 id="Maven插件"><a href="#Maven插件" class="headerlink" title="Maven插件"></a>Maven插件</h4><p>Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven 插件通常被用来：</p>
<ul>
<li>创建 jar 文件</li>
<li>创建 war 文件</li>
<li>编译代码文件</li>
<li>代码单元测试</li>
<li>创建工程文档</li>
<li>创建工程报告</li>
</ul>
<p>插件通常提供了一个目标的集合，并且可以使用下面的语法执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn [plugin-name]:[goal-name]</span><br><span class="line"><span class="meta">#</span> 执行“plugin-name”插件的“goal-name”目标（或者称为动作）</span><br><span class="line"><span class="meta">#</span>用户可以通过两种方式调用Maven插件目标。</span><br><span class="line"><span class="meta">#</span>第一种方式是将插件目标与生命周期阶段（lifecycle phase）绑定，这样用户在命令行只是输入生命周期阶段而已，例如Maven默认将maven-compiler-plugin的compile目标与compile生命周期阶段绑定，因此命令mvn compile实际上是先定位到compile这一生命周期阶段，然后再根据绑定关系调用maven-compiler-plugin的compile目标。</span><br><span class="line"><span class="meta">#</span>第二种方式是直接在命令行指定要执行的插件目标，例如mvnarchetype:generate 就表示调用maven-archetype-plugin的generate目标，这种带冒号的调用方式与生命周期无关。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>插件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>clean</td>
<td>构建之后清理目标文件。删除目标目录。</td>
</tr>
<tr>
<td>compiler</td>
<td>编译 Java 源文件。</td>
</tr>
<tr>
<td>surefile</td>
<td>运行 JUnit 单元测试。创建测试报告。</td>
</tr>
<tr>
<td>jar(package)</td>
<td>从当前工程中构建 JAR 文件。</td>
</tr>
<tr>
<td>war</td>
<td>从当前工程中构建 WAR 文件。</td>
</tr>
<tr>
<td>javadoc</td>
<td>为工程生成 Javadoc。</td>
</tr>
<tr>
<td>antrun</td>
<td>从构建过程的任意一个阶段中运行一个 ant 任务的集合。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>Maven命令列表</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>mvn –version</strong></td>
<td>显示版本信息</td>
</tr>
<tr>
<td><strong>mvn clean</strong></td>
<td>清理项目生产的临时文件,一般是模块下的target目录</td>
</tr>
<tr>
<td><strong>mvn compile</strong></td>
<td>编译源代码，一般编译模块下的src/main/java目录</td>
</tr>
<tr>
<td><strong>mvn package</strong></td>
<td>项目打包工具,会在模块下的target目录生成jar或war等文件</td>
</tr>
<tr>
<td><strong>mvn test</strong></td>
<td>测试命令,或执行src/test/java/下junit的测试用例.</td>
</tr>
<tr>
<td><strong>mvn install</strong></td>
<td>将打包的jar/war文件复制到你的本地仓库中,供其他模块使用</td>
</tr>
<tr>
<td><strong>mvn deploy</strong></td>
<td>将打包的文件发布到远程参考,提供其他人员进行下载依赖</td>
</tr>
<tr>
<td><strong>mvn site</strong></td>
<td>生成项目相关信息的网站</td>
</tr>
<tr>
<td><strong>mvn eclipse:eclipse</strong></td>
<td>将项目转化为Eclipse项目</td>
</tr>
<tr>
<td><strong>mvn dependency:tree</strong></td>
<td>打印出项目的整个依赖树</td>
</tr>
<tr>
<td><strong>mvn archetype:generate</strong></td>
<td>创建Maven的普通java项目</td>
</tr>
<tr>
<td><strong>mvn tomcat:run</strong></td>
<td>在tomcat容器中运行web应用</td>
</tr>
<tr>
<td><strong>mvn jetty:run</strong></td>
<td>调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用</td>
</tr>
</tbody>
</table>
<h4 id="Maven创建工程"><a href="#Maven创建工程" class="headerlink" title="Maven创建工程"></a>Maven创建工程</h4><p>Maven 使用<strong>原型（archetype）</strong>插件创建工程。要创建一个简单的 Java 应用，我们将使用 maven-archetype-quickstart 插件。在下面的例子中，将在 \MVN 文件夹下创建一个基于 maven 的 java 应用工程。打开命令控制台，跳转到 \MVN 目录，并执行下面的 <strong>mvn</strong> 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> \MVN&gt;mvn archetype:generate</span><br><span class="line">-DgroupId=com.companyname.bank </span><br><span class="line">-DartifactId=consumerBanking </span><br><span class="line">-DarchetypeArtifactId=maven-archetype-quickstart </span><br><span class="line">-DinteractiveMode=false</span><br></pre></td></tr></table></figure>
<h4 id="Maven构建-amp-测试工程"><a href="#Maven构建-amp-测试工程" class="headerlink" title="Maven构建&amp;测试工程"></a>Maven构建&amp;测试工程</h4><p>打开命令控制台，跳转到 \MVN\consumerBanking 目录下，并执行以下 <strong>mvn</strong> 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\MVN\consumerBanking&gt;mvn clean package #package的作用是打包</span><br></pre></td></tr></table></figure>
<p>Maven 将开始构建工程。</p>
<p>已经构建了你的工程并创建了最终的 jar 文件，下面是要学习的关键概念：</p>
<ul>
<li>我们给了 maven 两个目标，首先清理目标目录（clean），然后打包工程构建的输出为 jar（package）文件。</li>
<li>打包好的 jar 文件可以在 <code>demo\target</code>中获得，名称为 demo-1.0-SNAPSHOT.jar。</li>
<li>测试报告存放在 demo\target\surefire-reports 文件夹中。</li>
<li>Maven 编译源码文件，以及测试源码文件。</li>
<li>接着 Maven 运行测试用例。</li>
<li>最后Maven创建工程包。</li>
</ul>
<h4 id="编译工程"><a href="#编译工程" class="headerlink" title="编译工程"></a>编译工程</h4><p>当添加了一个文件后，可以输入下面的命令重新编译文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean compile</span><br></pre></td></tr></table></figure>
<h4 id="Maven中添加外部依赖"><a href="#Maven中添加外部依赖" class="headerlink" title="Maven中添加外部依赖"></a>Maven中添加外部依赖</h4><p>当远程仓库和中央仓库中都没有相关依赖时，可以手动添加jar包。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;\src\lib\ldapjdk.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Maven工程文档"><a href="#Maven工程文档" class="headerlink" title="Maven工程文档"></a>Maven工程文档</h4><p>在Demo项目目录下执行<code>mvn site</code>生成工程文档，打开 \demo\target\site 文件夹。点击 index.html 就可以看到文档了。</p>
<h4 id="Maven工程模板"><a href="#Maven工程模板" class="headerlink" title="Maven工程模板"></a>Maven工程模板</h4><h2 id="Maven-工程模板"><a href="#Maven-工程模板" class="headerlink" title="Maven - 工程模板"></a>Maven - 工程模板</h2><p>Maven 使用原型（Archetype）概念为用户提供了大量不同类型的工程模版（614 个）。Maven 使用下面的命令帮助用户快速创建 java 项目。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate</span><br></pre></td></tr></table></figure>
<p>原型是一个 Maven 插件，它的任务是根据模板创建一个项目结构。我们将使用 quickstart 原型插件创建一个简单的 java 应用程序。</p>
<p>打开命令控制台，跳转到 <strong>\ MVN</strong> 目录并执行以下 <strong>mvn</strong> 命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\MVN&gt;mvn archetype:generate</span><br></pre></td></tr></table></figure>
<p>Maven 将开始处理，并要求选择所需的原型</p>
<h3 id="mvn-compile与mvn-install、mvn-deploy的区别"><a href="#mvn-compile与mvn-install、mvn-deploy的区别" class="headerlink" title="mvn compile与mvn install、mvn deploy的区别"></a>mvn compile与mvn install、mvn deploy的区别</h3><ol>
<li>mvn compile，编译类文件</li>
<li>mvn install，包含mvn compile，mvn package，然后上传到本地仓库</li>
<li>mvn deploy,包含mvn install,然后，上传到本地仓库</li>
</ol>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/11/Docker 网络和存储管理/">Docker 网络和存储管理</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-11
        </span>
        
          <div class="post-category">
            
              <a href="/categories/分布式/">分布式</a>
            
              <a href="/categories/分布式/微服务/">微服务</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Docker-网络和存储管理"><a href="#Docker-网络和存储管理" class="headerlink" title="Docker 网络和存储管理"></a>Docker 网络和存储管理</h2><h3 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h3><p>网络是虚拟化技术中最复杂的部分，也是Docker 应用中的一个重要环节。Docker中的网络主要解决容器与容器，容器与外部网络，外部网络与容器之间互相通信的问题。</p>
<h4 id="Docker-通信方式"><a href="#Docker-通信方式" class="headerlink" title="Docker 通信方式"></a>Docker 通信方式</h4><p>在默认情况下，Docker 使用网桥(二层设备)+NAT的通信模型。如下图所示：<br><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-10%2010-20-05%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>Docker启动时会默认自动创建网桥设备Docker0 ，实际上是一个Linux的bridge，可以理解为一个软件交换机它会在挂载到它的网口之间进行转发,同时，Docker随机分配一个本地未占用的私有网段中的一个地址给docker0接口，比如典型的<code>172.17.42.1</code>，掩码是255.255.0.0，此后启动的容器内的网口也会自动分配一个同一个网段的地址。</p>
<p>当Docker启动容器时，会创建一对veth虚拟网络设备（当数据包发送到一个接口时，另外一个借口也可以收到相同的数据包），这对接口一端在容器内，即eth0,另一端在本地被挂载到docker0网桥，名称以veth开头。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker就创建了主机和所有容器之间一个虚拟共享网络。</p>
<p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-10%2014-49-54%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>为了解决容器与外部网络之间的通信，Docker引入了NAT.</p>
<h3 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h3><h4 id="网络设置参数"><a href="#网络设置参数" class="headerlink" title="网络设置参数"></a>网络设置参数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-b/--bridge: 指定Docker 使用的网桥设备</span><br><span class="line">--bip  指定网桥设备docker0的IP和掩码。</span><br><span class="line">--dns 配置容器的DNS</span><br></pre></td></tr></table></figure>
<h3 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h3><p>容器中可以运行一些网络应用，，要让外部也可以访问这些应用，可以通过-P或者-p参数来指定端口映射。使用-P标记时，Docker会随机映射一个49000-49900的端口到内部容器开放的网络端口。</p>
<p>-p可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器，支持的格式有<code>IP:hostport:containerPort</code></p>
<p>可以使用<code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址。</p>
<h3 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h3><p>Docker 容器一旦删除，容器本身对应的rootfs文件系统就会被删除，容器中的所有数据也将随之删除。但有时候，想要数据不随容器删除而删除，还有时候，希望同一台Host容器之间可以共享数据。</p>
<p>为此，Docker提供了数据卷，数据卷除了可以持久化数据，还可以用于容器之间共享数据。</p>
<p>数据卷是一个可以供一个或者多个容器使用的特殊目录，它绕过UFS,可以提供很多有用的特性：</p>
<ul>
<li>数据卷可以在容器之间共享和重用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>数据卷会默认一直存在，即使容器被删除。</li>
</ul>
<h4 id="创建并查看一个数据卷"><a href="#创建并查看一个数据卷" class="headerlink" title="创建并查看一个数据卷"></a>创建并查看一个数据卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker volume create my-vol #创建一个数据卷</span><br><span class="line"><span class="meta">$</span> docker volume ls #查看所有数据卷</span><br><span class="line"><span class="meta">$</span> docker volume inspect my-vol #查看指定数据卷信息</span><br><span class="line"><span class="meta">$</span> docker volume rm my-vol #删除数据卷</span><br></pre></td></tr></table></figure>
<h5 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h5><p>在用docker run命令的时候，使用 <code>--mount</code>标记来将数据卷挂载到容器里，在一个docker run中可以挂载多个数据卷。</p>
<p>下面创建一个名为web的容易，并加载一个数据卷到容器的、webapp目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -d -P --name web --mount source=my-vol,target=/webapp</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/11/Docker 镜像管理/">Docker 镜像管理&仓库管理</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-11
        </span>
        
          <div class="post-category">
            
              <a href="/categories/分布式/">分布式</a>
            
              <a href="/categories/分布式/微服务/">微服务</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Docker-镜像管理-amp-仓库管理"><a href="#Docker-镜像管理-amp-仓库管理" class="headerlink" title="Docker 镜像管理&amp;仓库管理"></a>Docker 镜像管理&amp;仓库管理</h2><p>创建容器时需要指定使用哪个镜像，新容器创建后，不依赖镜像就可以运行。使用<code>docker images</code> 可以查找到本机已有的所有镜像。</p>
<p>每个镜像也有唯一的标示ImageID，和容器的<code>Container ID</code>一样，默认128位，可以使用前16位的缩略形式。</p>
<h4 id="镜像的分层"><a href="#镜像的分层" class="headerlink" title="镜像的分层"></a>镜像的分层</h4><p>通过docker images  可以看到每个镜像的大小都很大，但是镜像所占的磁盘空间之和远远小于所有镜像之和。原因是镜像采用了分层机制，相同部分独立成层，只需要存储一份就可以了。大大节省了镜像空间。比如wordpress和mysql都是基于ubuntu系统构建的，那么就只需要一个ubuntu的镜像分层，再次基础上再根据wordpress 和mariadb各自不同1部分构建各自的独立分层。</p>
<p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-09%2017-02-30%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>Docker 的镜像通过联合文件系统将各层文件系统叠加在一起，在用户看来就像一个完整的文件系统。例如某个镜像有两层，第一层有三个文件夹，第二层有两个文件夹，使用联合文件系统叠加后，用户可以看到五个文件夹，感觉不到分层的存在。</p>
<p>通过<code>docker history</code>可以查询镜像分了多少层，每一层做了什么操作。</p>
<p>对于分层的Docker 镜像有两个特性，一个是已有的分层只能读不能修改，另一个是上层镜像的优先级高于底层镜像。</p>
<p> 下面举一个例子:</p>
<p>镜像B和镜像C都是在镜像A的基础上搭建起来的，镜像A有一个文件a.txt.内容为“HELLO WORLD”,从用户的视角来看，镜像B和镜像C都可以看到文件a.txt，且内容都是“HELLO,WORLD”,这时镜像B想要修改a.txt的内容为“hello docker”如果我们允许直接对镜像A中的文件a.txt进行修改，那么C看到的内容也会发生改变，这对C来说，是不可接受的，所以已有的分层都是不能修改的，要修改的话，只能通过在镜像B的基础上新增加一个分层B’,存储修改后的a.txt，利用上层镜像的优先级高于底层镜像原则，新增加的分层B’中的a.txt会覆盖原有镜像A的a.txt,从用户的视角，就会看到修改后的a.txt的内容为HELLO docker, 而镜像C看到的还是hello world</p>
<p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-10%2009-26-08%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-10%2009-29-58%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>每行都以一个关键字为行首，如果一行内容过长，它使用’\’把多行连接在一起。</p>
<p>第一行使用关键字FROM,表示新的镜像是从Ubuntu这个基础镜像开始构建的，MAINTAINER:指定该镜像的创建者 ENV:设置环境变量。</p>
<p>RUN:运行shell命令 多条命令用&amp;&amp;连接。</p>
<p>COPY 将编译机本地文件拷贝到镜像文件系统中。</p>
<p>EXPOSE:指定监听的端口</p>
<p>ENTRYPOINT: 欲执行命令，创建镜像时不执行，等到使用该镜像创建容器，容器启动后才执行的命令。</p>
<h4 id="项目中的镜像分层"><a href="#项目中的镜像分层" class="headerlink" title="项目中的镜像分层"></a>项目中的镜像分层</h4><p>将两个项目gitlab和Redmine两个项目的所有镜像分层放一起来看，可以发现：</p>
<p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-10%2009-41-49%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<ul>
<li>每个镜像加一个可写层形成容器，多个容器组合在一起，对外提供某些特殊功能的服务。</li>
<li>基于同一个镜像只需要增加一个可写层，就可以为不同项目创建各自需要的容器。</li>
</ul>
<h2 id="Docker-仓库管理"><a href="#Docker-仓库管理" class="headerlink" title="Docker 仓库管理"></a>Docker 仓库管理</h2><p>仓库主要用于镜像的存储，它是Docker镜像分发，部署的关键，实际应用中，由开发者或者运维制作好应用程序镜像，然后上传到镜像仓库，Docker 守护进程再从仓库拉取镜像，然后运行相应的镜像。</p>
<h3 id="镜像公有仓库"><a href="#镜像公有仓库" class="headerlink" title="镜像公有仓库"></a>镜像公有仓库</h3><h4 id="登录DockerHub"><a href="#登录DockerHub" class="headerlink" title="登录DockerHub"></a>登录DockerHub</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker login</span><br><span class="line">Username:</span><br><span class="line">Password:</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>上传镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker push ubuntu1404-baseimage:1.0</span><br></pre></td></tr></table></figure>
<ul>
<li>搜索镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker search centos</span><br></pre></td></tr></table></figure>
<ul>
<li>下载镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker pull</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
    
      <a class="next" href="/page/2/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:wangkangning1@foxmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="http://github.com/corn1ng" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://www.instagram.com/brett0427/" class="iconfont icon-instagram" title="instagram"></a>
        
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">corn1ng</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
