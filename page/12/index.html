<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Gotta Make A Change"/>













  <link rel="alternate" href="/default" title="Corn1ng's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="https://corn1ng.github.io/page/12/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> Corn1ng's Blog </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Corn1ng's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Corn1ng's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/01/13/解决Ubuntu图标消失问题/">解决Ubuntu 任务栏图标变成问号</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-13
        </span>
        
          <div class="post-category">
            
              <a href="/categories/计算机基础/">计算机基础</a>
            
              <a href="/categories/计算机基础/Linux/">Linux</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>Pycham 升级后,任务栏的图标就变成了问号,强迫症看着实在很难受,好在最后把问题解决了</p>
<p>在/usr/share/applications 存有图标文件,把对应图标文件的路径改对即可</p>
<p>原先,我总是自己创建一个pycharm.desktop的文件,其实是不用的,因为里面本来就有.</p>
          <div class="read-more">
            <a href="/2018/01/13/解决Ubuntu图标消失问题/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/01/12/RDB 和AOF/">Redis 持久化</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-12
        </span>
        
          <div class="post-category">
            
              <a href="/categories/数据库/">数据库</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h3 id="RDB-和AOF"><a href="#RDB-和AOF" class="headerlink" title="RDB 和AOF"></a>RDB 和AOF</h3><blockquote>
<p><a href="http://redisdoc.com/topic/persistence.html" target="_blank" rel="noopener">http://redisdoc.com/topic/persistence.html</a></p>
</blockquote>
<p>Redis 提供了多种不同级别的持久化方式：</p>
<ul>
<li><p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照。</p>
</li>
<li><p>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</p>
</li>
<li><p>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</p>
</li>
<li><p>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</p>
<p>​</p>
          <div class="read-more">
            <a href="/2018/01/12/RDB 和AOF/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/01/12/Redis 复制与内存/">Redis复制与内存</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-12
        </span>
        
          <div class="post-category">
            
              <a href="/categories/数据库/">数据库</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Redis-复制"><a href="#Redis-复制" class="headerlink" title="Redis 复制"></a>Redis 复制</h2><p>在分布式系统中为了解决单点问题， 通常会把数据复制多个副本部署到其他机器， 满足故障恢复和负载均衡等需求。 Redis也是如此， 它提供了复制功能， 实现了相同数据的多个Redis副本。 复制功能是高可用Redis的基础。</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li><p>Redis 使用异步复制。 从 Redis 2.8 开始， 从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。</p>
</li>
<li><p>一个主服务器可以有多个从服务器。</p>
</li>
<li><p>不仅主服务器可以有从服务器， 从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个图状结构。</p>
</li>
<li><p><strong>复制功能不会阻塞主服务器</strong>： 即使有一个或多个从服务器正在进行初次同步， 主服务器也可以继续处理命令请求。</p>
</li>
<li><p>复制功能也不会阻塞从服务器： 只要在 <code>redis.conf</code> 文件中进行了相应的设置， 即使从服务器正在进行初次同步， 服务器也可以使用旧版本的数据集来处理命令查询。不过， 在从服务器删除旧版本数据集并载入新版本数据集的那段时间内， 连接请求会被阻塞。</p>
<p>还可以配置从服务器， 让它在与主服务器之间的连接断开时， 向客户端发送一个错误。</p>
</li>
<li><p>复制功能可以单纯地用于数据冗余（data redundancy）， 也可以通过让多个从服务器处理只读命令请求来提升扩展性（scalability）： 比如说， 繁重的 <a href="http://doc.redisfans.com/key/sort.html#sort" target="_blank" rel="noopener"><em>SORT</em></a> 命令可以交给附属节点去运行。</p>
</li>
<li><p>可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可。</p>
</li>
</ul>
<p>Redis 使用复制功能非常容易,只需要在从数据库的配置文件中加入<code>slaveof 主库地址 主库端口</code>即可,主库无需进行任何配置.</p>
<p>默认情况下,从数据库是只读的.</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h5><p>当一个从数据库启动后,会向主数据库发送SYNC命令,同时主数据库收到SYNC命令后会开始在后台保存快照(即RDB持久化的过程)并在保存快照期间将收到的命令缓存起来,当快照完成后,Redis 会将快照文件和所有缓存的命令一起发给从数据库.从数据库收到后,会载入快照文件并执行收到的缓存命令,以上过程成为复制初始化.复制初始化结束后,主数据库每当收到写命令时就会将命令同步给从数据库.从而保障主从数据库数据库一致.</p>
<p>当主从数据库连接断开重连后,2.6之前的版本会进行复制初始化这样效率就很低,所以2.8后的版本支持了有条件的增量数据传输.从库重新连接上主库后,只需要将断线期间执行的命令传送给从库,大大提高了复制的可用性.</p>
<ul>
<li>执行slaveof后从节点保存主节点信息</li>
<li>从节点（ slave） 内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的主节点后， 会尝试与该节点建立网络连接。</li>
<li>从节点发送ping命令</li>
<li>主节点进行权限验证</li>
<li>同步数据集</li>
<li>命令持续复制</li>
</ul>
<p>无论是初次连接还是重新连接， 当建立一个从服务器时， 从服务器都将向主服务器发送一个 <a href="http://doc.redisfans.com/server/sync.html#sync" target="_blank" rel="noopener"><em>SYNC</em></a> 命令。</p>
<p>接到 <a href="http://doc.redisfans.com/server/sync.html#sync" target="_blank" rel="noopener"><em>SYNC</em></a> 命令的主服务器将开始执行 <a href="http://doc.redisfans.com/server/bgsave.html#bgsave" target="_blank" rel="noopener"><em>BGSAVE</em></a> ， 并在保存操作执行期间， 将所有新执行的写入命令都保存到一个缓冲区里面。</p>
<p>当 <a href="http://doc.redisfans.com/server/bgsave.html#bgsave" target="_blank" rel="noopener"><em>BGSAVE</em></a> 执行完毕后， 主服务器将执行保存操作所得的 <code>.rdb</code> 文件发送给从服务器， 从服务器接收这个 <code>.rdb</code> 文件， 并将文件中的数据载入到内存中。</p>
<p>之后主服务器会以 Redis 命令协议的格式， 将写命令缓冲区中积累的所有内容都发送给从服务器。</p>
<p>即使有多个从服务器同时向主服务器发送 <a href="http://doc.redisfans.com/server/sync.html#sync" target="_blank" rel="noopener"><em>SYNC</em></a> ， 主服务器也只需执行一次 <a href="http://doc.redisfans.com/server/bgsave.html#bgsave" target="_blank" rel="noopener"><em>BGSAVE</em></a> 命令， 就可以处理所有这些从服务器的同步请求。</p>
<p>Redis 采用了乐观复制的复制策略,允许一定时间内主从数据库的内容是不同的,但是两者的数据会最终同步.</p>
<h4 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h4><p>从 Redis 2.8 开始， 在网络连接短暂性失效之后， 主从服务器可以尝试继续执行原有的复制进程（process）， 而不一定要执行完整重同步操作。</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-28%2019-26-30.png" alt=""></p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-28%2019-26-39.png" alt=""></p>
<h4 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h4><ul>
<li>一主一从</li>
<li>一主多从</li>
<li>树状主从</li>
</ul>
<h2 id="Redis-内存"><a href="#Redis-内存" class="headerlink" title="Redis 内存"></a>Redis 内存</h2><p>Redis所有的数据都存在内存中， 当前内存虽然越来越便宜， 但跟廉价的硬盘相比成本还是比较昂贵， 因此如何高效利用Redis内存变得非常重要。 高效利用Redis内存首先需要理解Redis内存消耗在哪里， 如何管理内存， 最后才能考虑如何优化内存。</p>
<h4 id="内存消耗划分"><a href="#内存消耗划分" class="headerlink" title="内存消耗划分"></a>内存消耗划分</h4><p>Redis进程内消耗主要包括： 自身内存+对象内存+缓冲内存+内存碎片。</p>
<p>对象内存是Redis内存占用最大的一块， 存储着用户所有的数据。 Redis所有的数据都采用key-value数据类型， 每次创建键值对时， 至少创建两个类型对象： key对象和value对象。 对象内存消耗可以简单理解为sizeof（ keys）+sizeof（ values） 。 键对象都是字符串。 value对象更复杂些， 主要包含5种基本数据类型： 字符串、 列表、 哈希、 集合、 有序集合。 其他数据类型都是建立在这5种数据结构之上实现的。</p>
<p>缓冲内存主要包括： 客户端缓冲、 复制积压缓冲区、 AOF缓冲区。</p>
<p>客户端缓冲指的是所有接入到Redis服务器TCP连接的输入输出缓冲。输入缓冲无法控制， 最大空间为1G。复制积压缓冲区： Redis在2.8版本之后提供了一个可重用的固定大小缓冲区用于实现部分复制功能， 根据repl-backlog-size参数控制， 默认1MB。 对于复制积压缓冲区整个主节点只有一个， 所有的从节点共享此缓冲区。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/01/12/哨兵与集群/">Redis哨兵与集群</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-12
        </span>
        
          <div class="post-category">
            
              <a href="/categories/数据库/">数据库</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>Redis的主从复制模式下， 一旦主节点由于故障不能提供服务， 需要人工将从节点晋升为主节点， 同时还要通知应用方更新主节点地址， 对于很多应用场景这种故障处理的方式是无法接受的。 Redis从2.8开始正式提供了Redis Sentinel（ 哨兵） 架构来解决这个问题， </p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Redis Sentinel是Redis的高可用实现方案， 在实际的生产环境中， 对提高整个系统的高可用性是非常有帮助的。</p>
<p>哨兵的功能包括两个,一是监控主数据库和从数据库是否正常运行,二是主数据库出现故障时自动将从数据库转换为主数据库.</p>
<h5 id="主从复制的问题"><a href="#主从复制的问题" class="headerlink" title="主从复制的问题"></a>主从复制的问题</h5><p>Redis的主从复制模式可以将主节点的数据改变同步给从节点， 这样从节点就可以起到两个作用： 第一， 作为主节点的一个备份， 一旦主节点出了故障不可达的情况， 从节点可以作为后备“顶”上来， 并且保证数据尽量不丢失（ 主从复制是最终一致性） 。 第二， 从节点可以扩展主节点的读能力， 一旦主节点不能支撑住大并发量的读操作， 从节点可以在一定程度上帮助主节点分担读压力。</p>
<p>但是主从复制也带来了以下问题</p>
<ul>
<li>一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址， 还需要命令其他从节点去复制新的主节点， 整个过程都需要人工干预。(高可用问题)</li>
<li>主节点的写能力受到单机的限制。(分布式问题)</li>
<li>主节点的存储能力受到单机的限制。(分布式问题)</li>
</ul>
<h5 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h5><p>Redis主从复制模式下的主节点出现故障后， 故障转移过程如下所示。</p>
<p>1）主节点发生故障后，客户端连接主节点失败，两个从节点与主节点连接失败造成复制中断。</p>
<p>2）如果主节点无法正常启动， 需要选出一个从节点（slave-1),对其执行slaveof no one命令使其成为新的主节点。</p>
<p>3)原来的从节点（ slave-1） 成为新的主节点后， 更新应用方的主节点信息， 重新启动应用方。</p>
<p>4)客户端命令另一个从节点（ slave-2） 去复制新的主节点（ new-master）</p>
<p>5)待原来的主节点恢复后， 让它去复制新的主节点。</p>
<p>上述处理过程就可以认为整个服务或者架构的设计不是高可用的， 因为整个故障转移的过程需要人介入.</p>
<h5 id="Redis-哨兵的高可用性"><a href="#Redis-哨兵的高可用性" class="headerlink" title="Redis 哨兵的高可用性"></a>Redis 哨兵的高可用性</h5><p>当主节点出现故障时， Redis Sentinel能自动完成故障发现和故障转移，并通知应用方， 从而实现真正的高可用。</p>
<p>Redis Sentinel是一个分布式架构， 其中包含若干个Sentinel节点和Redis数据节点， 每个Sentinel节点会对数据节点和其余Sentinel节点进行监控， 当它发现节点不可达时， 会对节点做下线标识。 如果被标识的是主节点， 它还会和其他Sentinel节点进行“协商”， 当大多数Sentinel节点都认为主节点不可达时， 它们会选举出一个Sentinel节点来完成自动故障转移的工作， 同时会将这个变化实时通知给Redis应用方。 整个过程完全是自动的， 不需要人工来介入， 所以这套方案很有效地解决了Redis的高可用问题。</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效地解决了Redis分布式方面的需求。 当遇到单机内存、 并发、 流量等瓶颈时， 可以采用Cluster架构方案达到负载均衡的目的。</p>
<h3 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h3><h5 id="数据分布理论"><a href="#数据分布理论" class="headerlink" title="数据分布理论"></a>数据分布理论</h5><p>分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的问题， 即把数据集划分到多个节点上， 每个节点负责整体数据的一个子集。</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/1AF80826-FF01-413A-97AE-D1A995A1CB8D.png" width="40%"></p>
<p>常见的数据分区规则主要有哈希分区和顺序分区两种。Redis Cluster采用哈希分区规则.</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/2FCF5E61-5B5F-4BC2-93C2-2735A519F8FF.png"></p>
<p>常见哈希规则主要有</p>
<ul>
<li>节点取余分区</li>
</ul>
<p>使用特定的数据， 如Redis的键或用户ID， 再根据节点数量N使用公式：hash（ key） %N计算出哈希值， 用来决定数据映射到哪一个节点上。突出优点是简单性， 常用于数据库的分库分表规则。</p>
<ul>
<li>一致性哈希分区</li>
</ul>
<p>一致性哈希分区（ Distributed Hash Table） 实现思路是为系统中每个节点分配一个token， 范围一般在0~<code>2^32</code>， 这些token构成一个哈希环。 数据读写执行节点查找操作时， 先根据key计算hash值， 然后顺时针找到第一个大于等于该哈希值的token节点。 </p>
<ul>
<li>虚拟槽分区</li>
</ul>
<p>虚拟槽分区巧妙地使用了哈希空间， 使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中， 整数定义为槽（ slot） 。 这个范围一般远远大于节点数， 比如Redis Cluster槽范围是0~16383。 槽是集群内数据管理和迁移的基本单位。 采用大范围槽的主要目的是为了方便数据拆分和集群扩展。 每个节点会负责一定数量的槽， 如下图所示。当前集群有5个节点， 每个节点平均大约负责3276个槽。 由于采用高质量的哈希算法， 每个槽所映射的数据通常比较均匀， 将数据平均划分到5个节点进行数据分区。 Redis Cluster就是采用虚拟槽分区， 下面就介绍Redis数据分区方法。</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/F464CD1E-5B6C-49CB-9224-1B059B8D3D08.png" width="40%"></p>
<p>Redis Cluser采用虚拟槽分区， 所有的键根据哈希函数映射到0~16383整数槽内， 计算公式： <code>slot=CRC16 (key) &amp;16383</code>。 每一个节点负责维护一部分槽以及槽所映射的键值数据.</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/01/11/Java消息中间件/">Java消息中间件</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-11
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><h4 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h4><p>非底层操作系统软件,非业务应用软件,不是直接给最终用户使用的,不能直接给客户带来价值的软件都统称为中间件</p>
<h4 id="什么是消息中间件"><a href="#什么是消息中间件" class="headerlink" title="什么是消息中间件"></a>什么是消息中间件</h4><p>关注于数据的发送与接收,利用高效可靠的异步消息传递机制集成分布式系统.</p>
<p>应用A通过应用程序接口向消息中间件发送消息,消息中间件再通过应用B的应用程序接口向应用B发送消息.</p>
          <div class="read-more">
            <a href="/2018/01/11/Java消息中间件/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/01/10/Python-迭代器,生成器,装饰器,可变参数总结/">Python 迭代器,生成器,装饰器,可变参数总结</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-10
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Python/">Python</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h3 id="函数中的可变参数列表"><a href="#函数中的可变参数列表" class="headerlink" title="函数中的可变参数列表"></a>函数中的可变参数列表</h3><p>当函数调用可变个数的参数时,这些可变参数被包装进一个元组,在可变参数前,可以有0到多个普通的参数,多个参数用*作为前缀.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_multiple_items</span><span class="params">(file, separator, *args)</span>:</span></span><br><span class="line">    file.write(separator.join(args))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concat</span><span class="params">(*args, sep=<span class="string">"/"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sep.join(args)</span><br><span class="line"></span><br><span class="line">concat(<span class="string">"earth"</span>, <span class="string">"mars"</span>, <span class="string">"venus"</span>)</span><br><span class="line"><span class="string">'earth/mars/venus'</span></span><br><span class="line">concat(<span class="string">"earth"</span>, <span class="string">"mars"</span>, <span class="string">"venus"</span>, sep=<span class="string">"."</span>)</span><br><span class="line"><span class="string">'earth.mars.venus'</span></span><br></pre></td></tr></table></figure>
<p>相反的情况</p>
          <div class="read-more">
            <a href="/2018/01/10/Python-迭代器,生成器,装饰器,可变参数总结/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/01/09/Git/">Git</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-09
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Git/">Git</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="基础原理"><a href="#基础原理" class="headerlink" title="基础原理"></a>基础原理</h3><p>Git 是一个分布式版本管理系统,可以在任何时间点,把文档的状态作为更新记录保存起来,因此可以把编辑过的文档复原到以前状态,也可以显示编辑前后的内容差异.</p>
<p>版本库(Repository)是记录文件或目录状态的地方,存储着内容修改的历史记录,在版本库的管理下,把文件和目录修改的历史记录放在对应的目录下.</p>
          <div class="read-more">
            <a href="/2018/01/09/Git/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/01/07/绝对路径和相对路径/">绝对路径和相对路径</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-07
        </span>
        
          <div class="post-category">
            
              <a href="/categories/计算机基础/">计算机基础</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>相对路径就是相对于当前文件的路径。网页中一般表示路径使用这个方法.</p>
<p>绝对路径就是你的主页上的文件或目录在硬盘上真正的路径。绝对路径就是你的主页上的文件或目录在硬盘上真正的路径，比如，你的Perl 程序是存放在 c:/bin 下的，那么 c:/bin就是bin目录的绝对路径</p>
<p>在网络中,以http开头的链接都是绝对路径,绝对路径就是你的主页上的文件或目录在硬盘上真正的路径.</p>
          <div class="read-more">
            <a href="/2018/01/07/绝对路径和相对路径/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/11/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/13/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:wangkangning1@foxmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="http://github.com/corn1ng" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://www.instagram.com/brett0427/" class="iconfont icon-instagram" title="instagram"></a>
        
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">corn1ng</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
