<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Gotta Make A Change"/>













  <link rel="alternate" href="/default" title="Corn1ng's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="https://corn1ng.github.io/page/4/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> Corn1ng's Blog </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Corn1ng's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Corn1ng's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/27/RabbitMq/">RabbitMq入门</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-27
        </span>
        
          <div class="post-category">
            
              <a href="/categories/分布式/">分布式</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="RabbitMq"><a href="#RabbitMq" class="headerlink" title="RabbitMq"></a>RabbitMq</h2><p>RabbitMq 是一个消息队列，它接受并传递消息，可以认为它是一个邮局，但是它不传递纸，传递的是二进制的数据块，也就是消息。</p>
<p>有一些rabbitMq的术语，生产者值得是发送消息的人，队列指的是rabbitMq里面的一个消息盒子，消息都存储在这个队列里，队列受主机的内存和硬盘限制。实质上就是一个很大的消息缓冲区。许多生产者可以把消息都放入这个队列中，需要消费者可以从这个队列中取出消息。通常情况下，消费者，生产者，和消息队列三者都不在一个主机上。</p>
<h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h4><p>这里写两个程序，生产者发送一个单个的消息，然后消费者接受消息然后把他们打印。</p>
<p>RabbitMq支持许多种协议，这里使用的是AMQP 0-9-1,是一个开源的广泛使用的消息协议。<code>The RabbitMQ Java client is also in the central Maven repository, with the groupId **com.rabbitmq** and the artifactId **amqp-client**</code>.</p>
<p>下面用send代表生产者，用recv代表消费者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    <span class="comment">//设定RabbitMq的主机名</span></span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    <span class="comment">//创建一个连接</span></span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    <span class="comment">//创建一个通道</span></span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    <span class="comment">//指定一个队列</span></span><br><span class="line">        <span class="comment">//参数1 queue ：队列名</span></span><br><span class="line">        <span class="comment">// 参数2 durable ：是否持久化</span></span><br><span class="line">        <span class="comment">// 参数3 exclusive ：仅创建者可以使用的私有队列，断开后自动删除</span></span><br><span class="line">        <span class="comment">// 参数4 autoDelete : 当所有消费客户端连接断开后，是否自动删除队列</span></span><br><span class="line">        <span class="comment">// 参数5 arguments</span></span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">     <span class="comment">// basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body)</span></span><br><span class="line">        <span class="comment">// 参数1 exchange ：交换器</span></span><br><span class="line">        <span class="comment">// 参数2 routingKey ： 路由键</span></span><br><span class="line">        <span class="comment">// 参数3 props ： 消息的其他参数</span></span><br><span class="line">        <span class="comment">// 参数4 body ： 消息体</span></span><br><span class="line">    channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">    System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分开介绍：</p>
<p>建立一个到服务器的连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">Connection connection = factory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br></pre></td></tr></table></figure>
<p>Connection抽象了socket连接，主要帮助我们关心协议的版本沟通和认证。这里连接到的队列是本地的机器，如果想连接其他的机器的话应该填写具体的名字或者是IP地址。</p>
<p>接下来，创建一个通道(channel),绝大部分API方法需要通过调用它来完成。</p>
<p>为了发送信息，我们需要声明一个queue来帮助我们发送，然后我们就开始发送信息了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br></pre></td></tr></table></figure>
<p>声明一个队列是幂等的，它只会在不存在的时候创建，消息的内容是一个二进制的数组，最后关闭通道(channel)和连接(connection)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
<p>以上就是我们的发送者。RabbitMQ会把消息推送给接收者，所以不同于只发了一条信息的发送者，我们会让接收者一直监听消息并打印出来。</p>
<p>下面是消息的接收者，消费者从rabbitmq中拉取消息，需要持续的监听队列并打印其中的消息。</p>
<p>和生产者一样，我们打开一个连接和一个channel，然后声明一个我们将要去消费的队列，需要注意的是要和生产者生产的队列对应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="work-queues"><a href="#work-queues" class="headerlink" title="work queues"></a>work queues</h4><p>创建一个工作队列来分发任务到不同的执行单元中。</p>
<p>工作队列的主要思想就是避免避免占资源的任务的长时间阻塞，导致后面的任务的长时间等待。我们安排这个任务一会再做。我们把任务概述成信息然后发送到消息队列中，一个后台的工作单元将会取出这个任务然后执行它。当有许多个工作单元时，任务在他们之间是分享的。这个概念在Web应用中十分的有用。</p>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>前面部分中我们发送了一个Helloworld,现在我们发送字符串来代表复杂的信息，并用<code>Thread.sleep</code>来代替复杂的信息。我们用字符串后面的<code>.</code>的个数来代替这个任务需要执行的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String message = getMessage(argv);</span><br><span class="line">channel.basicPublish(<span class="string">""</span>, <span class="string">"hello"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String[] strings)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    <span class="keyword">return</span> joinStrings(strings, <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">joinStrings</span><span class="params">(String[] strings, String delimiter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = strings.length;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    StringBuilder words = <span class="keyword">new</span> StringBuilder(strings[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        words.append(delimiter).append(strings[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> words.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进后的消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">    System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork(message);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">" [x] Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">true</span>; <span class="comment">// acknowledgment is covered below</span></span><br><span class="line">channel.basicConsume(TASK_QUEUE_NAME, autoAck, consumer);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(String task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch: task.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'.'</span>) Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h5><p>使用工作队列的一个好处就是它能够并行的处理队列。如果堆积了很多任务，我们只需要添加更多的工作者（workers）就可以了，扩展很简单。</p>
<p>首先，我们先同时运行两个 worker实例，它们都会从队列中获取消息，到底是不是这样呢？我们看看。</p>
<p>然后需要打开三个终端，两个用来运行 worker程序，这两个终端就是我们的两个消费者(consumers)—C1 和 C2。</p>
<p>默认来说，RabbitMQ 会按顺序得把消息发送给每个消费者（consumer）。平均每个消费者都会收到同等数量得消息。这种发送消息得方式叫做——轮询（round-robin）。试着添加三个或更多得工作者（workers）。</p>
<h5 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h5><p>当处理一个比较耗时得任务的时候，你也许想知道消费者（consumers）是否运行到一半就挂掉。当前的代码中，当消息被 RabbitMQ 发送给消费者（consumers）之后，马上就会在内存中移除。这种情况，你只要把一个工作者（worker）停止，正在处理的消息就会丢失。同时，所有发送到这个工作者的还没有处理的消息都会丢失。</p>
<p>我们不想丢失任何任务消息。<strong>如果一个工作者（worker）挂掉了，我们希望任务会重新发送给其他的工作者（worker）</strong>。</p>
<p><strong>为了防止消息丢失，RabbitMQ 提供了消息响应（acknowledgments）</strong>。消费者会通过一个 ack（响应），告诉RabbitMQ已经收到并处理了某条消息，然后RabbitMQ就会释放并删除这条消息。</p>
<p>如果消费者（consumer）挂掉了，没有发送响应，RabbitMQ 就会认为消息没有被完全处理，然后重新发送给其他消费者（consumer）。这样，及时工作者（workers）偶尔的挂掉，也不会丢失消息。</p>
<p><strong>消息是没有超时这个概念的</strong>；当工作者与它断开的时候，RabbitMQ 会重新发送消息。这样在处理一个耗时非常长的消息任务的时候就不会出问题了。</p>
<p>消息响应默认是开启的。之前的例子中我们可以使用 no_ack=True 标识把它关闭。当它为false时，当工作者（worker）完成了任务，就发送一个响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>); <span class="comment">// accept only one unack-ed message at a time (see below)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork(message);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">" [x] Done"</span>);</span><br><span class="line">      channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(TASK_QUEUE_NAME, autoAck, consumer);</span><br></pre></td></tr></table></figure>
<p>运用上面的代码，即使杀死一个任务，也不会丢失消息。</p>
<h5 id="忘记确认"><a href="#忘记确认" class="headerlink" title="忘记确认"></a>忘记确认</h5><p>一个很容易犯的错误就是忘了 basic_ack，后果很严重。消息在你的程序退出之后就会重新发送，如果它不能够释放没响应的消息，RabbitMQ 就会占用越来越多的内存。</p>
<p>为了排除这种错误，你可以使用 rabbitmqctl 命令，输出 messages_unacknowledged 字段：</p>
<h5 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h5><p>如果你没有特意告诉 RabbitMQ，那么在它退出或者崩溃的时候，将会丢失所有队列和消息。为了确保信息不会丢失，有两个事情是需要注意的：我们必须把“队列”和“消息”设为持久化。</p>
<p>首先，为了不让队列消失，需要把队列声明为持久化（durable）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">channel.queueDeclare(<span class="string">"hello"</span>, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>尽管这行代码本身是正确的，但是仍然不会正确运行。因为我们已经定义过一个叫hello 的非持久化队列。RabbitMq 不允许你使用不同的参数重新定义一个队列，它会返回一个错误。但我们现在使用一个快捷的解决方法——用不同的名字，例如task_queue。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">channel.queueDeclare(<span class="string">"task_queue"</span>, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>这个queue_declare必须在生产者（producer）和消费者（consumer）对应的代码中修改。这时候，我们就可以确保在 RabbitMq 重启之后 queue_declare 队列不会丢失。另外，我们需要把我们的消息也要设为持久化——将 delivery_mode 的属性设为2。</p>
<h5 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h5><p>你应该已经发现，它仍旧没有按照我们期望的那样进行分发。比如有两个工作者（workers），处理奇数消息的比较繁忙，处理偶数消息的比较轻松。然而RabbitMQ 并不知道这些，它仍然一如既往的派发消息。</p>
<p>这是因为 RabbitMQ 只管分发进入队列的消息，不会关心有多少消费者(consumer)没有作出响应。它盲目的把第 n-th 条消息发给第 n-th 个消费者。</p>
<p>我们可以使用 basic.qos 方法，并设置 prefetch_count=1。这样是告诉RabbitMQ，再同一时刻，不要发送超过1条消息给一个工作者（worker），直到它已经处理了上一条消息并且作出了响应。这样，RabbitMQ 就会把消息分发给下一个空闲的工作者（worker）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>分发一个消息给多个消费者（consumers）。这种模式被称为“发布／订阅”。</p>
<p>为了描述这种模式，将会构建一个简单的日志系统。它包括两个程序，第一个程序负责发送日志消息，第二个程序负责获取消息并输出内容。</p>
<p>在我们的这个日志系统中，所有正在运行的接收方程序都会接受消息。我们用其中一个接收者（receiver）把日志写入硬盘中，另外一个接受者（receiver）把日志输出到屏幕上。</p>
<p>最终，日志消息被广播给所有的接受者（receivers）。</p>
<p><strong>RabbitMQ 消息模型的核心理念是</strong>：发布者（producer）不会直接发送任何消息给队列。事实上，发布者（producer）甚至不知道消息是否已经被投递到队列。</p>
<p>发布者（producer）只需要把消息发送给一个<strong>交换机（exchange）</strong>。交换机非常简单，它一边从发布者方接收消息，一边把消息推送到队列。交换机必须知道如何处理它接收到的消息，是应该推送到指定的队列还是是多个队列，或者是直接忽略消息。这些规则是通过交换机类型（exchange type）来定义的。</p>
<p>有几个可供选择的交换机类型：直连交换机(direct), 主题交换机(topic), 头交换机(headers)和 扇型交换机(fanout)。我们在这里主要说明最后一个—-扇型交换机（fanout）。先创建一个fanout类型的交换机，命名为logs：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">"logs"</span>, <span class="string">"fanout"</span>);</span><br></pre></td></tr></table></figure>
<p>扇型交换机（fanout）很简单，它把消息发送给它所知道的所有队列。这正是我们的日志系统所需要的。</p>
<p>现在，我们就可以发送消息到一个具名交换机了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish( <span class="string">"logs"</span>, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure>
<h5 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h5><p>给一个队列命名是很重要的——我们需要把工作者（workers）指向正确的队列。如果你打算在发布者（producers）和消费者（consumers）之间共享同队列的话，给队列命名是十分重要的。</p>
<p>但是这并不适用于我们的日志系统。我们打算接收所有的日志消息，而不仅仅是一小部分。我们关心的是最新的消息而不是旧的。为了解决这个问题，我们需要做两件事情。</p>
<p>首先，当我们连接上 RabbitMQ 的时候，我们需要一个全新的、空的队列。我们可以手动创建一个随机的队列名，或者让服务器为我们选择一个随机的队列名（推荐）。我们只需要在调用 queueDeclare 方法的时候，不提供 queue 参数就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure>
<p>这时候我们可以通过 result.method.queue 获得已经生成的随机队列名。它可能是这样子的：amq.gen-U0srCoW8TsaXjNh73pnVAw==。</p>
<p>第二步，当与消费者（consumer）断开连接的时候，这个队列应当被立即删除。exclusive 标识符即可达到此目的.</p>
<h5 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h5><p>我们已经创建了一个扇型交换机（fanout）和一个队列。现在我们需要告诉交换机如何发送消息给我们的队列。交换器和队列之间的联系我们称之为绑定(binding)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind(queueName, <span class="string">"logs"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure></p>
<p>现在，logs 交换机将会把消息添加到我们的队列中。</p>
<h5 id="绑定列表"><a href="#绑定列表" class="headerlink" title="绑定列表"></a>绑定列表</h5><p>你可以使用 <code>rabbitmqctl list_bindings</code> 列出所有现存的绑定。</p>
<hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">交换器与队列之间的连接叫做绑定，每一个绑定都有一个绑定键，叫做binding key，当消息发送过来时，消息会带有一个路由的标识，叫做routing key，交换器会根据这两个值来决定将消息发给哪个队列。</span><br><span class="line">- direct 根据生产者传过来的路由键是否等于绑定键，来决定发送的队列</span><br><span class="line">- topic 根据生产者传过来的路由键是否匹配一定的表达式，来决定</span><br><span class="line">- fanout 发送给知道的全部队列，会忽略路由键。</span><br><span class="line">- headers 根据消息的头信息来决定消息发送给哪个队列。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>我们打算新增一个功能 —— 使得它能够只订阅消息的一个子集。例如，我们只需要把严重的错误日志信息写入日志文件（存储到磁盘），但同时仍然把所有的日志信息输出到控制台中。</p>
<h4 id="绑定-1"><a href="#绑定-1" class="headerlink" title="绑定"></a>绑定</h4><p>前面的例子，我们已经创建过绑定（bindings），代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=exchange_name,queue=queue_name)</span><br></pre></td></tr></table></figure>
<p>绑定（binding）是指交换机（exchange）和队列（queue）的关系。可以简单理解为：这个队列（queue）对这个交换机（exchange）的消息感兴趣。</p>
<p>绑定的时候可以带上一个额外的 routing_key 参数。为了避免与basic_publish的参数混淆，我们把它叫做绑定键（binding key）。以下是如何创建一个带绑定键的绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=exchange_name,</span><br><span class="line">                   queue=queue_name,</span><br><span class="line">                   routing_key=<span class="string">'black'</span>)</span><br></pre></td></tr></table></figure>
<p>绑定键的意义取决于交换机（exchange）的类型。我们之前使用过的扇型交换机（fanout exchanges）会忽略这个值。</p>
<h5 id="直连交换机"><a href="#直连交换机" class="headerlink" title="直连交换机"></a>直连交换机</h5><p>我们的日志系统广播所有的消息给所有的消费者（consumers）。我们打算扩展它，使其基于日志的严重程度进行消息过滤。例如我们也许只是希望将比较严重的错误（error）日志写入磁盘，以免在警告（warning）或者信息（info）日志上浪费磁盘空间。</p>
<p>我们使用的扇型交换机（fanout exchange）没有足够的灵活性 —— 它能做的仅仅是广播。</p>
<p>我们将会使用直连交换机（direct exchange）来代替。路由的算法很简单 —— 交换机将会对绑定键（binding key）和路由键（routing key）进行精确匹配，从而确定消息该分发到哪个队列。</p>
<p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-27%2016-55-10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=X2MAXP8ssLktyMD9BBHes0qsvCxhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NzMyOTQ0JnQ9MTUyMjE0MDk0NCZyPTEyNTYyMTg3MTAmZj0vMjAxOC0wMy0yNyUyMDE2LTU1LTEwJUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""></p>
<p>在这个场景中，我们可以看到直连交换机 X 和两个队列进行了绑定。第一个队列使用 orange 作为绑定键，第二个队列有两个绑定，一个使用 black 作为绑定键，另外一个使用 green。</p>
<p>这样以来，当路由键为 orange 的消息发布到交换机，就会被路由到队列 Q1。路由键为 black 或者 green 的消息就会路由到 Q2。其他的所有消息都将会被丢弃。</p>
<h4 id="多个绑定"><a href="#多个绑定" class="headerlink" title="多个绑定"></a>多个绑定</h4><p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-27%2017-02-39%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=BX5GArkS2warxv6ICYDEzrvxq51hPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NzMzMzgzJnQ9MTUyMjE0MTM4MyZyPTE5NDg0NTAwMzImZj0vMjAxOC0wMy0yNyUyMDE3LTAyLTM5JUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""></p>
<p>多个队列使用相同的绑定键是合法的。这个例子中，我们可以添加一个 X 和 Q1 之间的绑定，使用 black 绑定键。这样一来，直连交换机就和扇型交换机的行为一样，会将消息广播到所有匹配的队列。带有 black 路由键的消息会同时发送到 Q1 和 Q2。</p>
<h5 id="发送日志"><a href="#发送日志" class="headerlink" title="发送日志"></a>发送日志</h5><p>我们将会发送消息到一个直连交换机，把日志级别作为路由键。这样接收日志的脚本就可以根据严重级别来选择它想要处理的日志。我们先看看发送日志。我们需要创建一个交换机（exchange）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.exchange_declare(exchange=<span class="string">'direct_logs'</span>,</span><br><span class="line">                         exchange_type=<span class="string">'direct'</span>)</span><br></pre></td></tr></table></figure>
<p>然后我们发送一则消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">'direct_logs'</span>,</span><br><span class="line">                      routing_key=severity,</span><br><span class="line">                      body=message)</span><br></pre></td></tr></table></figure>
<p>我们先假设 “severity” 的值是 info、warning、error 中的一个。</p>
<h5 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h5><p>处理接收消息的方式和之前差不多，只有一个例外，我们将会为我们感兴趣的每个严重级别分别创建一个新的绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> severity in severities:</span><br><span class="line">    channel.queue_bind(exchange=<span class="string">'direct_logs'</span>,</span><br><span class="line">                       queue=queue_name,</span><br><span class="line">                       routing_key=severity)</span><br></pre></td></tr></table></figure>
<h3 id="主题交换机"><a href="#主题交换机" class="headerlink" title="主题交换机"></a>主题交换机</h3><p>我们改进了我们的日志系统。我们使用直连交换机替代了扇型交换机，从只能盲目的广播消息改进为有可能选择性的接收日志。</p>
<p>尽管直连交换机能够改善我们的系统，但是它也有它的限制—-没办法基于多个标准执行路由操作。</p>
<p>在我们的日志系统中，我们不只希望订阅基于严重程度的日志，同时还希望订阅基于发送来源的日志。Unix 工具 <a href="http://en.wikipedia.org/wiki/Syslog" target="_blank" rel="noopener">syslog</a>就是同时基于严重程度 -severity (info/warn/crit…) 和 设备 -facility (auth/cron/kern…) 来路由日志的。</p>
<p>如果这样的话，将会给予我们非常大的灵活性，我们既可以监听来源于 “cron” 的严重程度为 “critical errors” 的日志，也可以监听来源于 “kern” 的所有日志。</p>
<p>为了实现这个目的，接下来我们学习如何使用另一种更复杂的交换机 —— 主题交换机。</p>
<p>发送到主题交换机（topic exchange）的消息不可以携带随意什么样子的路由键（routing_key），它的路由键必须是一个由.分隔开的词语列表。这些单词随便是什么都可以，但是最好是跟携带它们的消息有关系的词汇。以下是几个推荐的例子：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”。词语的个数可以随意，但是不要超过 255 字节。</p>
<p>绑定键也必须拥有同样的格式。主题交换机背后的逻辑跟直连交换机很相似 —— 一个携带着特定路由键的消息会被主题交换机投递给绑定键与之想匹配的队列。但是它的绑定键和路由键有两个特殊应用方式：</p>
<ul>
<li>星号用来表示一个单词</li>
<li>井号用来表示任意数量的单词</li>
</ul>
<p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-27%2017-10-21%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=GR5WD6Fevzoj0mkBDiqNz/gnybVhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NzMzODM0JnQ9MTUyMjE0MTgzNCZyPTEzMTU2MjkyNDUmZj0vMjAxOC0wMy0yNyUyMDE3LTEwLTIxJUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""></p>
<p>这个例子里，我们发送的所有消息都是用来描述小动物的。发送的消息所携带的路由键是由三个单词所组成的，这三个单词被两个.分割开。路由键里的第一个单词描述的是动物的手脚的利索程度，第二个单词是动物的颜色，第三个是动物的种类。所以它看起来是这样的： <code>&lt;celerity&gt;.&lt;colour&gt;.&lt;species&gt;</code></p>
<p>我们创建了三个绑定：Q1 的绑定键为<code>.orange.</code>，Q2 的绑定键为 <code>..rabbit</code> 和 <code>lazy.#</code> 。</p>
<p>这三个绑定键被可以总结为：</p>
<ul>
<li>Q1 对所有的桔黄色动物都感兴趣。</li>
<li>Q2 则是对所有的兔子和所有懒惰的动物感兴趣。</li>
</ul>
<p>一个携带有 <code>quick.orange.rabbit</code> 的消息将会被分别投递给这两个队列。携带着 <code>lazy.orange.elephant</code> 的消息同样也会给两个队列都投递过去。另一方面携带有 <code>quick.orange.fox</code>的消息会投递给第一个队列，携带有 <code>lazy.brown.fox</code> 的消息会投递给第二个队列。携带有 <code>lazy.pink.rabbit</code> 的消息只会被投递给第二个队列一次，即使它同时匹配第二个队列的两个绑定。携带着 <code>quick.brown.fox</code> 的消息不会投递给任何一个队列。</p>
<p>如果我们违反约定，发送了一个携带有一个单词或者四个单词<code>orange</code> or <code>quick.orange.male.rabbit</code>的消息时，发送的消息不会投递给任何一个队列，而且会丢失掉。</p>
<p>但是另一方面，即使 <code>lazy.orange.male.rabbit</code> 有四个单词，他还是会匹配最后一个绑定，并且被投递到第二个队列中。</p>
<p>主题交换机是很强大的，它可以表现出跟其他交换机类似的行为</p>
<p>当一个队列的绑定键为 “#”（井号） 的时候，这个队列将会无视消息的路由键，接收所有的消息。</p>
<p>当 * (星号) 和 # (井号) 这两个特殊字符都未在绑定键中出现的时候，此时主题交换机就拥有的直连交换机的行为。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/26/Linux 安装ZooKeeper/">Linux 安装ZooKeeper</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-26
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Linux/">Linux</a>
            
              <a href="/categories/Linux/分布式/">分布式</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Linux-安装ZooKeeper"><a href="#Linux-安装ZooKeeper" class="headerlink" title="Linux 安装ZooKeeper"></a>Linux 安装ZooKeeper</h2><ol>
<li><p>下载zookeeper二进制安装包</p>
</li>
<li><p>解压下载的ZooKeeper</p>
</li>
<li><p>用mv命令修改zookeeper-3.4.8 为zookeeper</p>
</li>
<li><p>用cd命令进入zookeeper/conf文件夹</p>
</li>
<li><p>用cp 命令拷贝一个zoo_samle.cfg 改名为zoo.cfg</p>
</li>
<li><p>然后用gedit zoo.cfg命令打开编辑zoo.cfg文件</p>
</li>
<li><p>使用超级管理员打开环境变量文件<code>/etc/profile</code>。</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export ZOOKEEPER_HOME=/home/corn1ng/software/zookeeper</span><br><span class="line">PATH=$ZOOKEEPER_HOME/bin:$PATH</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入zookeeper/bin运行./zkServer.sh start即可</p>
</li>
</ol>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/26/Spring Ioc 容器/">SpringIoC容器详解</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-26
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Spring-Ioc-容器"><a href="#Spring-Ioc-容器" class="headerlink" title="Spring Ioc 容器"></a>Spring Ioc 容器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="IoC容器和依赖反转模式"><a href="#IoC容器和依赖反转模式" class="headerlink" title="IoC容器和依赖反转模式"></a>IoC容器和依赖反转模式</h4><p>如果合作对象的引用或依赖关系的管理由具体对象来完成，会导致代码的高度耦合和可测试性的降低，这对复杂的面向对象设计非常不利， 对象的依赖关系常常体现在数据和方法的依赖上，这些依赖关系可以通过把对象的依赖注入交给框架或IoC容器来完成，这种方法可以在解耦代码的同时提高代码的可测试性。</p>
<p>依赖控制反转的实现有很多种方式，在Spring 中，IoC容器是事先这个模式的载体，它可以在对象生成或初始化时直接将数据注入到对象中，也可以通过将对象引用注入到对象数据域的方式来注入对方法调用的依赖，这种依赖注入是可以递归的，对象被逐层注入。</p>
<h3 id="IOC设计实现"><a href="#IOC设计实现" class="headerlink" title="IOC设计实现"></a>IOC设计实现</h3><p>springIOC设计中，有两个主要的容器系列，一个是实现<code>BeanFactory</code> 接口的简单容器系列，他们只实现了容器的基本功能，另一个<code>ApplicationContext</code>应用上下文，作为容器的高级形态而存在，它在简单容器的基础上，增加了许多面向框架的特性，同时对应用环境做了许多适配。</p>
<p>作为IOC容器，需要为他的具体实现指定基本的功能规范，这个功能规范的设计表现为接口类<code>BeanFactory</code>,它体现了Spring为提供给用户使用的Ioc容器所设定的最基本的功能规范。</p>
<p>同时，Spring还通过定义<code>BeanDefinition</code>来管理基于Spring的应用中的各种对象以及它们之间的相互依赖关系，<code>BeanDefinition</code>抽象了我们对于Bean的定义，是让容器起作用的主要数据类型。对于IOC容器来说，<code>BeanDefinition</code> 就是对依赖反转模式中管理的对象依赖关系的数据抽象。也是实现依赖反转功能的核心数据结构。</p>
<p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-25%2010-15-38%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=NMNkt6BEycayBNqxc2wyx/zU2Z1hPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NTM2NDg5JnQ9MTUyMTk0NDQ4OSZyPTk0OTE5MTA1MCZmPS8yMDE4LTAzLTI1JTIwMTAtMTUtMzglRTUlQjElOEYlRTUlQjklOTUlRTYlODglQUElRTUlOUIlQkUucG5nJmI9dHdv"></p>
<p>从<code>Beanfactory</code>到<code>HierarchicalBeanFactory</code>到<code>ConfigurableBeanFacotry</code> ，是一条<code>BeanFactory</code>的设计路径，其中，<code>BeanFactory</code>接口定义了基本的Ioc容器的规范，比如<code>getBean()</code>这样的Ioc容器的基本方法，<code>HierarchicalBeanFactory</code>在原来的接口基础上，增加了<code>getparentBeanFactory()</code>的接口功能，使BeanFactory具备了双亲IoC容器的管理功能。在<code>ConfigurableBeanFacotry</code>中，主要定义了一些对<code>Beanfactory</code>的配置功能。</p>
<p>还有一条主线是以<code>ApplicationContext</code>应用上下文接口为核心的接口设计。这里的主要接口设计有从<code>BeanFactory</code>到<code>ListableBeanFatory</code>,再到<code>ApplicationContext</code>,再到我们常用的<code>WebApplicationContext</code>或者<code>ConfigurableApplicationContext</code>接口。我们常用的应用上下文基本都是<code>ConfigurableApplicationContext</code>或者<code>WebApplicationContext</code>的实现。</p>
<h4 id="Beanfactory的应用场景"><a href="#Beanfactory的应用场景" class="headerlink" title="Beanfactory的应用场景"></a>Beanfactory的应用场景</h4><p>BeanFactory提供的是最基本的Ioc容器的功能，这些功能定义，我们可以在接口BeanFactory中看到。Beanfactory接口设计了getBean方法，这个方法是使用Ioc容器API的主要方法，通过这个方法，可以取得Ioc容器中管理的Bean.<br><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-25%2012-46-15%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=NdBuQsmoo7BVI7n0v2Zv5e3fNEthPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NTQ1MjI0JnQ9MTUyMTk1MzIyNCZyPTE5ODQ3Njk1MTcmZj0vMjAxOC0wMy0yNSUyMDEyLTQ2LTE1JUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""><br>这里定义的只是一系列的接口方法，通过不同的Bean检索方法，可以方便的从容器中取出需要的Bean。</p>
<h4 id="BeanFactory容器设计原理"><a href="#BeanFactory容器设计原理" class="headerlink" title="BeanFactory容器设计原理"></a>BeanFactory容器设计原理</h4><p>以<code>XMLBeanFactory</code>为例，简单说明Ioc容器的设计原理。<br>在spring中，实际上是把<code>DefaultListableBeanFactory</code>作为一个默认的功能完整的Ioc容器来使用的，以<code>XMLBeanFactory</code>继承了<code>DefaultListableBeanFactory</code>容器的功能的同时，增加了新的功能，也就是它是一个可以读取以XML文件方式定义的BeanDefinition的Ioc容器。<br>在<code>XMLBeanFactory</code>中，初始化了一个XMLBeanDefinitionReader对象，有了这个对象，那些以XML方式定义的<code>BeanDefinition</code>就有了处理的地方。可以看到，对这些XML形式的信息的处理实际上是由这个XmlBeanDefinitionReader来完成的。<br>构造<code>XMLBeanFactory</code>这个容器的时候，需要指定<code>BeanDefinition</code>的信息来源，而这个消息来源需要封装成Spring中的<code>Resource</code>类来给出。<code>Resource</code>是Spring用来封装IO操作的类。<br>XMLBeanFactory的实现方法如下：<br><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-25%2015-02-13%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=7LOfMx1Z8elGMbhsQU2tWS4zZNVhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NTUzMzQ0JnQ9MTUyMTk2MTM0NCZyPTE3MTkzNjg3NDAmZj0vMjAxOC0wMy0yNSUyMDE1LTAyLTEzJUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""><br>XMLBeanFactory使用了DefaultListableBeanFactory作为基类。<br>下面是编程式使用XMLBeanFactory<br><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-25%2015-04-11%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=SxB/vhdkKmozzMB5B3uUBHznNfZhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NTUzNDcxJnQ9MTUyMTk2MTQ3MSZyPTk5ODU4ODM4NiZmPS8yMDE4LTAzLTI1JTIwMTUtMDQtMTElRTUlQjElOEYlRTUlQjklOTUlRTYlODglQUElRTUlOUIlQkUucG5nJmI9dHdv" alt=""><br>所以使用Ioc容器时，需要的步骤如下:<br><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-25%2015-05-43%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=F2jZ1tG+NMBxTp1E3G3pUTe/TjxhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NTUzNTgxJnQ9MTUyMTk2MTU4MSZyPTIwNDM4MzA3MDQmZj0vMjAxOC0wMy0yNSUyMDE1LTA1LTQzJUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""></p>
<h4 id="ApplicationContext应用场景"><a href="#ApplicationContext应用场景" class="headerlink" title="ApplicationContext应用场景"></a>ApplicationContext应用场景</h4><p><code>ApplicationContext</code>是一个高级形态意义的IoC容器。提供了以下新特性：</p>
<ul>
<li>支持不同的信息源（扩展了MessageSource接口，可以支持国际化）</li>
<li>访问资源</li>
<li>支持应用事件</li>
<li>提供了附加服务</li>
</ul>
<h3 id="IOC容器的初始化过程"><a href="#IOC容器的初始化过程" class="headerlink" title="IOC容器的初始化过程"></a>IOC容器的初始化过程</h3><p>Ioc容器的初始化是由<code>refresh</code>方法来启动。这个方法标志着Ioc正式启动。具体来说，这个过程包括了<code>BeanDefinition</code>的Resource定位，载入和注册三个基本过程。</p>
<p>第一个过程是Resource定位过程。指的是<code>BeanDefinition</code>的资源定位，它由<code>ResourceLoader</code>提供统一的Resource接口来完成。这个Resource对各种形式的<code>BeanDefinition</code>的使用都提供了统一的接口。具体来说，首先是定义一个<code>Resource</code>来定位容器使用的<code>BeanDefinition</code>,这时使用的是<code>ClassPathResource</code>,这意味着Spring会在类路径中去寻找以文件形式存在的<code>BeanDefinition</code>信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource res =<span class="keyword">new</span> ClassPathResource(<span class="string">"beans.xml"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里定义的Resource并不能直接的使用。Spring通过<code>BeanDefinitionReader</code>来对这些信息进行处理。<br>以<code>FileSystemApplicationContext</code>为例，对<code>BeanDefinition</code>资源定位的过程，最初是由<code>refresh</code>来<strong>触发</strong>的，这个<code>refresh()</code>的调用是在<code>FileSystemApplicationContext</code>的构造函数中启动的。</p>
<p>定位过程完成后，就为<code>BeanDefinition</code>的载入创造了IO操作的条件，但是具体的数据还没有开始读入。相当于用水桶去打水，这时候水源就已经找到了。</p>
<p>第二个过程就是<code>BeanDefinition</code>的载入与解析。</p>
<p>对Ioc容器来说，这个载入过程，想当于把定义的<code>BeanDefinition</code>在Ioc容器中转化为一个Spring内部表示的数据结构的过程。Ioc容器对Bean的管理和依赖，都是通过对其持有的<code>BeanDefinition</code>进行各种相关操作完成的。这写<code>BeanDefinition</code>数据在Ioc容器中通过一个<code>HashMap</code>来保持和维护。</p>
<p>首先，先拐回头看下Ioc容器的初始化方法<code>refresh()</code>它是在<code>FileSystemApplicationContext</code>的构造函数中被调用的。标志着容器初始化的开始。实现如下：<br><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-25%2016-15-14%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=vQFXZS6/q2KCLJz4VDdpTcR2TQBhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NTU3NzI3JnQ9MTUyMTk2NTcyNyZyPTEwNjc3NTk4MTgmZj0vMjAxOC0wMy0yNSUyMDE2LTE1LTE0JUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""><br><code>refresh()</code>方法非常像重启动容器，在建立好当前的Ioc容器后，开始了对容器的初始化过程。<br>活动图如下：<br><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-25%2016-23-12%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=rONn3xfknKALogk/2jy2PIQ/Q8dhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NTU4MjA2JnQ9MTUyMTk2NjIwNiZyPTM1Mzc5MTAzMSZmPS8yMDE4LTAzLTI1JTIwMTYtMjMtMTIlRTUlQjElOEYlRTUlQjklOTUlRTYlODglQUElRTUlOUIlQkUucG5nJmI9dHdv" alt=""></p>
<p>这里的<code>LoadBeandefinition</code>是一个抽象方法，实际在<code>AbstractXmlApplicationContext</code>中的<code>LoadBeandefinition</code>中，初始化了读取器<code>XMLBeanDefinitionReader</code>,然后把这个读取器在Ioc容器中设置好。最后启动读取器来完成<code>BeanDefinition</code>在Ioc容器中的载入。</p>
<p>可以看到，在初始化<code>FileSystemApplicationContext</code>的过程中是通过调用Ioc容器中的<code>refresh</code>来启动整个<code>BeanDefinition</code>的载入过程的。这个初始化通过定义的<code>XMLBeanDefinitionReader</code>来完成。具体的<code>Resource</code>载入在<code>XMLBeanDefinitionReader</code>读入<code>BeanDefinition</code>时实现。然后后面就是对<code>BeanDefinition</code>定义元素的处理。具体的spring <code>BeanDefinition</code>的解析是在<code>BeanDefinitionParserDelegate</code>中完成的。里面包括了各种对Spring bean定义规则的处理。</p>
<p>第三个过程就是<code>BeanDefinition</code>在Ioc容器中的注册<br>载入解析完成后，用户定义的<code>BeanDefinition</code>信息已经在Ioc容器中建立起了自己的数据结构以及相应的数据表示。但是这些数据还不能供IOc容器直接使用，需要在IOc容器中对这些<code>BeanDefinition</code>数据进行注册。注册为IoC容器提供了更加友好的使用方式，在<code>DefaultListableBeanFactory</code>中，通过<code>HashMap</code>来持有载入的<code>BeanDefinition</code>的。注册过程实际上就是把解析到<code>BeanDefinition</code>设置到HashMap中去。</p>
<p>完成了BeanDefinition的注册，就完成了IOc容器的初始化过程。</p>
<h3 id="IOC容器的依赖注入"><a href="#IOC容器的依赖注入" class="headerlink" title="IOC容器的依赖注入"></a>IOC容器的依赖注入</h3><p>假设当前Ioc容器已经载入了用户定义的Bean信息，开始分析依赖注入的原理，首先，注意到依赖注入的过程是用户第一次向Ioc容器索要Bean时触发的，当然也有例外，也就是可以在<code>BeanDefinition</code>信息中通过控制lazy-init属性来让容器完成对Bean的预实例化。这个预实例化实际上也是一个完成依赖注入的过程。但是他是在初始化的过程中完成的。</p>
<p>在Ioc容器基本接口中，有一个<code>getBean()</code>的接口定义，这个接口的实现就是触发依赖注入的地方。<code>getBean()</code>方法最终是通过调用<code>doGetBean来实现的</code>。<br><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-25%2019-24-53%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=rhKXZ7+T5r4uetmkS/hGzDQE+vRhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NTY5MjQ2JnQ9MTUyMTk3NzI0NiZyPTgzMTQ1OTM5OSZmPS8yMDE4LTAzLTI1JTIwMTktMjQtNTMlRTUlQjElOEYlRTUlQjklOTUlRTYlODglQUElRTUlOUIlQkUucG5nJmI9dHdv" alt=""><br>实际的<code>doGetBean</code>如下:</p>
<blockquote>
<p>spring技术内幕55page</p>
</blockquote>
<p>主要的逻辑就是先尝试从缓存中去取得Bean,若取到，则不需要重复的创建。然后对容器中的BeanDefinition是否存在进行检查，检查是否能在当前的BeanFactory中取得需要的Bean,如果当前的工厂取不到，就从双亲BeanFactory中去取。如果还取不到，就沿着链一直往上取。然后根据Bean的名字取得BeanDefinition。接着获取当前Bean的所有依赖Bean，这样会触发getBean的递归调用，直到取到一个没有任何依赖的Bean为止。最后对创建的Bean进行类型检查，如果没有问题，则返回这个新创建的Bean.</p>
<p>依赖注入的发生就是在容器中的BeanDefinition数据已经建立好的前提下进行的。重点来说，<code>getBean()</code>是依赖注入的起点，<code>getBean()</code>调用<code>doGetBean</code>,<code>doGetBean</code>调用<code>createBean</code>,<code>createBean</code>不仅生成了需要的Bean,还对Bean初始化进行了处理。Bean对象根据BeanDefinition要求的定义生成。</p>
<p><code>CreateBean</code>中调用<code>doCreateBean</code>来生成需要的Bean.真正的创建Bean是由<code>createBeanInstance</code>来完成的。在<code>createBeanInstance</code>中，生成了Bean所包含的Java对象，这个对象的生成有多种不同的形式，可以通过工厂方法形成，也可以通过容器的autowired特性生成。Spring中生成对象的默认类是<code>SimpleInstantiationStrategy</code>类，它提供了两种实例化Java对象的方法，一种是通过BeanUtils，它使用了JVM的反射功能，一种是通过前面提到的CGLIB来生成。</p>
<p>通过前面的描述，实例化Bean就已经完成了，接下来就要处理这些Bean的依赖关系，完成整个依赖注入过程。这个过程涉及对各种Bean对象的属性的处理过程。这些依赖关系处理的依据就是已经解析到的BeanDefinition.</p>
<p>在<code>docreatBean</code>中的<code>poulateBean</code>就是处理Bean之间依赖关系的类，</p>
<p>通过Bean的创建和对象依赖注入后，这个Bean已经不是简单的Java对象了，该Bean系列以及Bean之间的依赖关系建立好以后，通过IOC容器的相关接口方法，就可以非常方便的进行上层调用了。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/25/SpringMVC Conveter 和Formatter/">SpringMVC Conveter 和Formatter</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-25
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="SpringMVC-Conveter-和Formatter"><a href="#SpringMVC-Conveter-和Formatter" class="headerlink" title="SpringMVC Conveter 和Formatter"></a>SpringMVC Conveter 和Formatter</h2><h3 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h3><p>Spring的Converter可以将一种类型转换成另一种类型。在使用时，必须编写一个实现org.springframework.core.convert.converter.Converter接口的java类。这个接口的声明如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(S var1)</span></span>;</span><br><span class="line">&#125;<span class="comment">//S表示源类型，T表示目标类型。</span></span><br></pre></td></tr></table></figure>
<p>下面是一个将String类型转换为Date类型的Converter。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(StringToDateConverter.class);</span><br><span class="line">    <span class="keyword">private</span> String datePattern;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringToDateConverter</span><span class="params">(String datePattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.datePattern = datePattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(datePattern);</span><br><span class="line">            dateFormat.setLenient(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> dateFormat.parse(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid date format. Please use this pattern\""</span> + datePattern + <span class="string">"\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用Spring MVC应用程序定制的Converter，需要在配置文件中添加一个conversionService bean。Bean的类名称必须为org.springframework.context.support.ConversionServiceFactoryBean。这个bean必须包含一个converters属性，它列出要在应用程序中使用的所有定制Converter。下面bean声明注册了上面StringToDateConverter。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.converter.StringToDateConverter"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"datePattern"</span> <span class="attr">value</span>=<span class="string">"yyyy-MM-dd"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后，还需要给annotation-driven元素的conversion-service属性赋上bean名称，如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h3><p>Formatter和Converter一样，也是将一种类型转换成另一种类型。但是，Formatter的源类型必须是一个String。<br>在使用时，必须编写一个实现org.springframework.format.Formatter接口的java类。这个接口的声明如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formatter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">print</span><span class="params">(T var1, Locale var2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">parse</span><span class="params">(String var1, Locale var2)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的T表示输入字符串要转换的目标类型。<br>parse方法利用指定的Locale将一个String解析成目标类型。print方法相反，它是返回目标对象的字符串表示法。<br>下面展示了一个将String类型转换成Date类型的Formatter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.format.Formatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String datePattern;</span><br><span class="line">    <span class="keyword">private</span> SimpleDateFormat dateFormat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DateFormatter</span><span class="params">(String datePattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dateFormat = dateFormat;</span><br><span class="line">        dateFormat = <span class="keyword">new</span> SimpleDateFormat(datePattern);</span><br><span class="line">        dateFormat.setLenient(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String s, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(datePattern);</span><br><span class="line">            dateFormat.setLenient(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> dateFormat.parse(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid date format. Please use this pattern\""</span> + datePattern + <span class="string">"\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">(Date date, Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用Spring MVC应用程序定制的Formatter，需要在配置文件中添加一个conversionService bean。Bean的类名称必须为org.springframework.format.support.FormattingConversionServiceFactoryBean。这个bean可以用一个formatters属性注册Formatter，用一个converters属性注册Converter。下面bean声明注册了上面DateFormatter。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"formatters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"app06a.formatter.DateFormatter"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"datePattern"</span> <span class="attr">value</span>=<span class="string">"yyyy-MM-dd"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后，还需要给annotation-driven元素的conversion-service属性赋上bean名称，如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="用Registrar注册Formatter"><a href="#用Registrar注册Formatter" class="headerlink" title="用Registrar注册Formatter"></a>用Registrar注册Formatter</h3><p>注册Formatter的另一种方法是使用Registrar。<br>下面就用Registrar来注册前面的DateFormatter。<br>先需要实现org.springframework.format.FormatterRegistrar接口，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.format.FormatterRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.format.FormatterRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFormatterRegistrar</span> <span class="keyword">implements</span> <span class="title">FormatterRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String datePattern;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyFormatterRegistrar</span><span class="params">(String datePattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.datePattern = datePattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFormatters</span><span class="params">(FormatterRegistry formatterRegistry)</span> </span>&#123;</span><br><span class="line">        formatterRegistry.addFormatter(<span class="keyword">new</span> DateFormatter(datePattern));</span><br><span class="line">        <span class="comment">//register more formatters here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了Registrar，就不需要在Spring MVC配置文件中注册Formatter，只要在配置文件中注册Registrar就行，如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"formatterRegistrars"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"app06a.formatter.MyFormatterRegistrar"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"datePattern"</span> <span class="attr">value</span>=<span class="string">"yyyy-MM-dd"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="选择Converter还是Formatter"><a href="#选择Converter还是Formatter" class="headerlink" title="选择Converter还是Formatter"></a>选择Converter还是Formatter</h3><p>Converter是一般工具，可以将一种类型转换成另一种类型。例如，将String转换成Date，或者将Long转换成Date。Converter既可以用在web层，也可以用在其它层中。<br>Formatter只能将String转成成另一种java类型。例如，将String转换成Date，但它不能将Long转换成Date。所以，Formatter适用于web层。为此，在Spring MVC应用程序中，选择Formatter比选择Converter更合适。</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000005708254" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005708254</a></p>
</blockquote>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/24/分布式基本理论/">分布式基本理论</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-24
        </span>
        
          <div class="post-category">
            
              <a href="/categories/分布式/">分布式</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="分布式基本理论"><a href="#分布式基本理论" class="headerlink" title="分布式基本理论"></a>分布式基本理论</h2><p>在计算机领域，分布式一致性是一个相当重要且被广泛探索与论证的问题。</p>
<p>终端用户在使用不同计算机产品时对于数据一致性的需求是不一样的。</p>
<ul>
<li>有些系统，既要快速的响应用户，同时还要保证系统的数据对于任意客户端都是真实可靠的，就像火车站的售票系统。</li>
<li>有些系统，需要为用户保证绝对可靠的数据安全，虽然在数据一致性上存在延时，但是最终务必保证严格的一致性，就像银行的转账系统。</li>
<li>有些系统，虽然向用户展示了一些错误的数据，但是在整个系统的使用过程中，一定会在某一个流程上对系统数据进行精确无误的检查，从而避免用户发生不必要的损失，就像网购系统。</li>
</ul>
<h3 id="分布一致性的提出"><a href="#分布一致性的提出" class="headerlink" title="分布一致性的提出"></a>分布一致性的提出</h3><p>在分布式系统中要解决的一个重要问题就是数据的复制。在我们的日常开发经验中，相信很多开发人员都遇到过这样的问题：假设客户端C1将系统中的一个值K由V1更新为V2，但客户端C2无法立即读取到K的最新值，需要在一段时间之后才能读取到。这很正常，因为数据库复制之间存在延时。</p>
<p>分布式系统对于数据的复制需求一般都来自于以下两个原因：</p>
<p>1、为了增加系统的可用性，以防止单点故障引起的系统不可用</p>
<p>2、提高系统的整体性能，通过负载均衡技术，能够让分布在不同地方的数据副本都能够为用户提供服务。</p>
<p>数据复制在可用性和性能方面给分布式系统带来的巨大好处是不言而喻的，然而数据复制所带来的一致性挑战，也是每一个系统研发人员不得不面对的。</p>
<p>所谓分布一致性问题，是指在分布式环境中引入数据复制机制之后，不同数据节点之间可能出现的，并无法依靠计算机应用程序自身解决的数据不一致的情况。简单讲，数据一致性就是指在对一个副本数据进行更新的时候，必须确保也能够更新其他的副本，否则不同副本之间的数据将不一致。</p>
<p>那么如何解决这个问题？一种思路是”<strong>既然是由于延时动作引起的问题，那我可以将写入的动作阻塞，直到数据复制完成后，才完成写入动作</strong>“。没错，这似乎能解决问题，而且有一些系统的架构也确实直接使用了这个思路。但这个思路在解决一致性问题的同时，又带来了新的问题：写入的性能。如果你的应用场景有非常多的写请求，那么使用这个思路之后，后续的写请求都将会阻塞在前一个请求的写操作上，导致系统整体性能急剧下降。</p>
<p>总得来说，我们无法找到一种能够满足分布式系统所有系统属性的分布式一致性解决方案。因此，如何既保证数据的一致性，同时又不影响系统运行的性能，是每一个分布式系统都需要重点考虑和权衡的。于是，一致性级别由此诞生：</p>
<p>1、强一致性</p>
<p>这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大</p>
<p>2、弱一致性</p>
<p>这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</p>
<p>3、最终一致性</p>
<p>最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型。</p>
<h3 id="分布式环境中的各种问题"><a href="#分布式环境中的各种问题" class="headerlink" title="分布式环境中的各种问题"></a>分布式环境中的各种问题</h3><p>分布式系统在其出现之初就伴随着诸多难题和挑战。</p>
<p>1、通信异常</p>
<p>从集中式向分布式演变的过程中，必然引入网络因素，由于网络本身的不可靠性，因此也引入了额外的问题。分布式系统需要在各个节点之间进行网络通信，因此每次网络通信都会伴随着网络不可用的风险，网络光纤、路由器或是DNS等硬件设备或是系统不可用都会导致最终分布式系统无法顺利完成一次网络通信。另外，即使分布式系统各个节点之间的网络通信能够正常进行，其延时也会大于单机操作。通常我们认为现代计算机体系结构中，单机内存访问的延时在纳秒数量级（通常是10ns），而正常的一次网络通信的延迟在0.1~1ms左右（相当于内存访问延时的105倍），如此巨大的延时差别，也会影响到消息的收发过程，因此消息丢失和消息延迟变得非常普遍</p>
<p>2、网络分区</p>
<p><strong>当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点之间能够正常通信，而另一些节点则不能—-我们将这个现象称为网络分区</strong>。当网络分区出现时，分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本需要整个分布式系统才能完成的功能，包括对数据的事物处理，这就对分布式一致性提出了非常大的挑战</p>
<p>3、三态</p>
<p>上面两点，我们已经了解到在分布式环境下，网络可能会出现各式各样的问题，因此分布式系统的每一次请求与响应，存在特有的三态概念，即<strong>成功、失败、超时</strong>。在传统的单机系统中，应用程序在调用一个函数之后，能够得到一个非常明确的响应：成功或失败。而在分布式系统中，由于网络是不可靠的，虽然在绝大部分情况下，网络通信也能够接受到成功或失败的响应，当时当网络出现异常的情况下，就可能会出现超时现象，通常有以下两种情况：</p>
<p>（1）由于网络原因，该请求并没有被成功地发送到接收方，而是在发送过程中就发生了消息丢失现象</p>
<p>（2）该请求成功地被接收方接收后，进行了处理，但是在将响应反馈给发送方的过程中，发生了消息丢失现象</p>
<p>当出现这样的超时现象时，网络通信的发起方是无法确定当前请求是否被成功处理的</p>
<p>4、节点故障</p>
<p>节点故障则是分布式环境下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或”僵死”现象，通常根据经验来说，每个节点都有可能出现故障，并且每天都在发生。</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>随着分布式计算的发展，事物在分布式计算领域也得到了广泛的应用。在单机数据库中，我们很容易能够实现一套满足ACID特性的事物处理系统，但在分布式数据库中，数据分散在各台不同的机器上，如何对这些数据进行分布式的事物处理具有非常大的挑战。</p>
<p>分布式事物是指事物的参与者、支持事物的服务器、资源服务器以及事物管理器分别位于分布式系统的不同节点上，通常一个分布式事物中会涉及对多个数据源或业务系统的操作。</p>
<p>可以设想一个最典型的分布式事物场景：一个跨银行的转账操作涉及调用两个异地的银行服务，其中一个是本地银行提供的取款服务，另一个则是目标银行提供的存款服务，这两个服务本身是无状态并且相互独立的，共同构成了一个完整的分布式事物。如果从本地银行取款成功，但是因为某种原因存款服务失败了，那么就必须回滚到取款之前的状态，否则用户可能会发现自己的钱不翼而飞了。</p>
<p>从这个例子可以看到，一个分布式事务可以看做是多个分布式的操作序列组成的，例如上面例子的取款服务和存款服务，通常可以把这一系列分布式的操作序列称为子事物。因此，分布式事务也可以被定义为一种嵌套型的事物，同时也就具有了ACID事物特性。但由于在分布式事务中，各个子事物的执行是分布式的，因此要实现一种能够保证ACID特性的分布式事物处理系统就显得格外复杂。</p>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>一个经典的分布式系统理论。CAP理论告诉我们：<strong>一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance*）这三个基本需求，最多只能同时满足其中两项</strong>。</p>
<p><strong>1、一致性</strong></p>
<p>在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一直的状态。</p>
<p>对于一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据进行了更新操作并且更新成功后，却没有使得第二个节点上的数据得到相应的更新，于是在对第二个节点的数据进行读取操作时，获取的依然是老数据（或称为脏数据），这就是典型的分布式数据不一致的情况。在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都可以读取到其最新的值，那么这样的系统就被认为具有强一致性</p>
<p><strong>2、可用性</strong></p>
<p>可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里的重点是”有限时间内”和”返回结果”。</p>
<p>“有限时间内”是指，对于用户的一个操作请求，系统必须能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。另外，”有限的时间内”是指系统设计之初就设计好的运行指标，通常不同系统之间有很大的不同，无论如何，对于用户请求，系统必须存在一个合理的响应时间，否则用户便会对系统感到失望。</p>
<p>“返回结果”是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出队请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。</p>
<p>3、分区容错性</p>
<p>分区容错性约束了一个分布式系统具有如下特性：<strong>分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障</strong>。</p>
<p>网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络）中，由于一些特殊的原因导致这些子网络出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区。</p>
<p>既然一个分布式系统无法同时满足一致性、可用性、分区容错性三个特点，所以我们就需要抛弃一样：</p>
<p><img src="http://images2015.cnblogs.com/blog/801753/201511/801753-20151107213219867-1667011131.png" alt="img"></p>
<p>用一张表格说明一下：</p>
<table>
<thead>
<tr>
<th><strong>选    择</strong></th>
<th><strong>说    明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CA</td>
<td>放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择</td>
</tr>
<tr>
<td>AP</td>
<td>放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此</td>
</tr>
<tr>
<td>CP</td>
<td>放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用</td>
</tr>
</tbody>
</table>
<p>需要明确的一点是，对于一个分布式系统而言，分区容错性是一个最基本的要求。因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统架构师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡。</p>
<p><strong>BASE理论</strong></p>
<p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。BASE理论的核心思想是：<strong>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</strong>。接下来看一下BASE中的三要素：</p>
<p><strong>1、基本可用</strong></p>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性—-注意，这绝不等价于系统不可用。比如：</p>
<p>（1）响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒</p>
<p>（2）系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面</p>
<p><strong>2、软状态</strong></p>
<p>软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</p>
<p><strong>3、最终一致性</strong></p>
<p>最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<p>总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，<strong>它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态</strong>。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/20/正则表达式/">正则表达式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-20
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Python/">Python</a>
            
              <a href="/categories/Python/计算机基础/">计算机基础</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="匹配定长的字符"><a href="#匹配定长的字符" class="headerlink" title="匹配定长的字符"></a>匹配定长的字符</h3><p>在正则表达式中,如果直接给出字符,就是精确匹配,</p>
<p>用<code>\d</code>可以匹配一个数字.</p>
<p><code>\w</code>可以匹配一个字母或者数字.</p>
<p><code>.</code>可以匹配任意字符.</p>
<h3 id="匹配变长的字符"><a href="#匹配变长的字符" class="headerlink" title="匹配变长的字符"></a>匹配变长的字符</h3><p>要匹配变长的字符，在正则表达式中.</p>
<p>用<code>*</code>表示任意个字符（包括0个）.</p>
<p>用<code>+</code>表示至少一个字符.</p>
<p>用<code>?</code>表示0个或1个字符.</p>
<p>用<code>{n}</code>表示n个字符.</p>
<p>用<code>{n,m}</code>表示n-m个字符.</p>
<h4 id="例子-d-3-s-d-3-8"><a href="#例子-d-3-s-d-3-8" class="headerlink" title="例子\d{3}\s+\d{3,8}"></a>例子<code>\d{3}\s+\d{3,8}</code></h4><ol>
<li><code>\d{3}</code>表示匹配3个数字，例如<code>&#39;010&#39;</code>；</li>
<li><code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>&#39; &#39;</code>，<code>&#39; &#39;</code>等；</li>
<li><code>\d{3,8}</code>表示3-8个数字，例如<code>&#39;1234567&#39;</code>。</li>
</ol>
<p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p>
<p>如果要匹配<code>&#39;010-12345&#39;</code>这样的号码呢？由于<code>&#39;-&#39;</code>是特殊字符，在正则表达式中，要用<code>&#39;\&#39;</code>转义，所以，上面的正则是<code>\d{3}\-\d{3,8}</code>。</p>
<h3 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h3><p>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：</p>
<ul>
<li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li>
<li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>&#39;a100&#39;</code>，<code>&#39;0_Z&#39;</code>，<code>&#39;Py3000&#39;</code>等等；</li>
<li><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</li>
<li><code>[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li>
</ul>
<p><code>A|B</code>可以匹配A或B，所以<code>(P|p)ython</code>可以匹配<code>&#39;Python&#39;</code>或者<code>&#39;python&#39;</code>。</p>
<p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p>
<p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p>
<p>所以<code>py</code>也可以匹配<code>&#39;python&#39;</code>，但是加上<code>^py$</code>就变成了整行匹配，就只能匹配<code>&#39;py&#39;</code>了。</p>
<h2 id="Python-中的正则匹配式"><a href="#Python-中的正则匹配式" class="headerlink" title="Python 中的正则匹配式"></a>Python 中的正则匹配式</h2><h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><p>由于Python的字符串本身也用<code>\</code>转义，因此使用Python的<code>r</code>前缀，就不用考虑转义的问题了.下面是一个例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">r'ABC\-001'</span> <span class="comment"># Python的字符串</span></span><br><span class="line"><span class="comment"># 对应的正则表达式字符串不变：</span></span><br><span class="line"><span class="comment"># 'ABC\-001'</span></span><br></pre></td></tr></table></figure>
<p><code>match()</code>方法判断是否匹配，如果匹配成功，返回一个<code>Match</code>对象，否则返回<code>None</code>。常见的判断方法就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test = <span class="string">'用户输入的字符串'</span></span><br><span class="line"><span class="keyword">if</span> re.match(<span class="string">r'正则表达式'</span>, test):</span><br><span class="line">    print(<span class="string">'ok'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'failed'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h3><p>用正则表达式切分字符串比用固定的字符更灵活，下面是正常的切分代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a b   c'</span>.split(<span class="string">' '</span>)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<p>无法识别连续的空格，下面正则表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\s+'</span>, <span class="string">'a b   c'</span>)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<p>无论多少个空格都可以正常分割。加入<code>,</code>试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'[\s\,]+'</span>, <span class="string">'a,b, c  d'</span>)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure>
<p>再加入<code>;</code>试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'[\s\,\;]+'</span>, <span class="string">'a,b;; c  d'</span>)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="comment"># 上面的正则表示\s,逗号,分号都至少有一个的话都可以当分隔符.</span></span><br></pre></td></tr></table></figure>
<p>如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。</p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是要提取的分组（Group）。比如：</p>
<p><code>^(\d{3})-(\d{3,8})$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>, <span class="string">'010-12345'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">9</span>), match=<span class="string">'010-12345'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)</span><br><span class="line"><span class="string">'010-12345'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)</span><br><span class="line"><span class="string">'010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)</span><br><span class="line"><span class="string">'12345'</span></span><br></pre></td></tr></table></figure>
<p>如果正则表达式中定义了组，就可以在<code>Match</code>对象上用<code>group()</code>方法提取出子串来。</p>
<p>注意到<code>group(0)</code>永远是原始字符串，<code>group(1)</code>、<code>group(2)</code>……表示第1、2、……个子串。</p>
<p>提取子串非常有用。来看一个更凶残的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="string">'19:05:30'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$'</span>, t)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()</span><br><span class="line">(<span class="string">'19'</span>, <span class="string">'05'</span>, <span class="string">'30'</span>)</span><br></pre></td></tr></table></figure>
<p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$'</span></span><br></pre></td></tr></table></figure>
<p>对于<code>&#39;2-30&#39;</code>，<code>&#39;4-31&#39;</code>这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p>
<h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^(\d+)(0*)$'</span>, <span class="string">'102300'</span>).groups()</span><br><span class="line">(<span class="string">'102300'</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p>
<p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^(\d+?)(0*)$'</span>, <span class="string">'102300'</span>).groups()</span><br><span class="line">(<span class="string">'1023'</span>, <span class="string">'00'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p>
<ol>
<li>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</li>
<li>用编译后的正则表达式去匹配字符串。</li>
</ol>
<p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 编译:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone = re.compile(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>)</span><br><span class="line"><span class="comment"># 使用：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone.match(<span class="string">'010-12345'</span>).groups()</span><br><span class="line">(<span class="string">'010'</span>, <span class="string">'12345'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone.match(<span class="string">'010-8086'</span>).groups()</span><br><span class="line">(<span class="string">'010'</span>, <span class="string">'8086'</span>)</span><br></pre></td></tr></table></figure>
<p>编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。</p>
<blockquote>
<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143193331387014ccd1040c814dee8b2164bb4f064cff000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143193331387014ccd1040c814dee8b2164bb4f064cff000</a></p>
</blockquote>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/03/Java 运行和编译的过程/">Java 运行和编译的过程</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-03
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Java-运行和编译的过程"><a href="#Java-运行和编译的过程" class="headerlink" title="Java 运行和编译的过程"></a>Java 运行和编译的过程</h2><p>Java程序从源文件创建到程序运行要经过两大步骤：1、源文件由编译器编译成字节码（ByteCode）（编译）  2、字节码由java虚拟机解释运行。（运行）因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言（ “semi-interpreted” language）。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>通过以下这个java程序，来说明java程序从编译到最后运行的整个流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainApp.java  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal(<span class="string">"Cat"</span>);  </span><br><span class="line">        animal.printName();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//Animal.java  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> String name;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Animal:"</span>+name);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>编译</p>
<p>创建完源文件之后，程序会先被编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用。编译后的字节码文件格式主要分为两部分：<strong>常量池</strong>和<strong>方法字节码</strong>。常量池记录的是代码出现过的所有token(类名，成员变量名等等)以及符号引用（方法引用，成员变量引用等等）；方法字节码放的是类中各个方法的字节码。</p>
</li>
<li><p>运行</p>
</li>
</ul>
<p>java类运行的过程大概可分为两个过程：1、类的加载  2、类的执行。需要说明的是：<strong>JVM主要在程序第一次主动使用类的时候，才会去加载该类</strong> 。也就是说，JVM并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。</p>
<pre><code>下面是程序运行期的详细步骤：
</code></pre><ol>
<li>在编译好java程序得到MainApp.class文件后，在命令行上敲java AppMain。系统就会启动一个jvm进程，jvm进程从classpath路径中找到一个名为AppMain.class的二进制文件，将MainApp的类信息加载到运行时数据区的方法区内，这个过程叫做MainApp类的加载。</li>
<li>然后JVM找到AppMain的主函数入口，开始执行main函数。</li>
<li>main函数的第一条命令是Animal  animal = new Animal(“Cat”);就是让JVM创建一个Animal对象，但是这时候方法区中没有Animal类的信息，所以JVM马上加载Animal类，把Animal类的类型信息放到方法区中。<strong>（new的时候才会加载）</strong></li>
<li>加载完Animal类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的Animal实例分配内存, 然后调用构造函数初始化Animal实例，这个Animal实例持有着指向方法区的Animal类的类型信息（其中包含有方法表，java动态绑定的底层实现）的引用。</li>
<li>当使用animal.printName()的时候，JVM根据animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息的方法表，获得printName()函数的字节码的地址。</li>
<li>开始运行printName()函数。</li>
</ol>
<h4 id="类加载简述"><a href="#类加载简述" class="headerlink" title="类加载简述"></a>类加载简述</h4><ul>
<li>(1) 装载：查找和导入Class文件；</li>
</ul>
<ul>
<li>(2) 链接：把类的二进制数据合并到JRE中；<ul>
<li>(a)校验：检查载入Class文件数据的正确性；</li>
<li>(b)准备：给类的静态变量分配存储空间；</li>
<li>(c)解析：将符号引用转成直接引用；</li>
</ul>
</li>
<li>(3) 初始化：对类的静态变量，静态代码块执行初始化操作</li>
</ul>
<p><strong>Java程序可以动态扩展是由运行期动态加载和动态链接实现的；比如：如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现(多态)，解析过程有时候还可以在初始化之后执行；比如：动态绑定(多态)。运行时动态加载需要加载的对象（反射）</strong></p>
<blockquote>
<p><a href="https://www.cnblogs.com/qiumingcheng/p/5398610.html" target="_blank" rel="noopener">https://www.cnblogs.com/qiumingcheng/p/5398610.html</a></p>
</blockquote>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/28/应用架构演进/">应用架构演进</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-28
        </span>
        
          <div class="post-category">
            
              <a href="/categories/分布式/">分布式</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="应用架构演进"><a href="#应用架构演进" class="headerlink" title="应用架构演进"></a>应用架构演进</h2><h4 id="传统垂直应用架构"><a href="#传统垂直应用架构" class="headerlink" title="传统垂直应用架构"></a>传统垂直应用架构</h4><p>06年前，比较流行的有LAMP架构，MVC架构(Spring，Struts，Hibernate)，厚重的EJB企业架构也流行了很长一段时间。他们都属于垂直应用架构，技术比较单一，学习成本低，开发上手快，因此很长一段时间都处于统治地位。</p>
<p>举例说明MVC的垂直架构的示意图如下所示：</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180228201842.png" alt=""></p>
<p>通常MVC架构的应用代码会统一打包成一个war包，部署在Tomcat等web容器中。不同的应用功能之间通过本地API进行调用，基本不存在跨进程的远程服务调用。</p>
<p>但是，垂直架构的缺点十分突出，主要表现在复杂应用的维护成本高，部署效率逐渐的降低，团队协作效率差，部分公共功能重复开发，代码重复率居高不下，系统可靠性不断的变差，新功能上线的周期越来越长。</p>
<h4 id="RPC-架构"><a href="#RPC-架构" class="headerlink" title="RPC 架构"></a>RPC 架构</h4><p>RPC全称Remote Procedure Call,是一种进程间的通信方式，允许像调用本地服务一样调用远程服务，它的具体实现方式可以不同，例如Spring 的HTTP Invoker,Facebook 的Thrift 二进制私有协议通信。</p>
<p>06年后，随着移动互联网的发展，远程分布式调用已经成为主流，RPC框架也犹如雨后春笋。RPC框架的普及标志着传统垂直应用架构时代的终结。</p>
<h5 id="RPC-框架原理"><a href="#RPC-框架原理" class="headerlink" title="RPC 框架原理"></a>RPC 框架原理</h5><p>RPC 框架的目标就是让远程过程调用更加简单，透明，RPC框架负责屏蔽底层的传输方式(TCP 或UDP), 序列化方式(XML,JSON,二进制)和通信细节。框架的使用者只需要知道了解谁在什么位置提供了什么样的远程服务接口即可，开发者不需要关心底层通信细节和调用过程。</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180228203828.png" alt=""></p>
<p>RPC 框架实现的技术核心点有</p>
<ul>
<li>远程服务提供者需要以某种形式提供服务调用相关的信息，包括但是不限于服务接口定义，数据结构，或者中间态的服务定义文件。</li>
<li>远程代理对象：服务调用者调用的服务实际上是远程服务的本地代理，对于Java语言来说，它的实现就是JDK的动态代理，通过动态代理的拦截机制，将本地调用封装成远程服务调用。</li>
<li>通信：RPC框架与具体的协议无关，</li>
<li>序列化：远程通信，需要将对象转化为二进制码流进行网络传输，不同的序列化框架，支持的数据类型，数据包大小，异常类型，性能等都不同。一般好的框架都支持多种序列化方式。</li>
</ul>
<p>业界主流的RPC框架有Facebook的Thrift,Google的gRPC等。</p>
<h5 id="RPC框架的挑战"><a href="#RPC框架的挑战" class="headerlink" title="RPC框架的挑战"></a>RPC框架的挑战</h5><p>在大规模服务化之前，应用可能只是通过RPC框架，简单的暴露和引用远程服务，通过配置简单的URL地址进行远程服务调用，当服务越来越多时，服务URL配置管理越来越困难，    硬件负载均衡器的单点压力也越来越大，此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。</p>
<p>随着业务的发展，服务间的依赖错综复杂，甚至分不清哪个应用需要在哪个应用之前启动，同时，服务的调用量越来越大，服务的容量问题也就暴露出来了。服务上线容易下线难，上线前的审批，下线通知，需要统一的服务生命周期管理泪流成进行管控，不同的服务安全权限不同，如何保证敏感服务不被误调用。服务化之后，服务治理问题，单凭RPC框架是无法解决的。</p>
<h4 id="SOA-面向服务的架构-可以说RPC是SOA架构的一种实现"><a href="#SOA-面向服务的架构-可以说RPC是SOA架构的一种实现" class="headerlink" title="SOA 面向服务的架构(可以说RPC是SOA架构的一种实现)"></a>SOA 面向服务的架构(可以说RPC是SOA架构的一种实现)</h4><p>SOA 是一种粗粒度，松耦合的以服务为中心的架构，接口之间通过明确的协议和接口进行通信。SOA帮助工程师们站在一个新的高度理解企业级架构中各种组件的开发和部署形式。相对于传统的非服务化架构，SOA能够更加从容的应对复杂企业系统集成和需求的快速变化。</p>
<p>它的设计原则主要有服务可复用，服务共享一个标准契约，服务是松耦合的，服务是底层逻辑的抽象，服务是可组合的，可编排的，服务是无状态的。所以SOA服务治理是关键。</p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构（MSA）是一种服务化架构风格，通过将功能分散到各个分散的服务中以实现对解决方案的解耦。</p>
<p>主要特征有，原子服务，专注于做一件事，高密度部署(重要的服务可以独立进程部署)，敏捷交付，微自治(服务足够小，功能单一，可以独立打包，部署，升级)</p>
<h3 id="微服务对比SOA"><a href="#微服务对比SOA" class="headerlink" title="微服务对比SOA"></a>微服务对比SOA</h3><ul>
<li>服务拆分粒度：SOA首先要解决的就是异构应用的服务化，微服务强调的是独舞拆分要尽可能的小，最好是独立的原子服务</li>
<li>服务依赖：传统的SOA服务，由于需要重用已有的资产，存在大量的服务间依赖：微服务的设计理念是服务自治，功能单一独立，，避免依赖其他服务产生耦合，耦合会带来更高的复杂度。</li>
<li>服务规模：传统的SOA服务粒度较大，多数会采用将多个服务合并打成war包的方案，因此服务实例数比较有限，微服务强调尽可能的拆分，同时，很多服务会独立部署，这也会导致服务规模急剧增加，对服务治理和运维带来新挑战。</li>
<li>架构差异 微服务化后，服务数量的激增会引起架构质量属性的变化，例如企业集成总线ESB逐渐被P2P虚拟总线替换，为了保证高性能，低时延，需要高性能的分布式服务框架保证微服务架构的实施。</li>
</ul>
<p>用一张图概括服务化架构演进图如下：</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180228215337.png" alt=""></p>
<p>(RPC算是SOA的一种简单实现)</p>
<blockquote>
<p>分布式服务框架原理与实践</p>
</blockquote>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/3/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/5/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:wangkangning1@foxmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="http://github.com/corn1ng" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://www.instagram.com/brett0427/" class="iconfont icon-instagram" title="instagram"></a>
        
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">corn1ng</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
