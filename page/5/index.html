<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Gotta Make A Change"/>













  <link rel="alternate" href="/default" title="Corn1ng's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="https://corn1ng.github.io/page/5/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> Corn1ng's Blog </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Corn1ng's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Corn1ng's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/23/虚拟机字节码执行引擎/">Java虚拟机字节码执行引擎</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-23
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>虚拟机的执行引擎由自己事先，所以可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。</p>
<p>在不同的虚拟机事先中，执行引擎在执行Java代码的时候可能会产生解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择，也可能两种兼备。但是从外观看来，大家都是一样的，输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</p>
<h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p>栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构,它是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程,都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候,栈帧中需要多大的局部变量表,多深的操作数栈都已经完全确定了,并且写入到方法表的Code属性之中 ,因此一个栈帧需要分配多少内存,不会受到程序运行期变量数据的影响,而仅仅取决于具体的虚拟机实现。</p>
<p>一个线程中的方法调用链可能会很长,很多方法都同时处于执行状态。对于执行引擎来说,在活动线程中,只有位于栈顶的栈帧才是有效的,称为当前栈帧(Current Stack Frame),与这个栈帧相关联的方法称为当前方法(Current Method)。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。</p>
<ul>
<li>局部变量表</li>
</ul>
<p>局部变量表(Local Variable Table)是一组变量值存储空间,用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时,就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。局部变量表建立在线程的堆栈上，时线程私有的数据。</p>
<ul>
<li>操作数栈</li>
</ul>
<p>操作数栈也常称为操作栈，同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型.</p>
<p>当一个方法刚刚开始执行的时候,这个方法的操作数栈是空的,在方法的执行过程中,会有各种字节码指令往操作数栈中写入和提取内容,也就是出栈/入栈操作。例如,在做算术运算的时候是通过操作数栈来进行的,又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。</p>
<ul>
<li>动态连接</li>
</ul>
<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用,持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。Class文件的常量池中存有大量的符号引用,字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用,这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用,这部分称为动态连接。</p>
<ul>
<li>方法返回地址</li>
</ul>
<p>当一个方法开始执行后,只有两种方式可以退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令,这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为调用者),是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定,这种退出方法的方式称为正常完成出口。<br>另外一种退出方式是,在方法执行过程中遇到了异常,并且这个异常没有在方法体内得到处理,无论是Java虚拟机内部产生的异常,还是代码中使用athrow字节码指令产生的异常,只要在本方法的异常表中没有搜索到匹配的异常处理器,就会导致方法退出,这种退出方法的方式称为异常完成出口。一个方法使用异常完成出口的方式退出,是不会给它的上层调用者产生任何返回值的。<br>无论采用何种退出方式,在方法退出之后,都需要返回到方法被调用的位置,程序才能继续执行,方法返回时可能需要在栈帧中保存一些信息,用来帮助恢复它的上层方法的执行状态。一般来说,方法正常退出时,调用者的PC计数器的值可以作为返回地址,栈帧中很可能会保存这个计数器值。而方法异常退出时,返回地址是要通过异常处理器表来确定的,栈帧中一般不会保存这部分信息。</p>
<ul>
<li>附加信息</li>
</ul>
<p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中,例如与调试相关的信息,这部分信息完全取决于具体的虚拟机实现,这里不再详述。在实际开发中,一般会把动态连接、方法返回地址与其他附加信息全部归为一类,称为栈帧信息。</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p><strong>方法调用并不等同于方法执行,方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法),暂时还不涉及方法内部的具体运行过程。在程序运行时,进行方法调用是最普遍、最频繁的操作,但前面已经讲过,Class文件的编译过程中不包含传统编译中的连接步骤,一切方法调用在Class文件里面存储的都只是符号引用,而不是方法在实际运行时内存布局中的入口地址(相当于之前说的直接引用)。这个特性给Java带来了更强大的动态扩展能力,但也使得Java方法调用过程变得相对复杂起来,需要在类加载期间,甚至到运行期间才能确定目标方法的直接引用。</strong></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用。在类加载的解析阶段，会将其中一部分符号引用转化为直接引用，这种解析能成立的前提是方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。这类方法的调用称为解析。</p>
<p><strong>在Java中，符合编译期可知，运行期不可变这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，他们都适合在类加载阶段进行解析。</strong></p>
<p>解析调用一定是一个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用。不会延迟到运行期再去完成。</p>
<h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><p>静态分派</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man =<span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>
<p> Human 称为变量的静态类型，Man称为变量的实际类型，静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是装载编译期可知的，而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p>
<p>在重载中，编译器的重载是通过参数的静态类型而不是实际类型作为判定依据的。而静态类型在编译期是可知的，所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，典型应用就是重载。</p>
<p>动态分派</p>
<p>动态分派与重写有密切关联。</p>
<h4 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h4><p><strong>动态语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期。比如,js,php,python,ruby,lua，相对的，在编译期就进行类型检查过程的语言就是最常用的静态类型语言。</strong></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/13/JZoffer56/">剑指offer56*数组中只出现一次的两个数字</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-13
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法题/">算法题</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
          <div class="read-more">
            <a href="/2018/02/13/JZoffer56/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/12/JZoffer54/">剑指offer54 二叉搜索树的第K大节点</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-12
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法题/">算法题</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个二叉搜索树，请找出第k大的节点。（leetcode230）</p>
          <div class="read-more">
            <a href="/2018/02/12/JZoffer54/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/12/JZoffer46/">剑指offer46 把数字翻译成字符串</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-12
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法题/">算法题</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个数字，按照如下规则把他翻译成字符串，0翻译成a,1翻译成b,……….11 翻译成l，25翻译成z,这样一个数字可能有多种翻译方式，请计算一个数字有多少种翻译的方法。</p>
          <div class="read-more">
            <a href="/2018/02/12/JZoffer46/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/11/JZoffer43/">剑指offer*43 1-n整数中1出现的次数</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-11
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法题/">算法题</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
          <div class="read-more">
            <a href="/2018/02/11/JZoffer43/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/11/虚拟机类加载机制/">Java虚拟机类加载机制</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-11
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、 转换解析和初始化， 最终形成可以被虚拟机直接使用的Java类型， 这就是虚拟机的类加载机制。</p>
<p>在Java语言里面， 类型的加载、 连接和初始化过程都是在程序运行期间完成的， 这种策略虽然会令类加载时稍微增加一些性能开销， 但是会为Java应用程序提供高度的灵活性， Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。 例如， 如果编写一个面向接口的应用程序， 可以等到运行时再指定其实际的实现类。</p>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>类从被加载到虚拟机内存中开始， 到卸载出内存为止， 它的整个生命周期包括： 加载（Loading）、 验证（Verification） 、 准备（Preparation） 、 解析（Resolution） 、 初始化（Initialization） 、 使用（Using） 和卸载（Unloading） 7个阶段。 其中验证、 准备、 解析3个部分统称为连接。</p>
<p> <img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180211111459.png" alt=""></p>
<p>加载、 验证、 准备、 初始化和卸载这5个阶段的顺序是确定的， 类的加载过程必须按照这种顺序按部就班地开始， 而解析阶段则不一定： 它在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定） 。 </p>
<p>虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化” （而加载、 验证、 准备自然需要在此之前开始）:</p>
<p>1） 遇到new、 getstatic、 putstatic或invokestatic这4条字节码指令时， 如果类没有进行过初始化，则需要先触发其初始化。 生成这4条指令的最常见的Java代码场景是： 使用new关键字实例化对象的时候、 读取或设置一个类的静态字段（被final修饰、 已在编译期把结果放入常量池的静态字段除外） 的时候， 以及调用一个类的静态方法的时候。<br>2） 使用java.lang.reflect包的方法对类进行反射调用的时候， 如果类没有进行过初始化， 则需要先触发其初始化。<br>3） 当初始化一个类的时候， 如果发现其父类还没有进行过初始化， 则需要先触发其父类的初始化。<br>4） 当虚拟机启动时， 用户需要指定一个要执行的主类（包含main（） 方法的那个类） ， 虚拟机会先初始化这个主类。<br>5） 当使用JDK 1.7的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、 REF_putStatic、 REF_invokeStatic的方法句柄， 并且这个方法句柄所对应的类没有进行过初始化， 则需要先触发其初始化。</p>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>“加载” 是“类加载” （Class Loading） 过程的一个阶段， 在加载阶段， 虚拟机需要完成以下3件事情：1通过一个类的全限定名来获取定义此类的二进制字节流。2将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。3在内存中生成一个代表这个类的java.lang.Class对象， 作为方法区这个类的各种数据的访问入口。</p>
<p>获取二进制字节流有许多种方法，从ZIP包中读取， 这很常见， 最终成为日后JAR、 EAR、 WAR格式的基础。从网络中获取， 这种场景最典型的应用就是Applet。运行时计算生成， 这种场景使用得最多的就是动态代理技术。等等</p>
<p>加载阶段完成后， 虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中， 方法区中的数据存储格式由虚拟机实现自行定义， 虚拟机规范未规定此区域的具体数据结构。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步， 这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求， 并且不会危害虚拟机自身的安全。主要有文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式<strong>为类变量分配内存并设置类变量初始值</strong>的阶段， 这些变量所使用的内存都将在方法区中进行分配。 这个阶段中有两个容易产生混淆的概念需要强调一下， 首先， 这时候进行内存分配的仅包括类变量（被static修饰的变量） ， 而不包括实例变量， 实例变量将会在对象实例化时随着对象一起分配在Java堆中。 其次， 这里所说的初始值“通常情况” 下是数据类型的零值。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。因为在编译时并不知道引用类的实际内存地址，因此只能用符号引用代替。直接引用就是实际的内存地址。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类初始化阶段是类加载过程的最后一步， 前面的类加载过程中， 除了在加载阶段用户应用程序可以通过自定义类加载器参与之外， 其余动作完全由虚拟机主导和控制。 到了初始化阶段， 才真正开始执行类中定义的Java程序代码（或者说是字节码） 。<br>在准备阶段， 变量已经赋过一次系统要求的初始值， 而在初始化阶段， 则根据程序员通过程序制定的主观计划去初始化类变量和其他资源， 或者可以从另外一个角度来表达： 初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code> 方法的过程。 </p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流” 这个动作放到Java虚拟机外部去实现， 以便让应用程序自己决定如何去获取所需要的类。 实现这个动作的代码模块称为“类加载器</p>
<h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作， 但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类， 都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性， 每一个类加载器， 都拥有一个独立的类名称空间。 这句话可以表达得更通俗一些： 比较两个类是否“相等” ， 只有在这两个类是由同一个类加载器加载的前提下才有意义， 否则， 即使这两个类来源于同一个Class文件， 被同一个虚拟机加载， 只要加载它们的类加载器不同， 那这两个类就必定不相等。</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>从Java虚拟机的角度来讲， 只存在两种不同的类加载器： 一种是启动类加载器（Bootstrap ClassLoader） ，这个类加载器使用C++语言实现， 是虚拟机自身的一部分； 另一种就是所有其他的类加载器， 这些类加载器都由Java语言实现， 独立于虚拟机外部， 并且全都继承自抽象类java.lang.ClassLoader。</p>
<p>从开发人员的角度看，类加载器还可以划分成以下三种系统提供的类加载器。</p>
<ul>
<li>启动器加载器，这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的， 并且是虚拟机识别的（仅按照文件名识别， 如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载） 类库加载到虚拟机内存中。 </li>
<li>扩展类加载器 这个加载器由sun.misc.Launcher $ExtClassLoader实现， 它负责加载＜JAVA_HOME＞\lib\ext目录中的， 或者被java.ext.dirs系统变量所指定的路径中的所有类库， 开发者可以直接使用扩展类加载器。</li>
<li>应用程序加载器 这个类加载器由sun.misc.Launcher $App-ClassLoader实现。 由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值， 所以一般也称它为系统类加载器。 它负责加载用户类路径（ClassPath） 上所指定的类库， 开发者可以直接使用这个类加载器， 如果应用程序中没有自定义过自己的类加载器， 一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p>应用程序由这三种类加载器互相配合进行加载，如果有必要，还可以加入自己定义的类加载器。</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180211163304.png" alt=""></p>
<p>上图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型，双亲委派模型要求除了顶层的启动类加载器外， 其余的类加载器都应当有自己的父类加载器。 这里类加载器之间的父子关系一般不会以继承（Inheritance） 的关系来实现， 而是都使用组合（Composition） 关系来复用<br>父加载器的代码。它并不是一个强制性的约束模型， 而是Java设计者推荐给开发者的一种类加载器实现方式。</p>
<p>双亲委派模型的工作过程是： 如果一个类加载器收到了类加载的请求， 它首先不会自己去尝试加载这个类， 而是把这个请求委派给父类加载器去完成， 每一个层次的类加载器都是如此， 因此所有的加载请求最终都应该传送到顶层的启动类加载器中， 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时， 子加载器才会尝试自己去加载。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/10/类文件结构/">Java虚拟机类文件结构概述</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-10
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>由于虚拟机的快速发展，编写的程序编译成二进制本地机器码已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的，平台中立的格式作为程序编译后的存储格式。</p>
<h3 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h3><p>Java中与平台无关的理想最终实现在操作系统的应用层上，SUN公司和其他厂商发布了许多可以运行在不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现程序一次编写，到处运行。</p>
<p>Java虚拟机不和包括Java在内的任何语言绑定，它只与class文件这种特定的二进制文件格式所关联。Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑， Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束， 但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。 作为一个通用的、 机器无关的执行平台， 任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。 例如， 使用Java编译器可以把Java代码编译为存储字节码的Class文件， 使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件， 虚拟机并不关心Class的来源是何种语言。</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180209101117.png" alt=""></p>
<h3 id="class-类文件的结构（字节码文件的结构）"><a href="#class-类文件的结构（字节码文件的结构）" class="headerlink" title="class 类文件的结构（字节码文件的结构）"></a>class 类文件的结构（字节码文件的结构）</h3><p>Class文件是一组以8位字节为基础单位的二进制流。各个数据项目按顺序紧凑排列在Class文件中。中间没有添加任何分隔符。当遇到大于8位字节的数据项时，会按照高位在前的方式分割成若干个8位字节进行存储。</p>
<p>Class文件采用一种类似于C语言结构体的伪结构来存储数据。这种伪结构只有两种数据类型，无符号数和表。无符号数属于基本的数据类型，以u1,u2,u4,u8 来分别代表1个字节，2个字节，4个字节，和8个字节的无符号数。无符号数可以用来描述数字，索引引用，数量值或者按照UTF8编码构成字符串值。 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性的以<code>_info</code>结尾。表用于描述有层次关系的复合结构的数据，整个class文件本质上就是一张表。</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180209102348.png" alt=""></p>
<p>无论是无符号数还是表，当需要描述同一类型但是数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的结合。</p>
<h4 id="详细分析字节码文件"><a href="#详细分析字节码文件" class="headerlink" title="详细分析字节码文件"></a>详细分析字节码文件</h4><p>把字节码文件用二进制方式打开，然后根据虚拟机的规范可以确定对应的字段什么意思，具体分析如下：</p>
<h5 id="魔数与class文件的版本"><a href="#魔数与class文件的版本" class="headerlink" title="魔数与class文件的版本"></a>魔数与class文件的版本</h5><p>每个class文件的头4个字节成为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。紧跟着魔数的4个字节存储的是class文件的版本号，第5，6字节是次版本号，7，8 字节是主版本号。</p>
<h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>紧跟着主次版本号的是常量池入口，常量池可以理解为Class文件之中的资源仓库。它是class文件结构中与其他项目关联最多的数据类型，也是占空间最大的项目之一。</p>
<p>因为常量池中常量数量不固定，所以常量池的入口需要放置一项u2类型的数据。代表常量池容量计数值。容量计数是从1开始的。</p>
<p>常量池中主要存放两大类常量，字面量和符号引用，字面量比较接近于Java语言层面的常量概念，如文本字符串，声明为final的常量值等，符号引用（编译原理方面的概念）则主要包括类和接口的全限定名，字段的名称和描述符，方法的名称和描述符。 </p>
<p><strong>Java代码在进行Javac编译的时候，没有连接的步骤，而是在虚拟机加载Class文件的时候进行动态连接，也就是说，在Class文件中不会保存各个方法和字段的最终内存布局，因此这些字段，方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析，翻译到具体的内存地址中。</strong></p>
<p>常量池中每一项常量都是一个表，一共有14种类型的常量，每种常量都有它自己的结构，根绝它的结构把二进制的字节码往后一直翻译成对应的人可以看懂的字节码文件就好了。</p>
<h5 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h5><p>常量池结束后，紧接着的两个字节代表访问标志，用于识别一些类或者接口层次的访问信息。</p>
<h5 id="类索引，父类索引与接口索引集合"><a href="#类索引，父类索引与接口索引集合" class="headerlink" title="类索引，父类索引与接口索引集合"></a>类索引，父类索引与接口索引集合</h5><p>类索引与父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合。class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。对于接口索引集合，入口的第一项是一个u2类型的接口计数器表示数量。例如类索引的u2值是0x0001,就标识类的名字就是常量池中index=1的常量名。</p>
<h5 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h5><p>字段表用于描述接口或者类中声明的变量，包括类级变量以及实例级变量，但是不包括方法内声明deed局部变量。一个变量需要有好多修饰，比如private ,infal ,static 等等，具体格式如图。</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180209122038.png" alt=""></p>
<h6 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h6><p>采用和字段表完全一样的描述方式。</p>
<h5 id="属性表集合（上面表中的attribute-info）"><a href="#属性表集合（上面表中的attribute-info）" class="headerlink" title="属性表集合（上面表中的attribute_info）"></a>属性表集合（上面表中的attribute_info）</h5><p>在class文件，字段表，方法表都<em>可以</em>携带自己的属性表集合，以用于描述某些场景专有的信息。</p>
<p>主要的属性有Code(在方法表使用，含义是Java代码编译成的字节码指令)，ConstantValue(字段表使用，含义是final关键字定义的常量值)，Exceptions(方法表中使用，含义是方法抛出的异常)等等。</p>
<p>比如Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合中（前面表中的arrtibute_info）。Code属性也有自己的表结构。</p>
<p>###字节码指令简介</p>
<p>Java虚拟机的指令由一个字节长度的，代表着某种特定操作含义的数字以及跟随其中的0至多个代表此操作所需参数而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/08/leetcode138/">138. Copy List with Random Pointer</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-08
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法题/">算法题</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>复制链表。<br>
          <div class="read-more">
            <a href="/2018/02/08/leetcode138/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/4/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/6/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:wangkangning1@foxmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="http://github.com/corn1ng" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://www.instagram.com/brett0427/" class="iconfont icon-instagram" title="instagram"></a>
        
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">corn1ng</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
