<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Gotta Make A Change"/>













  <link rel="alternate" href="/default" title="Corn1ng's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="https://corn1ng.github.io/page/6/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> Corn1ng's Blog </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Corn1ng's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Corn1ng's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/08/JZoffer34/">剑指offer34二叉树中和为某一值的路径</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-08
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法题/">算法题</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
          <div class="read-more">
            <a href="/2018/02/08/JZoffer34/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/08/JZoffer31/">剑指offer31栈的压入，弹出序列</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-08
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法题/">算法题</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
          <div class="read-more">
            <a href="/2018/02/08/JZoffer31/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/08/JZoffer30/">剑指offer*30包含min 函数的栈</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-08
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法题/">算法题</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
          <div class="read-more">
            <a href="/2018/02/08/JZoffer30/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/07/JZoffer28/">剑指offer*28对称的二叉树</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-07
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法题/">算法题</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
          <div class="read-more">
            <a href="/2018/02/07/JZoffer28/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/07/JZoffer26/">剑指offer*26树的子结构</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-07
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法题/">算法题</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
          <div class="read-more">
            <a href="/2018/02/07/JZoffer26/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/07/Java 内存区域/">Java虚拟机内存区域</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-07
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。  如下图所示：</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180206225209.png" alt=""></p>
<ul>
<li>程序计数器</li>
</ul>
<p>这是一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>因为在任意一个确定的时刻，一个处理器只能执行一条线程中的指令，为了线程切换后能回到正确的执行位置，每条线程都需要一个独立的程序计数器。称这类内存区域为线程私有的内存。</p>
<ul>
<li>Java 虚拟机栈</li>
</ul>
<p>Java虚拟机栈也是线程私有的，生命周期和线程相同，虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p> (每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为<strong>静态解析</strong>。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为<strong>动态连接</strong>。)</p>
<ul>
<li>本地方法栈</li>
</ul>
<p>本地方法栈为虚拟机使用到的native方法服务。</p>
<ul>
<li>Java堆</li>
</ul>
<p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆还是垃圾收集器管理的主要区域，Java堆可以细分为新生代和老年代，再细致有 eden空间，From Survivor 空间， To Survivor 空间。 Java堆可以处在物理上不连续的内存空间，只需逻辑上连续即可。</p>
<ul>
<li>方法区</li>
</ul>
<p>方法区也是线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。</p>
<ul>
<li>运行时常量池</li>
</ul>
<p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、 字段、 方法、 接口等描述信息外， 还有一项信息是常量池（Constant Pool Table） ， 用于存放编译期生成的各种字面量和符号引用， 这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<h3 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>虚拟机遇到一条new指令后，首先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析，初始化。如果没有，就必须先执行相应的类加载过程。</p>
<p>类加载检查完成后，虚拟机将为新生对象分配内存，对象所需内存大小在类加载完成后便可确定下来，为对象分配内存就是把一块确定大小的内存从Java堆中划分出来。有两种主要的分配方式分别是<code>指针碰撞</code>和<code>空闲列表</code></p>
<p>内存分配完成后，虚拟机需要将分配的内存空间都初始化为零值。接下来要对对象进行必要的设置，例如这个对象是哪一个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。</p>
<p>上述步骤完成后，虚拟机角度，一个新对象已经产生了。但是从程序员角度，执行new指令后会接着执行<code>&lt;init&gt;</code>方法，把对象按照程序员意愿进行初始化，这样一个可用对象才算最终产生。</p>
<p><strong>new 一个才会在堆中产生一个对象</strong></p>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对齐填充。</p>
<p> 对象头包括两部分信息， 第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode） 、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等。32位虚拟机和64位虚拟机分别占32bit和64bit.也称为mark word。对象头的另外一部分是类型指针， 即对象指向它的类元数据的指针， 虚拟机通过这个指针来确定这个对象是哪个类的实例。 </p>
<p>实例数据部分是对象真正存储的有效信息， 也是在程序代码中所定义的各种类型的字段内容。 无论是<br>从父类继承下来的， 还是在子类中定义的， 都需要记录起来。 这部分的存储顺序会受到虚拟机分配策略参数<br>和字段在Java源码中定义顺序的影响 </p>
<p>第三部分对齐填充并不是必然存在的， 也没有特别的含义， 它仅仅起着占位符的作用。</p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>建立对象是为了使用对象， Java程序需要通过栈上的reference数据来操作堆上的具体对象。主要的访问对象方式有使用句柄和直接指针两种。</p>
<ul>
<li>使用句柄</li>
</ul>
<p>Java堆中将会划分出一块内存来作为句柄池， reference中存储的就是对象的句柄地址， 而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180207093350.png" alt=""></p>
<ul>
<li>直接指针访问</li>
</ul>
<p>reference中存储的直接就是对象地址。</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180207100039.png" alt=""></p>
<p>SUN HotSpot 虚拟机选择的第二种。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/07/垃圾收集器和内存分配策略/">Java虚拟机GC与内存分配</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-07
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="垃圾收集器和内存分配策略"><a href="#垃圾收集器和内存分配策略" class="headerlink" title="垃圾收集器和内存分配策略"></a>垃圾收集器和内存分配策略</h2><p>程序计数器、 虚拟机栈、 本地方法栈3个区域随线程而生， 随线程而灭。这几个区域的内存分配和回收都具备确定性， 在这几个区域内就不需要过多考虑回收的问题， 因为方法结束或者线程结束时， 内存自然就跟随着回收了。Java堆不一样，一个接口中的多个实现类需要的内存可能不一样， 一个方法中的多个分支需要的内存也可能不一样， 我们只有在程序处于运行期间时才能知道会创建哪些对象， 这部分内存的分配和回收都是动态的， 垃圾收集器所关注的是这部分内存。</p>
<h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><h4 id="引用计数器算法"><a href="#引用计数器算法" class="headerlink" title="引用计数器算法"></a>引用计数器算法</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1，引用失效时，计数器就减1，任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>这种方法实现简单，判断效率高，但是主流虚拟机没有采用这种方法，因为它很难解决对象之间相互循环引用的问题。</p>
<h4 id="可达性分析方法"><a href="#可达性分析方法" class="headerlink" title="可达性分析方法"></a>可达性分析方法</h4><p>这个算法的基本思路就是通过一系列的称为“GC Roots” 的对象作为起始点， 从这些节点开始向下搜索， 搜索所走过的路径称为引用链 ， 当一个对象到GC Roots没有任何引用链相连（用图论的话来说， 就是从GC Roots到这个对象不可达） 时， 则证明此对象是不可用的。 </p>
<p>在Java中，可以作为GC roots 的对象包括以下几种。</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
<h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在JDK 1.2以前， Java中的引用的定义很传统： 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址， 就称这块内存代表着一个引用。 这种定义很纯粹， 但是太过狭隘， 一个对象在这种定义下只有被引用或者没有被引用两种状态， 对于如何描述一些“食之无味， 弃之可惜” 的对象就显得无能为力。</p>
<p>在JDK 1.2之后， Java对引用的概念进行了扩充， 将引用分为强引用 、 软引用 、 弱引用 、 虚引用4种， 这4种引用强度依次逐渐减弱。</p>
<h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><p>即使在可达性分析算法中不可达的对象， 也并非是“非死不可” 的， 要真正宣告一个对象死亡， 至少要经历两次标记过程： 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链， 那它将会被第一次标记并且进行一次筛选， 筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有覆盖finalize()方法， 或者finalize()方法已经被虚拟机调用过， 虚拟机将这两种情况都视为“没有必要执行” 。就直接进行GC.</p>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区也就是HotSpot虚拟机中的永生代也有一定的垃圾收集，主要回收两部分内容，废弃常量和无用的类。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>最基础的收集算法就是标记清除算法，分为标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。主要不足有两个，一是效率，标记和清除两个过程的效率都不高，另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，会导致以后有较大对象时没有内存分配而又一次触发GC.</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>此方法将内存划分为相等的两块，每次使用其中的一块，当这一块用完了，就将还存活的对象复制到另一块上，然后把已使用过的内存空间一次性清理掉。这样使得每次都是对整个半区进行内存回收，分配时就不用考虑内存碎片的问题，但是代价是内存缩小为了原来的一半。</p>
<p>现在的商用虚拟机都采用这种收集算法来<strong>回收新生代</strong>。但是进行了一定的改进，不是按照1比1进行划分。将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用一块eden和其中一块Survivor。当回收时，将Eden 和Survivor中还存活的对象一次性复制到另外一块Survivor 中。然后清理掉Eden和Survivor .HotSpot 虚拟机设置的默认比例是<code>8:1:1</code>.当Survivor 空间不够用时，需要依赖其他内存（老年代）进行分配担保。</p>
<h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>复制收集算法在对象存活率较高时就要进行较多的复制，<strong>所以一般老年代不选用这种算法</strong></p>
<p>根据老年代特点，有另外一种标记-整理算法，标记过程和前面标记清除过程一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据对象的存活周期的不同将Java堆分为新生代和老年代，根据各个代的特点选择不同的收集算法。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集器是内存回收的具体实现。下面讨论的1收集器基于JDK1.7后的HotSpot虚拟机。</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180207111724.png" alt=""></p>
<ul>
<li>Serial 收集器</li>
</ul>
<p>最基本，发展历史最悠久的收集器。单线程收集器。它在进行垃圾收集时，必须暂停所有其他所有的工作线程。直到它收集结束。</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180207112122.png" alt=""></p>
<p>Serial 是运行在Client 模式下的默认新生代收集器，优点是简单高效。</p>
<ul>
<li>ParNew 收集器</li>
</ul>
<p>Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余和Serial几乎完全一样。是运行在Server模式下的虚拟机中首选的新生代收集器。同时，也只有Serial 和ParNew 能和CMS收集器配合工作。</p>
<ul>
<li>Parallel Scavenge 收集器</li>
</ul>
<p>使用复制算法的新生代收集器。也是并行的多线程收集器。它的设计目标是达到一个可控制的吞吐量。所以也被成为吞吐量优先的收集器。</p>
<ul>
<li>Serial Old 收集器</li>
</ul>
<p>Serial 收集器的老年代版本，是一个单线程使用标记-整理算法的收集器。主要给Client模式下的虚拟机使用。</p>
<ul>
<li>Parallel Old </li>
</ul>
<p>parallel Scaenge 收集器的老年代版本，使用多线程和标记-整理算法。</p>
<ul>
<li>CMS收集器</li>
</ul>
<p>一种以获取最短回收停顿时间为目标的收集器。基于标记清除算法实现。主要有四个步骤，初始标记，并发标记，重新标记，并发清除。其中，初始标记、 重新标记这两个步骤仍然需要“Stop The World” 。 初始标记仅仅只是标记一下GC Roots能直接关联到的对象， 速度很快， 并发标记阶段就是进行GC RootsTracing的过程， 而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录， 这个阶段的停顿时间一般会比初始标记阶段稍长一些， 但远比并发标记的时间短。<br>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作， 所以， 从总体上<br>来说， CMS收集器的内存回收过程是与用户线程一起并发执行的。 下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间。</p>
<p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180207121214.png" alt=""></p>
<p>CMS也有很明显的缺点，主要是1对CPU资源非常敏感，2无法处理浮动垃圾，3，使用标记清除算法会产生大量碎片。</p>
<ul>
<li>G1 收集器</li>
</ul>
<p>一个面向服务器应用的垃圾收集器，主要有以下优点，并行与并发，分代收集，空间整合(整体上标记整理，局部是复制算法)，可预测的停顿(相比CMS的一大优势)。将堆华为多个大小相等的独立区域(region),新生代老年代不再物理隔离了.</p>
<p>G1 之所以能建立可预测的停顿时间模型,是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集,G1追踪各个region里面的垃圾堆积的价值大小,后台维护一个优先列表,每次根据允许的收集时间,优先回收价值最大的region.</p>
<p>主要划分为四个步骤</p>
<p>初始标记- 并发标记- 最终标记 - 筛选回收</p>
<p>初始标记仅标记一下GC root 能关联到的对象,这个阶段需要停顿,但耗时短</p>
<p>并发标记是从GC root 进行可达性分析 ,找出存活对象. 耗时长,但是可并发</p>
<p>最终标记是为了修正并发标记期间因用户程序继续运作导致标记变动的记录 ,需要停顿,但是可多条线程同时执行</p>
<p>筛选回收 根据各个region的回收价值和成本进行排序.根据用户期望的GC停顿时间来执行回收计划.</p>
<p><img src="http://two-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-03-16%2016-50-51.png?sign=p/JYxBRJ5YDRp5tiUOO/fgzD2AthPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTIzNzgyMjg3JnQ9MTUyMTE5MDI4NyZyPTEwNzI3NDIyNDYmZj0vU2NyZWVuc2hvdCUyMGZyb20lMjAyMDE4LTAzLTE2JTIwMTYtNTAtNTEucG5nJmI9dHdv" alt=""></p>
<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p>对象的内存分配，其实就是往堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能直接分配在老年代中。</p>
<h4 id="对象优先在Eden分区分配"><a href="#对象优先在Eden分区分配" class="headerlink" title="对象优先在Eden分区分配"></a>对象优先在Eden分区分配</h4><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次MInor GC.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Minor GC 也称为新生代GC，指发生在新生代的垃圾收集动作。因为Java对象大多具有朝生夕灭的特点，所以说新生代GC 非常频繁，一般回收速度也很快。</span><br><span class="line">Full GC(Major GC)也称为老年代GC,发生在老年代的GC，比Minor GC 慢10倍以上。基本上也会伴随新生代GC</span><br></pre></td></tr></table></figure>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象指的是需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组，大对象对内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾回收以获取足够的连续空间来安置它们。</p>
<h4 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h4><p>为了在回收时识别哪些对象应放在新生代，哪些应放在老年代，虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC 后仍然存活，并能被Survroir 容纳的话，将被移动到Survrior 空间中，并且对象年龄设置为1，对象在Survrior 中每熬过一次Minor GC 年龄就增加一岁，到达一定程度(默认15岁)就会晋升到老年代中。</p>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了能更好的适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代， 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代， 无须等到MaxTenuringThreshold中要求的年龄。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生Minor GC之前， 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间， 如果这个<br>条件成立， 那么Minor GC可以确保是安全的。 如果不成立， 则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。 如果允许， 那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于， 将尝试着进行一次Minor GC， 尽管这次Minor GC是有风险的； 如果小于， 或者HandlePromotionFailure设置不允许冒险， 那这时也要改为进行一次Full GC。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/06/JZoffer19/">剑指offer*19正则表达式匹配</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-06
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法题/">算法题</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
          <div class="read-more">
            <a href="/2018/02/06/JZoffer19/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/5/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/7/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:wangkangning1@foxmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="http://github.com/corn1ng" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://www.instagram.com/brett0427/" class="iconfont icon-instagram" title="instagram"></a>
        
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">corn1ng</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
