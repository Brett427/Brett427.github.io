<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql解密九 函数对索引的影响</title>
      <link href="/2019/10/24/Mysql%E8%A7%A3%E5%AF%86%E4%B9%9D%20%E5%87%BD%E6%95%B0%E5%AF%B9%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
      <url>/2019/10/24/Mysql%E8%A7%A3%E5%AF%86%E4%B9%9D%20%E5%87%BD%E6%95%B0%E5%AF%B9%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="函数不走索引"><a href="#函数不走索引" class="headerlink" title="函数不走索引"></a>函数不走索引</h2><p>在 MySQL 中，有很多看上去逻辑相同，但性能却差异巨大的 SQL 语句。对这些语句使用 不当的话，就会不经意间导致整个数据库的压力变大。</p><h3 id="案例一-条件字段函数操作"><a href="#案例一-条件字段函数操作" class="headerlink" title="案例一 条件字段函数操作"></a>案例一 条件字段函数操作</h3><p>假设现在维护了一个交易系统，其中交易记录表 tradelog 包含交易流水号 （tradeid）、交易员 id（operator）、交易时间（t_modified）等字段。为了便于描述， 先忽略其他字段。这个表的建表语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `tradelog` (</span><br><span class="line">     `id` int(11) NOT NULL,</span><br><span class="line">     `tradeid` varchar(32) DEFAULT NULL,</span><br><span class="line">     `operator` int(11) DEFAULT NULL,</span><br><span class="line">     `t_modified` datetime DEFAULT NULL,</span><br><span class="line">     PRIMARY KEY (`id`),</span><br><span class="line">     KEY `tradeid` (`tradeid`),</span><br><span class="line">     KEY `t_modified` (`t_modified`)</span><br><span class="line">     ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure><p>假设，现在已经记录了从 2016 年初到 2018 年底的所有数据，运营部门有一个需求是，要统计发生在所有年份中 7 月份的交易记录总数。这个逻辑看上去并不复杂，你的 SQL 语句 可能会这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from tradelog where month(t_modified)=7;</span><br></pre></td></tr></table></figure><p>虽然t_modified字段上有索引，但是返回的特别慢。<strong>如果对字段做了函数计算，就用不上索引了，这是 MySQL 的规定。</strong></p><p>下面是<code>t_modified</code>索引的示意图，方框上面的数字就是month()函数对应的值。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191028194234.png" alt=""></p><p>如果你的 SQL 语句条件用的是 where t_modified=’2018-7-1’的话，引擎就会按照上面 绿色箭头的路线，快速定位到 t_modified=’2018-7-1’需要的结果。实际上，B+ 树提供的这个快速定位能力，来源于同一层兄弟节点的有序性。</p><p>但是，如果计算 month() 函数的话，你会看到传入 7 的时候，在树的第一层就不知道该怎么办了。也就是说，<strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><p><em>需要注意的是，优化器并不是要放弃使用这个索引。</em></p><p>在这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引 t_modified，优化器对比索引大小后发现，索引 t_modified 更小，遍历这个索引比遍历主 键索引来得更快。因此最终还是会选择索引 t_modified。<strong>也就是说仍然会使用索引，但是会扫描索引中的所有值，并没有使用索引快速定位的能力。</strong></p><h3 id="案例二-隐式类型转换"><a href="#案例二-隐式类型转换" class="headerlink" title="案例二 隐式类型转换"></a>案例二 隐式类型转换</h3><p>看下面的一句sql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tradelog where tradeid = 110717;</span><br></pre></td></tr></table></figure><p>交易编号 tradeid 这个字段上，本来就有索引，但是 explain 的结果却显示，这条语句需 要走全表扫描。可以发现，tradeid 的字段类型是 varchar(32)，而输入的参数却是 整型，所以需要做类型转换。有两个问题需要解决：</p><ul><li>1数据类型转换的规则是什么？ 2为什么有数据类型转换，就要走全索引扫描</li></ul><p>在MySQL里，字符串和数字做比较的话，是将字符串转换成数字。</p><p>因此，上面语句对优化器来说，相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tradelog where CAST(tradid AS signed int) = 110717;</span><br></pre></td></tr></table></figure><p>触发了案例一中的规则，所以就会走全索引扫描。</p><h3 id="案例三-隐式字符编码转换"><a href="#案例三-隐式字符编码转换" class="headerlink" title="案例三 隐式字符编码转换"></a>案例三 隐式字符编码转换</h3><p>假设系统里还有一个表trade_detail ，用以记录交易的操作细节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `trade_detail` (</span><br><span class="line">     `id` int(11) NOT NULL,</span><br><span class="line">     `tradeid` varchar(32) DEFAULT NULL,</span><br><span class="line">     `trade_step` int(11) DEFAULT NULL, /* 操作步骤 */</span><br><span class="line">     `step_info` varchar(32) DEFAULT NULL, /* 步骤信息 */</span><br><span class="line">     PRIMARY KEY (`id`),</span><br><span class="line">     KEY `tradeid` (`tradeid`)</span><br><span class="line">     ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>这时，如果要查询id=2的交易的所有操作步骤信息，SQL语句可以这么写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2;</span><br></pre></td></tr></table></figure><p>一共分为三步执行：</p><p>第 1 步，是根据 id 在 tradelog 表里找到 L2 这一行；</p><p>第 2 步，是从 L2 中取出 tradeid 字段的值；</p><p>第 3 步，是根据 tradeid 值到 trade_detail 表中查找条件匹配的行。explain 的结果里 面第二行的 key=NULL 表示的就是，这个过程是通过遍历主键索引的方式，一个一个地 判断 tradeid 的值是否匹配。</p><p>通过explain可以发现，第三步中根据 tradeid 值到 trade_detail 表中查找条件匹配的行，这个过程是通过遍历主键索引的方式，一个一个地 判断 tradeid 的值是否匹配。这不符合我们的预期。因为表 trade_detail 里 tradeid 字段上 是有索引的，本来是希望通过使用 tradeid 索引能够快速定位到等值的行。但这里 并没有。</p><p>这里的原因是因为这两个表的字符集不同，一个是 utf8，一 个是 utf8mb4，所以做表连接查询的时候用不上关联字段的索引。字符集 utf8mb4 是 utf8 的超集，所以当这两个 类型的字符串在做比较的时候，MySQL 内部的操作是，先把 utf8 字符串转成 utf8mb4 字 符集，再做比较。</p><p>单独将第三步写成sql，就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_detail where tradeid=$L2.tradeid.value;</span><br><span class="line">其中，$L2.tradeid.value 的字符集是 utf8mb4。</span><br></pre></td></tr></table></figure><p>实际执行的时候，执行的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_detail where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value;</span><br><span class="line">// 如果反过来，加到参数上，就可以使用索引，就像</span><br><span class="line">select operator from tradelog where traideid =CONVERT($R4.tradeid.value USING utf8mb4)</span><br></pre></td></tr></table></figure><p>这再次触发了上面的原则，因此做了全表扫描。</p><hr><p>上面的例子，都说明了一件事，<strong>对索引字段做函数操作，可能会被破坏索引值的有序性，因此优化器就决定放弃走树搜索功能</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 详细总结</title>
      <link href="/2019/10/24/Maven%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/24/Maven%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven-总结"><a href="#Maven-总结" class="headerlink" title="Maven 总结"></a>Maven 总结</h2><p>Apache Maven，是一个软件（特别是Java软件）<strong>项目管理及自动构建工具</strong>，由Apache软件基金会所提供。基于<strong>项目对象模型（Project Object Model缩写：POM）</strong>概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven也可被用于构建和管理各种项目，例如C#，Ruby，Scala和其他语言编写的</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>在 Maven 的术语中，仓库是一个位置（place）。Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。</p><p>Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。Maven 仓库有三种类型：</p><ul><li>本地（local）</li><li>中央（central）</li><li>远程（remote）</li></ul><p>Maven 的本地仓库，在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建。运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2/respository/ 的仓库目录。</p><p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。中央仓库的关键概念：1这个仓库由 Maven 社区管理。2不需要配置。3需要通过网络才能访问。要浏览中央仓库的内容，maven 社区提供了一个 URL：<a href="http://search.maven.org/#browse" target="_blank" rel="noopener">http://search.maven.org/#browse</a>。使用这个仓库，开发人员可以搜索所有可以获取的代码库。</p><p>如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。举例说明，使用下面的 pom.xml，Maven 将从远程仓库中下载该 pom.xml 中声明的所依赖的（在中央仓库中获取不到的）文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.projectgroup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.common-lib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://download.companyname.org/maven2/lib1<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://download.companyname.org/maven2/lib2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="高级设置"><a href="#高级设置" class="headerlink" title="高级设置"></a>高级设置</h4><ul><li>每个公司或者和小组织一般都有自己的私有仓库，所以加入团队要首先配置自己的settings.xml文件， 当然最直接的方式是直接从同事那里进行拷贝。</li><li>接下来是配置本地仓库位置，默认位置是<strong>${user.home}/.m2/repository/</strong>, 如果想将仓库位置改成自己想要的位置，在settings.xml中修改localRepository的属性就可以</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/path/to/local/repo/<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置私有仓库和仓库的注册用户名、密码。公司的远程私有仓库部署定义在一个项目中的pom.xml文件中，通过<code>&lt;distributionManagement&gt;</code>来定义发布仓库位置，有几个仓库就在里面定义几个<code>&lt;repository&gt;</code>标签，每个仓库都有唯一的<code>&lt;id&gt;</code>标签和<code>&lt;url&gt;</code>标签。公司的私有仓库一般需要用户名，密码去认证才能进行下载，但是这些不能保存在项目中，pom文件是要上传到git服务器上，所有人都能看到，不安全，基于这个考虑可以在setting.xml进行添加，通过定义<code>&lt;servers&gt;</code>标签来定义多个私有仓库认证信息，每个仓库都有一个<code>&lt;server&gt;</code>相对应，然后通过定义<code>&lt;id&gt;</code>标签与pom文件中的<code>&lt;repository&gt;</code>中的<code>&lt;id&gt;</code>标签相同来对应，然后在里面定义<code>&lt;username&gt;</code>标签和<code>&lt;password&gt;</code>标签。如下分别是pom.xml中定义仓库位置，setting.xml定义对应的私有仓库用户名和密码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pom.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">....</span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>libs-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://mvn.hz.netease.com/artifactory/libs-releases<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>libs-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://mvn.hz.netease.com/artifactory/libs-snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setting.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>libs-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span>******<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>******<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>libs-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span>******<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>******<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现pom中的仓库的id与setting的id是相对应的。</p><h4 id="基础pom信息"><a href="#基础pom信息" class="headerlink" title="基础pom信息"></a>基础pom信息</h4><table><thead><tr><th>标识符</th><th>含义</th></tr></thead><tbody><tr><td>groupId</td><td>一般用该项目的组织或团体的域名来标识，例如:org.apache.maven.plugins</td></tr><tr><td>artifactId</td><td>代表唯一的工程名</td></tr><tr><td>version</td><td>版本号</td></tr><tr><td>packaging</td><td>标识打包的类型，例如有:jar, war, tar</td></tr><tr><td>dependencies</td><td>该工程内依赖的其他 jar 包</td></tr></tbody></table><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><strong>maven的生命周期就是对所有构建过程抽象与统一</strong>，生命周期包含项目的清理、初始化、编译、测试、打包、集成测试、验证、部署、站点生成等几乎所有的过程。</p><p><strong>Maven有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”</strong>，Maven的生命周期并不是一个整体。这三套生命周期分别是：</p><ul><li>CleanLifecycle 在进行真正的构建之前进行一些清理工作。</li><li>DefaultLifecycle 构建的核心部分，编译，测试，打包，部署等等。</li><li>SiteLifecycle 生成项目报告，站点，发布站点。</li></ul><p>每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。maven中所有的执行动作(goal)都需要指明自己在这个过程中的执行位置，然后maven执行的时候，就依照过程的发展依次调用这些goal进行各种处理。这个也是maven的一个基本调度机制。</p><p>每套生命周期可以分为多个阶段。</p><ul><li>clean 生命周期包含了</li></ul><table><thead><tr><th>Clean生命周期阶段</th><th>完成工作</th></tr></thead><tbody><tr><td>pre-clean</td><td>执行一些需要在clean之前完成的工作</td></tr><tr><td>clean</td><td>移除所有上一次构建生成的文件</td></tr><tr><td>post-clean</td><td>执行一些需要在clean之后立刻完成的工作</td></tr></tbody></table><p>命令“mvn clean”中的就是代表执行上面的clean阶段，<strong>在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，“mvn clean” 等同于 “mvn pre-clean clean” ，如果我们运行“mvn post-clean” ，那么 “pre-clean”，“clean” 都会被运行</strong>。这是Maven很重要的一个规则，可以大大简化命令行的输入。</p><ul><li>default 生命周期</li></ul><p><strong>Maven最重要就是的Default生命周期，也称构建生命周期，绝大部分工作都发生在这个生命周期中</strong>。</p><table><thead><tr><th>Default生命周期阶段</th><th>完成工作</th></tr></thead><tbody><tr><td>validate</td><td>验证项目是否正确，以及所有为了完整构建必要的信息是否可用</td></tr><tr><td>compile</td><td>编译项目的源代码</td></tr><tr><td>test</td><td>使用合适的单元测试框架运行测试。这些测试应该不需要代码被打包或发布</td></tr><tr><td>package</td><td>将编译好的代码打包成可分发的格式，如JAR，WAR，或者EAR</td></tr><tr><td>verify</td><td>执行所有检查，验证包是有效的，符合质量规范</td></tr><tr><td>install</td><td>安装包至本地仓库，以备本地的其它项目作为依赖使用</td></tr><tr><td>deploy</td><td>复制最终的包至远程仓库，共享给其它开发人员和项目（通常和一次正式的发布相关）</td></tr></tbody></table><ul><li>site 生命周期</li></ul><table><thead><tr><th>Site生命周期阶段</th><th>完成工作</th></tr></thead><tbody><tr><td>pre-site</td><td>执行一些需要在生成站点文档之前完成的工作</td></tr><tr><td>site</td><td>生成项目的站点文档</td></tr><tr><td>post-site</td><td>执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</td></tr><tr><td>site-deploy</td><td>将生成的站点文档部署到特定的服务器上</td></tr></tbody></table><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><strong>Maven本质上是一个插件框架</strong>，它的核心并不执行任何具体的构建任务，<strong>所有这些任务都交给插件来完成</strong>，像编译是通过maven-compile-plugin实现的、测试是通过maven-surefire-plugin实现的，maven也内置了很多插件，所以我们在项目进行编译、测试、打包的过程是没有感觉到。</p><p>Maven 使用 plugin 来执行实际操作的，在默认情况下，Maven 会绑定以下几个插件来完成基本操作。</p><table><thead><tr><th>plugin</th><th>function</th><th>life cycle phase</th></tr></thead><tbody><tr><td>maven-clean-plugin</td><td>清理上一次执行创建的目标文件</td><td>clean</td></tr><tr><td>maven-resources-plugin</td><td>处理源资源文件和测试资源文件</td><td>resources,testResources</td></tr><tr><td>maven-compiler-plugin</td><td>编译源文件和测试源文件</td><td>compile,testCompile</td></tr><tr><td>maven-surefire-plugin</td><td>执行测试文件</td><td>test</td></tr><tr><td>maven-jar-plugin</td><td>创建 jar</td><td>jar</td></tr><tr><td>maven-install-plugin</td><td>安装 jar，将创建生成的 jar 拷贝到 .m2/repository 下面</td><td>install</td></tr><tr><td>maven-deploy-plugin</td><td>发布 jar</td><td>deploy</td></tr></tbody></table><p>Maven官方有两个插件列表，第一个列表的GroupId为org.apache.maven.plugins，这里的插件最为成熟，具体地址为：<a href="http://maven.apache.org/plugins/index.html" target="_blank" rel="noopener">http://maven.apache.org/plugins/index.html</a>。第二个列表的GroupId为org.codehaus.mojo，这里的插件没有那么核心，但也有不少十分有用，其地址为：<a href="http://mojo.codehaus.org/plugins.html" target="_blank" rel="noopener">http://mojo.codehaus.org/plugins.html</a>。</p><h3 id="Setting-xml"><a href="#Setting-xml" class="headerlink" title="Setting.xml"></a>Setting.xml</h3><p><strong>settings.xml是maven的全局配置文件。而pom.xml文件是所在项目的局部配置。</strong></p><p>settings.xml文件一般存在于两个位置：全局配置:<code>${M2_HOME}/conf/settings.xml</code>用户配置: <code>user.home/.m2/settings.xml</code>前者叫做全局配置，对操作系统的所有使用者生效；后者为用户配置，只对当前操作系统的使用者生效。局部配置优先于全局配置。配置优先级从高到低：pom.xml&gt; user settings &gt; global settings如果这些文件同时存在，在应用配置时，会合并它们的内容，如果有重复的配置，优先级高的配置会覆盖优先级低的。如果全局配置和用户配置都存在，它们的内容将被合并，并且用户范围的settings.xml会覆盖全局的settings.xml。</p><h4 id="顶级元素"><a href="#顶级元素" class="headerlink" title="顶级元素"></a>顶级元素</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                          https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">interactiveMode</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">usePluginRegistry</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">offline</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>LocalRepository 表示构建系统本地仓库的路径。其默认值：~/.m2/repository。</li><li>InteractiveMode 表示maven是否需要和用户交互以获得输入。</li><li>UsePluginRegistry表示maven是否需要使用plugin-registry.xml文件来管理插件版本。</li><li>offline表示maven是否需要在离线模式下运行。</li><li><p>PluginGroups当插件的组织id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。</p></li><li><p>servers一般，仓库的下载和部署是在pom.xml文件中的repositories和distributionManagement元素中定义的。然而，一般类似用户名、密码（有些仓库访问是需要安全认证的）等信息不应该在pom.xml文件中配置，</p></li><li>Mirrors为仓库列表配置的下载镜像列表。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">--</span> 给定仓库的下载镜像。 <span class="attr">--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">--</span> 该镜像的唯一标识符。<span class="attr">id</span>用来区分不同的<span class="attr">mirror</span>元素。 <span class="attr">--</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>planetmirror.com<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">--</span> 镜像名称 <span class="attr">--</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>PlanetMirror Australia<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">--</span> 该镜像的<span class="attr">URL</span>。构建系统会优先考虑使用该<span class="attr">URL</span>，而非使用默认的服务器<span class="attr">URL</span>。 <span class="attr">--</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://downloads.planetmirror.com/pub/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">--</span> 被镜像的服务器的<span class="attr">id</span>。例如，如果我们要设置了一个<span class="attr">Maven</span>中央仓库（<span class="attr">http:</span>//<span class="attr">repo.maven.apache.org</span>/<span class="attr">maven2</span>/）的镜像，就需要将该元素设置成<span class="attr">central</span>。这必须和中央仓库的<span class="attr">id</span> <span class="attr">central</span>完全一致。 <span class="attr">--</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Proxies 用来配置不同的代理</li><li>Profiles 根据环境参数来调整构建配置的列表</li><li>Activation自动触发profile 的条件逻辑</li><li>Properties 对应profile的扩展属性列表</li><li>Repositories 远程仓库列表，它是maven用来填充构建系统本地仓库所使用的一组远程仓库。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">--包含需要连接到远程仓库的信息</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">--远程仓库唯一标识</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>codehausSnapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">--远程仓库名称</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Codehaus Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">--如何处理远程仓库里发布版本的下载</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories</span>/<span class="attr">repository</span>/<span class="attr">releases</span>元素 <span class="attr">--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">--远程仓库URL，按protocol:</span>//<span class="attr">hostname</span>/<span class="attr">path</span>形式 <span class="attr">--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://snapshots.maven.codehaus.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven</span> <span class="attr">2</span>为其仓库提供了一个默认的布局；然而，<span class="attr">Maven</span> <span class="attr">1.x</span>有一种不同的布局。我们可以使用该元素指定布局是<span class="attr">default</span>（默认）还是<span class="attr">legacy</span>（遗留）。 <span class="attr">--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>pluginRepositories 发现插件的远程仓库列表</p></li><li><p>Activeprofiles 手动激活profile的列表，按照profile被应用的顺序定义activeProfile。</p></li></ul><hr><h4 id="mirror（镜像）与repository（仓库）区别"><a href="#mirror（镜像）与repository（仓库）区别" class="headerlink" title="mirror（镜像）与repository（仓库）区别"></a>mirror（镜像）与repository（仓库）区别</h4><p>repository就是个仓库。maven里有两种仓库，本地仓库和远程仓库。远程仓库相当于公共的仓库，大家都能看到。本地仓库是你本地的一个山寨版，只有你看的到，主要起缓存作用。当你向仓库请求插件或依赖的时候，会先检查本地仓库里是否有。如果有则直接返回，否则会向远程仓库请求，并做缓存。你也可以把你做的东西上传到本地仓库给你本地自己用，或上传到远程仓库，供大家使用。 internal repository是指在局域网内部搭建的repository，它跟central repository, jboss repository等的区别仅仅在于其URL是一个内部网址。</p><p>远程仓库可以在工程的pom.xml文件里指定。如果没指定，默认就会把下面这地方做远程仓库，即默认会到<a href="http://repo1.maven.org/maven2这个地方去请求插件和依赖包。" target="_blank" rel="noopener">http://repo1.maven.org/maven2这个地方去请求插件和依赖包。</a></p><p>镜像是仓库的镜子，保存了被镜像仓库的所有的内容,主要针对远程仓库而言。配置mirror的目的一般是出于网速考虑。如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的一个镜像。换句话说，任何一个可以从仓库Y获得的构件，都能够从它的镜像中获取。举个例子，<a href="http://maven.NET.cn/content/groups/public/" target="_blank" rel="noopener">http://maven.NET.cn/content/groups/public/</a> 是中央仓库<a href="http://repo1.maven.org/maven2/" target="_blank" rel="noopener">http://repo1.maven.org/maven2/</a> 在中国的镜像，由于地理位置的因素，该镜像往往能够提供比中央仓库更快的务。</p><p><code>&lt;mirrorOf&gt;</code>的值为central，表示该配置为中央仓库的镜像，任何对于中央仓库的请求都会转至该镜像，用户也可以使用同样的方法配置其他仓库的镜像。</p><p>关于镜像的一个更为常见的用法是结合私服。由于私服可以代理任何外部的公共仓库(包括中央仓库)，因此，对于组织内部的Maven用户来说，使用一个私服地址就等于使用了所有需要的外部仓库，这可以将配置集中到私服，从而简化Maven本身的配置。在这种情况下，任何需要的构件都可以从私服获得，私服就是所有仓库的镜像。这时，可以配置这样的一个镜像。</p><h3 id="Pom-xml"><a href="#Pom-xml" class="headerlink" title="Pom.xml"></a>Pom.xml</h3><p>pom.xml主要描述了<strong>项目</strong>的maven坐标，依赖关系，开发者需要遵循的规则，缺陷管理系统，组织和licenses，以及其他所有的项目相关因素，<strong>是项目级别的配置文件</strong>。Super Pom是Maven的默认POM文件，所有的pom文件都会继承这个super pom。</p><p>Pom 最少要求包含以下几点project root , model version groupId artifactId version 。例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模块的pom会继承父模块的pom文件</p><p><strong>如果想要模块的groupId 和/或 version与父模块的相同</strong> ，只需要将groupId和/或version从你的模块中删除定义即可,因为pom.xml允许你模块继承父模块的groupId和version。</p><p>例如下面是父亲的pom文件和子模块的pom文件，父亲pom里面定义了modules是其中模块的信息，还定义了packaging是pom类型。 子pom里面定义了父pom的parent 标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="dependencies与dependencyManagement的区别"><a href="#dependencies与dependencyManagement的区别" class="headerlink" title="dependencies与dependencyManagement的区别"></a><strong>dependencies与dependencyManagement的区别</strong></h4><p>在项目顶层的POM文件中，会看到dependencyManagement元素。通过该元素来管理jar包的版本，让子项目中引用一个依赖而不用显示的列出版本号。Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用在这个dependencyManagement元素中指定的版本号。</p><p>这样做的好处：<strong>统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，才能保证测试的和发布的是相同的成果，因此，在顶层pom中定义共同的依赖关系。同时可以避免在每个使用的子项目中都声明一个版本号，这样想升级或者切换到另一个版本时，只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个版本号时，只需要在dependencies中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号</strong>。</p><p>相对于dependencyManagement，所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承。<strong>dependencies即使在子项目中不写该依赖项，那么子项目仍然会从父项目中继承该依赖项（全部继承）</strong> <strong>dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本</strong>。</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">--</span> 父模块中的配置 <span class="attr">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">--</span> 子模块中选择继承，如果不声明，不继承；不写<span class="attr">version</span>，<span class="attr">scope</span>，继承父模块<span class="attr">dependencyManagement</span>中；如果自己定义<span class="attr">version</span>，则使用自己的依赖 <span class="attr">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="dependencyManagement继承优化"><a href="#dependencyManagement继承优化" class="headerlink" title="dependencyManagement继承优化"></a><strong>dependencyManagement继承优化</strong></h4><p>Maven的继承和Java的继承一样，是无法实现多重继承的，如果10个、20个甚至更多模块继承自同一个模块，那么按照我们之前的做法，这个父模块的dependencyManagement会包含大量的依赖。如果你想把这些依赖分类以更清晰的管理，那就不可能了，<strong>import scope依赖能解决这个问题</strong>。可以<strong>把dependencyManagement放到单独的专门用来管理依赖的POM中，然后在需要使用依赖的模块中通过import scope依赖，就可以引入dependencyManagement</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juvenxu.sample<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sample-dependency-infrastructure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juvenxu.sample<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>sample-dependency-infrastructure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，父模块的POM就会非常干净，由专门的packaging为pom的POM来管理依赖，也契合的面向对象设计中的单一职责原则。此外，我们还能够创建多个这样的依赖管理POM，以更细化的方式管理依赖。这种做法与面向对象设计中使用组合而非继承也有点相似的味道。</p><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>     <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--</span> 模型版本。<span class="attr">maven2.0</span>必须是这样写，现在是<span class="attr">maven2</span>唯一支持的版本 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--</span> 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如<span class="attr">com.winner.trade</span>，<span class="attr">maven</span>会将该项目打成的<span class="attr">jar</span>包放本地路径：/<span class="attr">com</span>/<span class="attr">winner</span>/<span class="attr">trade</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.winner.trade<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">--</span> 本项目的唯一<span class="attr">ID</span>，一个<span class="attr">groupId</span>下面可能多个项目，就是靠<span class="attr">artifactId</span>来区分的 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>trade-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--</span> 本项目目前所处的版本号 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--</span> 打包的机制，如<span class="attr">pom</span>,<span class="attr">jar</span>, <span class="attr">maven-plugin</span>, <span class="attr">ejb</span>, <span class="attr">war</span>, <span class="attr">ear</span>, <span class="attr">rar</span>, <span class="attr">par</span>，默认为<span class="attr">jar</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--</span> 帮助定义构件输出的一些附属构件,附属构件与主构件对应，有时候需要加上<span class="attr">classifier</span>才能唯一的确定该构件 不能直接定义项目的<span class="attr">classifer</span>,因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成的 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>...<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--</span> 定义本项目的依赖关系 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--</span> 每个<span class="attr">dependency</span>都对应这一个<span class="attr">jar</span>包 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--一般情况下，maven是通过groupId、artifactId、version这三个元素值（俗称坐标）来检索该构件，</span> 然后引入你的工程。如果别人想引用你现在开发的这个项目（前提是已开发完毕并发布到了远程仓库），<span class="attr">--</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">--就需要在他的pom文件中新建一个dependency节点，将本项目的groupId、artifactId、version写入，</span> <span class="attr">maven</span>就会把你上传的<span class="attr">jar</span>包下载到他的本地 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.winner.trade<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>trade-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--</span> <span class="attr">maven</span>认为，程序对外部的依赖会随着程序的所处阶段和应用场景而变化，所以<span class="attr">maven</span>中的依赖关系有作用域(<span class="attr">scope</span>)的限制。 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--scope包含如下的取值：compile（编译范围）、provided（已提供范围）、runtime（运行时范围）、test（测试范围）、system（系统范围）</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--</span> 设置指依赖是否可选，默认为<span class="attr">false</span>,即子项目默认都继承<span class="attr">:</span>为<span class="attr">true</span>,则子项目必需显示的引入，与<span class="attr">dependencyManagement</span>里定义的依赖类似  <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>false<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--</span> 屏蔽依赖关系。 比如项目中使用的<span class="attr">libA</span>依赖某个库的<span class="attr">1.0</span>版，<span class="attr">libB</span>依赖某个库的<span class="attr">2.0</span>版，现在想统一使用<span class="attr">2.0</span>版，就应该屏蔽掉对<span class="attr">1.0</span>版的依赖 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--</span> 为<span class="attr">pom</span>定义一些常量，在<span class="attr">pom</span>中的其它地方可以直接引用 使用方式 如下 ：$&#123;<span class="attr">file.encoding</span>&#125; <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">file.encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">file.encoding</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">java.source.version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">java.source.version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">java.target.version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">java.target.version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line">    ...  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--</span> 产生的构件的文件名，默认值是$&#123;<span class="attr">artifactId</span>&#125;<span class="attr">-</span>$&#123;<span class="attr">version</span>&#125;。 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>myPorjectName<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--</span> 构建产生的所有文件存放的目录,默认为$&#123;<span class="attr">basedir</span>&#125;/<span class="attr">target</span>，即项目根目录下的<span class="attr">target</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--当项目没有规定目标（Maven2叫做阶段（phase））时的默认值，</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--必须跟命令行上的参数相同例如jar:jar，或者与某个阶段（phase）相同例如install、compile等</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultGoal</span>&gt;</span>install<span class="tag">&lt;/<span class="name">defaultGoal</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--当filtering开关打开时，使用到的过滤器属性文件列表。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--项目配置信息中诸如$&#123;spring.version&#125;之类的占位符会被属性文件中的实际值替换掉</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filters</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span>&gt;</span>../filter.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">filters</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--项目相关的所有资源路径列表，例如和项目相关的配置文件、属性文件，这些资源被包含在最终的打包文件里。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--描述了资源的目标路径。该路径相对target</span>/<span class="attr">classes</span>目录（例如$&#123;<span class="attr">project.build.outputDirectory</span>&#125;）。 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org</span>/<span class="attr">apache</span>/<span class="attr">maven</span>/<span class="attr">messages</span>。 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>resources<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--描述存放资源的目录，该路径相对POM路径</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--包含的模式列表</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>  </span><br><span class="line">            &lt;--排除的模式列表 如果&lt;include&gt;与&lt;exclude&gt;划定的范围存在冲突，以&lt;exclude&gt;为准 --&gt;  </span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>jdbc.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--单元测试相关的所有资源路径，配制方法与resources类似</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">testResource</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;basedir&#125;\src\main\java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span>  </span><br><span class="line">    &lt;--项目脚本源码目录，该目录和源码目录不同， &lt;-- 绝大多数情况下，该目录下的内容会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;  </span><br><span class="line">    <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>$&#123;basedir&#125;\src\main\scripts  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$&#123;basedir&#125;\src\test\java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--被编译过的应用程序class文件存放的目录。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;basedir&#125;\target\classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--被编译过的测试class文件存放的目录。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>$&#123;basedir&#125;\target\test-classes  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--项目的一系列构建扩展,它们是一系列build过程中要使用的产品，会包含在running</span> <span class="attr">bulid</span>‘<span class="attr">s</span> <span class="attr">classpath</span>里面。 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--他们可以开启extensions，也可以通过提供条件来激活plugins。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--简单来讲，extensions是在build过程被激活的产品</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--例如，通常情况下，程序开发完成后部署到线上Linux服务器，可能需要经历打包、</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--将包文件传到服务器、SSH连上服务器、敲命令启动程序等一系列繁琐的步骤。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--实际上这些步骤都可以通过Maven的一个插件</span> <span class="attr">wagon-maven-plugin</span> 来自动完成 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--下面的扩展插件wagon-ssh用于通过SSH的方式连接远程服务器，</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--类似的还有支持ftp方式的wagon-ftp插件</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">extension</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.wagon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wagon-ssh<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">extension</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--使用的插件列表</span> 。 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">--配置的执行目标</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">--配置是否被传播到子POM</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--作为DOM对象的配置,配置项因插件而异</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;finalName&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>assembly.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--是否从该插件下载Maven扩展（例如打包和类型处理器），</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--由于性能原因，只有在真需要下载时，该元素才被设置成true。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--项目引入插件所需要的额外依赖</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--任何配置是否被传播到子项目</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--主要定义插件的共同元素、扩展元素集合，类似于dependencyManagement，</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--所有继承于此项目的子项目都能使用。该插件配置项直到被引用时才会被解析或绑定到生命周期。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--给定插件的任何本地配置都会覆盖这里的配置</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>...<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="分发配置"><a href="#分发配置" class="headerlink" title="分发配置"></a>分发配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">--项目分发信息，在执行mvn</span> <span class="attr">deploy</span>后表示要发布的位置。 <span class="attr">--</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">--有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--部署项目产生的构件到远程仓库需要的信息</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--是分配给快照一个唯一的版本号（由时间戳和构建流水号），还是每次都使用相同的版本号</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--参见repositories</span>/<span class="attr">repository</span>元素 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">uniqueVersion</span>&gt;</span>true<span class="tag">&lt;/<span class="name">uniqueVersion</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span> repo-id <span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> repo-name<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$&#123;basedir&#125;/target/deploy <span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--构件的快照部署到哪里,如果没有配置该元素，默认部署到repository元素配置的仓库</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--部署项目的网站需要的信息</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">site</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span> site-id <span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--部署位置的名称</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> site-name<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--部署位置的URL，按protocol:</span>//<span class="attr">hostname</span>/<span class="attr">path</span>形式 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web <span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">site</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--项目下载页面的URL。如果没有该元素，用户应该参考主页。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">downloadUrl</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--如果构件有了新的groupID和artifact</span> <span class="attr">ID</span>（构件移到了新的位置），这里列出构件的重定位信息。 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">relocation</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--构件新的group</span> <span class="attr">ID</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--构件新的artifact</span> <span class="attr">ID</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--构件新的版本号</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--显示给用户的，关于移动的额外信息，例如原因。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">message</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--有效的值有：none（默认），converted（仓库管理员从Maven</span> <span class="attr">1</span> <span class="attr">POM</span>转换过来）， <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--partner（直接从伙伴Maven</span> <span class="attr">2</span>仓库同步过来），<span class="attr">deployed</span>（从<span class="attr">Maven</span> <span class="attr">2</span>实例部署），<span class="attr">verified</span>（被核实时正确的和最终的）。 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">status</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">--发现依赖和扩展的远程仓库列表。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--包含需要连接到远程仓库的信息</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--如何处理远程仓库里发布版本的下载</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--这里的选项是：always（一直），daily（默认，每日），</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--当Maven验证构件校验文件失败时该怎么做：</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--ignore（忽略），fail（失败），或者warn（警告）。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--例如，可能有人会决定只为开发目的开启对快照版本下载的支持</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span> repo-id <span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--远程仓库名称</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> repo-name<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--远程仓库URL，按protocol:</span>//<span class="attr">hostname</span>/<span class="attr">path</span>形式 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.169:9999/repository/ <span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--Maven</span> <span class="attr">2</span>为其仓库提供了一个默认的布局； <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--然而，Maven1.x有一种不同的布局。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span>&gt;</span> default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">--发现插件的远程仓库列表，这些插件用于构建和报表</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">--包含需要连接到远程插件仓库的信息.参见repositories</span>/<span class="attr">repository</span>元素 <span class="attr">--</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepository</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="profile-配置"><a href="#profile-配置" class="headerlink" title="profile 配置"></a>profile 配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">--在列的项目构建profile，如果被激活，会修改构建处理</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">--根据环境参数或命令行参数激活某个构建处理</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--自动触发profile的条件逻辑。Activation是profile的开启钥匙。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">--profile默认是否激活的标识</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">--activation有一个内建的java版本检测，如果检测到jdk版本与期待的一样，profile被激活。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">os</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">--激活profile的操作系统的名字</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">--激活profile的操作系统所属家族(如</span> '<span class="attr">windows</span>') <span class="attr">--</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">--激活profile的操作系统体系结构</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">--激活profile的操作系统版本</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">os</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--</span> 如果值字段是空的，那么存在属性名称字段就会激活<span class="attr">profile</span>，否则按区分大小写方式匹配属性值字段 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">--激活profile的属性的名称</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">--激活profile的属性的值</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">--另一方面，exists则会检查文件是否存在，如果存在则激活profile。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">file</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">--如果指定的文件存在，则激活profile。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">exists</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/<span class="tag">&lt;/<span class="name">exists</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">--如果指定的文件不存在，则激活profile。</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">missing</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/<span class="tag">&lt;/<span class="name">missing</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">file</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">build</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">modules</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">repositories</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepositories</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">reporting</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencyManagement</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">distributionManagement</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>profile配置项在setting.xml中也有，是pom.xml中profile元素的裁剪版本，包含了id，activation, repositories, pluginRepositories和 properties元素。这里的profile元素只包含这五个子元素是因为setting.xml只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。<strong>一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile</strong>。</p><p><strong>pom.xml中的profile可以看做pom.xml的副本，拥有与pom.xm**</strong>l相同的子元素与配置方法**。它包含可选的activation（profile的触发器）和一系列的changes。例如test过程可能会指向不同的数据库（相对最终的deployment）或者不同的dependencies或者不同的repositories，并且是根据不同的JDK来改变的。只需要其中一个成立就可以激活profile，如果第一个条件满足了，那么后面就不会在进行匹配。</p><h3 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h3><p>Maven 默认约定了一套目录结构，在通过maven创建了项目以后，项目的目录结构就是以这套目录结构作为模板创建的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$&#123;basedir&#125;</span><br><span class="line">|-- pom.xml</span><br><span class="line">|-- src</span><br><span class="line">|   |-- main</span><br><span class="line">|   |   `-- java</span><br><span class="line">|   |   `-- resources</span><br><span class="line">|   |   `-- filters</span><br><span class="line">|   `-- test</span><br><span class="line">|   |   `-- java</span><br><span class="line">|   |   `-- resources</span><br><span class="line">|   |   `-- filters</span><br><span class="line">|   `-- it</span><br><span class="line">|   `-- assembly</span><br><span class="line">|   `-- site</span><br><span class="line">`-- LICENSE.txt</span><br><span class="line">`-- NOTICE.txt</span><br><span class="line">`-- README.txt</span><br></pre></td></tr></table></figure><p>在根目录下，主要有两个目录，<strong>分别是src和target目录</strong>，除此之外，还会有一些版本控制系统的元数据文件，包括git的.gitignore或者svn的.svn。如果一个项目是由多个子项目组成的，那么在该项目的根目录下，还会包含它的子项目的目录。子项目的目录布局，默认也是和上面列出的目录结构一致的。target目录，这个目录只要用于存放<strong>项目构建的输出文件，比如class文件以及打包后的包文件等</strong>。在src目录下，包含了项目所有的源代码和资源文件，以及其他项目相关的文件。在该目录的main目录下，包含了构建该项目的artifact（可以理解为时项目的程序部分）所需的代码和资源，而test目录包含了测试相关的代码和资源文件。</p><h4 id="版本规范"><a href="#版本规范" class="headerlink" title="版本规范"></a>版本规范</h4><ul><li><strong>SNAPSHOT</strong><br>如果一个版本包含字符串”SNAPSHOT”，Maven就会在安装或发布这个组件的时候将该符号展开为一个日期和时间值，转换为UTC时间。例如，”1.0-SNAPSHOT”会在2010年5月5日下午2点10分发布时候变成1.0-20100505-141000-1。<br>这个词只能用于开发过程中，因为一般来说，项目组都会频繁发布一些版本，最后实际发布的时候，会在这些snapshot版本中寻找一个稳定的，用于正式发 布，比如1.4版本发布之前，就会有一系列的1.4-SNAPSHOT，而实际发布的1.4，也是从中拿出来的一个稳定版。</li><li><strong>LATEST</strong><br>指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个snapshot版，具体看哪个时间最后。</li><li><strong>RELEASE</strong><br>指最后一个发布版。</li></ul><h3 id="Maven-命令"><a href="#Maven-命令" class="headerlink" title="Maven 命令"></a>Maven 命令</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>Maven命令列表</th><th>目标</th></tr></thead><tbody><tr><td>mvn –version</td><td>显示版本信息</td></tr><tr><td>mvn clean</td><td>清理项目生产的临时文件,一般是模块下的target目录</td></tr><tr><td>mvn compile</td><td>编译源代码，一般编译模块下的src/main/Java目录</td></tr><tr><td>mvn package</td><td>项目打包工具,会在模块下的target目录生成jar或war等文件</td></tr><tr><td>mvn test</td><td>测试命令,或执行src/test/java/下junit的测试用例.</td></tr><tr><td>mvn install</td><td>将打包的jar/war文件复制到你的本地仓库中,供其他模块使用</td></tr><tr><td>mvn deploy</td><td>将打包的文件发布到远程参考,提供其他人员进行下载依赖</td></tr><tr><td>mvn site</td><td>生成项目相关信息的网站</td></tr><tr><td>mvn eclipse:eclipse</td><td>将项目转化为Eclipse项目</td></tr><tr><td>mvn dependency:tree</td><td>打印出项目的整个依赖树</td></tr><tr><td>mvn archetype:generate</td><td>创建Maven的普通java项目</td></tr><tr><td>mvn tomcat:run</td><td>在tomcat容器中运行web应用</td></tr><tr><td>mvn jetty:run</td><td>调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用</td></tr></tbody></table><h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-D 传入属性参数 eg:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn package -Dmaven.test.skip=true</span><br><span class="line">---------------------------------</span><br><span class="line">以“-D”开头，将“maven.test.skip”的值设为“true”,就是告诉maven打包的时候跳过单元测试。同理，“mvn deploy -Dmaven.test.skip=true”代表部署项目并跳过单元测试。</span><br></pre></td></tr></table></figure><p>-P 使用指定的Profile配置</p><p><strong>-e 显示maven运行出错的信息</strong></p><p><strong>-o 离线执行命令,即不去远程仓库更新包</strong></p><p><strong>-X 显示maven允许的debug信息</strong></p><p><strong>-U 强制去远程更新snapshot的插件或依赖，默认每天只更新一次</strong></p><h3 id="仓库-1"><a href="#仓库-1" class="headerlink" title="仓库"></a>仓库</h3><p>中央仓库、中央仓库的镜像仓库、其他公共仓库、私服都属于远程仓库的范畴。</p><p>如果maven没有在本地仓库找到想要的东西，就会自动去配置文件中指定的远程仓库寻找，找到后将它下载到本地仓库。如果连远程仓库都找不到想要的东西，肯定是配置写错了，就会报错。</p><h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h4><p>仓库分为本地仓库和远程仓库，是依赖和插件的存储的地方，本地仓库是在自己电脑上，默认位置是${user.home}/.m2/repository,在pom.xml中声明之后，maven会首先在本地仓库中找，找到了，自动引入工程的依赖lib库即可。找不到需要去远程仓库查找。</p><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>远程仓库，先从最核心的中央仓库开始，中央仓库是默认的远程仓库，maven在安装的时候，自带的默认中央仓库地址为<a href="http://repo1.maven.org/maven2/，此仓库由Maven社区管理，包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。Maven社区提供了一个中央仓库的搜索地址:http://search.maven.org/#browse，可以查询到所有可用的库文件。" target="_blank" rel="noopener">http://repo1.maven.org/maven2/，此仓库由Maven社区管理，包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。Maven社区提供了一个中央仓库的搜索地址:http://search.maven.org/#browse，可以查询到所有可用的库文件。</a></p><p>除了中央仓库，还有其它很多公共的远程仓库，如中央仓库的镜像仓库。全世界都从中央仓库请求资源，中央仓库扛不住啊，所以在世界各地还有很多中央仓库的镜像仓库。镜像仓库可以理解为仓库的副本，会从原仓库定期更新资源，以保持与原仓库的一致性。从仓库中可以找到的构件，从镜像仓库中也可以找到，直接访问镜像仓库，更快更稳定。</p><p>除此之外，还有很多各具特色的公共仓库，如果需要都可以在网上找到，比如Apache Snapshots仓库，包含了来自于Apache软件基金会的快照版本。</p><ul><li>私服</li></ul><p>一般来讲，公司都会通过自己的私有服务器在局域网内架设一个仓库代理。私服可以看作一种特殊的远程仓库，代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，先从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。</p><p><strong>Maven私服有很多好处</strong>：</p><ol><li>可以把公司的私有jar包，以及无法从外部仓库下载到的构件上传到私服上，供公司内部使用；</li><li>节省自己的外网带宽：减少重复请求造成的外网带宽消耗；</li><li>加速Maven构建：如果项目配置了很多外部远程仓库的时候，构建速度就会大大降低；</li><li>提高稳定性，增强控制：Internet不稳定的时候，maven构建也会变的不稳定，一些私服软件还提供了其他的功能</li></ol><p>当前主流的maven私服有Apache的Archiva、JFrog的Artifactory以及Sonatype的Nexus。</p><h4 id="仓库配置-1"><a href="#仓库配置-1" class="headerlink" title="仓库配置"></a>仓库配置</h4><p>仓库配置要做两件事，一是告诉maven你的本地仓库在哪里，二是你的远程仓库在哪里。</p><p>setting.xml的第一个节点<code>&lt;localRepository&gt;</code>就是配置本地仓库的地方，</p><p>远程仓库比较复杂，因为会涉及很多附属特性。以Nexus为例，至于Nexus怎么部署，怎么维护仓库，作为开发人员是不需要关心的，只需要把Nexus私服的局域网地址写入maven的本地配置文件即可。具体的配置方法如下</p><p>1 设置镜像</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">--</span> 该镜像的唯一标识符。<span class="attr">id</span>用来区分不同的<span class="attr">mirror</span>元素。 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">--</span> 镜像名，起注解作用，应做到见文知意。可以不配置  <span class="attr">--</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name <span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">--</span>  所有仓库的构件都要从镜像下载  <span class="attr">--</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">--</span> 私服的局域网地址<span class="attr">--</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.0.1:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">-----------------------</span><br><span class="line">节点<span class="tag">&lt;<span class="name">mirrors</span>&gt;</span>下面可以配置多个镜像，<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>用于指明是哪个仓库的镜像，上例中使用通配符“*”表明该私服是所有仓库的镜像，不管本地使用了多少种远程仓库，需要下载构件时都会从私服请求。</span><br><span class="line">如果只想将私服设置成某一个远程仓库的镜像，使用<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>指定该远程仓库的ID即可。</span><br></pre></td></tr></table></figure><p>2设置远程仓库</p><p>远程仓库的设置在<code>&lt;profile&gt;</code>节点下面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">--</span> 仓库唯一标识 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>repoId <span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">--</span> 远程仓库名称  <span class="attr">--</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>repoName<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">--</span> 远程仓库<span class="attr">URL</span>，如果该仓库配置了镜像，这里的<span class="attr">URL</span>就没有意义了，因为任何下载请求都会交由镜像仓库处理，前提是镜像（也就是设置好的私服）需要确保该远程仓库里的任何构件都能通过它下载到  <span class="attr">--</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://……<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">--</span> 如何处理远程仓库里发布版本的下载 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">releases</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">--</span> <span class="attr">true</span>或者<span class="attr">false</span>表示该仓库是否为下载某种类型构件（发布版，快照版）开启。   <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">--</span> 该元素指定更新发生的频率。<span class="attr">Maven</span>会比较本地<span class="attr">POM</span>和远程<span class="attr">POM</span>的时间戳。这里的选项是：<span class="attr">--</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">--</span> <span class="attr">always</span>（一直），<span class="attr">daily</span>（默认，每日），<span class="attr">interval</span>：<span class="attr">X</span>（这里<span class="attr">X</span>是以分钟为单位的时间间隔），或者<span class="attr">never</span>（从不）。  <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">--</span> 当<span class="attr">Maven</span>验证构件校验文件失败时该怎么做<span class="attr">:--</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">--</span> <span class="attr">ignore</span>（忽略），<span class="attr">fail</span>（失败），或者<span class="attr">warn</span>（警告）。 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">releases</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">--</span> 如何处理远程仓库里快照版本的下载，与发布版的配置类似 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">updatePolicy</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">checksumPolicy</span>/&gt;</span>        </span><br><span class="line">  <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><p>项目的依赖关系主要分为三种，依赖，继承，聚合</p><ul><li>依赖关系</li></ul><p>依赖关系是最常用的一种，就是你的项目需要依赖其他项目，比如Apache-common包，Spring包等等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span> &gt;</span>jar<span class="tag">&lt;/ <span class="attr">type</span> &gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span> &gt;</span>true<span class="tag">&lt;/ <span class="attr">optional</span> &gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>任意一个外部依赖说明包含如下几个要素：<strong>groupId, artifactId, version, scope, type, optional</strong>。其中前3个是必须的。</p><ul><li>继承关系</li></ul><p>继承就是避免重复，maven的继承也是这样，虽然前面进行了介绍，但是为了进一步强调，还是重复一下，它还有一个好处就是让项目更加安全。项目之间存在上下级关系时就属于继承关系。</p><p>父项目的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.clf.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>   </span><br><span class="line">      <span class="tag">&lt;<span class="name">--</span> 该节点下的依赖会被子项目自动全部继承 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--</span> 该节点下的依赖关系只是为了统一版本号，不会被子项目自动继承，<span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">--</span> 除非子项目主动引用，好处是子项目可以不用写版本号 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">--</span> 这个元素和<span class="attr">dependencyManagement</span>相类似，它是用来进行插件管理的<span class="attr">--</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span>    </span><br><span class="line">       ......  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Maven 使用dependencyManagement 元素来提供了一种管理依赖版本号的方式</strong>。通常会在一个组织或者项目的最顶层的父POM 中看到dependencyManagement 元素。使用pom.xml 中的dependencyManagement 元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。Maven 会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用在这个dependencyManagement 元素中指定的版本号。</p><p><strong>父项目在dependencies声明的依赖，子项目会从全部自动地继承</strong>。而父项目在dependencyManagement里只是声明依赖，<strong>并不实现引入</strong>，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</p><p>如果某个项目需要继承该父项目，基础配置应该这样</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.clf.parent.son<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-son<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   </span><br><span class="line">      <span class="tag">&lt;<span class="name">--</span> 声明将父项目的坐标 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">parent</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.clf.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">          <span class="tag">&lt;<span class="name">--</span> 父项目的<span class="attr">pom.xml</span>文件的相对路径。相对路径允许你选择一个不同的路径。 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">--</span>   默认值是<span class="attr">..</span>/<span class="attr">pom.xml</span>。<span class="attr">Maven</span>首先在构建当前项目的地方寻找父项目的<span class="attr">pom</span>， <span class="attr">--</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">--</span>   其次在文件系统的这个位置（<span class="attr">relativePath</span>位置）， <span class="attr">--</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">--</span>   然后在本地仓库，最后在远程仓库寻找父项目的<span class="attr">pom</span>。 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../parent-project/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>   </span><br><span class="line">      <span class="tag">&lt;<span class="name">--</span> 声明父项目<span class="attr">dependencyManagement</span>的依赖，不用写版本号 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>聚合关系</li></ul><p>maven的多模块管理也是非常强大的。一般来说，maven要求同一个工程的所有模块都放置到同一个目录下，每一个子目录代表一个模块，比如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总项目/</span><br><span class="line"> pom.xml 总项目的pom配置文件</span><br><span class="line"> 子模块1/  </span><br><span class="line">       pom.xml 子模块1的pom文件  </span><br><span class="line"> 子模块2/  </span><br><span class="line">      pom.xml子模块2的pom文件</span><br></pre></td></tr></table></figure><p>总项目配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span>   </span><br><span class="line">       <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>   </span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.clf.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   </span><br><span class="line">       <span class="tag">&lt;<span class="name">--</span> 打包类型必须为<span class="attr">pom</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">--</span> 声明了该项目的直接子模块 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">--</span> 这里配置的不是<span class="attr">artifactId</span>，而是这个模块的目录名称<span class="attr">--</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-1<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-2<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-3<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span>   </span><br><span class="line">       <span class="tag">&lt;<span class="name">--</span> 聚合也属于父子关系，总项目中的<span class="attr">dependencies</span>与<span class="attr">dependencyManagement</span>、<span class="attr">pluginManagement</span>用法与继承关系类似 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">        ......  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>  </span><br><span class="line">        ......  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span>   </span><br><span class="line">       ......  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模块的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span>   </span><br><span class="line">       <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>   </span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.clf.parent.son<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-son<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">--</span> 声明将父项目的坐标 <span class="attr">--</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">parent</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.clf.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   </span><br><span class="line">       <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>继承与聚合的关系</li></ul><p>首先，继承与聚合都属于父子关系，并且，聚合 POM与继承关系中的父POM的packaging都是pom。<br>不同的是，对于聚合模块来说，它知道有哪些被聚合的模块，但那些被聚合的模块不知道这个聚合模块的存在。对于继承关系的父 POM来说，它不知道有哪些子模块继承与它，但那些子模块都必须知道自己的父 POM是什么。<br>在实际项目中，一个 POM往往既是聚合POM，又是父 POM，它继承了某个项目，本身包含几个子模块，同时肯定会存在普通的依赖关系，就是说，依赖、继承、聚合这三种关系是并存的。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 无消息丢失配置</title>
      <link href="/2019/10/23/Kafka%203%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/10/23/Kafka%203%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="无消息丢失配置"><a href="#无消息丢失配置" class="headerlink" title="无消息丢失配置"></a>无消息丢失配置</h2><p>Kafka 在什么情况下才能保证消息不丢失呢？</p><p><strong>一句话概括，Kafka 只对“已提交”的消息（committed message）做有限度的持久化保证。</strong></p><p>两个核心要素。</p><p>第一个核心要素是<strong>已提交的消息</strong>。什么是已提交的消息？当 Kafka 的若干个 Broker 成功地接收到一条消息并写入到日志文件后，它们会告诉生产者程序这条消息已成功提交。此时，这条消息在 Kafka 看来就正式变为“已提交”消息了。</p><p>第二个核心要素是<strong>有限度的持久化保证</strong>,，也就是说 Kafka 不可能保证在任何情况下 都做到不丢失消息。</p><p>“有限度”的含义其实就是说 Kafka 不丢消息是 有前提条件的。假如你的消息保存在 N 个 Kafka Broker 上，那么这个前提条件就是这 N 个 Broker 中至少有 1 个存活。只要这个条件成立，Kafka 就能保证你的这条消息永远不会 丢失。</p><h4 id="案例一：生产者程序丢失数据"><a href="#案例一：生产者程序丢失数据" class="headerlink" title="案例一：生产者程序丢失数据"></a>案例一：生产者程序丢失数据</h4><p>Producer 程序丢失消息，这应该算是被抱怨最多的数据丢失场景了。目前 Kafka Producer 是异步发送消息的，也就是说如果你调用的是 producer.send(msg) 这个 API，那么它通常会立即返回，但此时你不能认为消息发送已成功完成。如果用这个方式，可能会有哪些因素导致消息没有发送成功呢？其实原因有很多，例如网络抖动，导致消息压根就没有发送到 Broker 端；或者消息本身不合格导致 Broker 拒绝接收 （比如消息太大了，超过了 Broker 的承受能力）等。这么来看，让 Kafka“背锅”就有点 冤枉它了。就像前面说过的，Kafka 不认为消息是已提交的，因此也就没有 Kafka 丢失消息这一说了。</p><p>解决问题的方法就是<strong>Producer 永远要使用带有回调通知的发送 API，也就是说不要使用 <code>producer.send(msg)</code>，而要使用 <code>producer.send(msg, callback)</code>。不要小瞧这里的 callback（回调），它能准确地告诉你消息是否真的提交成功了。一旦出现消息提交失败的 情况，你就可以有针对性地进行处理。</strong></p><h4 id="案例二：消费者程序丢失程序"><a href="#案例二：消费者程序丢失程序" class="headerlink" title="案例二：消费者程序丢失程序"></a>案例二：消费者程序丢失程序</h4><p>Consumer 端丢失数据主要体现在 Consumer 端要消费的消息不见了。Consumer 程序有 个“位移”的概念，表示的是这个 Consumer 当前消费到的 Topic 分区的位置。下面这张 图清晰地展示了 Consumer 端的位移数据。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191028205552.png" width="50%"></p><p>比如对于消费者A,它当前的位移值就是9，而B的位移值就是11。这里的“位移”类似于看书时使用的书签，它会标记我们当前阅读了多少页，下次翻书 的时候我们能直接跳到书签页继续阅读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正确使用书签有两个步骤：第一步是读书，第二步是更新书签页。如果这两步的顺序颠倒 了，就可能出现这样的场景：当前的书签页是第 90 页，我先将书签放到第 100 页上，之 后开始读书。当阅读到第 95 页时，我临时有事中止了阅读。那么问题来了，当我下次直接 跳到书签页阅读时，我就丢失了第 96～99 页的内容，即这些消息就丢失了。</span><br></pre></td></tr></table></figure><p>同理，Kafka 中 Consumer 端的消息丢失就是这么一回事。要对抗这种消息丢失，办法很 简单：维持先消费消息（阅读），再更新位移（书签）的顺序即可。这样就能最大限度地保证消息不丢失。</p><p>还有一种情况就是Consumer 程序从 Kafka 获取到消息后开启了多个线程异步处 理消息，而 Consumer 程序自动地向前更新位移。假如其中某个线程运行失败了，它负责 的消息没有被成功处理，但位移已经被更新了，因此这条消息对于 Consumer 而言实际上 是丢失了。<strong>这个问题的解决方案也很简单：如果是多线程异步处理消费消息，Consumer 程序不要开 启自动提交位移，而是要应用程序手动提交位移。</strong></p><h4 id="推荐的无消息丢失配置"><a href="#推荐的无消息丢失配置" class="headerlink" title="推荐的无消息丢失配置"></a>推荐的无消息丢失配置</h4><ol><li><p>不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一 定要使用带有回调通知的 send 方法。</p></li><li><p>设置 acks = all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。 如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。 这是最高等级的“已提交”定义。</p></li><li><p>设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到 的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</p></li><li><p>设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪 些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么 它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false， 即不允许这种情况的发生。</p></li><li><p>设置 replication.factor &gt;= 3。这也是 Broker 端的参数。其实这里想表述的是，最好将 消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。</p></li><li><p>设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入 到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千 万不要使用默认值 1。</p></li><li><p>确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂 机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要 在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。</p></li><li><p>确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设 置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程 处理的场景而言是至关重要的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql解密八 锁</title>
      <link href="/2019/10/09/Mysql%20%E9%94%81/"/>
      <url>/2019/10/09/Mysql%20%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql-锁"><a href="#Mysql-锁" class="headerlink" title="Mysql 锁"></a>Mysql 锁</h2><p>数据库锁设计的初衷是处理并发问题。作为多用户共享 的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实 现这些访问规则的重要数据结构。</p><p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。</p><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>全局锁就是对整个数据库实例加锁，MySQL 提供了一个加全局读锁的方法，命令是 <code>Flush tables with read lock (FTWRL)。</code>当需要让整个库处于只读状态的时候，可 以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p><p><strong>全局锁的典型使用场景是 做全库逻辑备份</strong> 也就是把整库每个表都select 出来存成文本。</p><p>业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。 不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被 锁住的。</p><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>MYSQL里面的表级别的锁有两种，一种是表锁，一种是元数据锁。</p><p>表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别 的线程的读写外，也限定了本线程接下来的操作对象。</p><p>例如, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程 写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执 行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p><p>另一类表级的锁时MDL。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在 遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，在 MySQL 5.5 版本中引入了 MDL，<strong>当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</strong></p><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</p><p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个 线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p><p>同时，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马 上释放，而会等到整个事务提交后再释放。</p><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>InnoDB 是支持行锁的，这也是MyISAM 被InnoDB替代的重要原因之一。</p><p>看下面的例子,在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象 呢？假设字段 id 是表 t 的主键。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191015225037.png" alt=""></p><p>实际上事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。</p><p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻 释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p><p>这对我们的启发就是，如果你的事务中需要锁多个行， 要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><h5 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h5><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会 导致这几个线程都进入无限等待的状态，称为死锁。当出现死锁后，有两种策略</p><p>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他 事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql解密七 OrderBy</title>
      <link href="/2019/10/05/mysql%20orderby%20--16/"/>
      <url>/2019/10/05/mysql%20orderby%20--16/</url>
      
        <content type="html"><![CDATA[<h2 id="orderby-–16"><a href="#orderby-–16" class="headerlink" title="orderby –16"></a>orderby –16</h2><h4 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h4><p>假设要查询杭州市所有人的名字，并且按照姓名排序返回前1000个人的姓名和年龄。</p><p>SQL十分清晰，可以这么写<code>select city,name,age from t where city=&#39;杭州&#39; order by name limit 1000</code></p><p>为了避免全表扫描，需要在city字段加上索引。添加后，使用explain命令查看执行情况</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191010201132.png" alt=""></p><p>Extra 这个字段中的“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一 块内存用于排序，称为 sort_buffer。</p><p>先来看city索引的示意图。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191010201222.png" alt=""></p><p>图中可以看到，满足 city=’杭州’条件的行，是从 ID_X 到 ID_(X+N) 的这些记录。</p><p>通常情况下，这个语句执行流程如下所示 ：</p><ol><li><p>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</p></li><li><p>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</p></li><li><p>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；</p></li><li><p>从索引 city 取下一个记录的主键 id；</p></li><li><p>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；</p></li><li><p>对 sort_buffer 中的数据按照字段 name 做快速排序；</p></li><li><p>按照排序结果取前 1000 行返回给客户端。</p><hr></li></ol><p>暂且把这个排序过程，称为全字段排序，执行流程的示意图如下所示。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191010201400.png" alt=""></p><p>按name 排序的动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数sort_buffer_size。</p><p>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的 数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不 下，则不得不利用磁盘临时文件辅助排序。</p><h4 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h4><p>上面的算法过程中，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的，但这个算法有一个问题，<strong>就是如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个 临时文件，排序的性能会很差。</strong></p><p>所以，如果MYSQL认为排序的单行长度太大会怎么做</p><p>修改参数<code>max_length_for_sort_data=16</code>，<code>max_length_for_sort_data</code>，是 MySQL 中专门控制用于排序的行数据的长度的一个参 数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</p><p>city、name、age 这三个字段的定义总长度是 36，把 max_length_for_sort_data 设置 为 16，再来看看计算过程有什么改变。</p><p>新的算法放入 sort_buffer 的字段，只有要排序的列（即 name 字段）和主键 id。</p><p>但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就 变成如下所示的样子：</p><ol><li>初始化 sort_buffer，确定放入两个字段，即 name 和 id；</li><li>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</li><li>到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到不满足 city=’杭州’条件为止，也就是图中的 ID_Y；</li><li>对 sort_buffer 中的数据按照字段 name 进行排序；</li><li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个 字段返回给客户端。</li></ol><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191010203028.png" alt=""></p><p>对比全字段排序流程图会发现，rowid 排序多访问了一次表 t 的主键索引.</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这 样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p><p>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p><p>这也就体现了 MySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访 问。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 工作总结</title>
      <link href="/2019/10/03/git%20%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/03/git%20%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="git-工作总结"><a href="#git-工作总结" class="headerlink" title="git 工作总结"></a>git 工作总结</h3><h4 id="易忘操作"><a href="#易忘操作" class="headerlink" title="易忘操作"></a>易忘操作</h4><ul><li><p>要随时掌握⼯作区的状态，使⽤git status命令。</p></li><li><p>如果git status告诉你有⽂件被修改过，⽤git diff可以查看修改内容。</p></li><li><p>git log 查看日志</p></li><li>在Git 中，用HEAD表示当前版本，也就是最新的提交，上⼀个版本就是<code>HEAD^</code>，上上⼀个版本就是<code>HEAD^^</code>，当然往上100 个版本写100个^⽐较容易数不过来， 所以写成<code>HEAD~100</code>。</li><li>回退版本时，使用git reset 命令。<code>git reset --hard HEAD^</code></li><li>git reflog 记录每一次命令。</li></ul><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190920143835.png" width="50%"></p><p>左边是工作区，add 以后是暂存区，然后commit 提交到分支。</p><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><p><code>git checkout -- file</code>可以丢弃⼯作区的修改.</p><p>命令git checkout – readme.txt意思就是，把readme.txt⽂件在⼯作区的修改全部撤销，这 ⾥有两种情况：</p><p>⼀种是readme.txt⾃修改后还没有被放到暂存区，现在，撤销修改就回到和版本库⼀模⼀ 样的状态；</p><p>⼀种是readme.txt已经添加到暂存区后，⼜作了修改，现在，撤销修改就回到添加到暂存 区后的状态。</p><p>总之，就是让这个⽂件回到最近⼀次git commit或git add时的状态。</p><p><strong>git checkout – file命令中的“–”很重要，没有“–”，就变成了“创建⼀个新分⽀”的命 令，我们在后⾯的分⽀管理中会再次遇到git checkout命令。</strong></p><p><strong>git reset命令既可以回退版本，也可以把暂存区的修改回退到⼯作区。当我们⽤HEAD时， 表⽰最新的版本。</strong></p><p><code>git reset HEAD readme.txt</code> 就可以把暂存区的修改退出工作区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read.txt 还没有add ，想丢弃修改，用 git checkout --read.txt</span><br><span class="line">read.txt 已经add了，但是想丢弃修改，用 git reset HEAD readme.txt</span><br></pre></td></tr></table></figure><p><strong>git checkout –file其实是⽤版本库⾥的版本替换⼯作区的版本，⽆论⼯作区是修改还是删除，都 可以“⼀键还原”。</strong></p><h4 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h4><ul><li><p>要关联⼀个远程库，使⽤命令git remote add origin git@server-name:path/repo-name.git；</p></li><li><p>关联后，使⽤命令git push -u origin master第⼀次推送master分⽀的所有内容；</p></li><li><p>此后，每次本地提交后，只要有必要，就可以使⽤命令git push origin master推送最新修改；</p></li></ul><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>HEAD严格来说不是指向提交，⽽是指向master，master才是指向提交的，所以，HEAD指向的就是当前分⽀。</p><p>⼀开始的时候，master分⽀是⼀条线，Git⽤master指向最新的提交，再⽤HEAD指向 master，就能确定当前分⽀，以及当前分⽀的提交点：</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190920164414.png" width="50%"></p><p>每次提交，master分⽀都会向前移动⼀步，这样，随着你不断提交，master分⽀的线也越 来越⻓长。</p><p>当我们创建新的分⽀，例如dev时，Git新建了⼀个指针叫dev，指向master相同的提交， 再把HEAD指向dev，就表⽰当前分⽀在dev上：</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190920190313.png" width="50%"></p><p>创建分支 <code>git checkout -b dev</code>创建dev分支，并切换到dev分支。</p><p>git checkout命令加上-b参数表⽰创建并切换，相当于以下两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>git branch 查看所有分支</p><p>现在，我们把dev分⽀的⼯作成果合并到master分⽀上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p>git merge命令⽤于合并指定分⽀到当前分⽀。</p><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190920194120.png" width="50%"></p><p>这种情况下不能快速合并分支（直接改变master的位置）,git 会进行试图合并。合并完成下面的样子</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190920194225.png" width="50%"></p><h4 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h4><p>Git还提供了⼀个stash功能，可以把当前⼯作现场“储藏”起来，等以后恢复现场后继续⼯作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: 6224937 add merge HEAD is now at 6224937 add merge</span><br></pre></td></tr></table></figure><p>现在，⽤git status查看⼯作区，就是干净的（除⾮有没有被Git管理的⽂件），因此可以放⼼地创建分⽀来修复bug。</p><p>修复完bug后，返回之前的分支，可以看到工作区是干净的，用<code>git stash list</code>查看工作现场。</p><p>⼯作现场还在，Git把stash内容存在某个地⽅了，但是需要恢复⼀下，有两个办法： ⼀是⽤<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要⽤git stash drop来删 除； 另⼀种⽅式是⽤<code>git stash pop</code>，恢复的同时把stash内容也删了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 分区与压缩算法</title>
      <link href="/2019/10/02/kafka%20%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/10/02/kafka%20%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="kafka-分区与压缩算法（二）"><a href="#kafka-分区与压缩算法（二）" class="headerlink" title="kafka 分区与压缩算法（二）"></a>kafka 分区与压缩算法（二）</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>使用kafka生产和消费消息的时候，肯定希望能够将数据均匀的分配到所有服务器上，如何将大数据量的数据分配到kafka的各个broker上，是一个重要的问题。</p><p>kafka有主题的概念，在主题下还有若干个分区。也就是说 Kafka 的消息组织方式实际上是三级结构：主题 - 分区 - 消息。主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190926194306.png" alt=""></p><p>分区的作用就是提供负载均衡的能力，不同的分区能够被放置到不同节点的机器上。而数据的读写操作也都是针对分区这个粒度而进行的， 这样每个节点的机器都能独立地执行各自分区的读写请求处理。</p><h4 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h4><p>所谓分区策略是决 定生产者将消息发送到哪个分区的算法。所谓分区策略是决 定生产者将消息发送到哪个分区的算法。Kafka 为我们提供 了默认的分区策略，同时它也支持自定义分区策略。</p><p>如果要自定义分区策略，你需要显式地配置生产者端的参数 partitioner.class。</p><h5 id="轮询策略"><a href="#轮询策略" class="headerlink" title="轮询策略"></a>轮询策略</h5><p>也称 Round-robin 策略，即顺序分配。比如一个主题下有 3 个分区，那么第一条消息被发送到分区 0，第二条被发送 到分区 1，第三条被发送到分区 2，以此类推。当生产第 4 条消息时又会重新开始，即将其分配到分区 0。<strong>轮询策略是 Kafka Java 生产者 API 默认提供的分区策略。</strong></p><h5 id="随机策略"><a href="#随机策略" class="headerlink" title="随机策略"></a>随机策略</h5><p>也称 Randomness 策略。所谓随机就是我们随意地将消息 放置到任意一个分区上。</p><h5 id="按消息键保序策略"><a href="#按消息键保序策略" class="headerlink" title="按消息键保序策略"></a>按消息键保序策略</h5><p>Kafka 允许为每条消息定义消息键，简称为 Key。这个 Key 的作用非常大，它可以是一个有着明确业务含义的字符串， 比如客户代码、部门编号或是业务ID 等；也可以用来表征 消息元数据。特别是在 Kafka 不支持时间戳的年代，在一些场景中，工程师们都是直接将消息创建时间封装进 Key 里面的。<strong>一旦消息被定义了 Key，那么你就可以保证同一个 Key 的所有消息都进入到相同的分区里面，由于每个分区下 的消息处理都是有顺序的，故这个策略被称为按消息键保序策略。</strong></p><hr><p>前面提到的 Kafka 默认分区策略实际上同时实现了两种策 略：如果指定了 Key，那么默认实现按消息键保序策略；如 果没有指定 Key，则使用轮询策略。</p><hr><h3 id="生产者压缩算法"><a href="#生产者压缩算法" class="headerlink" title="生产者压缩算法"></a>生产者压缩算法</h3><h5 id="压缩时机"><a href="#压缩时机" class="headerlink" title="压缩时机"></a>压缩时机</h5><p>kafka中的消息是可以压缩的，目前Kafka 共有两大类消息格式，社区分别称之为 V1 版本和 V2 版本。V2 版本是 Kafka 0.11.0.0 中正式引入的。</p><p>不论是哪个版本，Kafka 的消息层次都分为两层：消息集合（message set）以及消息 （message）。一个消息集合中包含若干条日志项（record item），而日志项才是真正封装消息的地方。Kafka 底层的消息日志由一系列消息集合日志项组成。Kafka 通常不会直接操作具体的一条条消息，它总是在消息集合这个层面上进行写入操作。</p><p>在 Kafka 中，压缩可能发生在两个地方：生产者端和 Broker 端。</p><p>生产者程序中配置 compression.type 参数即表示启用指定类型的压缩算法。</p><p>其实 大部分情况下 Broker 从 Producer 端接收到消息后仅仅是原封不动地保存而不会对其进行 任何修改，但这里的“大部分情况”也是要满足一定条件的。有两种例外情况就可能让 Broker 重新压缩消息。</p><ul><li>情况一：Broker 端指定了和 Producer 端不同的压缩算法。</li><li>Broker 端发生了消息格式转换。（所谓的消息格式转换主要是为了兼容老版本的消费者程序。还记得之前说过的 V1、V2 版 本吧？在一个生产环境中，Kafka 集群中同时保存多种版本的消息格式非常常见。为了兼容 老版本的格式，Broker 端会对新版本消息执行向老版本格式的转换。这个过程中会涉及消 息的解压缩和重新压缩。）</li></ul><p>通常来说解压缩发生在消费者程序中，也就是Producer发送压缩消息到broker后，broker原样保存起来，当 Consumer 程序请求这部分消息 时，Broker 依然原样发送出去，当消息到达 Consumer 端后，由 Consumer 自行解压缩 还原成之前的消息。Kafka 会将启用了哪种压缩算法封装进消息集合中，这样当 Consumer 读取 到消息集合时，它自然就知道了这些消息使用的是哪种压缩算法。如果用一句话总结一下压 缩和解压缩，<strong>Producer 端压缩、Broker 端保持、Consumer 端解压缩。</strong></p><h5 id="压缩算法"><a href="#压缩算法" class="headerlink" title="压缩算法"></a>压缩算法</h5><p>Kafka 支持 3 种压缩算法：GZIP、Snappy 和 LZ4。从 2.1.0 开 始，Kafka 正式支持 Zstandard 算法（简写为 zstd）。它是 Facebook 开源的一个压缩算法，能够提供超高的压缩比（compression ratio）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看一个压缩算法的优劣，有两个重要的指标：一个指标是压缩比，原先占 100 份空 间的东西经压缩之后变成了占 20 份空间，那么压缩比就是 5，显然压缩比越高越好；另一 个指标就是压缩 / 解压缩吞吐量，比如每秒能压缩或解压缩多少 MB 的数据。同样地，吞 吐量也是越高越好。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 术语与重要配置</title>
      <link href="/2019/10/01/kafka%20%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/10/01/kafka%20%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="kafka-（一）术语与重要配置"><a href="#kafka-（一）术语与重要配置" class="headerlink" title="kafka （一）术语与重要配置"></a>kafka （一）术语与重要配置</h2><p>切记：聪明人要下死功夫！</p><p>Apache Kafka 是一款开 源的消息引擎系统。</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>在 Kafka 中，发布订阅的对象是主题（Topic），你可以为每 个业务、每个应用甚至是每类数据都创建专属的主题。</p><p>向主题发布消息的客户端应用程序称为生产者（Producer），生产者程序通常持续不断地 向一个或多个主题发送消息，</p><p>而订阅这些主题消息的客户端应用程序就被称为消费者 （Consumer）。和生产者类似，消费者也能够同时订阅多个主题的消息。</p><p>我们把生产者和 消费者统称为客户端（Clients）。可以同时运行多个生产者和消费者实例，这些实例会不断地向 Kafka 集群中的多个主题生产和消费消息。</p><p>有客户端自然也就有服务器端。Kafka 的服务器端由被称为 Broker 的服务进程构成，即一 个 Kafka 集群由多个 Broker 组成，Broker 负责接收和处理客户端发送过来的请求，以及 对消息进行持久化。虽然多个 Broker 进程能够运行在同一台机器上，但更常见的做法是将 不同的 Broker 分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在它上面 运行的所有 Broker 进程都挂掉了，其他机器上的 Broker 也依然能够对外提供服务。这其 实就是 Kafka 提供高可用的手段之一。</p><p>实现高可用的另一个手段就是备份机制（Replication）。备份的思想很简单，就是把相同的数据拷贝到多台机器上，而这些相同的数据拷贝在 Kafka 中被称为副本（Replica）。副本的数量是可以配置的，这些副本保存 着相同的数据，但却有不同的角色和作用。Kafka 定义了两类副本：领导者副本（Leader Replica）和追随者副本（Follower Replica）。前者对外提供服务，这里的对外指的是与 客户端程序进行交互；而后者只是被动地追随领导者副本而已，不能与外界进行交互。</p><p>副本的工作机制也很简单：生产者总是向领导者副本写消息；而消费者总是从领导者副本读 消息。<em>至于追随者副本，它只做一件事：向领导者副本发送请求，请求领导者把最新生产的 消息发给它，这样它能保持与领导者的同步。</em></p><p>kafaka的伸缩性问题 主要采用分区的方法。Kafka 中的分区机制指的是将每个主题划分成多个分区（Partition），每个分区是一组有序的消息日志。<strong>生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分 区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。</strong>Kafka 的分区编号是从 0 开始的，如果 Topic 有 100 个分区，那么它们的分区号就是从 0 到 99。</p><p>副本和分区的联系：副本是在分区这个层级定义的。每个分区下可以配置若干个副本，其中只能有 1 个领 导者副本和 N-1 个追随者副本。生产者向分区写入消息，<strong>每条消息在分区中的位置信息由 一个叫位移（Offset）的数据来表征</strong>。分区位移总是从 0 开始，假设一个生产者向一个空 分区写入了 10 条消息，那么这 10 条消息的位移依次是 0、1、2、…、9。</p><hr><p>总结： Kafka 的三层消息架构：</p><p>第一层是主题层，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本。</p><p>第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务； 其他 N-1 个副本是追随者副本，只是提供数据冗余之用。</p><p>第三层是消息层，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。</p><p>最后，客户端程序只能与分区的领导者副本进行交互。</p><hr><p>Kafka 使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。因为只能追加写入，故避免了缓慢的随机 I/O 操作，改为性能较好的顺序 I/O 写操作，这也是实现 Kafka 高吞吐量特性的一个重要手段。</p><p>不过如果你不停地向一个 日志写入消息，最终也会耗尽所有的磁盘空间，因此 Kafka 必然要定期地删除消息以回收 磁盘。简单来说就是通过日志段（Log Segment）机制来进行删除。在 Kafka 底层，一 个日志又近一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来。Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</p><p>kafka中引入了消费者组的概念，所谓的消费者组，指的是多个消费者实例共同组成一个组来 消费一组主题。<strong>这组主题中的每个分区都只会被组内的一个消费者实例消费</strong>，其他消费者实 例不能消费它。为什么要引入消费者组呢？主要是为了提升消费者端的吞吐量。多个消费者 实例同时消费，加速整个消费端的吞吐量（TPS）。另外这里的消费者实例可以是运行消 费者应用的进程，也可以是一个线程，它们都称为一个消费者实例（Consumer Instance）。</p><p><strong>消费者组里面的所有消费者实例不仅“瓜分”订阅主题的数据，而且它们还能彼此协助。</strong>假设组内某个实例挂掉了，Kafka 能够自动检测到，然后把这个 Failed 实例之前负 责的分区转移给其他活着的消费者。这个过程就是 Kafka 中大名鼎鼎的“重平 衡”（Rebalance）。</p><p>每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上， 这个字段就是消费者位移（Consumer Offset）。注意，<strong>这和上面所说的位移完全不是一 个概念。上面的“位移”表征的是分区内的消息位置，它是不变的，即一旦消息被成功写入 到一个分区上，它的位移值就是固定的了</strong>。而消费者位移则不同，它可能是随时变化的，毕 竟它是消费者消费进度的指示器嘛。另外每个消费者有着自己的消费者位移，因此一定要区 分这两类位移的区别。通常把消息在分区中的位移称为分区位移，而把消费者端的位移称 为消费者位移。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190926171941.png" alt=""></p><h3 id="重要配置"><a href="#重要配置" class="headerlink" title="重要配置"></a>重要配置</h3><h4 id="Broker端参数"><a href="#Broker端参数" class="headerlink" title="Broker端参数"></a>Broker端参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.dirs：非常重要的参数，指定了Broker需要使用的若干个文件目录路径。没有默认值。</span><br><span class="line">log.dir：结尾没有 s，说明它只能表示单个路径，它是补充上一个参数用的。</span><br><span class="line">其实log.dir只需要设置第一个参数就好了，不要设置log.dir。更重要的是，在线上生产环境中一定要为log.dirs配置多个路径，具体格式是一个 CSV 格式，也就是用逗号分隔 的多个路径，比 如/home/kafka1,/home/kafka2,/home/kafka3这样。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zookeeper相关配置</span><br><span class="line">zk负责协调管理并保存 Kafka 集群的所有元数据信息，比如集群都有哪些 Broker 在运行、创建了哪些 Topic，每个 Topic 都有多少分区以及这些分区的 Leader 副本都在哪些机器上等信息。</span><br><span class="line">最重要的参数当属 zookeeper.connect。这也是一个 CSV 格式的参数，比 如我可以指定它的值为 zk1:2181,zk2:2181,zk3:2181。2181 是 ZooKeeper 的默认端口。如果你有两套 Kafka 集群，假设分别叫它们 kafka1 和 kafka2，那么两套集群的zookeeper.connect参数可以 这样指定：zk1:2181,zk2:2181,zk3:2181/kafka1和 zk1:2181,zk2:2181,zk3:2181/kafka2。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">与Broker连接相关的，即客户端或其他broker 如何与该broker进行通信的设置。</span><br><span class="line">listeners：学名叫监听器，其实就是告诉外部连接者要通过什么协议访问指定主机名和端口开放的Kafka服务。</span><br><span class="line">advertised.listeners：和 listeners 相比多了个 advertised。Advertised 的含义表示宣称的、公布的， 就是说这组监听器是 Broker 用于对外发布的。</span><br><span class="line">host.name/port：都是过期的参数。</span><br><span class="line">[Broker端和Client端应用配置中全部填写主机名]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">topic管理类</span><br><span class="line">auto.create.topics.enable：是否允许自动创建 Topic。最好设置false</span><br><span class="line">unclean.leader.election.enable：是否允许 Unclean Leader 选举。</span><br><span class="line">auto.leader.rebalance.enable：是否允许定期进行 Leader 选举。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据留存方面</span><br><span class="line">log.retention.&#123;hour|minutes|ms&#125;：这三个”，都是控制一条消息数据被保存多长时间。从优先 级上来说 ms 设置最高、minutes 次之、hour 最低。</span><br><span class="line">log.retention.bytes：这是指定 Broker 为消息保存的总磁盘容量大小。</span><br><span class="line">message.max.bytes：控制 Broker 能够接收的最大消息大小。</span><br></pre></td></tr></table></figure><h4 id="Topic级别参数"><a href="#Topic级别参数" class="headerlink" title="Topic级别参数"></a>Topic级别参数</h4><p>Topic 级别参数会覆盖全局 Broker 参数的值，而每个 Topic 都能设置自己的参数值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retention.ms 规定了该Topic消息被保存的时长，默认7天，即该 Topic 只保存最近 7 天的消息。一旦 设置了这个值，它会覆盖掉 Broker 端的全局参数值。</span><br><span class="line">retention.bytes：规定了要为该 Topic 预留多大的磁 盘空间。和全局参数作用相似，这个值通常在多租户的 Kafka 集群中会有用。当前默认值是 -1，表示可以 无限使用磁盘空间。</span><br><span class="line">max.message.bytes。它决定了 Kafka Broker 能够正常 接收该 Topic 的最大消息大小</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql解密六 数据库表的空间回收</title>
      <link href="/2019/10/01/mysql%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/"/>
      <url>/2019/10/01/mysql%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库表的空间回收"><a href="#数据库表的空间回收" class="headerlink" title="数据库表的空间回收"></a>数据库表的空间回收</h2><p>一个 InnoDB 表包 含两部分，即：表结构定义和数据。在 MySQL 8.0 版本以前，表结构是存在以.frm 为后缀 的文件里。而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很小，所以主要讨论的是表数据。</p><h4 id="参数innodb-file-per-table"><a href="#参数innodb-file-per-table" class="headerlink" title="参数innodb_file_per_table"></a>参数innodb_file_per_table</h4><p>表数据既可以存在共享表空间里，也可以是单独的文件，这个行为是由参数innodb_file_per_table 控制的，OFF表示表的数据放在系统共享表空间，也就是跟数据字典放在一起，ON表示每个InnoDB表数据存储在一个以<code>.ibd</code>为后缀的文件中。从5.6.6版本后，默认值为ON。建议你不论使用 MySQL 的哪个版本，都将这个值设置为 ON。因为，一个表单独存储为 一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直 接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><p><strong>所以，将 innodb_file_per_table 设置为 ON，是推荐做法，接下来的讨论都是基于 这个设置展开的。</strong></p><h4 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h4><p>先再来看一下 InnoDB 中一个索引的示意图。InnoDB 里的数据都是用 B+ 树的结构组织的。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191009194048.png" width="50%"></p><p>假设要删除R4这个记录，InnoDB引擎只会把R4这个记录标记为删除，如果之后再插入一个ID为300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p><p>如果删掉了一个数据页上的所有记录，那么整个数据页都可以复用，但是，<strong>数据页的复用跟记录的复用是不同的，</strong> 记录的复用，只限于符合范围条件的数据，而整个页从B+树上删除以后，可以复用到任何位置。</p><p>如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另 外一个数据页就被标记为可复用。</p><p>进一步地，如果我们用 delete 命令把整个表的数据删除呢？结果就是，所有的数据页都会 被标记为可复用。但是磁盘上，文件不会变小。</p><p>你现在知道了，delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，<strong>通过 delete 命令是不能回收表空间的。这些可以 复用，而没有被使用的空间，看起来就像是“空洞”。</strong></p><p><strong>实际上，不止是删除数据会造成空洞，插入数据也会。</strong></p><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可 能造成索引的数据页分裂。</p><p>例如上图中PageA已经满了，这时要再插入一行数据，会咋样</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191009195123.png" width="50%"></p><p>可以看到，由于 page A 满了，再插入一个 ID 是 550 的数据时，就不得不再申请一个新的 页面 page B 来保存数据了。页分裂完成后，page A 的末尾就留下了空洞（注意：实际 上，可能不止 1 个记录的位置是空洞）。另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是 会造成空洞的。</p><p>也就是说，经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去 掉，就能达到收缩表空间的目的。<strong>而重建表，就可以达到这样的目的。</strong></p><h4 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h4><p>如果有一个表A，需要做空间压缩，为了把表中的空洞去掉，怎么做。可以新建一个与A结构相同的表B，然后按照主键ID递增的顺序，把数据一行一行的从A里读出来再插入到B中。</p><p>这里，你可以使用 <code>alter table A engine=InnoDB</code> 命令来重建表。在 MySQL 5.5 版本之 前，这个命令的执行流程跟我们前面描述的差不多，区别只是这个临时表 B 不需要你自己 创建，MySQL 会自动完成转存数据、交换表名、删除旧表的操作。</p><p><strong>花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表 A 的话，就会造成数据丢失。因此，在整个 DDL 过程中，表 A 中不能有更新。也 就是说，这个 DDL 不是 Online 的。</strong></p><p>而在MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。</p><p>下面简单描述引入了Online DDL之后，重建表的流程。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191009200257.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 建立一个临时文件，扫描表 A 主键的所有数据页；</span><br><span class="line">2. 用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</span><br><span class="line">3. 生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应 的是图中 state2 的状态；</span><br><span class="line">4. 临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相 同的数据文件，对应的就是图中 state3 的状态；</span><br><span class="line">5. 用临时文件替换表 A 的数据文件。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql解密五 抖动</title>
      <link href="/2019/09/30/mysql%20%20%E4%BA%94%E6%8A%96%E5%8A%A8/"/>
      <url>/2019/09/30/mysql%20%20%E4%BA%94%E6%8A%96%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql-抖动"><a href="#mysql-抖动" class="headerlink" title="mysql 抖动"></a>mysql 抖动</h2><h4 id="sql-为什么变慢了"><a href="#sql-为什么变慢了" class="headerlink" title="sql 为什么变慢了"></a>sql 为什么变慢了</h4><p>InnoDB 在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作 redo log（重做日志），也就是《孔乙己》里咸亨酒店掌柜用来记账的粉板，<strong>在更新内存写完 redo log 后，就返回给客户端，本次更新成功。</strong></p><p>做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记忆就是内存。</p><p><strong>掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是 flush。</strong>在这个 flush 操作执行之前，孔乙己的赊账总额，其实跟掌柜手中账本里面的记录 是不一致的。因为孔乙己今天的赊账金额还只在粉板上，而账本里的记录是老的，还没把今天的赊账算进去。<strong>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写 入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</strong>不论是脏页还是干净页，都在内存中。在这个例子里，内存对应的就是掌柜的记忆。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191008204414.png" width="60%"></p><p><strong>平时执行很快的更新操作，其实就是在写内存和日志， 而 MySQL 偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。</strong></p><p>什么情况会引入刷脏页呢？</p><p>第一种场景 是就是 InnoDB 的 redo log 写满了。这时候系统会停止所有更新操作， 把 checkpoint 往前推进，redo log 留出空间可以继续写。</p><p>第二种场景就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘 汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到 磁盘。</p><p>第三种场景是MySQL 认为系统“空闲”的时候。当然，MySQL“这家酒 店”的生意好起来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使 是“生意好”的时候，也要见缝插针地找时间，只要有机会就刷一点“脏页”。</p><p>第四种情况就是 MySQL 正常关闭的情况。这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度 会很快。</p><p>下面主要讨论第一种 第二种的性能问题</p><p>第一种是redo log 写满了，要flush脏页，这种情况是 InnoDB 要尽量避免的。因为 出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监 控上看，这时候更新数会跌为 0。</p><p>第二种是内存不够用了，要先将脏页写到磁盘，InnoDB用缓冲池来管理内存，缓冲池中的内存页有三种状态：</p><ul><li>第一种是，还没有使用的；</li><li>第二种是，使用了并且是干净页；</li><li>第三种是，使用了并且是脏页。</li></ul><p>InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很 少。</p><p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把 最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用； 但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p><p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p><ol><li><p>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</p></li><li><p>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql解密四 Count 的实现</title>
      <link href="/2019/09/29/mysql%20Count()%20--14/"/>
      <url>/2019/09/29/mysql%20Count()%20--14/</url>
      
        <content type="html"><![CDATA[<h3 id="Count-–14"><a href="#Count-–14" class="headerlink" title="Count(*) –14"></a>Count(*) –14</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>在不同的 MySQL 引擎中，count(*) 有不同的实现方式。</p><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。（没有过滤条件的情况下）</p><p>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面 读出来，然后累积计数。</p><p>InnoDB不跟Myisam一样把数字存起来的原因是因为多版本并发控制MVCC的原因,InnoDB表应该返回多少行的原因也是不确定的。</p><h4 id="InnoDB做的优化"><a href="#InnoDB做的优化" class="headerlink" title="InnoDB做的优化"></a>InnoDB做的优化</h4><p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节 点是主键值。所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪 个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍 历。<strong>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之 一。</strong></p><p>总结来说 <strong>MyISAM 表虽然 count(<em>) 很快，但是不支持事务；show table status 命令虽然返回很快，但是不准确；InnoDB 表直接 count(</em>) 会遍历全表，虽然结果准确，但会导致性能问题。</strong></p><h4 id="自己计数-用缓存系统保存计数"><a href="#自己计数-用缓存系统保存计数" class="headerlink" title="自己计数-用缓存系统保存计数"></a>自己计数-用缓存系统保存计数</h4><p>对于更新频繁的库，可以用缓存系统来支持。</p><p>用一个 Redis 服务来保存这个表的总行数。这个表每被插入一行 Redis 计数就加 1，每被删除一行 Redis 计数就减 1。这种方式下，读和更新操作都很快，但是可能会发生数据丢失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Redis 的数据不能永久地留在内存里，所以你会找一个地方把这个值定期地持久化存储起 来。但即使这样，仍然可能丢失更新。试想如果刚刚在数据表中插入了一行，Redis 中保存 的值也加了 1，然后 Redis 异常重启了，重启后你要从存储 redis 数据的地方把这个值读回 来，而刚刚加 1 的这个计数操作却丢失了。</span><br><span class="line">-----------------------------------------</span><br><span class="line">当然了，这还是有解的。比如，Redis 异常重启以后，到数据库里面单独执行一次 count(*) 获取真实的行数，再把这个值写回到 Redis 里就可以了。异常重启毕竟不是经常 出现的情况，这一次全表扫描的成本，还是可以接受的。</span><br></pre></td></tr></table></figure><p>实际上，将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常 工作，这个值还是逻辑上不精确的。</p><p>想象一个页面，要显示操作记录的总数，同时还要显示最近操作的100条记录，那么这个页面的逻辑就是先到redis中取出计数，再到数据表里面取数据记录。</p><p>下面两种情况，逻辑都是不一致的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 一种是，查到的 100 行结果里面有最新插入记录，而 Redis 的计数里还没加 1；</span><br><span class="line">2. 另一种是，查到的 100 行结果里没有最新插入的记录，而 Redis 的计数里已经加了1。</span><br></pre></td></tr></table></figure><h4 id="在数据库中保存计数"><a href="#在数据库中保存计数" class="headerlink" title="在数据库中保存计数"></a>在数据库中保存计数</h4><p>如果我们把 这个计数直接放到数据库里单独的一张计数表 C 中，会怎么样？</p><p>首先这解决了奔溃丢失的问题，InnoDB是支持崩溃恢复不丢数据的。</p><p>同时，利用事务的特性，获得逻辑上一致的结果</p><h4 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h4><p>count()是一个聚合函数，对于返回的结果集，一行行的判断，如果count的参数不是null,那么累加值就加1，否则不加，最后返回累计值。</p><p>所以，<code>count(*)</code>、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p><p>对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回 给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p><p>对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行， 放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p><strong>单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因 为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</strong></p><p>对于count(字段)来说：</p><ol><li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不 能为 null，按行累加； </li><li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值 取出来再判断一下，不是 null 才累加。</li></ol><p>也就是前面的第一条原则，server 层要什么字段，InnoDB 就返回什么字段。</p><p>但是<code>count(*)</code> 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p><p>所以结论是：按照效率排序的话，<code>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)，</code>所 以我建议你，尽量使用<code>count(*)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql解密三 索引</title>
      <link href="/2019/09/27/mysql%20%E8%A7%A3%E5%AF%86%E4%B8%89%20%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/09/27/mysql%20%E8%A7%A3%E5%AF%86%E4%B8%89%20%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。</p><h4 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h4><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索 引模型的概念。可以用于提高读写效率的数据结构很多，三种常见、也比 较简单的数据结构，分别是哈希表、有序数组和搜索树。</p><p>假设现在维护着一个身份证和姓名的表，需要根据身份证号查询对应的名字，对应的哈希索引如图。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190926203051.png" width="50%"></p><p>由于哈希表的结构数据不是连续的，所以哈希表适用于只有等值查询的场景。</p><p>有序数组在等值查询和范围查询场景中的性能十分优秀。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190926203151.png" width="50%"></p><p>这里假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如 果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到。如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p><p><strong>所以，有序数组索引只适用于静态存储引擎。</strong></p><p>用二叉搜索树实现，如图所示。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190926203832.png" width="70%"></p><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要 查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。</p><p><strong>二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。 其原因是，索引不止存在内存中，还要写到磁盘上。（因为内存放不下）</strong>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不 应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的 大小。<strong>树根的数据块是肯定在内存中的，树的第二层很大概率也在内存中，那么从第三次层开始的数据块都是在磁盘中，获取里面的数据都要把所在的数据块先加载到内存中，这样的开销极大，所以树一般都为矮胖型</strong>。</p><h4 id="InnoDB的索引模型※※※"><a href="#InnoDB的索引模型※※※" class="headerlink" title="InnoDB的索引模型※※※"></a>InnoDB的索引模型※※※</h4><p>在 InnoDB 中，<strong>表都是根据主键顺序以索引的形式存放的，</strong>这种存储方式的表称为索引组织表。又因为前面我们提到的，<strong>InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</strong></p><p>每一个索引在InnoDB里面都对应一颗B+树。</p><p>假设 有一个主键列为ID的表，表中有字段k,并且在k上有索引，建表语句就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T( </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, </span><br><span class="line">    k <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>, </span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    <span class="keyword">index</span> (k))<span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树 的示例示意图如下。（如果ID 和K的顺序是不对应的，那么右边的图中K的顺序仍然是12356，下面的100，200，300，500，600取与K对应的值即可）</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190926210624.png" alt=""></p><p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p><p><strong>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引 （clustered index）。</strong></p><p><strong>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引</strong></p><p>基于主键索引和普通索引的查询的区别在于</p><p>如果语句是 select <em> from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；如果语句是 select </em> from T where k=5，即普通索引查询方式，则需要先搜索 k 索引 树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</p><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使 用主键查询。</p><h4 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h4><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。</p><p>以上面的为例，如果插入的新的行ID值为700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一 个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会 受影响。</p><hr><p>根据上述说明，分析下哪些场景下应该使用自增主键，哪些不该。</p><p>自增主键是指自增列上定义的主键，一般定义为NOT NULL PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。<strong>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入 一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</strong>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。同时，从存储空间的角度看，主键的自增字段占用空间小，叶子节点也小。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">k <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">s <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line"><span class="keyword">index</span> k(k))</span><br><span class="line"><span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>, <span class="string">'aa'</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">'bb'</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">'cc'</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">'ee'</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">'ff'</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">'gg'</span>);</span><br></pre></td></tr></table></figure><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190926235950.png" alt=""></p><p>下面是select * from T where k between 3 and 5 这条语句的执行流程。</p><ul><li><p>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</p></li><li><p>再到 ID 索引树查到 ID=300 对应的 R3；</p></li><li><p>在 k 索引树取下一个值 k=5，取得 ID=500；</p></li><li><p>再回到 ID 索引树查到 ID=500 对应的 R4；</p></li><li><p>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</p></li></ul><p>在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。**</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值， <strong>而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在 这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</strong></p><p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p><h4 id="最左前缀原则（联合索引相关）"><a href="#最左前缀原则（联合索引相关）" class="headerlink" title="最左前缀原则（联合索引相关）"></a>最左前缀原则（联合索引相关）</h4><p>B+树这种索引结构，可以利用索引的最左前缀，来定位记录。以(name,age)这个联合索引来分析。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190927103647.png" alt=""></p><p>可以看到，索引项按照索引里定义里出现的字段顺序排序的。</p><p>当逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得 到所有需要的结果。可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个 最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><h3 id="普通索引还是唯一索引"><a href="#普通索引还是唯一索引" class="headerlink" title="普通索引还是唯一索引"></a>普通索引还是唯一索引</h3><p>仍然是上面的例子</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190926235950.png" alt=""></p><p>假设，执行查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的 过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据 页，然后可以认为数据页内部通过二分法来定位记录。</p><p><strong>对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直 到碰到第一个不满足 k=5 条件的记录。</strong></p><p><strong>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止 继续检索。</strong></p><p>InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时 候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。因为引擎是按页读写的，所以说，当找到 k=5 的记录的时候，它所在的数据页就都在内存 里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只 需要一次指针寻找和一次计算。</p><h4 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h4><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内 存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的 时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方 式就能保证这个数据逻辑的正确性。</p><p>需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说， change buffer 在内存中有拷贝，也会被写入到磁盘上。将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问 这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭 （shutdown）的过程中，也会执行 merge 操作。</p><p>显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到 明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占 用内存，提高内存利用率。</p><p><strong>唯一索引的更新不能使用change buffer ，普通索引才可以使用</strong>。这是因为对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插 入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据 页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p><p>现在来看一下 如果要往上面的例子中插入一个新纪录（4，400） 的话，InnoDB的处理流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一种情况是，这个记录要更新的目标页在内存中。这时，InnoDB 的处理流程如下：</span><br><span class="line">对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行 结束；</span><br><span class="line">对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。</span><br><span class="line"></span><br><span class="line">这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小 的 CPU 时间。</span><br><span class="line">但，这不是我们关注的重点。</span><br><span class="line"></span><br><span class="line">第二种情况是，这个记录要更新的目标页不在内存中。这时，InnoDB 的处理流程如下：</span><br><span class="line">对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结 束；</span><br><span class="line">对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</span><br><span class="line"></span><br><span class="line">将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</span><br></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>普通索引的所有场景，使用 change buffer 都可以起到加速作用吗？</p><p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录 的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多 （也就是这个页面上要更新的次数越多），收益就越大。</p><p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新 先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。 这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这 种业务模式来说，change buffer 反而起到了副作用。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>其实，这两类索引在查询能 力上是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。 而在其他情况下，change buffer 都能提升更新性能。</p><h3 id="mysql-选择索引"><a href="#mysql-选择索引" class="headerlink" title="mysql 选择索引"></a>mysql 选择索引</h3><p>MYSQL中一张表可以支持多个索引，使用哪个索引是由MYSQL来确定的。</p><p>选择索引是优化器的工作，而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数 据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的 次数越少，消耗的 CPU 资源越少。当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素 进行综合判断。</p><p><strong>扫描行数是如何判断的？</strong></p><p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只 能根据统计信息来估算记录数。</p><p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度 就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说， 这个基数越大，索引的区分度越好。</p><p>可以使用show index 方法，看到一个索引的基数。但是并不准确。MYSQL获得索引基数的方法是通过采样统计的方法。</p><p>采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个 平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。</p><p>对于由于索引统计信息不准确导致的问题，可以用 analyze table 来解决。</p><p>而对于其他优化器误判的情况，可以在应用端用 force index 来强行指定索引，也可以通过修改语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。</p><h3 id="给字符串加索引—-前缀索引"><a href="#给字符串加索引—-前缀索引" class="headerlink" title="给字符串加索引— 前缀索引"></a>给字符串加索引— 前缀索引</h3><p>假设给一个邮箱加索引，有两种方法，一种是对整个email加索引，另一种是对email的一部分加索引，在存储上，这两个索引如下所示。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191008201959.png" width="50%"></p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20191008202019.png" width="50%"></p><p>由于 email(6) 这个索引结构中每个邮箱字段都只取前 6 个字节（即： zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。但，这同时带来的损失是，可能会增加额外的记录扫描次数。</p><p>假如是下面的语句，<code>select id,name,email from SUser where email=&#39;zhangssxyz@xxx.com&#39;;</code></p><p>如果使用的是 index1（即 email 整个字符串的索引结构），执行顺序是这样的：</p><ol><li><p>从 index1 索引树找到满足索引值是<a href="mailto:`zhangssxyz@xxx.com" target="_blank" rel="noopener">`zhangssxyz@xxx.com</a>`的这条记录，取得 ID2 的值；</p></li><li><p>到主键上查到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集；</p></li><li><p>取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足 <a href="mailto:email=`zhangssxyz@xxx.com" target="_blank" rel="noopener">email=`zhangssxyz@xxx.com</a>`的条件了，循环结束。</p></li></ol><p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p><p>如果使用的是index2 （即 email(6) 索引结构），执行顺序是这样的：</p><ol><li><p>从 index2 索引树找到满足索引值是’zhangs’的记录，找到的第一个是 ID1；</p></li><li><p>到主键上查到主键值是 ID1 的行，判断出 email 的值不是<a href="mailto:`zhangssxyz@xxx.com" target="_blank" rel="noopener">`zhangssxyz@xxx.com</a>`， 这行记录丢弃；</p></li><li><p>取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集；</p></li><li><p>重复上一步，直到在 idxe2 上取到的值不是’zhangs’时，循环结束。</p></li></ol><p>在这个过程中，要回主键索引取 4 次数据，也就是扫描了 4 行。</p><h5 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h5><p>如果查询语句从 <code>select id,email from SUser where email=&#39;zhangssxyz@xxx.com&#39;;</code>换成<code>select id,name,email from SUser where email=&#39;zhangssxyz@xxx.com&#39;;</code>这个语句只要求返回id 和eamil .</p><p>所以，如果使用 index1（即 email 整个字符串的索引结构）的话，可以利用覆盖索引，从 index1 查到结果后直接就返回了，不需要回到 ID 索引再去查一次。而如果使用 index2（即 email(6) 索引结构）的话，就不得不回到 ID 索引再去判断 email 字段的值。<strong>也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql解密二 事务隔离</title>
      <link href="/2019/09/26/mysql%20%E8%A7%A3%E5%AF%86%E4%BA%8C%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
      <url>/2019/09/26/mysql%20%E8%A7%A3%E5%AF%86%E4%BA%8C%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql-解密二-事务隔离"><a href="#mysql-解密二-事务隔离" class="headerlink" title="mysql 解密二 事务隔离"></a>mysql 解密二 事务隔离</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不 是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读 （non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有 了“隔离级别”的概念。</p><p>隔离得越严实，效率就会越低。因此很多时候，我们 都要在二者之间寻找一个平衡点。</p><ul><li><p>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</p></li><li><p>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</p></li><li><p>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是 一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p></li><li><p>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出 现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p></li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。 在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行 化”隔离级别下直接用加锁的方式来避免并行访问。</p><p>下面展开说明可重复读。</p><p><strong>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</strong></p><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190926001224.png" alt=""></p><p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如 图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统 中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要 得到 1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、 C 对应的事务是不会冲突的。</p><p>回滚日志会在不需要的时候进行删除，也就是系统会判断，当没有事务需要用到这些回滚日志时，回滚日志会被删除。</p><h4 id="为什么不使用长事务"><a href="#为什么不使用长事务" class="headerlink" title="为什么不使用长事务"></a>为什么不使用长事务</h4><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任 何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导 致大量占用存储空间。</p><p>你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语 句，用于查找持续时间超过 60s 的事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190929194738.png" alt=""></p><p>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。如果想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。</p><p>MYSQL里，有两个视图的概念，一个是view, 是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。</p><p>另一个是InnoDB里实现MVCC时用到的一致性读视图，即consistent read view 用 于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</p><p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</p><h4 id="快照的工作原理"><a href="#快照的工作原理" class="headerlink" title="快照的工作原理"></a>快照的工作原理</h4><p>在可重复读隔离级别下，事务在启动的时候就拍了个快照，<strong>这个快照是基于整库的。</strong></p><p>这个快照的实现原理如下：</p><p>InnoDB里面每个事务都有一个唯一的事务ID,叫做transaction id ,它是在事务开始的时候向InnoDB的事务系统申请的，按照申请顺序严格递增。</p><p>每行数据同样有多个版本，每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id 赋值给这个<strong>数据版本的事务ID</strong>,记为 row trx_id 。同时，旧的数据也会保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p><p><strong>也就是说，数据表中的一行记录，其实可能有多个版本，每个版本都有自己的row trx_id</strong>,如下所示，就是一个记录被多个事务连续更新后的状态。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190929202906.png" alt=""></p><p>图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。（上面的三个虚线箭头，就是undo log,V1,V2,V3并不是物理上真实存在的而是每次需要时根据当前版本和undo log 计算出来的）</p><p>可重复读的定义中，一个事务启动，能够看见所有已经提交的事务结果，之后事务执行期间，其他事务的更新对它不可见。因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上 一个版本或者上上个版本直到找到为止”。</p><p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p><p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p><p>而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到 的。这个视图数组把所有的row trx_id 分成了几种不同的情况。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190929203747.png" alt=""></p><p>这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p><ol><li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数 据是可见的；</li><li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在黄色部分，那就包括两种情况</li></ol><p>a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</p><p>b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</p><p>////由于事务号是递增的，因此当前事务前的事务号的都是已经提交的，所以都是可见的。</p><p>因此，InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</p><p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可 见以外，有三种情况：</p><ol><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ol><p><strong>同时，更新数据都是先读后写的，而这个读，只能读当前的 值，称为“当前读”（current read）。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql解密一</title>
      <link href="/2019/09/26/mysql%20%E8%A7%A3%E5%AF%86%E4%B8%80/"/>
      <url>/2019/09/26/mysql%20%E8%A7%A3%E5%AF%86%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql解密"><a href="#Mysql解密" class="headerlink" title="Mysql解密"></a>Mysql解密</h2><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190925200718.png" alt=""></p><p>总体来说，MYSQL分为Server层和存储引擎层两部分。Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核 心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎 的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、 Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开 始成为了默认存储引擎。不同的存储引擎公用同一个Server层。</p><h5 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h5><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建 立连接、获取权限、维持和管理连接。<code>show processlist</code>命令可以看到连接状态。</p><h5 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h5><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执 行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的 语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询 缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p><strong>大多数情况不建议使用缓存，因为弊大于利</strong>。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。 因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大 的数据库来说，查询缓存的命中率会非常低。</p><h5 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h5><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句， MySQL 需要识别出里面的字符串分别是什么，代表什么。做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法 规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><h5 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h5><p>经过分析器，MYSQL知道客户端要干什么了，在开始执行前，还需要先经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联 （join）的时候，决定各个表的连接顺序。</p><h5 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h5><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返 回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这 个引擎提供的接口。</p><h3 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h3><p>更新流程涉及两个重要的日志模块，redo log重做日志 和binlog 归档日志</p><p>在 MySQL 里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决问题，MYSQL采用了粉板（暂存）加账本的方法来提升效率。<strong>也就是MySQL 里经常说到的 WAL 技术，WAL 的全称 是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</strong></p><p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候， 将这个操作记录更新到磁盘（账本）里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>如果粉板写满了，就只能把粉板中的一部分记录更新到账本中，然后把这些记录从粉板中擦掉，为新账腾出空间。<strong>与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件 的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就 又回到开头循环写，</strong></p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190925210708.png" alt=""></p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录 更新到数据文件。write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如 果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下 来先擦掉一些记录，把 checkpoint 推进一下。</p><p><strong>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢 失，这个能力称为crash-safe。</strong></p><ul><li><p>redo log 是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog。两种日志有以下三种不同之处。</p></li><li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都 可以使用。</p></li><li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日 志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ul><p>一个update的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘 读入内存，然后再返回。</span><br><span class="line"></span><br><span class="line">2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新 的一行数据，再调用引擎接口写入这行新数据。</span><br><span class="line"></span><br><span class="line">3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</span><br><span class="line"></span><br><span class="line">4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</span><br><span class="line"></span><br><span class="line">5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状 态，更新完成。</span><br></pre></td></tr></table></figure><p><strong>将 redo log 的写入拆成了两个步骤： prepare 和 commit，这就是”两阶段提交”。</strong></p><p>binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你 的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 新特性总结</title>
      <link href="/2019/09/09/java8%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/09/java8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><p>java8的最大变化就是引入了lambda表达式，一个紧凑的传递行为的方式。</p><p>最简单的Lambda表达式可以用逗号分隔的参数列表<code>-&gt;</code>符号和功能语句块来表示。<code>-&gt;</code>前面的是参数，<code>-&gt;</code>后面的处理的流程。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( e -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure><p>注意到编译器会根据上下文来推测参数的类型，或者也可以显示地指定参数类型，只需要将类型包在括号里。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( ( String e ) -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure><p>如果Lambda的功能语句块太复杂，我们可以用大括号包起来，跟普通的Java方法一样，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach(</span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure><p>Lambda表达式可能会引用类的成员或者局部变量（会被隐式地转变成final类型），下面两种写法的效果是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach(</span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach(</span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure><p>Lambda表达式可能会有返回值，编译器会根据上下文推断返回值的类型。如果lambda的语句块只有一行，不需要return关键字。下面两个写法是等价的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</span><br><span class="line"></span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> result = e1.compareTo( e2 );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>为了让现有功能和lambda 表达式友好兼容，有了函数接口的概念，<strong>函数接口是一种只有一个方法的接口</strong>。函数接口可以隐式的转换成lambda表达式。</p><p>如下定义了一个函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就可以使用Lambda表达式来表示该接口的一个实现.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GreetingService greetService1 = message -&gt; System.out.println(<span class="string">"Hello "</span> + message);</span><br></pre></td></tr></table></figure><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用提供了一个很有用的语义来<strong>直接访问类或者实例的已经存在的方法或者构造方法</strong>。结合Lambda表达式，方法引用使语法结构紧凑简明。不需要复杂的引用。</p><p>下面以Car 类做示例说明支持的4种方法引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">create</span><span class="params">( <span class="keyword">final</span> Supplier&lt; Car &gt; supplier )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;              </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">( <span class="keyword">final</span> Car car )</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Collided "</span> + car.toString() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">( <span class="keyword">final</span> Car another )</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Following the "</span> + another.toString() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Repaired "</span> + <span class="keyword">this</span>.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种方法引用是构造方法引用，语法是：<code>Class::new</code> ，</p><p>对于泛型来说语法是：<code>Class&lt;T &gt;::new</code>，注意构造方法没有参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Car car = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line"><span class="keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );</span><br></pre></td></tr></table></figure><p>第二种方法引用是静态方法引用，语法是：<code>Class::static_method</code>注意这个静态方法只支持一个类型为Car的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure><p>第三种方法引用是类实例的方法引用，语法是：<code>Class::method</code>注意方法没有参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure><p>最后一种方法引用是引用特殊类的方法，语法是：<code>instance::method</code>，注意只接受Car类型的一个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Car police = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure><h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><p>Optional 是核心类库新设计的一个数据类型，用来替换null值。人们常用null值来表示值不存在，Optional对象可以更好的表达这个概念，使用null表示值最大的问题在于NullPointerException。一旦引用一个存储null值的变量，程序会立即崩溃。</p><p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。<strong>Optional 类的引入很好的解决空指针异常。</strong></p><p>使用工厂方法of,可以从某个值创建出一个Optional对象，Optional对象相当于值的容器，该值可以通过get方法提取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; a = Optional.of(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><p>Optional 对象也可能为空，因此还有一个对应的工厂方法empty（创建一个空值在Optional中）。另外一个工厂方法ofNullable则可以将一个空值转换为Optional对象。还有一个方法isPresent 表示一个Optional对象里是否有值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optinoal emptyOptional = Optional.empty();</span><br><span class="line">Optional alsoEmpty = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">Boolean b = a.isPresent();</span><br></pre></td></tr></table></figure><p><code>T orElse(T other)</code> 方法表示如果存在值，则返回值，否则返回other。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer value1 = a.orElse(new Integer(0));</span><br></pre></td></tr></table></figure><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>Stream API引入了函数式编程。Stream 是用函数式编程方式在集合类上进行复杂操作的工具。首先注意stream()方法的调用，返回了内部迭代中的相应接口：Stream。</p><p>例如要计算来自北京的艺术家人数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = allArtists.steeam().filter(artist-&gt;artist.isForm(<span class="string">"Beijing"</span>).count());</span><br></pre></td></tr></table></figure><p>上面分为两步，分别是1找出所有来自北京的艺术家2计算人数。每个操作都对应stream接口的一个方法。为了找出来自北京的，需要对stream对象进行过滤：使用了filter。count()方法计算给定Stream里包含多少个对象。</p><p>Stream里的一些方法虽然是普通的Java方法，但返回的Stream对象却不是一个新集合。而是创建新集合的配方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allArtists.stream().filter(artist-&gt;artist.isFrom(<span class="string">"Beijing"</span>) );<span class="comment">//只过滤不计数</span></span><br></pre></td></tr></table></figure><p>这行代码并没有做什么实际性的工作，filter只刻画了Stream,但是没有产生新的集合，像filter这样只描述Stream最终不产生新集合的方法叫做惰性求值方法，而像count这样最终会从Stream产生值的方法叫作及早求值方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">流的特点：</span><br><span class="line"> 元素序列——就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元</span><br><span class="line">素（如`ArrayList` 与 `LinkedList`）。但流的目的在于表达计算，比如 `filter`、`sorted`和`map`。集合讲的是数据，流讲的是计算。</span><br><span class="line"> 源——流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</span><br><span class="line"> 数据处理操作——流的数据处理功能支持类似于数据库的操作，如`filter`、`map`、`reduce`、`find`、`match`、`sort`等。流操作可以顺序执行，也可并行执行。</span><br><span class="line"> 流水线——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。流水线的操作可以看作对数据源进行数据库式查询。</span><br><span class="line"> 内部迭代——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</span><br><span class="line"></span><br><span class="line">流与集合的区别：</span><br><span class="line"> <span class="number">1</span>、集合是一个内存中的数据结构，它包含数据结构中目前所有的值—— 集合中的每个元素都得先算出来才能添加到集合中。</span><br><span class="line"> <span class="number">2</span>、流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line">流的操作：</span><br><span class="line"><span class="number">1</span>、中间操作：中间操作会返回另一个流，比如`filter、map、sort、distinct`等操作</span><br><span class="line"><span class="number">2</span>、终端操作： 终端操作会从流的流水线生成结果，比如`forEach、count、collect`</span><br><span class="line">--------------------------------------------</span><br></pre></td></tr></table></figure><p>在过滤器中加入一条print语句，来输出艺术家的名字，就能看出不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allArtiest.stream().filter(artiest-&gt;&#123;System.out.println(artiest.getName());&#125;) <span class="comment">// 由于使用了惰性求值，没有输出艺术家的名字。</span></span><br></pre></td></tr></table></figure><p>如果将同样的输出语句加入一个拥有终止操作的流，如一个计数操作，艺术家的名字就会被输出。</p><p>常用的流操作主要有：</p><p>collect(toList()) 方法由Stream里的值生成一个列表，是一个及早求值操作。</p><p>Stream的of方法使用一组初始值生成新的Stream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collected =Stream.of(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>上面是使用collect(toList())方法从Stream中生成一个列表。由于很多Stream操作都是惰性操作，因此调用Stream上一系列方法后，还需要最后再调用一个类似collect的及早求值方法。</p><p>map 函数可以将一种类型的值转换成另外一种新的类型。</p><p>filter用来遍历元素并检查其中的元素。</p><p>flatmap 可以用Stream替换值，然后将多个Stream连接成一个Stream.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guava-Cache</title>
      <link href="/2019/09/04/Guava-Cache/"/>
      <url>/2019/09/04/Guava-Cache/</url>
      
        <content type="html"><![CDATA[<h2 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava-Cache"></a>Guava-Cache</h2><p>缓存是日常开发中经常应用到的一种技术手段，合理的利用缓存可以极大的改善应用程序的性能。 缓存在各种各样的用例中非常有用。例如，当计算或检索值很昂贵时，您应该考虑使用缓存，并且不止一次需要它在某个输入上的值。 </p><h3 id="maven-依赖"><a href="#maven-依赖" class="headerlink" title="maven 依赖"></a>maven 依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>23.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Guava Cache与ConcurrentMap很相似，但也不完全一样。最基本的区别是ConcurrentMap会一直保存所有添加的元素，直到显式地移除。相对地，Guava Cache为了限制内存占用，通常都设定为自动回收元素。在某些场景下，尽管LoadingCache 不回收元素，它也是很有用的，因为它会自动加载缓存。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p> Guava Cache有两种缓存加载的方式：CacheLoader 和 Callable，这两种方式都是按照”获取缓存-如果没有-则计算”[get-if-absent-compute]的规则加载的。不同的是，CacheLoader是在创建Cache的时候，实现了一个统一的根据key获取value的方法，而Callable更加灵活，允许你在get的时候指定一个callable来获取value（<code>get(K, Callable)</code>）</p><ul><li>CacheLoader</li></ul><p>创建CacheLoader，只需要实现load方法，如下面代码示例。<strong>当我们调用get方法获取指定key的缓存值时，如果key的value值还没有缓存，Guava Cache则会自动调用load方法加载value值到缓存并返回</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()  </span><br><span class="line">            .maximumSize(<span class="number">1000</span>)</span><br><span class="line">            .build(</span><br><span class="line">                <span class="keyword">new</span> CacheLoader&lt;Key, Graph&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Graph <span class="title">load</span><span class="params">(Key key)</span> <span class="keyword">throws</span> AnyException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> createExpensiveGraph(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> graphs.get(key);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> OtherException(e.getCause());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从LoadingCache查询的正规方式是使用<code>get(K)</code>方法。这个方法要么返回已经缓存的值，要么使用CacheLoader向缓存原子地加载新值。由于CacheLoader可能抛出异常，LoadingCache.get(K)也声明为抛出ExecutionException异常。</p><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>所有类型的Guava Cache，不管有没有自动加载功能，都支持<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/Cache.html#get%28java.lang.Object,java.util.concurrent.Callable%29" target="_blank" rel="noopener">get(K, Callable)</a>方法。这个方法返回缓存中相应的值，或者用给定的Callable运算并把结果加入到缓存中。在整个加载方法完成前，缓存项相关的可观察状态都不会更改。这个方法简便地实现了模式”如果有缓存则返回；否则运算、缓存、然后返回”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder()  </span><br><span class="line">            .maximumSize(<span class="number">1000</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个key时，在Cache.get中单独为其指定load方法</span></span><br><span class="line">String resultVal = cache.get(<span class="string">"hello"</span>, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </span><br><span class="line">                        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            String strProValue=<span class="string">"hello world!"</span>;</span><br><span class="line">                            <span class="keyword">return</span> strProValue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure><h3 id="显式插入"><a href="#显式插入" class="headerlink" title="显式插入"></a>显式插入</h3><p>使用<code>cache.put(key, value)</code>方法可以直接向缓存中插入值，这会直接覆盖掉该key之前缓存的值。使用<code>Cache.asMap()</code>视图提供的任何方法也能相应的修改缓存。但是，asMap视图的任何方法都不能保证缓存项被原子地加载到缓存中。</p><h3 id="缓存回收"><a href="#缓存回收" class="headerlink" title="缓存回收"></a>缓存回收</h3><p>因为我们的数据是缓存在java堆内存上的，存储容量受到堆内存大小限制。当我们缓存的数据量很大时，会影响到GC，所以缓存必须要有回收策略。Guava Cache提供三种回收方式：</p><h4 id="基于容量回收"><a href="#基于容量回收" class="headerlink" title="基于容量回收"></a>基于容量回收</h4><p>通过<code>CacheBuilder.maximumSize(long)</code>设置缓存项的最大数目，当达到最大数目后，继续添加缓存项，Guava Cache会根据LRU策略回收缓存项来保证不超过最大数目。</p><p> 另外，可以通过<code>CacheBuilder.weigher(Weigher)</code>设置不同缓存项的权重，Guava Cache根据权重来回收缓存项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()  </span><br><span class="line">        .maximumWeight(<span class="number">100000</span>)</span><br><span class="line">        .weigher(<span class="keyword">new</span> Weigher&lt;Key, Graph&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">weigh</span><span class="params">(Key k, Graph g)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> g.vertices().size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .build(</span><br><span class="line">            <span class="keyword">new</span> CacheLoader&lt;Key, Graph&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Graph <span class="title">load</span><span class="params">(Key key)</span> </span>&#123; <span class="comment">// no checked exception</span></span><br><span class="line">                    <span class="keyword">return</span> createExpensiveGraph(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h4 id="定时回收"><a href="#定时回收" class="headerlink" title="定时回收"></a>定时回收</h4><p> CacheBuilder提供两种定时回收的方法：</p><p><code>expireAfterAccess(long, TimeUnit)</code>：缓存项在给定时间范围内没有读/写访问，那么下次访问时，会被回收，然后同步<code>load()</code>（一个线程去load，其他线程等待）。</p><p><code>expireAfterWrite(long, TimeUnit)</code>：缓存项在给定时间范围内没有写访问，那么下次访问时，会被回收，然后同步<code>load()</code>（一个线程去load，其他线程等待）。</p><blockquote><p>Guava Cache不会专门维护一个线程来回收这些过期的缓存项，只有在读/写访问时，才去判断该缓存项是否过期，如果过期，则会回收。</p></blockquote><h4 id="基于引用回收"><a href="#基于引用回收" class="headerlink" title="基于引用回收"></a>基于引用回收</h4><p>通过使用弱引用的键、或弱引用的值、或软引用的值，Guava Cache可以把缓存设置为允许垃圾回收：</p><ul><li><code>CacheBuilder.weakKeys()</code>：使用弱引用存储键。当键没有其它（强或软）引用时，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式（），使用弱引用键的缓存用而不是equals比较键。</li><li><code>CacheBuilder.weakValues()</code>：使用弱引用存储值。当值没有其它（强或软）引用时，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式（），使用弱引用值的缓存用而不是equals比较值。</li><li><code>CacheBuilder.softValues()</code>：使用软引用存储值。软引用只有在响应内存需要时，才按照全局最近最少使用的顺序回收。考虑到使用软引用的性能影响，我们通常建议使用更有性能预测性的缓存大小限定（见上文，基于容量回收）。使用软引用值的缓存同样用==而不是equals比较值。</li></ul><h3 id="显式清除"><a href="#显式清除" class="headerlink" title="显式清除"></a>显式清除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任何时候，你都可以显式地清除缓存项，而不是等到它被回收：</span><br></pre></td></tr></table></figure><ul><li>个别清除：<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/Cache.html#invalidate%28java.lang.Object%29" target="_blank" rel="noopener"><code>Cache.invalidate(key)</code></a></li><li>批量清除：<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/Cache.html#invalidateAll%28java.lang.Iterable%29" target="_blank" rel="noopener"><code>Cache.invalidateAll(keys)</code></a></li><li>清除所有缓存项：<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/Cache.html#invalidateAll%28%29" target="_blank" rel="noopener"><code>Cache.invalidateAll()</code></a></li></ul><h4 id="移除监听器"><a href="#移除监听器" class="headerlink" title="移除监听器"></a>移除监听器</h4><p>通过CacheBuilder.removalListener(RemovalListener)，你可以声明一个监听器，以便缓存项被移除时做一些额外操作。缓存项被移除时，RemovalListener会获取移除通知RemovalNotification其中包含移除原因RemovalCause键和值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CacheLoader&lt;Key, DatabaseConnection&gt; loader = <span class="keyword">new</span> CacheLoader&lt;Key, DatabaseConnection&gt; () &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DatabaseConnection <span class="title">load</span><span class="params">(Key key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> openConnection(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RemovalListener&lt;Key, DatabaseConnection&gt; removalListener = <span class="keyword">new</span> RemovalListener&lt;Key, DatabaseConnection&gt;() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;Key, DatabaseConnection&gt; removal)</span> </span>&#123;</span><br><span class="line">        DatabaseConnection conn = removal.getValue();</span><br><span class="line">        conn.close(); <span class="comment">// tear down properly</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CacheBuilder.newBuilder()</span><br><span class="line">    .expireAfterWrite(<span class="number">2</span>, TimeUnit.MINUTES)</span><br><span class="line">    .removalListener(removalListener)</span><br><span class="line">    .build(loader);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch 总结</title>
      <link href="/2019/09/03/ES%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/03/ES%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li><strong>Near Realtime（NRT） 近实时</strong>。数据提交索引后，立马就可以搜索到。<br><strong>Cluster 集群</strong>，一个集群由一个唯一的名字标识，默认为“elasticsearch”。集群名称非常重要，<strong>具有相同集群名的节点才会组成一个集群</strong>。集群名称可以在配置文件中指定。</li><li><strong>Node 节点</strong>：存储集群的数据，参与集群的索引和搜索功能。像集群有名字，节点也有自己的名称，默认在启动时会以一个随机的UUID的前七个字符作为节点的名字，你可以为其指定任意的名字。通过集群名在网络中发现同伴组成集群。一个节点也可是集群。</li><li><strong>Index 索引</strong>: 一个索引是一个文档的集合（等同于solr中的集合）。每个索引有唯一的名字，通过这个名字来操作它。一个集群中可以有任意多个索引。</li><li><strong>Type 类型</strong>：指在一个索引中，可以索引不同类型的文档，如用户数据、博客数据。从6.0.0 版本起已废弃，一个索引中只存放一类数据。</li><li><strong>Document 文档</strong>：被索引的一条数据，索引的基本信息单元，以JSON格式来表示。</li><li><strong>Shard 分片</strong>：在创建一个索引时可以指定分成多少个分片来存储。每个分片本身也是一个功能完善且独立的“索引”，可以被放置在集群的任意节点上。分片的好处：允许我们水平切分/扩展容量。可在多个分片上进行分布式的、并行的操作，提高系统的性能和吞吐量。</li></ul><p><strong>注意：分片数创建索引时指定，创建后不可改了。备份数可以随时改。</strong></p><ul><li><strong>Replication 备份:</strong> 一个分片可以有多个备份（副本）。备份的好处：高可用。<strong>一个主分片挂了，副本分片就顶上去</strong>。扩展搜索的并发能力、吞吐量。搜索可以在所有的副本上并行运行。-<strong>高并发下副本也可搜索</strong></li></ul><h4 id="索引常用操作"><a href="#索引常用操作" class="headerlink" title="索引常用操作"></a>索引常用操作</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建索引(在ES中创建一个索引类似于在数据库中建立一个数据库(ES6.0之后类似于创建一个表))</span><br><span class="line">//设置索引的分片数为3，备份数为2</span><br><span class="line">PUT twitter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span> : &#123;</span><br><span class="line">        <span class="attr">"index"</span> : &#123;</span><br><span class="line">            <span class="attr">"number_of_shards"</span> : <span class="number">3</span>, </span><br><span class="line">            <span class="attr">"number_of_replicas"</span> : <span class="number">2</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//默认的分片数是5到1024</span><br><span class="line">//默认的备份数是1</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//创建mapping映射</span><br><span class="line">//在ES中创建一个mapping映射类似于在数据库中定义表结构，即表里面有哪些字段、字段是什么类型、字段的默认值等</span><br><span class="line">PUT twitter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span> : &#123;</span><br><span class="line">        <span class="attr">"index"</span> : &#123;</span><br><span class="line">            <span class="attr">"number_of_shards"</span> : <span class="number">3</span>, </span><br><span class="line">            <span class="attr">"number_of_replicas"</span> : <span class="number">2</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">   <span class="attr">"mappings"</span> : &#123;</span><br><span class="line">        <span class="attr">"type1"</span> : &#123;</span><br><span class="line">            <span class="attr">"properties"</span> : &#123;</span><br><span class="line">                <span class="attr">"field1"</span> : &#123; <span class="attr">"type"</span> : <span class="string">"text"</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// type1 指的是type。 field1指的是字段名。text是字段类型。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查看索引的定义信息</span><br><span class="line">GET /twitter</span><br><span class="line">//查看所有索引的定义信息</span><br><span class="line">GET /_all</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//删除索引</span><br><span class="line">DELETE /twitter</span><br><span class="line">// 删除所有索引</span><br><span class="line">DELETE /_all</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//判断索引是否存在</span><br><span class="line">HEAD twitter</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//索引监控</span><br><span class="line">GET /_stats</span><br><span class="line">//查看指定索引的状态信息</span><br><span class="line">GET /index1,index2/_stats</span><br></pre></td></tr></table></figure><h4 id="映射常见操作"><a href="#映射常见操作" class="headerlink" title="映射常见操作"></a>映射常见操作</h4><p>映射定义索引中有什么字段、字段的类型等结构信息。<strong>相当于数据库中表结构定义，或 solr中的schema</strong>。因为lucene索引文档时需要知道该如何来索引存储文档的字段。ES中支持手动定义映射，动态映射两种方式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//为索引test创建mapping</span><br><span class="line">PUT test</span><br><span class="line">&#123;</span><br><span class="line">//映射定义</span><br><span class="line">"mappings" : &#123;</span><br><span class="line">//名为type1的映射类别(mapping type)</span><br><span class="line">        "type1" : &#123;</span><br><span class="line">        //字段定义</span><br><span class="line">            "properties" : &#123;</span><br><span class="line">            //名为field1的字段，它的field datatype 为 text</span><br><span class="line">                "field1" : &#123; "type" : "text" &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//映射类别的废除说明</span><br><span class="line">//为了与之后的版本匹配，现在将这个唯一的映射类别名定义为“_doc”,因为索引的请求地址将规范为：PUT &#123;index&#125;/_doc/&#123;id&#125; and POST &#123;index&#125;/_doc</span><br><span class="line">因此改为了</span><br><span class="line">PUT twitter</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    "_doc": &#123; //////////////// type 改为 _doc</span><br><span class="line">      "properties": &#123;</span><br><span class="line">        "type": &#123; "type": "keyword" &#125;, </span><br><span class="line">        "name": &#123; "type": "text" &#125;,</span><br><span class="line">        "user_name": &#123; "type": "keyword" &#125;,</span><br><span class="line">        "email": &#123; "type": "keyword" &#125;,</span><br><span class="line">        "content": &#123; "type": "text" &#125;,</span><br><span class="line">        "tweeted_at": &#123; "type": "date" &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h4><p>动态映射是ES中提供的重要特性，让我们可以快速使用ES，而不需要先创建索引、定义映射。 如我们直接向ES提交文档进行索引。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT data/_doc/1 </span><br><span class="line">&#123; <span class="attr">"count"</span>: <span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>ES将自动为我们创建data索引、_doc 映射、类型为 long 的字段 count</strong></p><p>索引文档时，当有新字段时， ES将根据我们字段的json的数据类型为我们自动加人字段定义到mapping中。</p><h4 id="分析器Analyzer"><a href="#分析器Analyzer" class="headerlink" title="分析器Analyzer"></a>分析器Analyzer</h4><p>在ES中一个分析器由以下三种组件组合而成。</p><p><strong>character filter ：</strong>字符过滤器，对文本进行字符过滤处理，如处理文本中的html标签字符。处理完后再交给tokenizer进行分词。<strong>一个analyzer中可包含0个或多个字符过滤器，多个按配置顺序依次进行处理</strong>。<br><strong>tokenizer：</strong>分词器，对文本进行分词。<strong>一个analyzer必需且只可包含一个tokenizer</strong>。<br><strong>token filter：</strong>词项过滤器，对tokenizer分出的词进行过滤处理。如转小写、停用词处理、同义词处理。<strong>一个analyzer可包含0个或多个词项过滤器，按配置顺序进行过滤</strong>。</p><h4 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a>文档管理</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//指定文档id，新增、修改</span><br><span class="line">PUT twitter/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"user"</span> : <span class="string">"kimchy"</span>,</span><br><span class="line">    <span class="attr">"post_date"</span> : <span class="string">"2009-11-15T14:12:12"</span>,</span><br><span class="line">    <span class="attr">"message"</span> : <span class="string">"trying out Elasticsearch"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//新增，自动生成文档id</span><br><span class="line">POST twitter/_doc/</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"user"</span> : <span class="string">"kimchy"</span>,</span><br><span class="line">    <span class="attr">"post_date"</span> : <span class="string">"2009-11-15T14:12:12"</span>,</span><br><span class="line">    <span class="attr">"message"</span> : <span class="string">"trying out Elasticsearch"</span></span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">//  返回结果</span><br><span class="line">&#123;</span><br><span class="line">  "_index" : "twitter",   // 所属索引</span><br><span class="line">  "_type" : "_doc",       //所属mapping type</span><br><span class="line">  "_id" : "ec5B9mwB-bWstPBClp9t",   //文档id</span><br><span class="line">  "_version" : 1,         // 文档版本</span><br><span class="line">  "result" : "created",   </span><br><span class="line">  "_shards" : &#123;            // 分片的写入情况</span><br><span class="line">    "total" : 3,           //所在分片有三个副本</span><br><span class="line">    "successful" : 1,      // 1个副本上成功写入</span><br><span class="line">    "failed" : 0           // 失败副本数</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 0,           // 第几次操作该文档</span><br><span class="line">  "_primary_term" : 1      // 词项数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//获取单个文档</span><br><span class="line">HEAD twitter/_doc/11</span><br><span class="line">GET twitter/_doc/1</span><br><span class="line">不获取文档的source：</span><br><span class="line">GET twitter/_doc/1?_source=false</span><br><span class="line">获取文档的source：</span><br><span class="line">GET twitter/_doc/1/_source</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//删除文档</span><br><span class="line">指定文档id进行删除</span><br><span class="line">DELETE twitter/_doc/1</span><br><span class="line"> 用版本来控制删除</span><br><span class="line">DELETE twitter/_doc/1?version=1</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//更新文档</span><br><span class="line">// 指定文档id进行修改</span><br><span class="line">PUT twitter/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"user"</span> : <span class="string">"kimchy"</span>,</span><br><span class="line">    <span class="attr">"post_date"</span> : <span class="string">"2009-11-15T14:12:12"</span>,</span><br><span class="line">    <span class="attr">"message"</span> : <span class="string">"trying out Elasticsearch"</span></span><br><span class="line">&#125;</span><br><span class="line">----------------乐观锁并发更新控制</span><br><span class="line">PUT twitter/_doc/1?version=1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"user"</span> : <span class="string">"kimchy"</span>,</span><br><span class="line">    <span class="attr">"post_date"</span> : <span class="string">"2009-11-15T14:12:12"</span>,</span><br><span class="line">    <span class="attr">"message"</span> : <span class="string">"trying out Elasticsearch"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//从索引tweet里面搜索字段user为k的记录</span><br><span class="line"> GET /twitter/_search?q=user:k</span><br><span class="line">//从索引tweet,user里面搜索字段user为k的记录</span><br><span class="line">GET /tweet,user/_search?q=user:k</span><br><span class="line">//从所有索引里面搜索字段tag 为wow的记录</span><br><span class="line">GET /_all/_search?q=tag:wow</span><br><span class="line">GET /_search?q=tag:wow</span><br></pre></td></tr></table></figure><h4 id="特殊的搜索方法"><a href="#特殊的搜索方法" class="headerlink" title="特殊的搜索方法"></a>特殊的搜索方法</h4><p>如果我们只想知道有多少文档匹配某个查询，可以这样用参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search?q=city:b*&amp;size=0</span><br></pre></td></tr></table></figure><p>如果我们只想知道有没有文档匹配某个查询，可以这样用参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search?q=city:b*&amp;size=0&amp;terminate_after=1</span><br></pre></td></tr></table></figure><h4 id="Request-body-Search"><a href="#Request-body-Search" class="headerlink" title="Request body Search"></a>Request body Search</h4><p>Request body 搜索方式以JSON格式在请求体中定义查询 query。请求方式可以是 GET 、POST 。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /twitter/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"term"</span> : &#123; <span class="attr">"user"</span> : <span class="string">"kimchy"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------</span><br><span class="line">可用的参数:(query和下面的都是同等级的参数)</span><br><span class="line">query: 用Query DSL来定义查询</span><br><span class="line">timeout：请求超时时长，限定在指定时长内响应（即使没查完）；</span><br><span class="line">from： 分页的起始行，默认0；</span><br><span class="line">size：分页大小；</span><br><span class="line">request_cache：是否缓存请求结果，默认true。</span><br><span class="line">terminate_after：限定每个分片取几个文档。如果设置，则响应将有一个布尔型字段terminated_early来指示查询执行是否实际已经terminate_early。缺省为no terminate_after；</span><br><span class="line">search_type：查询的执行方式，可选值dfs_query_then_fetch or query_then_fetch ，默认： query_then_fetch ；</span><br><span class="line">batched_reduce_size：一次在协调节点上应该减少的分片结果的数量。如果请求中的潜在分片数量可能很大，则应将此值用作保护机制以减少每个搜索请求的内存开销。</span><br></pre></td></tr></table></figure><h5 id="指定返回哪些内容（和query同等级）"><a href="#指定返回哪些内容（和query同等级）" class="headerlink" title="指定返回哪些内容（和query同等级）"></a>指定返回哪些内容（和query同等级）</h5><ul><li>source filter 对_source 字段进行选择</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_source"</span>: <span class="keyword">false</span>,</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"term"</span> : &#123; <span class="string">"user"</span> : <span class="string">"kimchy"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>version 来指定返回文档的版本字段</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"version"</span>: <span class="keyword">true</span>,</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"term"</span> : &#123; <span class="string">"user"</span> : <span class="string">"kimchy"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Sort 排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">可以指定按一个或多个字段排序。也可通过_score指定按评分值排序，_doc 按索引顺序排序。默认是按相关性评分从高到低排序。</span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"age"</span>: &#123;</span><br><span class="line">        <span class="string">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"balance"</span>: &#123;</span><br><span class="line">        <span class="string">"order"</span>: <span class="string">"asc"</span></span><br><span class="line">      &#125;    &#125;,</span><br><span class="line">    <span class="string">"_score"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体的Query-即-Query-DSL领域特定语言"><a href="#具体的Query-即-Query-DSL领域特定语言" class="headerlink" title="具体的Query 即 Query DSL领域特定语言"></a>具体的Query 即 Query DSL领域特定语言</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Match all query 查询所有</span></span><br><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 什么都不查</span></span><br><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"match_none"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//match query 全文查询的标准查询，可以对一个字段进行模糊，短语查询。</span></span><br><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"match"</span> : &#123;</span><br><span class="line">            <span class="string">"message"</span> : <span class="string">"this is a test"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a>聚合分析</h4><p>聚合分析是数据库中重要的功能特性，完成对一个查询的数据集中数据的聚合计算，如：找出某字段（或计算表达式的结果）的最大值、最小值，计算和、平均值等。ES作为搜索引擎兼数据库，同样提供了强大的聚合分析能力。对一个数据集求最大、最小、和、平均值等指标的聚合，在ES中称为<strong>指标聚合   metric</strong>。而关系型数据库中除了有聚合函数外，还可以对查询出的数据进行分组group by，再在组上进行指标聚合。在 ES 中group by 称为<strong>分桶</strong>，<strong>桶聚合 bucketing</strong>。ES中还提供了矩阵聚合（matrix）、管道聚合（pipleline），但还在完善中。</p><p>聚合的写法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">"aggregations" : &#123;</span><br><span class="line">    "&lt;aggregation_name&gt;" : &#123; &lt;!--聚合的名字 --&gt;</span><br><span class="line">        "&lt;aggregation_type&gt;" : &#123; &lt;!--聚合的类型 --&gt;</span><br><span class="line">            &lt;aggregation_body&gt; &lt;!--聚合体：对哪些字段进行聚合 --&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        [,"meta" : &#123;  [&lt;meta_data_body&gt;] &#125; ]? &lt;!--元 --&gt;</span><br><span class="line">        [,"aggregations" : &#123; [&lt;sub_aggregation&gt;]+ &#125; ]? &lt;!--在聚合里面在定义子聚合 --&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    [,"&lt;aggregation_name_2&gt;" : &#123; ... &#125; ]*&lt;!--聚合的名字 --&gt;</span><br><span class="line">&#125;</span><br><span class="line">//聚合计算的值可以取字段的值，也可是脚本计算的结果。</span><br><span class="line">// aggregations 可以简写为aggs</span><br></pre></td></tr></table></figure><ul><li>Max min sum avg </li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//查询所有客户中余额的最大值</span><br><span class="line">POST /bank/_search?</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">0</span>, </span><br><span class="line">  "aggs": &#123;            //   !!!!!!!!!!!</span><br><span class="line">    "masssbalance": &#123;  //!!!!!!!!!!!!!!</span><br><span class="line">      "max": &#123;         //   !!!!!!!!!!!!!</span><br><span class="line">        "field": "balance"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">2080</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  "aggregations": &#123;      //!!!!!!!!!!!!!!!!</span><br><span class="line">    "masssbalance": &#123;    //!!!!!!!!!!!!!!!！</span><br><span class="line">      "value": 49989     //!!!!!!!!!!!!!!!!</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 查询年龄为21岁的客户中的余额最大值</span><br><span class="line">POST /bank/_search?</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">2</span>, </span><br><span class="line">  "query": &#123;      //!!!!!!!!!!!!!!</span><br><span class="line">    "match": &#123;    //!!!!!!!!!!!!!!</span><br><span class="line">      "age": 24   //!!!!!!!!!!!!!</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "sort": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"balance"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "max_balance": &#123;</span><br><span class="line">      "max": &#123;    //!!!!!!!!!!!!!!!!</span><br><span class="line">        "field": "balance"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">42</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  "aggregations": &#123;          //!!!!!!!!!!!!!!</span><br><span class="line">    "max_balance": &#123;         //!!!!!!!!!!!!!!</span><br><span class="line">      "value": 48745         //!!!!!!!!!!!!!!</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文档计数count</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//统计银行索引bank下年龄为24的文档数量</span><br><span class="line">POST /bank/_doc/_count</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"age"</span> : <span class="number">24</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"count"</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="桶聚合"><a href="#桶聚合" class="headerlink" title="桶聚合"></a>桶聚合</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//根据项分组计数(根据工资进行统计)</span><br><span class="line">POST /customer/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">0</span>, </span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"group_count"</span>: &#123;</span><br><span class="line">      <span class="attr">"terms"</span>: &#123;<span class="attr">"field"</span>: <span class="string">"salary"</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"took"</span>: <span class="number">26</span>,</span><br><span class="line">    <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hits"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">6</span>,</span><br><span class="line">        <span class="attr">"max_score"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"hits"</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggregations"</span>: &#123;</span><br><span class="line">        <span class="attr">"group_count"</span>: &#123;</span><br><span class="line">            <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"buckets"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">15000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">20000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">17000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">18000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//分组基础上再统计</span><br><span class="line">POST /customer/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">0</span>, </span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"group_count"</span>: &#123;</span><br><span class="line">      <span class="attr">"terms"</span>: &#123;<span class="attr">"field"</span>: <span class="string">"salary"</span>&#125;,</span><br><span class="line">      <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">        <span class="attr">"avg_age"</span>:&#123;</span><br><span class="line">          <span class="attr">"avg"</span>:&#123;<span class="attr">"field"</span>: <span class="string">"age"</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"took"</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hits"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">6</span>,</span><br><span class="line">        <span class="attr">"max_score"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"hits"</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggregations"</span>: &#123;</span><br><span class="line">        <span class="attr">"group_count"</span>: &#123;</span><br><span class="line">            <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"buckets"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">15000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">"avg_age"</span>: &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">26.5</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">20000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">"avg_age"</span>: &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">30.5</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">17000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">"avg_age"</span>: &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">26</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">18000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">"avg_age"</span>: &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">27</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastJSON</title>
      <link href="/2019/08/05/fastJSON%20%E9%80%9F%E8%A7%88/"/>
      <url>/2019/08/05/fastJSON%20%E9%80%9F%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>JSON 语法是 JavaScript 对象表示语法的子集。</p><ul><li>数据在名称/值对中</li><li>数据由逗号分隔</li><li>大括号保存对象</li><li>中括号保存数组</li></ul><h4 id="JSON-值"><a href="#JSON-值" class="headerlink" title="JSON 值"></a>JSON 值</h4><p>JSON 值可以是：</p><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在中括号中）</li><li>对象（在大括号中）</li><li>null</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;syn:[1,2,3]&#125; 表示syn的值是一个数组，里面有三个元素 1 2 3</span><br><span class="line">或者 &#123;syn:[&#123;'value':1&#125;,&#123;'value':2&#125;,&#123;'value':3&#125;]&#125;;  syn的值是一个数组 ，数组里每个对元素是一个对象。</span><br></pre></td></tr></table></figure><h4 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"ID"</span>:<span class="number">1001</span>,</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"nnn"</span>,</span><br><span class="line">    <span class="attr">"age"</span>:<span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JSON-对象数组"><a href="#JSON-对象数组" class="headerlink" title="JSON 对象数组"></a>JSON 对象数组</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;<span class="attr">"ID"</span>:<span class="number">1001</span>,<span class="attr">"name"</span>:<span class="string">"zhangsan"</span>,<span class="attr">"age"</span>:<span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"ID"</span>:<span class="number">1002</span>,<span class="attr">"name"</span>:<span class="string">"lisi"</span>,<span class="attr">"age"</span>:<span class="number">252222</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"ID"</span>:<span class="number">1003</span>,<span class="attr">"name"</span>:<span class="string">"wangwu"</span>,<span class="attr">"age"</span>:<span class="number">2224</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="JSON-字符串"><a href="#JSON-字符串" class="headerlink" title="JSON 字符串"></a>JSON 字符串</h4><ul><li>它必须是一个字符串，由<code>&quot;&quot;</code>或者<code>&#39;&#39;</code>包裹数据，支持字符串的各种操作。</li><li>里面的数据格式应该要满足其中一个格式，可以是JSON对象，也可以是JSON对象数组或者是基本形式的组合变形。</li></ul><h3 id="fastJSON"><a href="#fastJSON" class="headerlink" title="fastJSON"></a>fastJSON</h3><p>fastJSON可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在fastJSON中，可以发现三个主要的类，JSON，JSONObject，JSONArray。</p><p>三者的关系是JSONObject 和JSONArray 继承JSON。</p><p><strong>JSONObject是JSON字符串与pojo对象转换过程中的中间表达类型，实现了Map接口，可以看做是一个模拟JSON对象键值对再加上多层嵌套的数据集合，对象的每一个基本类型属性是map里的一个key-value，一个非基本类型属性是一个嵌套的JSONObject对象（key是属性名称，value是表示这个属性值的对象的JSONObject）。</strong></p><p>可以发现，<strong>JSONObject代表json对象，JSONArray代表json对象数组，JSON代表JSONObject和JSONArray的转化。</strong></p><hr><p>JSONObject 对象JSON对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</p><hr><p>JSONArray代表json对象数组，json数组对象中存储的是一个个json对象，所以类中的方法主要用于直接操作json对象。比如这其中的add(),remove()，containsAll()方法，对应于json对象的添加，删除与判断。和JSONObject 一样，其中也有一些get()方法，不过都不常用，最常用的是getJSONObject(int index)方法，该方法用于获取json对象数组中指定位置的JSONObject对象，配合size()方法，可用于遍历json对象数组中的各个对象。</p><hr><p>JSON类主要是实现转化用的，最后的数据获取，还是要通过上面的JSONObject和JSONArray来实现。</p><ul><li>JSON.toJSONString()方法，实现JSON对象转换为json字符串和Javabean 转换为json字符串。</li><li>JSON.parseObject()方法，实现json字符串转换为json对象或javabean对象，该方法返回JSONObject对象，用于实现json字符串向json对象的转化。json字符串与javaBean之间的转换可以使用 Class这个类。</li><li>JSON.parseArray()将json字符串转化为json对象数组或转化成包含泛型的List</li><li>JSON.toJSON()方法，实现JavaBean对象转换为json对象。</li><li>JSON.toJavaObject()方法，实现json对象转化为javabean对象</li></ul><p><strong>对于jsonstring转POJO（或POJO转jsonstring），尽量使用直接转的方式，而不是先转成JSONObject过渡的方式。特别是对于Fastjson，由于性能优化的考虑，这两个执行的代码是不一样的，可能导致不一样的结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String jsonstring = <span class="string">"&#123;\"a\":12&#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐这种方式</span></span><br><span class="line"><span class="comment">// 除非这里需要对jsonObject做一些简单处理</span></span><br><span class="line">JSONObject jsonObject = JSON.parseObject(jsonstring);</span><br><span class="line">A a = jsonObject.toJavaObject(A.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐方式</span></span><br><span class="line">A a = JSON.parseObject(jsonstring, A.class);</span><br></pre></td></tr></table></figure><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><h5 id="序列化一个Java对象成JSON字符串"><a href="#序列化一个Java对象成JSON字符串" class="headerlink" title="序列化一个Java对象成JSON字符串"></a>序列化一个Java对象成JSON字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setName(<span class="string">"校长"</span>);</span><br><span class="line">user.setAge(<span class="number">3</span>);</span><br><span class="line">user.setSalary(<span class="keyword">new</span> BigDecimal(<span class="string">"123456789.0123"</span>));</span><br><span class="line">String jsonString = JSON.toJSONString(user);</span><br><span class="line">System.out.println(jsonString);</span><br><span class="line"><span class="comment">// 输出 &#123;"age":3,"name":"校长","old":false,"salary":123456789.0123&#125;</span></span><br></pre></td></tr></table></figure><h5 id="反序列化一个JSON字符串成Java对象"><a href="#反序列化一个JSON字符串成Java对象" class="headerlink" title="反序列化一个JSON字符串成Java对象"></a>反序列化一个JSON字符串成Java对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> String jsonString = <span class="string">"&#123;\"age\":3,\"birthdate\":1496738822842,\"name\":\"校长\",\"old\":true,\"salary\":123456789.0123&#125;"</span>;</span><br><span class="line"> User u = JSON.parseObject(jsonString ,User.class);</span><br><span class="line"> System.out.println(u.getName());</span><br><span class="line"> <span class="comment">// 输出 校长</span></span><br><span class="line"></span><br><span class="line">String jsonStringArray = <span class="string">"[&#123;\"age\":3,\"birthdate\":1496738822842,\"name\":\"校长\",\"old\":true,\"salary\":123456789.0123&#125;]"</span>;</span><br><span class="line">List&lt;User&gt; userList = JSON.parseArray(jsonStringArray, User.class);</span><br><span class="line">System.out.println(userList.size());</span><br><span class="line"><span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastJSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes基本概念</title>
      <link href="/2018/11/01/Kubernetes/"/>
      <url>/2018/11/01/Kubernetes/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubernetes基本概念"><a href="#Kubernetes基本概念" class="headerlink" title="Kubernetes基本概念"></a>Kubernetes基本概念</h2><p>Kubernetes最初源于谷歌内部的Borg，提供了面向应用的容器集群部署和管理系统。Kubernetes的目标旨在消除编排物理/虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的workflows 和更高级的自动化任务。 Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。 Kubernetes 还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。</p><p>K8S的目的是让用户能够不必操心资源管理的问题，让他们专注于自己的核心业务，并且做到跨多个数据中心的资源利用率最大化。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>借鉴了Borg的设计理念，比如Pod、Service、Label和单Pod单IP等。Kubernetes的整体架构跟Borg非常像。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20181030153820.png" alt=""></p><p>Kubernetes主要由以下几个核心组件组成：</p><ul><li>etcd保存了整个集群的状态；</li><li>apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li><li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li><li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li><li>kubelet负责维护容器的生命周期，同时也负责Volume（CSI）和网络（CNI）的管理；</li><li>Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；</li><li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；</li></ul><p>除了核心组件，还有一些推荐的插件，其中有的已经成为CNCF中的托管项目：</p><ul><li>CoreDNS负责为整个集群提供DNS服务</li><li>Ingress Controller为服务提供外网入口</li><li>Prometheus提供资源监控</li><li>Dashboard提供GUI</li><li>Federation提供跨可用区的集群</li></ul><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20181030154121.png" alt=""></p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20181030154145.png" alt=""></p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20181030154217.png" alt=""></p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20181030154237.png" alt=""></p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20181030154302.png" alt=""></p><ul><li>核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境</li><li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等）、Service Mesh（部分位于应用层）</li><li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等）、Service Mesh（部分位于管理层）</li><li>接口层：kubectl命令行工具、客户端SDK以及集群联邦</li><li>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴<ul><li>Kubernetes外部：日志、监控、配置管理、CI/CD、Workflow、FaaS、OTS应用、ChatOps、GitOps、SecOps等</li><li>Kubernetes内部：<a href="https://jimmysong.io/kubernetes-handbook/concepts/cri.html" target="_blank" rel="noopener">CRI</a>、<a href="https://jimmysong.io/kubernetes-handbook/concepts/cni.html" target="_blank" rel="noopener">CNI</a>、<a href="https://jimmysong.io/kubernetes-handbook/concepts/csi.html" target="_blank" rel="noopener">CSI</a>、镜像仓库、Cloud Provider、集群自身的配置和管理等</li></ul></li></ul><h3 id="核心技术概念和API对象"><a href="#核心技术概念和API对象" class="headerlink" title="核心技术概念和API对象"></a>核心技术概念和API对象</h3><p>API对象是Kubernetes集群中的管理操作单元。Kubernetes集群系统每支持一项新功能，引入一项新技术，一定会新引入对应的API对象，支持对该功能的管理操作。例如副本集Replica Set对应的API对象是RS。</p><p><strong>每个API对象都有3大类属性：元数据metadata、规范spec（期待的状态）和状态status（当前的状态）。</strong></p><p>元数据是用来标识API对象的，每个对象都至少有3个元数据：namespace，name和uid；除此以外还有各种各样的标签labels用来标识和匹配不同的对象，例如用户可以用标签env来标识区分不同的服务部署环境，分别用env=dev、env=testing、env=production来标识开发、测试、生产的不同服务。规范描述了用户期望Kubernetes集群中的分布式系统达到的理想状态（Desired State），例如用户可以通过复制控制器Replication Controller设置期望的Pod副本数为3；status描述了系统实际当前达到的状态（Status），例如系统当前实际的Pod副本数为2；那么复制控制器当前的程序逻辑就是自动启动新的Pod，争取达到副本数为3。</p><p><strong>Kubernetes中所有的配置都是通过API对象的spec去设置的，也就是用户通过配置系统的理想状态来改变系统，这是Kubernetes重要设计理念之一</strong>，即所有的操作都是声明式（Declarative）的而不是命令式（Imperative）的。声明式操作在分布式系统中的好处是稳定，不怕丢操作或运行多次，例如设置副本数为3的操作运行多次也还是一个结果，而给副本数加1的操作就不是声明式的，运行多次结果就错了。</p><h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><p>Kubernetes有很多技术概念，同时对应很多API对象，最重要的也是最基础的是Pod。<strong>Pod是在Kubernetes集群中运行部署应用或服务的最小单元，它是可以支持多容器的</strong>。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。<strong>Pod对多容器的支持是K8最基础的设计理念</strong>。比如你运行一个操作系统发行版的软件仓库，一个Nginx容器用来发布软件，另一个容器专门用来从源仓库做同步，这两个容器的镜像不太可能是一个团队开发的，但是他们一块儿工作才能提供一个微服务；这种情况下，不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。</p><p>Pod是Kubernetes集群中所有业务类型的基础，可以看作运行在K8集群中的小机器人，不同类型的业务就需要不同类型的小机器人去执行。<strong>目前Kubernetes中的业务主要可以分为长期伺服型（long-running）、批处理型（batch）、节点后台支撑型（node-daemon）和有状态应用型（stateful application）；分别对应的小机器人控制器为Deployment、Job、DaemonSet和StatefulSet</strong>，本文后面会一一介绍。</p><h4 id="副本控制器"><a href="#副本控制器" class="headerlink" title="副本控制器"></a>副本控制器</h4><p>RC是Kubernetes集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动运行新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证永远有1个Pod在运行。RC是Kubernetes较早期的技术概念，只适用于长期伺服型的业务类型，比如控制小机器人提供高可用的Web服务。</p><h4 id="副本集（Replica-Set，RS）"><a href="#副本集（Replica-Set，RS）" class="headerlink" title="副本集（Replica Set，RS）"></a>副本集（Replica Set，RS）</h4><p>RS是新一代RC，提供同样的高可用能力，区别主要在于RS后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数使用。</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p><strong>部署表示用户对Kubernetes集群的一次更新操作</strong>。部署是一个比RS应用模式更广的API对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态，将旧RS中的副本数减小到0的复合操作；这样一个复合操作用一个RS是不太好描述的，所以用一个更通用的Deployment来描述。以Kubernetes的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。</p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>RC、RS和Deployment只是保证了支撑服务的微服务Pod的数量，<strong>但是没有解决如何访问这些服务的问题</strong>。一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。要稳定地提供服务需要服务发现和负载均衡能力。服务发现完成的工作，是针对客户端访问的服务，找到对应的的后端服务实例。<strong>在K8集群中，客户端需要访问的服务就是Service对象</strong>。每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务。在Kubernetes集群中微服务的负载均衡是由Kube-proxy实现的。Kube-proxy是Kubernetes集群内部的负载均衡器。它是一个分布式代理服务器，在Kubernetes的每个节点上都有一个；这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多。与之相比，我们平时在服务器端做个反向代理做负载均衡，还要进一步解决反向代理的负载均衡和高可用问题。</p><h4 id="任务Job"><a href="#任务Job" class="headerlink" title="任务Job"></a>任务Job</h4><p><strong>Job是Kubernetes用来控制批处理型任务的API对象。</strong>批处理业务与长期伺服业务的主要区别是批处理业务的运行有头有尾，而长期伺服业务在用户不停止的情况下永远运行。Job管理的Pod根据用户的设置把任务成功完成就自动退出了。成功完成的标志根据不同的spec.completions策略而不同：单Pod型任务有一个Pod成功就标志完成；定数成功型任务保证有N个任务全部成功；工作队列型任务根据应用确认的全局成功而标志成功。</p><h4 id="后台支撑服务集"><a href="#后台支撑服务集" class="headerlink" title="后台支撑服务集"></a>后台支撑服务集</h4><p>长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些节点上又没有这类Pod运行；而后台支撑型服务的核心关注点在Kubernetes集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点也可能是通过nodeSelector选定的一些特定节点。典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支持Kubernetes集群运行的服务</p><h4 id="有状态服务集（StatefulSet）"><a href="#有状态服务集（StatefulSet）" class="headerlink" title="有状态服务集（StatefulSet）"></a>有状态服务集（StatefulSet）</h4><p><strong>RC和RS主要是控制提供无状态服务的，其所控制的Pod的名字是随机设置的，一个Pod出故障了就被丢弃掉，在另一个地方重启一个新的Pod，名字变了、名字和启动在哪儿都不重要，重要的只是Pod总数；而StatefulSet是用来控制有状态服务，StatefulSet中的每个Pod的名字都是事先确定的，不能更改。</strong>StatefulSet中Pod的名字的作用，并不是《千与千寻》的人性原因，而是关联与该Pod对应的状态。</p><p>对于RC和RS中的Pod，一般不挂载存储或者挂载共享存储，保存的是所有Pod共享的状态，Pod像牲畜一样没有分别（这似乎也确实意味着失去了人性特征）；对于StatefulSet中的Pod，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来Pod的存储继续以它的状态提供服务。</p><p><strong>适合于StatefulSet的业务包括数据库服务MySQL和PostgreSQL，集群化管理服务ZooKeeper、etcd等有状态服务。</strong>StatefulSet的另一种典型应用场景是作为一种比普通容器更稳定可靠的模拟虚拟机的机制。</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>命名空间为Kubernetes集群提供虚拟的隔离作用，Kubernetes集群初始有两个命名空间，分别是默认命名空间default和系统命名空间kube-system，除此以外，管理员可以可以创建新的命名空间满足需要。</p><h3 id="理解K8S中的对象"><a href="#理解K8S中的对象" class="headerlink" title="理解K8S中的对象"></a>理解K8S中的对象</h3><p>在 Kubernetes 系统中，<em>Kubernetes 对象</em> 是持久化的条目。Kubernetes 使用这些条目去表示整个集群的状态。特别地，它们描述了如下信息：</p><ul><li>什么容器化应用在运行（以及在哪个 Node 上）</li><li>可以被应用使用的资源</li><li>关于应用如何表现的策略，比如重启策略、升级策略，以及容错策略</li></ul><p>Kubernetes 对象是 “目标性记录” —— 一旦创建对象，Kubernetes 系统将持续工作以确保对象存在。通过创建对象，可以有效地告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的，这就是 Kubernetes 集群的 <strong>期望状态</strong>。</p><p>与 Kubernetes 对象工作 —— 是否创建、修改，或者删除 —— 需要使用 Kubernetes API。当使用 <code>kubectl</code> 命令行接口时，比如，CLI 会使用必要的 Kubernetes API 调用，也可以在程序中直接使用 Kubernetes API。</p><h3 id="集群资源管理"><a href="#集群资源管理" class="headerlink" title="集群资源管理"></a>集群资源管理</h3><p>为了管理异构和不同配置的主机，为了便于Pod的运维管理，Kubernetes中提供了很多集群管理的配置和管理功能，通过namespace划分的空间，通过为node节点创建label和taint用于pod的调度等。</p><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>Node 是K8S集群中的工作节点，可以是物理机也可以是虚拟机。</p><p>Node 的状态：Node包括如下状态信息：</p><ul><li>Address<ul><li>HostName：可以被kubelet中的<code>--hostname-override</code>参数替代。</li><li>ExternalIP：可以被集群外部路由到的IP地址。</li><li>InternalIP：集群内部使用的IP，集群外部无法访问。</li></ul></li><li>Condition<ul><li>OutOfDisk：磁盘空间不足时为<code>True</code></li><li>Ready：Node controller 40秒内没有收到node的状态报告为<code>Unknown</code>，健康为<code>True</code>，否则为<code>False</code>。</li><li>MemoryPressure：当node没有内存压力时为<code>True</code>，否则为<code>False</code>。</li><li>DiskPressure：当node没有磁盘压力时为<code>True</code>，否则为<code>False</code>。</li></ul></li><li>Capacity<ul><li>CPU</li><li>内存</li><li>可运行的最大Pod个数</li></ul></li><li>Info：节点的一些版本信息，如OS、kubernetes、docker等</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf基础</title>
      <link href="/2018/10/24/Thymeleaf%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/10/24/Thymeleaf%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><ul><li><p>一款Java模板引擎，能够处理HTML,XML，JS,CSS等，类似JSP，Freemarker</p></li><li><p>自然模板，原型即页面</p></li><li>语法优雅易懂 OGNL，SpringEL</li><li>遵循web标准，支持HTML5.</li></ul><h5 id="Thymeleaf-标准方言-五种"><a href="#Thymeleaf-标准方言-五种" class="headerlink" title="Thymeleaf 标准方言(五种)"></a>Thymeleaf 标准方言(五种)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&#123;...&#125; 变量表达式</span><br><span class="line">*&#123;...&#125; 选择表达式</span><br><span class="line">#&#123;...&#125; i18n表达式</span><br><span class="line">@&#123;...&#125; 链接表达式</span><br><span class="line">~&#123;...&#125; 片段表达式</span><br></pre></td></tr></table></figure><p>如何识别</p><ul><li><code>&lt;span th:text=&quot;...&quot;&gt;</code></li><li><code>&lt;span data-th-text=&quot;...&quot;&gt;</code></li></ul><h4 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h4><p>语法：<code>${...}</code></p><p><code>&lt;span th:text=&quot;${book.author.name}&quot;&gt;</code></p><h4 id="消息表达式-也称为文本外部化-国际化"><a href="#消息表达式-也称为文本外部化-国际化" class="headerlink" title="消息表达式(也称为文本外部化 国际化)"></a>消息表达式(也称为文本外部化 国际化)</h4><p>语法：<code>#{...}</code></p><p><code>&lt;th th:text=&quot;#{header.address.city}&quot;&gt;...&lt;/th&gt;</code></p><h4 id="选择表示式"><a href="#选择表示式" class="headerlink" title="选择表示式"></a>选择表示式</h4><p>语法：<code>*{...}</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:object</span>=<span class="string">"$&#123;book&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;title&#125;"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>  <span class="attr">action</span>=<span class="string">"/users"</span>  <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">th:object</span>=<span class="string">"$&#123;user&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">th:value</span>=<span class="string">"*&#123;id&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    名称:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">th:value</span>=<span class="string">"*&#123;name&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Email:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">th:value</span>=<span class="string">"*&#123;email&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>与变量表达式区别：它们是在当前选择的对象而不是整个上下文变量映射上执行。</p><p>即上面的title 实际是<code>book.title</code> <code>user.id</code></p><h4 id="链接表达式"><a href="#链接表达式" class="headerlink" title="链接表达式"></a>链接表达式</h4><p>语法：<code>@{...}</code></p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20181024205757.png" alt=""></p><h4 id="分段表达式"><a href="#分段表达式" class="headerlink" title="分段表达式"></a>分段表达式</h4><p>语法：th:insert 或 th:replace</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">header.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">"header1111"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf in action<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/users/list"</span>&gt;</span>welcome to site<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">引用上面header</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"~&#123;fragment/footer :: footer1111&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">位置+“::”+ fragment名字</span><br></pre></td></tr></table></figure><h4 id="设置属性值"><a href="#设置属性值" class="headerlink" title="设置属性值"></a>设置属性值</h4><p>语法：<code>th:attr</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"1.html"</span> <span class="attr">th:attr</span>=<span class="string">"action=@&#123;/sub&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>基本的迭代 <code>th:each</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"book:$&#123;books&#125;"</span> &gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;book.id&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;book.site&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p><code>&lt;th:if&gt;</code> <code>&lt;th:unless&gt;</code> <code>&lt;th:switch&gt;</code></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启发性算法简介</title>
      <link href="/2018/09/17/%E5%90%AF%E5%8F%91%E6%80%A7%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/09/17/%E5%90%AF%E5%8F%91%E6%80%A7%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="启发式算法简介"><a href="#启发式算法简介" class="headerlink" title="启发式算法简介"></a>启发式算法简介</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>启发式算法是一种基于直观或经验的局部优化算法。启发式算法的定义：</p><ul><li>人们常常把从大自然的运行规律或者面向具体问题的经验和规则中启发出来的方法称之为启发式算法。现在的启发式算法也不是全部来自大自然的规律，也有来自人类积累的工作经验。</li><li>在可以接受的花费下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度不一定事先可以预计。</li><li>启发性算法是一种技术，该技术使得能再可接受的计算费用内去寻找尽可能好的解，但不一定能保证所得解的可行性和最优性，甚至在多数情况下，无法描述所得解与最优解的近似程度。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>禁忌搜索：是对局部领域搜索的一种扩展，是一种全局逐步寻优算法，是对人类智力过程的一种模拟。</li><li>模拟退火：它是一种通过模拟物理退火过程搜索最优解的方法</li><li>遗传算法：是一种通过模拟自然进化过程搜索最优解的方法</li><li>神经网络：是一种模拟动物神经网络行为特征，进行分布式并行信息处理的算法数学模型</li><li>蚁群算法：是一种模拟蚂蚁在寻找食物过程中发现路径的行为来寻找优化路径的几率型算法。</li></ul><h4 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h4><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20180917215643.png" alt=""></p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20180917215706.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务 两阶段提交 三阶段提交</title>
      <link href="/2018/08/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%20%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
      <url>/2018/08/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%20%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式事务-两阶段提交-三阶段提交"><a href="#分布式事务-两阶段提交-三阶段提交" class="headerlink" title="分布式事务 两阶段提交 三阶段提交"></a>分布式事务 两阶段提交 三阶段提交</h2><p>在分布式系统中，为了保证数据的高可用，通常，我们会将数据保留多个副本(replica)，这些副本会放置在不同的物理的机器上。为了对用户提供正确的增\删\改\差等语义，我们需要保证这些放置在不同物理机器上的副本是一致的。</p><p>为了解决这种分布式一致性问题，前人在性能和数据一致性的反反复复权衡过程中总结了许多典型的协议和算法。其中比较著名的有<strong>二阶提交协议</strong>（Two Phase Commitment Protocol）、<strong>三阶提交协议</strong>（Three Phase Commitment Protocol）和<strong>Paxos算法</strong>。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分布式事务是指会涉及到操作多个数据库的事务。其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）</span><br></pre></td></tr></table></figure><p>在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以他也就不知道本次事务到底应该commit还是 roolback。因此，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。 </p><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在<strong>进行事务提交时保持一致性</strong>而设计的一种算法。通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，<strong>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</strong> </p><p>所谓的两个阶段是指：第一阶段 ，<strong>准备阶段(投票阶段) </strong>和第二阶段：<strong>提交阶段（执行阶段）</strong>。</p><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p><p>可以进一步将准备阶段分为以下三个步骤：</p><blockquote><p>1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</p><p>2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p><p>3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</p></blockquote><h4 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h4><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p><p>接下来分两种情况分别讨论提交阶段的过程。</p><p><font color="ffgfgf">情况一</font>当协调者节点从所有参与者节点获得的相应消息都为”同意”时:</p><blockquote><p>1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求。</p><p>2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</p><p>3）参与者节点向协调者节点发送”完成”消息。</p><p>4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</p></blockquote><p><img src="http://four-1252095801.cosbj.myqcloud.com/1111.png" alt=""></p><p><font color="ffgfgf">情况二</font>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时： </p><blockquote><p>1）协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</p><p>2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p><p>3）参与者节点向协调者节点发送”回滚完成”消息。</p><p>4）协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p></blockquote><p><img src="http://four-1252095801.cosbj.myqcloud.com/222222.png" alt=""></p><p>不管最后结果如何，第二阶段都会结束当前事务。</p><h4 id="2PC-的缺点"><a href="#2PC-的缺点" class="headerlink" title="2PC 的缺点"></a>2PC 的缺点</h4><p>1、<strong>同步阻塞问题</strong>。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p><p>2、<strong>单点故障</strong>。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p><p>3、<strong>数据不一致</strong>。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p><p>4、二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。 </p><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><ul><li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li></ul><p>也就是说，除了引入超时机制之外，<strong>3PC把2PC的准备阶段再次一分为二</strong>，这样三阶段提交就有<code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code>三个阶段。 </p><h4 id="CanCommit-阶段"><a href="#CanCommit-阶段" class="headerlink" title="CanCommit 阶段"></a>CanCommit 阶段</h4><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。 </p><blockquote><p><strong>1.事务询问</strong> 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p><p><strong>2.响应反馈</strong> 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</p></blockquote><h4 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a>PreCommit阶段</h4><p>协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。</p><p><font color="ffgfgf">情况一</font>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。</p><blockquote><p><strong>1.发送预提交请求</strong> 协调者向参与者发送PreCommit请求，并进入Prepared阶段。</p><p><strong>2.事务预提交</strong> 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</p><p><strong>3.响应反馈</strong> 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p></blockquote><p><font color="ffgfgf">情况二</font>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><blockquote><p><strong>1.发送中断请求</strong> 协调者向所有参与者发送abort请求。</p><p><strong>2.中断事务</strong> 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</p></blockquote><h4 id="doCommit-阶段"><a href="#doCommit-阶段" class="headerlink" title="doCommit 阶段"></a>doCommit 阶段</h4><p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p><p><font color="ffgfgf">情况一</font> 执行提交</p><blockquote><p><strong>1.发送提交请求</strong> 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p><p><strong>2.事务提交</strong> 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p><p><strong>3.响应反馈</strong> 事务提交完之后，向协调者发送Ack响应。</p><p><strong>4.完成事务</strong> 协调者接收到所有参与者的ack响应之后，完成事务。</p></blockquote><p><font color="ffgfgf">情况二</font>  中断事务：协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。 </p><blockquote><p><strong>1.发送中断请求</strong> 协调者向所有参与者发送abort请求</p><p><strong>2.事务回滚</strong> 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p><p><strong>3.反馈结果</strong> 参与者完成事务回滚之后，向协调者发送ACK消息</p><p><strong>4.中断事务</strong> 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）</span><br></pre></td></tr></table></figure><h2 id="2PC与3PC的区别"><a href="#2PC与3PC的区别" class="headerlink" title="2PC与3PC的区别"></a>2PC与3PC的区别</h2><p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 流量控制与拥塞控制</title>
      <link href="/2018/08/01/TCP%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
      <url>/2018/08/01/TCP%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-流量控制与拥塞控制"><a href="#TCP-流量控制与拥塞控制" class="headerlink" title="TCP 流量控制与拥塞控制"></a>TCP 流量控制与拥塞控制</h2><p>在TCP协议中，客户端发送的每一个包，服务端都应该有一个回复，如果服务端超过一定的时间没有回复，客户端就会重新发送这个包，直到有回复。</p><p>这个发送应答的过程是什么样呢？可以是上一个收到了应答，再发送下一个，这种模式有点像两个人直接打电话，你一句，我一句。但是这种方式的缺点是效率比较低。如果一方在电话那头处理的时间比较长，这一头就要干等着，双方都没办法干其他事情。</p><p>TCP 协议使用的也是同样的模式。为了保证顺序性，每一个包都有一个 ID。在建立连接的时候，会商定起始的 ID 是什么，然后按照 ID 一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式称为累计确认或者累计应答。</p><p>为了记录所有发送的包和接收的包，TCP 也需要发送端和接收端分别都有缓存来保存这些记录。发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分。</p><ul><li>第一部分：发送了并且已经确认的。这部分就是你交代下属的，并且也做完了的，应该划掉的。</li><li>第二部分：发送了并且尚未确认的。这部分是你交代下属的，但是还没做完的，需要等待做完的回复之后，才能划掉。</li><li>第三部分：没有发送，但是已经等待发送的。这部分是你还没有交代给下属，但是马上就要交代的。</li><li>第四部分：没有发送，并且暂时还不会发送的。这部分是你还没有交代给下属，而且暂时还不会交代给下属的。</li></ul><p>到底员工能同时处理多少事情呢，TCP里，接收端会给发送端报一个窗口的大小，叫Advertised window 这个窗口的大小应该等于上面第二部分加上第三部分，就是已经交代的加上马上要交代的，超过这个窗口的，接收端做不过来，就不能发送了。</p><p>于是，发送端需要保持下面的数据结构</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%888.30.05.png" alt=""></p><ul><li>LastByteAcked: 第一部分第二部分的分界线</li><li>LastByteSent : 第二部分和第三部分的分界线</li><li>LastByteAcked+AdvertisedWindow: 第三部分和第四部分的分界线</li></ul><p>对于接收端，缓存里简单一点，</p><ul><li>第一部分，接受并且确认过的，也就是领导交代我，并且我做完的</li><li>第二部分，还没接受，但是马上就能接收的，也就是我自己能够接收的最大工作量。</li><li>第三部分 还没接受，也没法接受的，也就是超过工作量的部分，实在做不完。</li></ul><p>数据结构是下面这样</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%888.35.02.png" alt=""></p><ul><li>MaxRecBuffer 最大缓存的量</li><li>LastByteRead 之后是已经接受了，但是还没被应用层读取的</li><li>NextByteExpected  是第一部分第二部分的分界线。</li></ul><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>在对于包的确认中，同时会携带一个窗口的大小</p><p>先假设窗口不变的情况下，窗口始终为9，4的确认来的时候，会右移一个，这个时候第13个包也可以发送了。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%888.45.08.png" alt=""></p><p>这时，假如发送端发送过猛，会将第三部分的10 11 12 13 全部发送完毕，之后就停止发送了，未发送可发送部分为0.</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%888.50.18.png" alt=""></p><p>当对于包5的确认到达的时候，在客户端相当于窗口再滑动了一格，这时，才可以有更多的包可以发送了，例如第14个包才可以发送</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%888.53.10.png" alt=""></p><p>如果接收方实在处理的慢，导致缓存中没空间了，可以通过确认信息修改窗口的大小，甚至可以设置为0.则发送方暂时停止发送。</p><p>假设，接收端的应用一直不读取缓存的数据，当数据包6确认后，串口大小就不再是9了，就要缩小为8.</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%888.56.00.png" alt=""></p><p>这个新的窗口8通过6的确认消息到达发送端的时候，窗口没有平行右移，而是仅仅左面的边右移了，窗口由9变为8</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%888.57.50.png" alt=""></p><p>如果接受端还是一直不处理数据，则随着确认的包越来越多，窗口越来越小，直到为0.</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%888.57.50.png" alt=""></p><p>当这个窗口通过包14的确认到达发送端的时候，发送端窗口也调整为0 停止发送。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%889.02.26.png" alt=""></p><p>如果这样的话，发送方会定时发送窗口探测数据包，看是否有机会调整窗口的大小。当接收方比较慢的时候，要防止低能窗口综合征，别空出一个字节来就赶快告诉发送方，然后马上又填满了，可以当窗口太小的时候，不更新窗口，直到达到一定大小，或者缓冲区一半为空，才更新窗口。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>也是通过窗口的大小来控制的，前面的滑动窗口rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口cwnd, 是怕把网络塞满。</p><p>LastByteSent-LastByteAcked&lt;=min{cwnd,rwnd}, 是拥塞窗口和滑动窗口共同控制发送的速度。</p><p>TCP的拥塞控制就是在不堵塞，不丢包的情况下，尽量发挥带宽。</p><p>水管有粗细，网络有带宽，也即每秒钟能够发送多少数据；水管有长度，端到端有时延，在理想状态下，水管里的水= 水管粗细<em> 水管长度，对于到网络上，通道的容量=带宽</em>往返延迟。</p><p>如果设置发送窗口，使得发送但未确认的包为通道的容量，就能够撑满整个管道。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%8810.24.55.png" alt=""></p><p>如图所示，假设往返时间为 8s，去 4s，回 4s，每秒发送一个包，每个包 1024byte。已经过去了 8s，则 8 个包都发出去了，其中前 4 个包已经到达接收端，但是 ACK 还没有返回，不能算发送成功。5-8 后四个包还在路上，还没被接收。这个时候，整个管道正好撑满，在发送端，已发送未确认的为 8 个包，正好等于带宽，也即每秒发送 1 个包，乘以来回时间 8s。</p><p> 如果在这个基础上再调大窗口，使得单位时间内更多的包可以发送，会怎么样呢？</p><p>我们来想，原来发送一个包，从一端到达另一端，假设一共经过四个设备，每个设备处理一个包时间耗费 1s，所以到达另一端需要耗费 4s，如果发送的更加快速，则单位时间内，会有更多的包到达这些中间设备，这些设备还是只能每秒处理一个包的话，多出来的包就会被丢弃，这是我们不想看到的。</p><p>这个时候，我们可以想其他的办法，例如这个四个设备本来每秒处理一个包，但是我们在这些设备上加缓存，处理不过来的在队列里面排着，这样包就不会丢失，但是缺点是会增加时延，这个缓存的包，4s 肯定到达不了接收端了，如果时延达到一定程度，就会超时重传，也是我们不想看到的。</p><p>于是 TCP 的拥塞控制主要来避免两种现象，包丢失和超时重传，。一旦出现了这些现象就说明，发送速度太快了，要慢一点。但是一开始我怎么知道速度多快呢，我怎么知道应该把窗口调整到多大呢？</p><p>如果我们通过漏斗往瓶子里灌水，我们就知道，不能一桶水一下子倒进去，肯定会溅出来，要一开始慢慢的倒，然后发现总能够倒进去，就可以越倒越快。这叫作慢启动。</p><p>一条 TCP 连接开始，cwnd 设置为一个报文段，一次只能发送一个；当收到这一个确认的时候，cwnd 加一，于是一次能够发送两个；当这两个的确认到来的时候，每个确认 cwnd 加一，两个确认 cwnd 加二，于是一次能够发送四个；当这四个的确认到来的时候，每个确认 cwnd 加一，四个确认 cwnd 加四，于是一次能够发送八个。可以看出这是指数级的增长</p><p>涨到什么时候是个头呢？有一个值 ssthresh 为 65535 个字节，当超过这个值的时候，就要小心一点了，不能倒这么快了，可能快满了，再慢下来。</p><p>每收到一个确认后，cwnd 增加 1/cwnd，我们接着上面的过程来，一次发送八个，当八个确认到来的时候，每个确认增加 1/8，八个确认一共 cwnd 增加 1，于是一次能够发送九个，变成了线性增长。</p><p>但是线性增长还是增长，还是越来越多，直到有一天，水满则溢，出现了拥塞，这时候一般就会一下子降低倒水的速度，等待溢出的水慢慢渗下去。</p><p>拥塞的一种表现形式是丢包，需要超时重传，这个时候，将 sshresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动。这真是一旦超时重传，马上回到解放前。但是这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。</p><p>前面的快速重传算法中。当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速的重传，不必等待超时再重传。TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，cwnd 减半为 cwnd/2，然后 sshthresh = cwnd，当三个包返回的时候，cwnd = sshthresh + 3，也就是没有一夜回到解放前，而是还在比较高的值，呈线性增长。</p><p>就像前面说的一样，正是这种知进退，使得时延很重要的情况下，反而降低了速度。但是如果你仔细想一下，TCP 的拥塞控制主要来避免的两个现象都是有问题的。</p><p>第一个问题是是丢包并不代表着通道满了，也可能是管子本来就漏水。例如公网上带宽不满也会丢包，这个时候就认为拥塞了，退缩了，其实是不对的。</p><p>第二个问题是 TCP 的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了。其实 TCP 只要填满管道就可以了，不应该接着填，直到连缓存也填满。</p><p>为了优化这两个问题，后来有了TCP BBR 拥塞算法。。它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java序列化原理</title>
      <link href="/2018/07/25/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2018/07/25/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>Java中主要对象实现了java.io.Serializable 就可以进行序列化</p><h4 id="ObjectInputStream-和ObjectOutputStream"><a href="#ObjectInputStream-和ObjectOutputStream" class="headerlink" title="ObjectInputStream 和ObjectOutputStream"></a>ObjectInputStream 和ObjectOutputStream</h4><p>Java IO 包中为我们提供了 ObjectInputStream 和 ObjectOutputStream 两个类。 java.io.ObjectOutputStream 类实现类的序列化功能。 java.io.ObjectInputStream 类实现了反序列化功能。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"d:\\a.user"</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        User user1 = <span class="keyword">new</span> User();</span><br><span class="line">        user1.setUserName(<span class="string">"zhangsan"</span>);</span><br><span class="line">        user1.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        user1.setAddr(<span class="string">"北京中关村"</span>);</span><br><span class="line">        oos.writeObject(user1);     </span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        User user2 = (User)ois.readObject();</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">User [userName=zhangsan, password=123456, addr=北京中关村]</span><br><span class="line">使用 ObjectOutputStream 把 user1 实例序列化到 d:\user 文件中。</span><br><span class="line">使用 ObjectInputStream 把 d:\user 文件中的数据反序列化成 user2 实，并打印。</span><br></pre></td></tr></table></figure><hr><p>在序列化过程中，<strong>如果被序列化的类中定义了writeObject 和 readObject 方法，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化。</strong></p><p>如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。</p><p>用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。</p><p>如果一个类中包含了writeObject 和writeObject方法，这两个方法如何调用？</p><p>答案是在使用ObjectOutputStream的writeObject方法和ObjectInputStream的readObject方法时，会通过反射的方式调用。 </p><hr><h4 id="ObjectOutputStream-原理解析"><a href="#ObjectOutputStream-原理解析" class="headerlink" title="ObjectOutputStream 原理解析"></a>ObjectOutputStream 原理解析</h4><h5 id="writeObject-方法"><a href="#writeObject-方法" class="headerlink" title="writeObject 方法"></a>writeObject 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">           writeObjectOverride(obj);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           writeObject0(obj, <span class="keyword">false</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">           <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">               writeFatalException(ex);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">throw</span> ex;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>1、通过 enableOverride 判断是否执行 writeObjectOverride() 方法。</p><p> 2、调用writeObject() 方法。 </p><h5 id="writeObject0-方法"><a href="#writeObject0-方法" class="headerlink" title="writeObject0 方法"></a>writeObject0 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> oldMode = bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// handle previously written and non-replaceable objects</span></span><br><span class="line">            <span class="keyword">int</span> h;</span><br><span class="line">            <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                writeNull();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                writeHandle(h);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                writeClass((Class) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check for replacement object</span></span><br><span class="line">            Object orig = obj;</span><br><span class="line">            Class cl = obj.getClass();</span><br><span class="line">            ObjectStreamClass desc;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// REMIND: skip this check for strings/arrays?</span></span><br><span class="line">                Class repCl;</span><br><span class="line">                desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||</span><br><span class="line">                    (obj = desc.invokeWriteReplace(obj)) == <span class="keyword">null</span> ||</span><br><span class="line">                    (repCl = obj.getClass()) == cl)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cl = repCl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">                Object rep = replaceObject(obj);</span><br><span class="line">                <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cl = rep.getClass();</span><br><span class="line">                    desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                obj = rep;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if object replaced, run through original checks a second time</span></span><br><span class="line">            <span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">                subs.assign(orig, obj);</span><br><span class="line">                <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    writeNull();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    writeHandle(h);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                    writeClass((Class) obj, unshared);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                    writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">**************<span class="comment">// 下面是重点</span></span><br><span class="line">            <span class="comment">// remaining cases</span></span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                writeString((String) obj, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">                writeArray(obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">                writeEnum((Enum) obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">                writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                        cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            depth--;</span><br><span class="line">            bout.setBlockDataMode(oldMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1、 如果该对象是String、数组、枚举类型的，调用相应的方法进行写入。 </p><p>2、如果对象是 Serializable 的，则调用 writeOrdinaryObject() 方法，该方法是序列化的核心方法 。<strong>在这里我们终于看到 Serializable的作用了。因为Serializable中没有定义方法，只是起到标识作用，该标识作用就在这提现。 </strong></p><h5 id="writeOrdinaryObject-方法"><a href="#writeOrdinaryObject-方法" class="headerlink" title="writeOrdinaryObject 方法"></a>writeOrdinaryObject 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     ObjectStreamClass desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.push(</span><br><span class="line">                (depth == <span class="number">1</span> ? <span class="string">"root "</span> : <span class="string">""</span>) + <span class="string">"object (class \""</span> +</span><br><span class="line">                obj.getClass().getName() + <span class="string">"\", "</span> + obj.toString() + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            desc.checkSerialize();</span><br><span class="line"></span><br><span class="line">            bout.writeByte(TC_OBJECT);</span><br><span class="line">            writeClassDesc(desc, <span class="keyword">false</span>);</span><br><span class="line">            handles.assign(unshared ? <span class="keyword">null</span> : obj);</span><br><span class="line">            <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">                writeExternalData((Externalizable) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                writeSerialData(obj, desc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1、检查是否可以序列化<br>2、写入类型<br>3、写 class 的描述信息<br>4、判断是 该对象 否实现了 Externalizable 接口</p><ul><li>如果实现了则调用 writeExternalData 方法。</li><li>如果没有实现则调用 writeSerialData 方法。</li></ul><h5 id="writeSerialData-方法"><a href="#writeSerialData-方法" class="headerlink" title="writeSerialData 方法"></a>writeSerialData 方法</h5><p>实现Serializable 序列化接口</p><p>1、判断该类是否定义了 writeObject() 方法，如果定义了，则通过反射调用该对象的 writeObject() 方法，执行我们自己定义的序列化规则。</p><p>2、没有定义writeObject() 方法，则调用 defaultWriteFields() 方法执行默认的序列化规则。<br> 我们平常在重写 writeObject() 方法的时候一般也会先调用 defaultWriteFields() 方法的，然后在写上其它特殊的序列化。</p><h3 id="ArrayList-的序列化"><a href="#ArrayList-的序列化" class="headerlink" title="ArrayList 的序列化"></a>ArrayList 的序列化</h3><p>ArrayList实现了<code>java.io.Serializable</code>接口，那么我们就可以对它进行序列化及反序列化。因为elementData是<code>transient</code>的，所以我们认为这个成员变量不会被序列化而保留下来。 ArrayList底层是通过数组实现的。那么数组<code>elementData</code>其实就是用来保存列表中的元素的。通过该属性的声明方式我们知道，他是无法通过序列化持久化下来的。那么为什么通过序列化和反序列化把List中的元素保留下来了呢？ </p><p>还是因为ArrayList 中定义了<strong>writeObject</strong> 方法和<strong>WriteObject</strong> 方法</p><p>为什么ArrayList 要自定义序列化方式呢？</p><p>ArrayList实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化99个null元素。为了保证在序列化的时候不会将这么多null同时进行序列化，ArrayList把元素数组设置为transient。 </p><p>前面说过，为了防止一个包含大量空对象的数组被序列化，为了优化存储，所以，ArrayList使用<code>transient</code>来声明<code>elementData</code>。 但是，作为一个集合，在序列化过程中还必须保证其中的元素可以被持久化下来，所以，通过重写<code>writeObject</code> 和 <code>readObject</code>方法的方式把其中的元素保留下来。</p><p><code>writeObject</code>方法把<code>elementData</code>数组中的元素遍历的保存到输出流（ObjectOutputStream）中。</p><p><code>readObject</code>方法从输入流（ObjectInputStream）中读出对象并保存赋值到<code>elementData</code>数组中。</p><blockquote><p><a href="https://www.jianshu.com/p/af2f0a4b03b5" target="_blank" rel="noopener">https://www.jianshu.com/p/af2f0a4b03b5</a></p><p><a href="https://www.jianshu.com/p/3e3d86716f76" target="_blank" rel="noopener">https://www.jianshu.com/p/3e3d86716f76</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java注解的原理</title>
      <link href="/2018/07/25/%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2018/07/25/%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-注解"><a href="#Java-注解" class="headerlink" title="Java 注解"></a>Java 注解</h2><p>Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。</p><p>注解其实同class 和Interface 一样，注解也属于一种类型，它是在JavaSE5.0版本中开始引入的概念。<strong>注解就相当于标签</strong></p><h4 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h4><p>注解通过@interface 关键字进行定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的形式和接口很像，只不过前面多了一个@符号，上面的代码就创建了一个名字叫TestAnnotation 的注解。可以简单理解为创建了一张名字为TestAnnotation的标签。</p><h4 id="注解的应用"><a href="#注解的应用" class="headerlink" title="注解的应用"></a>注解的应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;    </span><br><span class="line">&#125;<span class="comment">// 可以简单理解为将@TestAnnotation 这张标签贴到Test 这个类上面。</span></span><br></pre></td></tr></table></figure><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。</p><p>元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。</p><p>元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。</p><ul><li>@Retention 保留期</li></ul><p>解释说明这个注解的存活时间</p><p>RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 </p><p>RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 </p><p>RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。</p><ul><li>@Documented</li></ul><p>它的作用是能够将注解中的元素包含到JavaDoc中去。</p><ul><li>@Target</li></ul><p>Target 是目标的意思，@target 指定了注解运用的地方。</p><p>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</p><p>ElementType.CONSTRUCTOR 可以给构造方法进行注解</p><p>ElementType.FIELD 可以给属性进行注解</p><p>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</p><p>ElementType.METHOD 可以给方法进行注解</p><p>ElementType.PACKAGE 可以给一个包进行注解</p><p>ElementType.PARAMETER 可以给一个方法内的参数进行注解</p><p>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</p><ul><li>@Inherited </li></ul><p>继承的意思，是指如果一个超类被@Inherited注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。</p><ul><li>@Repeatable</li></ul><p>可重复，就是可以添加多个一样的注解，但是属性可以不一样。</p><h4 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h4><p>注解的属性也叫做成员变量，注解只有成员变量，没有方法，注解的成员变量在注解中的定义中以“无参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">msg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了TestAnnotation 这个注解拥有id 和msg 两个属性，在使用的时候，应该给他们赋值，赋值的方式是在注解的括号内以value=””形式，多个属性之前用，隔开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span>(id=<span class="number">3</span>,msg=<span class="string">"hello annotation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解中的属性可以有默认值，默认值需要用default 关键字指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestAnnotation 中 id 属性默认值为 -1，msg 属性默认值为 Hi。</p><h4 id="注解的提取"><a href="#注解的提取" class="headerlink" title="注解的提取"></a>注解的提取</h4><p>当写好注解后，现在的工作是检查这些注解，提取上面的信息。</p><p>要想正确的检阅注解，需要使用反射。</p><p>注解通过反射获取，首先可以通过Class 对象的isAnnotationPresent()方法判断它是否应用了某个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>然后通过getAnnotation()方法来获取Annotation 对象。(返回指定类型的注解)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>或者是getAnnotations()方法（返回注解到这个元素上的所有注解）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations() &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果获取到的Annotation 如果不为空，就可以调用他们的属性方法了。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span> ( hasAnnotation ) &#123;</span><br><span class="line">            TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"id:"</span>+testAnnotation.id());</span><br><span class="line">            System.out.println(<span class="string">"msg:"</span>+testAnnotation.msg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 集群</title>
      <link href="/2018/07/10/Redis%20%20%E9%9B%86%E7%BE%A4/"/>
      <url>/2018/07/10/Redis%20%20%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><p>Redis 集群是一个提供在<strong>多个Redis间节点间共享数据</strong>的程序集。</p><p>Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.</p><p>Redis 集群通过分区来提供<strong>一定程度的可用性</strong>,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:</p><ul><li>自动分割数据到不同的节点上。</li><li>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</li></ul><h4 id="Redis-集群的目标"><a href="#Redis-集群的目标" class="headerlink" title="Redis 集群的目标"></a>Redis 集群的目标</h4><p>Redis 集群是 Redis 的一个分布式实现，主要是为了实现以下这些目标（按在设计中的重要性排序）：</p><ul><li>在1000个节点的时候仍能表现得很好并且可扩展性（scalability）是线性的。</li><li>没有合并操作，这样在 Redis 的数据模型中最典型的大数据值中也能有很好的表现。</li><li>写入安全（Write safety）：那些与大多数节点相连的客户端所做的写入操作，系统尝试全部都保存下来。不过公认的，还是会有小部分（small windows?）写入会丢失。</li><li>可用性（Availability）：在绝大多数的主节点（master node）是可达的，并且对于每一个不可达的主节点都至少有一个它的从节点（slave）可达的情况下，Redis 集群仍能进行分区（partitions）操作。</li></ul><h4 id="Redis-集群的数据分片"><a href="#Redis-集群的数据分片" class="headerlink" title="Redis 集群的数据分片"></a>Redis 集群的数据分片</h4><p>Redis 集群没有使用一致性hash, 而是引入了 <strong>哈希槽</strong>的概念.</p><p>Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p><ul><li>节点 A 包含 0 到 5500号哈希槽.</li><li>节点 B 包含5501 到 11000 号哈希槽.</li><li>节点 C 包含11001 到 16384号哈希槽.</li></ul><p>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p><h4 id="Redis集群的主从复制模型"><a href="#Redis集群的主从复制模型" class="headerlink" title="Redis集群的主从复制模型"></a>Redis集群的主从复制模型</h4><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p><p>在我们例子中具有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用.</p><p>然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了</p><p>不过当B和B1 都失败后，集群是不可用的.</p><h4 id="Redis-一致性保证"><a href="#Redis-一致性保证" class="headerlink" title="Redis 一致性保证"></a>Redis 一致性保证</h4><p>Redis 并不能保证数据的<strong>强一致性</strong>. 这意味这在实际中集群在特定的条件下可能会丢失写操作.</p><p>第一个原因是因为集群是用了异步复制. 写操作过程:</p><ul><li>客户端向主节点B写入一条命令.</li><li>主节点B向客户端回复命令状态.</li><li>主节点将写操作复制给他得从节点 B1, B2 和 B3.</li></ul><p><strong>主节点对命令的复制工作发生在返回命令回复之后</strong>， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</p><p>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .</p><p>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.</p><p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项。</p><h4 id="实现的功能子集"><a href="#实现的功能子集" class="headerlink" title="实现的功能子集"></a>实现的功能子集</h4><p>Redis 集群实现了所有在非分布式 Redis 版本中出现的处理单一键值（key）的命令。那些使用多个键值的复杂操作， 比如 set 里的并集（unions）和交集（intersections）操作，就没有实现。通常来说，那些处理命令的节点获取不到键值的所有操作都不会被实现。 </p><h4 id="Redis-集群协议中的客户端和服务器端"><a href="#Redis-集群协议中的客户端和服务器端" class="headerlink" title="Redis  集群协议中的客户端和服务器端"></a>Redis  集群协议中的客户端和服务器端</h4><p>在 Redis 集群中，节点负责存储数据、记录集群的状态（包括键值到正确节点的映射）。集群节点同样能自动发现其他节点，检测出没正常工作的节点， 并且在需要的时候在从节点中推选出主节点。</p><p>为了执行这些任务，所有的集群节点都通过TCP连接（TCP bus？）和一个二进制协议（集群连接，cluster bus）建立通信。 每一个节点都通过集群连接（cluster bus）与集群上的其余每个节点连接起来。节点们使用一个 gossip 协议来传播集群的信息，这样可以：发现新的节点、 发送ping包（用来确保所有节点都在正常工作中）、在特定情况发生时发送集群消息。集群连接也用于在集群中发布或订阅消息。</p><h4 id="键分布模型"><a href="#键分布模型" class="headerlink" title="键分布模型"></a>键分布模型</h4><p>键空间被分割为16384槽，事实上集群的最大节点数量是16384个</p><p>所有主节点都负责16384个哈希槽中的一部分，当集群处于稳定状态时，集群中没有在执行重配置操作，每个哈希槽都只由一个节点进行处理。</p><p>以下是用来把键映射到哈希槽的算法</p><p><code>HASH_SLOT=CRC16(key)mod 16384</code></p><h4 id="集群节点属性"><a href="#集群节点属性" class="headerlink" title="集群节点属性"></a>集群节点属性</h4><p>集群中，每个节点都有一个唯一的名字，节点名字是一个16进制表示的160bit随机数，这个随机数是节点第一次启动时获得的，节点会把它的ID保存在配置文件里，以后永远使用这个ID,只要这个节点配置文件没有被系统管理员删除掉。</p><p>节点ID是用于在整个集群中标识每个节点。一个给定的节点可以在不改变节点ID的情况下改变IP和地址。集群能检测到IP或端口的变化。</p><h4 id="集群拓扑结构"><a href="#集群拓扑结构" class="headerlink" title="集群拓扑结构"></a>集群拓扑结构</h4><p>Redis 集群是一个网状结构，每个节点都通过 TCP 连接跟其他每个节点连接。</p><p>在一个有 N 个节点的集群中，每个节点都有 N-1 个流出的 TCP 连接，和 N-1 个流入的连接。 这些 TCP 连接会永久保持，并不是按需创建的。</p><h4 id="集群在线重配置"><a href="#集群在线重配置" class="headerlink" title="集群在线重配置"></a>集群在线重配置</h4><p>Redis 集群支持在集群运行过程中添加或移除节点。实际上，添加或移除节点都被抽象为同一个操作，那就是把哈希槽从一个节点移到另一个节点。</p><ul><li>向集群添加一个新节点，就是把一个空节点加入到集群中并把某些哈希槽从已存在的节点移到新节点上。</li><li>从集群中移除一个节点，就是把该节点上的哈希槽移到其他已存在的节点上。</li><li>所以实现这个的核心是能把哈希槽移来移去。从实际角度看，哈希槽就只是一堆键，所以 Redis 集群在重组碎片（reshard）时做的就是把键从一个节点移到另一个节点。</li></ul><h4 id="失效检测"><a href="#失效检测" class="headerlink" title="失效检测"></a>失效检测</h4><p>Redis 集群失效检测是用来识别出大多数节点何时无法访问某一个主节点或从节点。当这个事件发生时，就提升一个从节点来做主节点；若如果无法提升从节点来做主节点的话，那么整个集群就置为错误状态并停止接收客户端的查询。</p><p>每个节点都有一份跟其他已知节点相关的标识列表。其中有两个标识是用于失效检测，分别是 PFAIL 和 FAIL。PFAIL 表示可能失效（Possible failure），这是一个非公认的（non acknowledged）失效类型。FAIL 表示一个节点已经失效，而且这个情况已经被大多数主节点在某段固定时间内确认过的了。</p><blockquote><p><a href="http://www.redis.cn/topics/cluster-spec.html" target="_blank" rel="noopener">http://www.redis.cn/topics/cluster-spec.html</a></p><p><a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">http://www.redis.cn/topics/cluster-tutorial.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper系统模型</title>
      <link href="/2018/07/07/zookeeper%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/07/07/zookeeper%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Zookeeper-系统模型"><a href="#Zookeeper-系统模型" class="headerlink" title="Zookeeper 系统模型"></a>Zookeeper 系统模型</h2><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>zookeeper 的视图结构和标准的Unix文件系统非常类似，但是没有引入传统文件系统中目录和文件等相关概念，而是使用了其特有的数据节点概念，我们称为Znode,Znode 是zookeeper中数据的最小单元，每个Znode上都可以保存数据，同时还可以挂载子节点，因此构成了一个层次化的命名空间，我们称为树。</p><p>Znode的节点路径标识方式和Unix文件系统路径非常相似，都是由一系列使用斜杠（/）进行分割的路径表示，开发人员可以向这个节点中写入数据，也可以在节点下面创建子节点。</p><p>在ZK中，事务是指能够改变ZK服务器状态的操作，我们称之为事务操作或更新操作，一般包括数据节点创建与删除，数据节点内容更新和客户端会话创建与失效等操作。对于每一个事务请求，ZK都会为其分配一个全局唯一的事务ID,用ZXID表示，通常是一个64位的数字，每一个ZXID对应一次更新操作，从这些ZXID可以间接地识别出ZK处理这些更新操作请求的全局顺序。</p><h4 id="节点特性"><a href="#节点特性" class="headerlink" title="节点特性"></a>节点特性</h4><p>ZK中，每个数据节点都是有生命周期的，其生命周期的长短取决于数据节点的节点类型，在ZK中，节点类型可以分为<strong>持久节点</strong>，<strong>临时节点</strong>，<strong>顺序节点</strong>三大类，具体在节点创建过程中，通过组合使用，可以生成以下四种组合类型节点类型。</p><ul><li><p>持久节点</p><p>最常见类型，创建后，就会一直存在于ZK服务器上，直到有删除操作来主动清除这个节点。</p></li><li><p>持久顺序节点</p><p>基本特性与持久节点一样，额外的特性表现在顺序性上，在ZK上，每个父节点都会为它的第一级子节点维护一份顺序，用于记录下每个子节点创建的先后顺序，基于这个顺序特性，在创建子节点的时候，可以设置这个标记，那么在创建节点过程中，ZK会自动为给定节点加上一个数字后缀，作为一个新的，完整的节点名。</p></li><li><p>临时节点</p><p>临时节点生命周期与客户端会话绑定在一起，如果客户端会话失效，节点就会被自动清理掉。另外，不能基于临时节点来创建子节点，临时节点只能作为叶子节点。</p></li><li><p>临时顺序节点</p><p>同样在临时节点的基础上，加上了顺序的特性。</p></li></ul><p>事实上，每个数据节点除了存储了数据内容外，还存储了数据节点本身的一些状态信息，也就是Stat对象的输出。包括了事务ID，版本信息和子节点个数等信息。</p><h4 id="版本—保证分布式数据原子性操作"><a href="#版本—保证分布式数据原子性操作" class="headerlink" title="版本—保证分布式数据原子性操作"></a>版本—保证分布式数据原子性操作</h4><p>每个数据节点都具有三种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化，三种版本信息分别是version(当前数据节点数据内容的版本号)，cversion(当前数据节点子节点的版本号)，aversion(当前数据节点ACL变更版本号)</p><p>ZK中的吧版本概念表示的是对数据节点的数据内容，子节点列表，或是节点ACL信息的修改次数，即使前后两次变更并没有使得数据内容的值发生变化，version的值依然会变更。</p><hr><p>先看分布式领域中最常见的一个概念，锁</p><p>悲观锁，又被称作悲观并发控制，是数据库中一种非常典型且非常严格的并发控制策略，适合解决那些对于数据更新竞争十分激烈的场景</p><p>乐观锁，在更新事务提交之前，每个事务都会检查当前事务读取数据后，是否有其他事务对该数据进行了修改，若有其他事务更新的话，那么提交的事务就需要回滚，所以适合并发竞争不大，事务冲突较少的场景。</p><hr><p>ZK中，version属性正是用来实现乐观锁机制中的“写入校验”的，在ZK服务器的PreRequestProcessor 处理器类中，在处理每一个数据更新请求时，都会先对版本进行检查，获取当前请求的版本version,同时从数据记录nodeRecore中获取当前服务器上该数据的最新版本currentVersion。</p><h4 id="watcher-数据变更的通知"><a href="#watcher-数据变更的通知" class="headerlink" title="watcher 数据变更的通知"></a>watcher 数据变更的通知</h4><p>ZK提供了分布式数据的发布、订阅功能，一个典型的发布订阅模型系统定义了一种一对多的订阅关系，能够让多个订阅者同时监听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使他们能够做出相应的处理。ZK中，引入了watcher 这种分布式的通知机制，ZK允许客户端向服务端注册一个watcher监听，当服务端的一些指定事件触发了这个watcher，那么就会向指定客户端发送一个事件通知来实现分布式的通知功能，</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-07%20%E4%B8%8B%E5%8D%8810.34.58.png" alt=""></p><p>ZK的watcher机制主要包括客户端线程，客户端watcherManager，ZK服务器三部分，具体流程上，客户端在向ZK服务器注册watcher的同时，会将watcher对象存储在客户端的watcherManager中。当ZK服务器触发watcher事件后，会向客户端发送通知，客户端线程从watcherManager 中取出对应的Watcher 对象来执行回调逻辑。</p><p><strong>工作机制</strong></p><p>watcher机制，总的来说可以概括为以下三个过程，客户端注册Watcher，服务端处理Watcher和客户端回调watcher。</p><p><strong>特性</strong></p><p>一次性：一旦一个watcher被触发，ZK都会将其从对应的存储中移除。</p><p>客户端串行执行： 客户端watcher回调的过程是一个串行同步的过程，这保证了顺序。</p><p>轻量：网络开销和服务端内存开销都是非常廉价的。</p><h4 id="ACL-保障数据的安全"><a href="#ACL-保障数据的安全" class="headerlink" title="ACL 保障数据的安全"></a>ACL 保障数据的安全</h4><p>ZK提供了一套完整的ACL权限控制机制来保障数据的安全。</p><p>三个方面理解ACL机制，分别是“权限模式”，授权对象和权限，通常使用“<code>schema:id:permission</code> 来标识一个有效的ACL信息。</p><p><strong>权限模式</strong> 权限模式用来确定权限验证过程中使用的检验策略，有四种主要的权限模式，分别是IP，Digest(类似于username：password的形式）World,Super </p><p>IP模式指的是通过IP地址粒度来进行权限控制，例如配置了“ip:192.168.0.110”,即表示权限控制都是针对这个IP地址的，</p><p>Digest 是最常用的权限控制，其以类似于“username:password” 形式的权限标识来进行权限控制，便于区分不同应用来进行权限控制。</p><p>world 是最开放的一种权限控制模式，几乎没有任何作用，数据节点的访问权限对所有用户开放，即所有用户可以在不尽兴任何权限校验的情况下操作ZK上的数据。</p><p>Super 也就是超级用户，对ZK上的数据节点进行任何操作。</p><p><strong>授权对象：ID</strong>  授权对象指的是权限授予的用户或一个指定实体，</p><p><strong>权限 Permission</strong> 指通过权限检查后可以被允许执行的操作，有五大类，CREATE,DELETE,READ,WRITE,ADMIN</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 高可用性</title>
      <link href="/2018/07/07/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/"/>
      <url>/2018/07/07/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h2><p>高可用性意味着更少的宕机时间，通常以百分比表示，本身也是一种暗示，高可用性不是绝对的，只有相对更高的可用性，可用性的9规则是表示可用性最普遍的方法，5个9表示99.999%的正常可用时间，换句话说，每年只允许5分钟的宕机时间。</p><h4 id="导致宕机的原因"><a href="#导致宕机的原因" class="headerlink" title="导致宕机的原因"></a>导致宕机的原因</h4><p>首先对宕机事件按表现方式而非导致的原因进行分类，一般来说，“运行环境”是排名第一的宕机类别，大约35%的事件属于这一类，运行环境可以看作是支持数据库服务器运行的系统和资源集合，包括操作系统，硬盘以及网络等。性能问题紧随其后，也是占约35%，然后是复制，占20%，最后剩下的10%包括各种类型的数据丢失或损坏，以及其他问题。</p><p>下面是一些需要注意的地方</p><ul><li>在运行环境的问题中，最普遍的问题是磁盘空间耗尽</li><li>在性能问题中，最普遍的宕机原因是运行很糟糕的SQL,也有问题是服务器bug或错误的行为导致的。</li><li>糟糕的schema和索引设计是第二大影响性能的问题</li><li>复制问题通常由于主备数据不一致导致</li><li>数据丢失问题通常由于DROP TABLE 的误操作导致，并总是伴随着缺少可用备份的问题。</li></ul><p>复制虽然常被人用来改善可用时间，但却也可能导致宕机，主要由于不正确的使用导致的，也就是说，许多高可用策略可能会产生反作用。</p><h3 id="如何实现高可用性"><a href="#如何实现高可用性" class="headerlink" title="如何实现高可用性"></a>如何实现高可用性</h3><p>可以通过同时进行以下两步来获得高可用性，</p><p>首先，可以尝试避免导致宕机的原因来减少宕机时间，例如通过适当的配置，监控，以及规范或安全保障措施来避免人为错误，第二，尽量保证在发生宕机时能够快速恢复，最常见的策略是在系统中制造冗余，并且具备故障转移能力，这两个维度的高可用性可以通过两个相关的度量来确定，即平均失效时间MTBF和平均恢复时间MTTR.</p><p>其次，通过冗余快速恢复。</p><h4 id="提升平均失效时间MTBF"><a href="#提升平均失效时间MTBF" class="headerlink" title="提升平均失效时间MTBF"></a>提升平均失效时间MTBF</h4><p>对系统变更管理的缺失是所有导致宕机的事件中最普遍的原因，典型错误包括了粗心的升级导致升级失败并遭遇一些bug,或是尚未测试就将schema或查询语句的更改直接运行到线上。或是没有为一些失败的情况制定计划，另外一个导致问题的主要原因是缺少严格的监控，例如因为疏忽没有确认备份是否是可以恢复的。最后，可能是没有正确的监控MYSQL的相关信息。</p><h4 id="降低平均恢复时间"><a href="#降低平均恢复时间" class="headerlink" title="降低平均恢复时间"></a>降低平均恢复时间</h4><p>在降低恢复时间上进行投资非常重要，一个能够提供冗余和故障转移能力的系统架构，则是降低恢复时间的关键环节，但实现高可用不单单是一个技术问题，还有许多个人和组织的因素，组织和个人在避免宕机和从宕机事件中恢复的成熟度和能力层次各不相同。</p><p>团队成员是最重要的高可用资产，所以恢复制定一个好的流程非常重要，拥有熟练技能，应变能力，训练有素的雇员，以及处理应急事件的详细文档和经过仔细测试的流程，对从宕机恢复中有巨大的作用，但是也不能完全依赖工具和系统，因为他们并不能理解实际情况的细微差别。</p><h3 id="避免单点失效"><a href="#避免单点失效" class="headerlink" title="避免单点失效"></a>避免单点失效</h3><p>找到并消除系统中可能失效的单点，并结合切换到备用组件的机制，这是一种通过减少恢复时间来改善可用性的方法。</p><p>可以通过两种方法来为系统增加冗余：增加空余容量和重复组件。增加容量余量通常很简单，一个提升可用性的方法是创建一个集群或者服务器池，并使用负载均衡解决方案，如果一台服务器失效，其他服务器可以接管它的负载。</p><h4 id="共享存储或磁盘复制"><a href="#共享存储或磁盘复制" class="headerlink" title="共享存储或磁盘复制"></a>共享存储或磁盘复制</h4><p>共享存储能够为数据库服务器和存储解耦合，通常使用SAN，使用共享存储时，服务器能够正常挂载文件系统并进行操作。如果服务器挂了，备用服务器可以挂载相同的文件系统，执行需要的恢复操作，并在失效服务器的数据上启动MYSQL,这个过程在逻辑上跟修复那台故障的服务器没什么区别。</p><p>共享存储有两个优点，可以避免除存储外的其他任何组件失效所引起的数据丢失，并为非存储组件建立冗余提供可能。</p><p>说到底，共享存储和磁盘复制与其说是高可用性的解决方案，不如说是一种保证数据安全的方案，只要拥有数据，就可以从故障中恢复。</p><h4 id="MYSQL-同步复制"><a href="#MYSQL-同步复制" class="headerlink" title="MYSQL 同步复制"></a>MYSQL 同步复制</h4><p>当使用同步复制时，主库上的事务只有在至少一个备库上提交后才能认为其执行完成，这实现了两个目标，当服务器崩溃时没有提交的事务会丢失，并且至少有一个备库拥有实时的数据副本。大多数同步复制架构运行在主动-主动模型，这意味着每个服务器在任何时候都是故障转移的候选者，这使得通过冗余获得高可用更加容易。</p><h4 id="基于复制的冗余"><a href="#基于复制的冗余" class="headerlink" title="基于复制的冗余"></a>基于复制的冗余</h4><p>复制管理器是使用标准MYsql复制来创建冗余的工具。尽管可以通过复制来改善可用性，但也有一些“天花板”，会阻止MYSQL当前版本的异步复制和半同步复制获得和真正的同步复制相同的结果，复制无法保证实时的故障转移和数据零丢失，也无法将所有节点等同对待。</p><h3 id="故障转移和故障恢复"><a href="#故障转移和故障恢复" class="headerlink" title="故障转移和故障恢复"></a>故障转移和故障恢复</h3><p>冗余是很好的技术，但是实际上只有在遇到故障需要恢复时才会用到，冗余不会增加可用性或减少宕机，在故障转移的过程中，高可用性是建立在冗余的基础上，当有一个组件失效，但存在冗余时，可以停止使用发生故障的组件，而使用冗余备件，冗余和故障转移结合可以帮助更快的恢复。 故障转移是一个双向过程，当服务器A失效，服务器B替代它，在修复A后可以再替换回来。</p><p>故障转移比仅仅故障中恢复更好，当发生故障时可以根据计划进行故障转移来减少宕机时间。</p><p>需要确定故障转移到底有多快，也要知道在一次故障转移后替换一个失效组件应该多快，在你恢复系统耗尽的备件容量之前，会出现冗余不足，并面临额外风险。所以一个完全的故障转移解决方案至少能够监控并自动替换组件。</p><p>故障转移最重要的是故障恢复，如果服务器间不能自如切换，故障转移就是一个死胡同，只能是延缓宕机时间而已。下面是一些较普遍的故障转移技术。</p><h5 id="提升备库或者切换角色"><a href="#提升备库或者切换角色" class="headerlink" title="提升备库或者切换角色"></a>提升备库或者切换角色</h5><p>提升一台备库为主库，或者在一个主主复制结构中调换主动和被动角色。</p><h5 id="虚拟IP地址或IP接管"><a href="#虚拟IP地址或IP接管" class="headerlink" title="虚拟IP地址或IP接管"></a>虚拟IP地址或IP接管</h5><p>可以为需要提供特定服务的MYSQL实例指定一个逻辑IP地址，当MYSQL实例失效时，可以将IP地址转移到另一台MYSQL服务器上。</p><h5 id="中间件解决方案"><a href="#中间件解决方案" class="headerlink" title="中间件解决方案"></a>中间件解决方案</h5><p>可以使用代理，端口转发，网络地址转换NAT，或者硬件负载均衡来实现故障转移和故障恢复，<strong>这些都是很好的解决方案。</strong> 它们是控制应用和服务器间连接的中枢，但是，它们自身也引入了单点失效，需要准备冗余来避免这个问题。</p><h5 id="在应用中处理故障转移"><a href="#在应用中处理故障转移" class="headerlink" title="在应用中处理故障转移"></a>在应用中处理故障转移</h5><p>有时，让应用来处理故障转移会更简单或者更灵活，例如，如果应用遇到一个错误，这个错误外部观察者正常情况下是无法察觉的，例如关于数据库损坏的错误日志信息，应用可以自己来处理故障转移过程。</p><p>但是这种方法十分复杂，也十分笨拙。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reactor 模式</title>
      <link href="/2018/07/07/Reactor/"/>
      <url>/2018/07/07/Reactor/</url>
      
        <content type="html"><![CDATA[<h2 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><p>Reactor是一种广泛应用在服务器端开发的设计模式。</p><p>那么，Reactor模式究竟是个什么东西呢？这要从事件驱动的开发方式说起。对于应用服务器，一个主要规律就是，CPU的处理速度是要远远快于IO速度的，如果CPU为了IO操作（例如从Socket读取一段数据）而阻塞显然是不划算的。好一点的方法是分为多进程或者线程去进行处理，但是这样会带来一些进程切换的开销，试想一个进程一个数据读了500ms，期间进程切换到它3次，但是CPU却什么都不能干，就这么切换走了，是不是也不划算？</p><p>这时先驱们找到了事件驱动，或者叫回调的方式，来完成这件事情。这种方式就是，应用业务向一个中间人注册一个回调（event handler），当IO就绪后，就向这个中间人产生一个事件，并通知此handler进行处理。<em>这种回调的方式，也体现了“好莱坞原则”（Hollywood principle）-“Don’t call us, we’ll call you”，在我们熟悉的IoC中也有用到。看来软件开发真是互通的！</em></p><p>现在来看Reactor模式。在前面事件驱动的例子里有个问题：我们如何知道IO就绪这个事件，谁来充当这个中间人？Reactor模式的答案是：由一个不断等待和循环的单独进程（线程）来做这件事，它接受所有handler的注册，并负责先操作系统查询IO是否就绪，在就绪后就调用指定handler进行处理，这个角色的名字就叫做Reactor。</p><p>在reactor模式里，操作系统只负责通知IO就绪，具体的IO操作仍然是要在业务进程里阻塞的去做的。</p><h4 id="Reactor的各个模块"><a href="#Reactor的各个模块" class="headerlink" title="Reactor的各个模块"></a>Reactor的各个模块</h4><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-06%20%E4%B8%8B%E5%8D%8810.32.22.png" alt=""></p><p><strong>Handle</strong> 即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接（Connection，在Java NIO中的Channel）。这个Channel注册到<code>Synchronous Event Demultiplexer</code>中，以监听Handle中发生的事件，对ServerSocketChannnel可以是CONNECT事件，对SocketChannel可以是READ、WRITE、CLOSE事件等。</p><p><strong>Synchronous Event Demultiplexer</strong>：阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。在Java NIO中用Selector来封装，当Selector.select()返回时，可以调用Selector的selectedKeys()方法获取<code>Set&lt;SelectionKey&gt;</code>，一个SelectionKey表达一个有事件发生的Channel以及该Channel上的事件类型。</p><p><strong>Initiation Dispatcher</strong>：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。</p><p><strong>Event Handler</strong>：定义事件处理方法：handle_event()，以供InitiationDispatcher回调使用。<br><strong>Concrete Event Handler</strong>：事件EventHandler接口，实现特定事件处理逻辑。</p><p>以读操作为例来看看Reactor中的具体步骤</p><p>读取操作：<br>1应用程序注册读就绪事件和相关联的事件处理器</p><p>2 事件分离器等待事件的发生</p><p>3当发生读就绪事件的时候，事件分离器调用第一步注册的事件处理器</p><p>4 事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理。</p><p><strong>使用同步IO来模拟Reactor模式的流程如下：</strong><br>1 主线程首先将socket的读就绪事件注册到epoll内核注册表中。</p><p>2 主线程调用epoll_wait 等待socket的读就绪事件</p><p>3epoll 返回就绪的socket（socket上有数据可读）并通知主线程，主线程将该socket读就绪事件放入到请求队列中。</p><p>4 睡眠在请求队列中的某个工作线程被唤醒，处理该socket读就绪事件，处理完成后，将该socket的写就绪事件注册到epoll内核注册表中。</p><p>5 主线程调用epoll_wait等待socket的写就绪事件</p><p>6 当socket可写时,通知主线程，主线程将写就绪socket放入请求队列</p><p>7睡眠在请求队列的工作线程被唤醒，处理该socket写事件。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海量数据处理</title>
      <link href="/2018/07/04/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2018/07/04/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h2><p>海量数据一般指数据量大，无法再较短时间内解决，或者无法一次性装入内存。</p><p>解决方法有两个方面，针对时间，可以用巧妙的算法配合合适的数据结构，如Bloom filter /Hash /Bit-map / 堆 / 数据库 或倒排索引 / trie 树</p><p>针对空间，就一个办法，大而化小，分而治之。</p><h4 id="从set-map到hashtable-hash-map-hash-set"><a href="#从set-map到hashtable-hash-map-hash-set" class="headerlink" title="从set/map到hashtable/hash_map/hash_set"></a>从set/map到hashtable/hash_map/hash_set</h4><p>一般来说，STL容器分为两种，序列式容器（vector，list, queue等）</p><p>关联式容器（set，map）。</p><p>关联式容器，类似关联式数据库，每笔数据或每个元素都有一个键值和实值，当元素被插入到关联式容器中时，容器内部结构(RB-tree/hashtable)便依照其键值大小，以某种特定规则将这个元素放置于适当位置。</p><h3 id="六把密钥"><a href="#六把密钥" class="headerlink" title="六把密钥"></a>六把密钥</h3><h4 id="分而治之-Hash映射-Hash-map统计-堆-快速-归并排序"><a href="#分而治之-Hash映射-Hash-map统计-堆-快速-归并排序" class="headerlink" title="分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序"></a>分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序</h4><p><strong>1、海量日志数据，提取出某日访问百度次数最多的那个IP。</strong></p><p>   先映射，而后统计，最后排序：</p><ol><li>分而治之/hash映射：针对数据太大，内存受限，只能是：把大文件化成(取模映射)小文件，即16字方针：大而化小，各个击破，缩小规模，逐个解决</li><li>hash_map统计：当大文件转化了小文件，那么我们便可以采用常规的hash_map(ip，value)来进行频率统计。</li><li><p>堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。</p><p>具体而论，则是： “首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如%1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map对那1000个文件中的所有IP进行频率统计，然后依次找出各个文件中频率最大的那个IP）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。</p><p><strong>2、寻找热门查询，300万个查询字符串中统计最热门的10个查询</strong></p></li></ol><p>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p><p>​    解答：由上面第1题，我们知道，数据大则划为小的，如如一亿个Ip求Top 10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结。</p><p>​    但如果数据规模比较小，能一次性装入内存呢?比如这第2题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去（300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理），而现在只是需要一个合适的数据结构，在这里，HashTable绝对是我们优先的选择。</p><p>​    所以我们放弃分而治之/hash映射的步骤，直接上hash统计，然后排序。所以，<strong>针对此类典型的TOP K问题，采取的对策往往是：hashmap + 堆。</strong>如下所示：</p><ol><li>hash_map统计：先对这批海量数据预处理。具体方法是：维护一个Key为Query字串，Value为该Query出现次数的HashTable，即hash_map(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计；</li><li>堆排序：第二步、借助堆这个数据结构，找出Top K，<strong>时间复杂度</strong>为N‘logK（N’个数，每个数最多移动logK次到自己的位置）。<strong>即借助堆结构，我们可以在log量级的时间内查找和调整/移动</strong>。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是：O（N） + N’ * O（logK），（N为1000万，N’为300万）。</li></ol><p>​    这篇文章中所述的堆排序思路：“维护k个元素的最小堆，即用容量为k的最小堆存储最先遍历到的k个数，并假设它们即是最大的k个数，建堆费时O（k），并调整堆(费时O（logk）)后，有k1&gt;k2&gt;…kmin（kmin设为小顶堆中最小元素）。继续遍历数列，每次遍历一个元素x，与堆顶元素比较，若x&gt;kmin，则更新堆（x入堆，用时logk），否则不更新堆。这样下来，总费时O（k<em>logk+（n-k）</em>logk）=O（n*logk）。此方法得益于在堆中，查找等各项操作时间复杂度均为logk。”-<br>    当然，你也可以采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p><p><strong>3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</strong><br>       由上面那两个例题，分而治之 + hash统计 + 堆/快速排序这个套路，请看此第3题：又是文件很大，又是内存受限，无非还是：</p><ol><li>分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。</li><li>hash_map统计：对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。</li><li>堆/归并排序：取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。</li></ol><p><strong>4、海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</strong></p><p>​    如果每个数据元素只出现一次，而且只出现在某一台机器中，那么可以采取以下步骤统计出现次数TOP10的数据元素：</p><ol><li>堆排序：在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆，比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大）。</li><li>求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。</li></ol><p>如果同一个元素重复出现在不同的电脑中，可以遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，统计每台电脑中各个元素的出现次数找出TOP10，继而组合100台电脑上的TOP10，找出最终的TOP10。</p><p><strong>5、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</strong></p><p>   方案1：直接上：</p><ol><li>hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为a0,a1,..a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。</li><li>hash_map统计：找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。</li><li>堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序，将排序好的query和对应的query_cout输出到文件中，这样得到了10个排好序的文件（最后，对这10个文件进行归并排序（内排序与外排序相结合）。</li></ol><p>​     除此之外，此题还有以下两个方法：</p><p>​    方案2：一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。</p><p>​    方案3：与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p><p><strong>6、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</strong></p><p>​    <strong>方案</strong>1（都做哈希，两个相同的哈希可能相同，不同的一定不会相同）：可以估计每个文件的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p><p>遍历文件a，对每个url求取hash(url)00，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。</p><p>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</p><p>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</p><p>方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</p><p><strong>7、怎么在海量数据中找出重复次数最多的一个？</strong></p><p>​    方案：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p><p><strong>8、上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</strong></p><p>​    方案：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后利用堆取出前N个出现次数最多的数据。</p><p><strong>9、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</strong></p><p>​    方案1：如果文件比较大，无法一次性读入内存，可以采用hash取模的方法，将大文件分解为多个小文件，对于单个小文件利用hash_map统计出每个小文件中10个最常出现的词，然后再进行归并处理，找出最终的10个最常出现的词。</p><p>​    方案2：通过hash取模将大文件分解为多个小文件后，除了可以用hash_map统计出每个小文件中10个最常出现的词，也可以用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平准长度），最终同样找出出现最频繁的前10个词（可用堆来实现），时间复杂度是O(n</em>lg10)。</p><h3 id="多层划分"><a href="#多层划分" class="headerlink" title="多层划分"></a>多层划分</h3><p>本质还是分而治之，重在“分”的技巧上。</p><p>适用范围：第k大，中位数，不重复或重复的数字<br>　　基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。</p><p><strong>11、2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</strong><br>    有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</p><p><strong>12、5亿个int找它们的中位数。</strong></p><ol><li>思路一：这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。<br>实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。</li></ol><h3 id="布隆过滤器-、bitmap"><a href="#布隆过滤器-、bitmap" class="headerlink" title="布隆过滤器 、bitmap"></a>布隆过滤器 、bitmap</h3><p>适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集</p><p>　　基本原理及要点：</p><p>　　对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。</p><p>　　还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)<em>(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于n</em>lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。</p><p>　　举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。</p><p>　　注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。</p><p>　　扩展：</p><p>　　Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。</p><p>   可以看下上文中的第6题：</p><p><strong>6、给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？</strong></p><p>　　根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。</p><p>​    同时，上文的第5题：给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。”</p><p><strong>13、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</strong></p><p>​    方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p><p><strong>15、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</strong><br>    方案1：frome oo，用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p><p>方案2：**！！！！<br>因为2^32为40亿多，所以给定一个数可能在，也可能不在其中；<br>这里我们把40亿个数中的每一个用32位的二进制来表示<br>假设这40亿个数开始放在一个文件中。</p><p>然后将这40亿个数分成两类:<br>1.最高位为0<br>2.最高位为1<br>并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=20亿，而另一个&gt;=20亿（这相当于折半了）；<br>与要查找的数的最高位比较并接着进入相应的文件再查找</p><p>再然后把这个文件为又分成两类:<br>1.次最高位为0<br>2.次最高位为1</p><p>并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=10亿，而另一个&gt;=10亿（这相当于折半了）；<br>与要查找的数的次最高位比较并接着进入相应的文件再查找。<br>…….<br>以此类推，就可以找到了,而且时间复杂度为O(logn)，方案2完。</p><h3 id="Trie树-数据库-倒排索引"><a href="#Trie树-数据库-倒排索引" class="headerlink" title="Trie树/数据库/倒排索引"></a>Trie树/数据库/倒排索引</h3><p><strong>Trie树</strong></p><p>　　适用范围：数据量大，重复多，但是数据种类小可以放入内存<br>　　基本原理及要点：实现方式，节点孩子的表示方式<br>　　扩展：压缩实现。<br>　　问题实例：</p><ol><li>上面的<strong>第2题</strong>：寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。</li><li>上面的<strong>第5题</strong>：有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。</li><li>1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？</li><li>上面的<strong>第8</strong>题：一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词。其解决方法是：用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度），然后是找出出现最频繁的前10个词。</li></ol><p><strong>数据库索引</strong><br>　　适用范围：大数据量的增删改查<br>　　基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</p><p><strong>倒排索引(Inverted index)</strong><br>　　适用范围：搜索引擎，关键字查询<br>　　基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。<br>　以英文为例，下面是要被索引的文本：<br>    T0 = “it is what it is”<br>    T1 = “what is it”<br>    T2 = “it is a banana”<br>    我们就能得到下面的反向文件索引：<br>    “a”:      {2}<br>    “banana”: {2}<br>    “is”:     {0, 1, 2}<br>    “it”:     {0, 1, 2}<br>    “what”:   {0, 1}<br>　检索的条件”what”,”is”和”it”将对应集合的交集。<br>　　正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。<br>　　扩展：<br>　　问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。</p><h3 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h3><p>适用范围：大数据的排序，去重<br>　　基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树<br>问题实例：<br>　　1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。<br>　　这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1M做hash明显不够，所以可以用来排序。内存可以当输入缓冲区使用。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BitMap</title>
      <link href="/2018/07/04/Bitmap/"/>
      <url>/2018/07/04/Bitmap/</url>
      
        <content type="html"><![CDATA[<h2 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h2><p>所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p><p>假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0(如下图：)</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8B%E5%8D%888.49.50.png" alt=""></p><p>然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 p+(i/8)|(0×01&lt;&lt;(i%8)) 当然了这里的操作涉及到Big-ending和Little-ending的情况，这里默认为Big-ending）,因为是从零开始的，所以要把第五位置为一：然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态如下：</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8B%E5%8D%888.52.24.png" alt=""></p><p>然后我们现在遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的</p><h4 id="基本原理及要点"><a href="#基本原理及要点" class="headerlink" title="基本原理及要点"></a>基本原理及要点</h4><p>使用bit数组来表示某些元素是否存在，比如8位电话号码</p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>Bloom filter可以看做是对bit-map的扩展.</p><h4 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h4><p><strong>1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。</strong></p><p>​    8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。 （可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话）</p><p><strong>2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</strong></p><p>​    将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上，在遍历这些数的时候，如果对应位置的值是0，则将其置为1；如果是1，将其置为2；如果是2，则保持不变。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map，都是一样的道理。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper应用场景</title>
      <link href="/2018/06/28/Zookeeperd%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2018/06/28/Zookeeperd%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="ZooKeeper-典型运用场景"><a href="#ZooKeeper-典型运用场景" class="headerlink" title="ZooKeeper 典型运用场景"></a>ZooKeeper 典型运用场景</h2><p>基于ZAB 算法的实现，zk 可以很好的保证分布式环境中数据的一致性。</p><h3 id="数据发布-订阅"><a href="#数据发布-订阅" class="headerlink" title="数据发布/订阅"></a>数据发布/订阅</h3><p>发布者将数据发布到zk 的一个或者一系列节点上，供订阅者进行数据订阅。进而达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。</p><p>Zookeeper 采用推拉相结合的方式，客户端向服务端注册自己需要关注的节点，一旦该节点发生数据变更，那么服务端就会向相应的客户端发送watcher 事件通知，客户端接收到这个消息通知之后，需要主动到服务端获取最新的数据。</p><p>如果将配置信息存放到zookeeper上进行集中管理，那么通常情况下，应用在启动的时候会主动到zk服务端进行配置信息的获取，同时，在指定节点上注册一个watcher 监听，这样一来，但凡配置信息发生变更，服务端都会实时通知到所有订阅的客户端，从而达到实时获取最新配置信息的目的。</p><h3 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h3><p>分布式系统中，被命名的实体通常可以是集群中的机器，提供的服务地址或远程对象等，这些都可以统称为名字，其中较为常见的就是分布式服务框架中的服务地址列表，通过使用命名服务，客户端能够根据指定名字来获取资源的实体，服务地址和提供者的信息。</p><p>下面使用zk 实现一套分布式全局唯一ID的分配机制。</p><p>随着分库分表的实现，无法依靠数据库的auto_increment 属性来唯一标识一条记录了，</p><p>常见的实现由UUID, 包含32位字符和4个短线的字符串。然而缺点是长度过长，含义不明。</p><p>通过调用zk节点创建的API接口可以创建一个顺序节点，并且在API返回值中返回这个节点的完整名字。利用这个特性，就可以借助zk 生成全局ID.</p><p>步骤是1 所有客户端根据自己任务类型，在指定类型的任务下面通过调用create() 接口来创建一个顺序节点，2 节点创建完毕后，create()节点会返回一个完整的节点名，3 客户端拿到返回值，拼上type ,就是全局唯一ID.</p><h3 id="分布式协调-通知"><a href="#分布式协调-通知" class="headerlink" title="分布式协调/通知"></a>分布式协调/通知</h3><p>分布式协调通知服务是分布式系统中不可缺少的一个环节，是将不同分布式组件有机结合的关键，基于ZK实现的分布式协调/通知功能，通常做法是不同的客户端都对zk上同一个数据节点进行watcher 注册，监听数据节点的变化，如果数据发生变化，那么所有订阅的客户端都会接收到相应的watcher 通知，并作出相应的处理。</p><h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p>集群管理包括集群监控和集群控制两大块，劝着侧重对集群运行时状态的收集，后者则是对集群进行操作与控制。基于ZK的实现方法是监控系统在/clusterServers 节点上注册一个watcher监听，那么但凡动态添加的机器的操作，就会在/clusterserver节点下创建一个临时节点，这样一来，监控系统就能够实时监测到机器的变动情况。后续处理就是监控系统的业务了。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式，如果不同的系统或者同一个系统的不同主机之间共享了同一个或一组资源，那么访问这个资源的时候，往往需要一些互斥手段来防止彼此的干扰，以保证一致性，这种情况下，就需要分布式锁了。</p><h4 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h4><p>简称X锁，又称为写锁或者独占锁，如果事务T1 对数据对象O1 加上了排它锁，那么在整个加锁期间，只允许事务T1对O1进行读取和更新操作。即排它锁的核心是保证当前有且一个事务获得锁，并且锁被释放后，所有正在等待获取锁的事务都能被通知到。</p><p><strong>定义锁</strong> 通过ZK上的数据节点来表示一个锁 例如/exclusive/lock</p><p><strong>获取锁</strong> 需要获取排他锁时，所有客户端都会试图调用create()接口，创建临时子节点/exclusive/lock 。ZK会保证客户端中，最终只有一个客户端能够创建成功，那么久认为该客户端获取了锁，同时，没有获取到锁的客户端就需要到/exclusive节点上注册一个子节点变更的watcher监听，以便实时监听lock节点的变更情况。</p><p><strong>释放锁</strong> 获取锁的客户端发生宕机，正常执行完业务逻辑后，都会将临时节点删除。都会释放锁。无论什么情况下移除了lock,zk会通知所有在/exclusive 节点上注册了子节点变更watcher监听的客户端。这些客户端接收到通知后，会重新发起分布式锁获取。</p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>与排它锁的根本区别在于，加排它锁后，数据对象只对一个事务可见，加共享锁后，数据对所有事务都可见。</p><p><strong>定义锁</strong>：也是通过zk上一个数据节点来表示一个锁，是一个类似/shared/[hostname]-请求类型-序号 的临时顺序节点。（shared 表示一个共享锁）</p><p><strong>获取锁</strong> 当需要获取共享锁时，所有客户端都回到/shared/ 这个节点下面创建一个临时顺序节点，如果是读请求，就创建/shared/192.168.0.1-R-00001 写的话就创建/shared/192.168.0.1-W-00001的节点</p><p><strong>判断读写顺序</strong></p><p>根据共享锁定义，不同事务都可以同时对同一个数据对象进行读取操作，而更新操作必须在当前没有任何事务进行读写操作的情况下进行。下面通过ZK来确定分布式读写顺序。</p><ul><li>创建完节点后，获取/shared/节点下所有子节点，并对该节点注册子节点变更的watcher监听。</li><li>确定自己节点序号在所有子节点中的顺序</li><li>对读请求，如果没有比自己序号小的子节点，或是所有比自己序号小的子节点都是读请求，那么表明自己已经成功获取共享锁，如果有比自己序号小的子节点有写请求，那么需要进行等待。对写来说，如果自己不是需要最小的子节点，就需要进入等待。</li><li>接收到watcher 通知后，重复步骤1。</li></ul><p><strong>释放锁</strong></p><h3 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h3><p>分为两类，一种是常规的先入先出队列，另一种是等到队列元素集聚之后才统一安排执行的Barrier 模型。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper进阶</title>
      <link href="/2018/06/28/zookeeper%E8%BF%9B%E9%98%B6/"/>
      <url>/2018/06/28/zookeeper%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Zookeeper-进阶"><a href="#Zookeeper-进阶" class="headerlink" title="Zookeeper 进阶"></a>Zookeeper 进阶</h2><p>zookeeper 是一个开放源代码的分布式协调服务，设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><p>分布式程序可以基于zookeeper 实现诸如 数据发布订阅，负载均衡，命名服务，分布式协调、通知，集群管理 Master选举，分布式锁，分布式队列等功能。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>集群角色</strong>：zookeeper 中，没有传统的主从概念，引入了leader，follower，observer 三种角色。zookeeper集群中所有机器通过一个leader 选举过程来选定一台被称为leader的机器，leader服务器为客户端提供读和写服务。除了leader外，还包括follower和observer，他们都能够提供服务，唯一的区别是observer 不参与leader选举过程，也不参与写操作的”过半写成功”策略，因此observer可以在不影响写性能的情况下提升集群的读性能。</p><p><strong>会话（sesseion）</strong>： session 指客户端会话。在zk中，一个客户端连接是指客户端和服务端之间的一个TCP长连接，客户端启动时，首先与服务器建立一个TCP连接，从第一次建立连接开始，客户端的生命周期就开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向zk服务器发送请求并接受相应，同时还能够通过该连接接收来自服务器的watcher事件通知。</p><p><strong>数据节点znode</strong>: zookeeper将所有数据存储在内存中，数据模型是一颗树，由斜杠分割的路径，就是一个Znode 每个Znode 都会保存自己的数据内容，同时还会保存一系列的属性信息。zk中，数据节点分为持久节点和临时节点两种，持久节点就是一旦创建，除非主动进行移除工作，否则znode会一直保存在zk上，而临时节点不一样，它的生命周期和客户端会话绑定，一旦客户端会话失败，那么这个客户端创建的临时节点也会被移除。</p><p><strong>版本：</strong>对于每个znode，zk 都会为其维护一个叫stat的数据结构，stat 记录了这个Znode 的三个数据版本，分别是当前znode版本，当前znode 子节点版本，当前znode acl版本。</p><p><strong>watcher</strong> 即事件监听器，是zookeeper 中一个很重要的特性，允许用户在指定节点上注册一些watcher ，并且在一些特定事件触发的时候，zk 服务端会将事件通知到感兴趣的客户端上，该机制是zK 实现分布式协调服务的重要特性。</p><p><strong>ACL</strong></p><p>采用ACL 策略进行权限控制，定义了五种权限，</p><p>CREATE 创建子节点的权限</p><p>READ 获取节点数据和子节点列表的权限</p><p>WRITE 更新节点数据的权限</p><p>DELETE 删除子节点的权限</p><p>ADMIN 设置节点ACL的权限</p><h4 id="ZK-的ZAB-协议"><a href="#ZK-的ZAB-协议" class="headerlink" title="ZK 的ZAB 协议"></a>ZK 的ZAB 协议</h4><p>Zookeeper Atomic Broadcast zk 原子消息广播协议。 作为其数据一致性的核心算法。</p><p>是为zk专门设计的一种支持奔溃恢复的原子关闭协议。</p><p>zk中，主要依赖ZAB协议来实现分布式数据一致性。基于该协议，zk实现了一种主备模式的系统架构来保持集群中各副本之间的数据一致性。</p><p>具体来说，zk使用一个单一的主进程来接受并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更以事务proposal的形式广播到所有的副本进程上去，ZAB的这个主备模型架构保证了同一时刻集群中只有一个主进程来广播服务器的状态变更，因此能够很好的处理客户端大量的并发请求。</p><p>ZAB协议包括两种基本的模式，分别是崩溃恢复和消息广播，当服务框架启动过程中，或者是当leader服务器出现网络中断，奔溃退出或者重启等异常状况时，ZAB就会进入恢复模式并选举出新的leader服务器。当选举出leader服务器并且集群中已经有过半的机器与该leader服务器完成了状态同步之后，ZAB就会退出恢复模式，其中，状态同步就是指数据同步。</p><p>当集群中有过半follower完成了与leader的状态同步后，整个服务框架就可以进入消息广播模式了，当一台同样遵守ZAB的服务器启动加入集群中时，如果集群中已经存在一个leader进行广播，新加入的服务器就会自觉地进入数据恢复模式，即找到leader服务器，并与其进行数据同步，然后一起参与到消息广播流程中。</p><p>当leader服务器出现崩溃或者重启，或者集群中已经不存在过半的服务器与该leader服务器保持正常通信时，那么在重新开始新一轮的原子广播事务操作之前，所有进程会首先使用崩溃协议来使彼此达到一个一致的状态，ZAB流程会从消息广播模式进入崩溃恢复阶段。</p><h5 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h5><p>消息广播使用的是原子广播协议，类似一个二阶段提交过程，针对客户端的事务请求，leader服务器会为其生成对应的事务proposal,并将其发送给集群中其余所有机器，然后再分别收集各自的选票，最后进行事务提交。<strong>即先发送propose，受到半数Ack，然后再发送commit 进行提交。</strong></p><p>在整个消息广播过程中，leader 服务器会为每个事务请求生成对应的proposal来进行广播，并且在广播事务proposal之前，leader服务器会首先为这个事务proposal分配一个全局递增的唯一ID，称之为事务ID. 由于ZAB还要保证消息严格的因果关系，因此必须将每个事务proposal按照其事务ID的先后顺序排序与处理。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-27%20%E4%B8%8A%E5%8D%889.22.44.png" alt=""></p><h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><p>一旦leader服务器出现崩溃，或者网络原因导致leader 服务器失去了与过半follower 的联系，就会进入崩溃恢复模式，在ZAB协议中，为了保证程序正确运行，整个恢复过程结束后需要选举一个新的leader 服务器。因此，ZAB需要一个高效可靠的leader选举算法。</p><p>leader选举算法应该能够确保提交已经被leader提交的事务proposal，同时丢弃已经被跳过的事务proposal。</p><p>针对这个要求，如果让leader选举算法能够保证新选举出来的leader 服务器拥有集群中所有机器最高编号的事务proposal ，那么就可以保证这个新选举的leader一定具有所有已经提交的提案，更为重要的是，如果让具有最高编号事务proposal 的机器来成为leader，就可以省去leader 服务器检查proposal 的提交和丢弃工作的这一步操作了。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean的生命周期</title>
      <link href="/2018/06/26/Spring%20Bean%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/06/26/Spring%20Bean%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h2><p>对于普通的Java对象，当new的时候创建对象，当它没有任何引用的时候被垃圾回收机制回收。而由Spring IoC容器托管的对象，它们的生命周期完全由容器控制。Spring中每个Bean的生命周期如下：</p><p><img src="https://pic1.zhimg.com/80/v2-baaf7d50702f6d0935820b9415ff364c_hd.jpg" alt="img"></p><h4 id="1-实例化Bean"><a href="#1-实例化Bean" class="headerlink" title="1. 实例化Bean"></a>1. 实例化Bean</h4><p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。<br>对于ApplicationContext容器，当容器启动结束后，便实例化所有的bean。<br><strong>容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入</strong>。<br>实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</p><h4 id="2-设置对象属性（依赖注入）"><a href="#2-设置对象属性（依赖注入）" class="headerlink" title="2. 设置对象属性（依赖注入）"></a>2. 设置对象属性（依赖注入）</h4><p>实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。<br>紧接着，Spring根据BeanDefinition中的信息进行依赖注入。<br>并且通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><h4 id="3-注入Aware接口"><a href="#3-注入Aware接口" class="headerlink" title="3. 注入Aware接口"></a>3. 注入Aware接口</h4><p>紧接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean。</p><h4 id="4-BeanPostProcessor"><a href="#4-BeanPostProcessor" class="headerlink" title="4. BeanPostProcessor"></a>4. BeanPostProcessor</h4><p>当经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。<br>该接口提供了两个函数：</p><ul><li>postProcessBeforeInitialzation( Object bean, String beanName )<br>当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。<br>这个函数会先于InitialzationBean执行，因此称为前置处理。<br>所有Aware接口的注入就是在这一步完成的。</li><li>postProcessAfterInitialzation( Object bean, String beanName )<br>当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。<br>这个函数会在InitialzationBean完成后执行，因此称为后置处理。</li></ul><h4 id="5-InitializingBean与init-method"><a href="#5-InitializingBean与init-method" class="headerlink" title="5. InitializingBean与init-method"></a>5. InitializingBean与init-method</h4><p>当BeanPostProcessor的前置处理完成后就会进入本阶段。<br>InitializingBean接口只有一个函数：</p><ul><li>afterPropertiesSet()</li></ul><p>这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。<br>若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet函数。</p><p>当然，Spring为了降低对客户代码的侵入性，给bean的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring便会在<strong>初始化阶段</strong>执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。</p><h4 id="6-DisposableBean和destroy-method"><a href="#6-DisposableBean和destroy-method" class="headerlink" title="6. DisposableBean和destroy-method"></a>6. DisposableBean和destroy-method</h4><p>和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>343***. Integer Break</title>
      <link href="/2018/05/26/leetcode343/"/>
      <url>/2018/05/26/leetcode343/</url>
      
        <content type="html"><![CDATA[<h2 id="Leetcode343-Integer-Break"><a href="#Leetcode343-Integer-Break" class="headerlink" title="Leetcode343 Integer Break"></a>Leetcode343 Integer Break</h2><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a positive integer <em>n</em>, break it into the sum of <strong>at least</strong> two positive integers and maximize the product of those integers. Return the maximum product you can get.</p><p>For example, given <em>n</em> = 2, return 1 (2 = 1 + 1); given <em>n</em> = 10, return 36 (10 = 3 + 3 + 4).</p><p>**</p><p>Note*<em>: You may assume that </em>n* is not less than 2 and not larger than 58.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter" target="_blank" rel="noopener">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>给定一个正数n,可以将其分割成多个数字的和，若要让这些数字的乘积最大，求分割的方法（至少要分成两个数）。算法返回这个最大的乘积。</p><h4 id="解法1-记忆化搜索"><a href="#解法1-记忆化搜索" class="headerlink" title="解法1 记忆化搜索"></a>解法1 记忆化搜索</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> vec[<span class="number">60</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Break</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(vec[n]!=<span class="number">0</span>) <span class="keyword">return</span> vec[n];</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res =max(max(res,i*Break(n-i)),i*(n-i));</span><br><span class="line">            <span class="comment">// i*(n-i)是不对后面(n-i)进行分割，i*Break(n-i)是对后面(n-i)进行再分割。</span></span><br><span class="line">        &#125;</span><br><span class="line">        vec[n]=res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> Break(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><p>使用记忆化搜索的方法，也就是暴力回溯加数组的方法，首先要求n的乘积最大，则</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-26%20%E4%B8%8B%E5%8D%888.24.19.png" alt=""></p><p>不断的从1开始分割。</p><ul><li>动态规划法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> vec[<span class="number">60</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Break</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//vec[i]代表表示将数字i分割(至少两份)后得到的最大乘积。</span></span><br><span class="line">        vec[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                vec[i]= max(max(vec[i],j*(i-j)),j*vec[i-j]);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> Break(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>上面用一个二重循环的动态规划进行求解。</p><p>首先memo[1]表示1的最大乘积。</p><p>那么memo[2] 就等于<code>max3(memo[2],1*1,1*memo[1])</code></p><p>首先第一层的循环是通过memo[1]得到memo[2]，通过memo[2]得到memo[3] ,通过memo[3]得到memo[4]等等。</p><p>里面的第二层循环是为了求把memo[i]分成<code>1,i-1</code>,<code>2,i-2</code>,<code>3,i-3</code>等等，然后找出他们的最大值。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FloodFill 算法（leetcode200）</title>
      <link href="/2018/05/26/FloodFill%20%E7%AE%97%E6%B3%95/"/>
      <url>/2018/05/26/FloodFill%20%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="FloodFill-算法（leetcode200）"><a href="#FloodFill-算法（leetcode200）" class="headerlink" title="FloodFill 算法（leetcode200）"></a>FloodFill 算法（leetcode200）</h2><p>给定一个二维数组，只含有0和1两个字符，其中1代表陆地，0代表水域，横向和纵向的陆地连接成岛屿，被水域分隔开。问给出的地图中有多少岛屿。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-26%20%E4%B8%8B%E5%8D%887.21.39.png" alt=""></p><p>想象上面是一个地图，棕色的是陆地，蓝色的是海洋，现在滴一滴墨水到第一个点，然后墨水蔓延到小岛的所有地方。</p><p><strong>其实求岛屿就是对所有点进行一次深度优先遍历</strong>。对于每个点，一旦没有访问过而且也是陆地的话就也对它进行标记。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isArea</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从grid[x][y]的位置开始，进行floodfill.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x,<span class="keyword">int</span>  y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[x][y]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> newx =x+d[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> newy =y+d[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(isArea(newx,newy)&amp;&amp;!visit[newx][newy]&amp;&amp;grid[newx][newy]==<span class="string">'1'</span>)<span class="comment">//递归终止条件包含在if条件中。</span></span><br><span class="line">        &#123;</span><br><span class="line">            dfs(grid,newx,newy);</span><br><span class="line">            <span class="comment">//因为要floodfill，所以这visit是不用回溯的。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numberisland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m=grid.size();</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    n=grid.size();</span><br><span class="line">    visited =<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt;(m,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">int</span> res =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>&amp;&amp; !visited[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                dfs(grid,i,j); <span class="comment">//floodfill</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YAML学习笔记</title>
      <link href="/2018/05/25/YAML%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/25/YAML%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="YAML-学习笔记"><a href="#YAML-学习笔记" class="headerlink" title="YAML 学习笔记"></a>YAML 学习笔记</h2><p>YAML 是专门用来写配置文件的语言，非常的简洁和强大，远比JSON格式要方便。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>YAML是一种通用的数据串行化格式。它的基本语法规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">大小写敏感</span><br><span class="line">使用缩进表示层级关系</span><br><span class="line">缩进时不允许使用Tab键，只允许使用空格。</span><br><span class="line">缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</span><br></pre></td></tr></table></figure><p><code>#</code>表示注释，从这个字符一直到行尾，都会被解析器所忽略。</p><p>YAML 支持的数据结构有三种，分别是对象（键值对的集合，又称为映射，哈希，字典）。数组（一组按次序排列的值，又称为序列，列表）。纯量（单个的，不可再分的值）。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象的一组键值对，使用冒号结构来表示</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">pets</span></span><br></pre></td></tr></table></figure><p>yaml也允许另外一种写法，将所有的键值对写成一个行内对象。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hash:</span> <span class="string">&#123;name:</span> <span class="string">Stave,</span> <span class="attr">foo:</span> <span class="string">bar&#125;</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一组连词线开头的行，构成了一个数组。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">goldfish</span></span><br></pre></td></tr></table></figure><p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">goldfish</span></span><br></pre></td></tr></table></figure><h3 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h3><p>对象和数组可以结合使用，形成复合结构。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">languages:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Ruby</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Perl</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Python</span></span><br><span class="line"><span class="attr">websites:</span></span><br><span class="line"><span class="attr"> YAML:</span> <span class="string">yaml.org</span></span><br><span class="line"><span class="attr"> RUBY:</span> <span class="string">ruby-lang.org</span></span><br><span class="line"><span class="attr"> Python:</span> <span class="string">python.org</span></span><br><span class="line"><span class="attr"> Perl:</span> <span class="string">use.perl.org</span></span><br></pre></td></tr></table></figure><h3 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h3><p>纯量是最基本的，不可再分的值，以下数据类型都属于JS中的纯量。</p><p>字符串，布尔值，整数，浮点数，Null, 时间 日期。</p><p>数字直接以字面量的形式表示</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">number:</span> <span class="number">12.30</span></span><br></pre></td></tr></table></figure><p>布尔值用 true和false 表示</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">isSet:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>Null</code> 用<code>~</code>表示</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">parent:</span> <span class="string">~</span></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串默认是不使用引号的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">str:</span> <span class="string">这是一行字符串</span></span><br></pre></td></tr></table></figure><p>如果字符串之中包含空格或者特殊字符，需要放在引号之中（单双引号都可)。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">str:</span> <span class="string">'内容： 字符串'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yaml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MiniKube和Kubectl</title>
      <link href="/2018/05/24/minikube/"/>
      <url>/2018/05/24/minikube/</url>
      
        <content type="html"><![CDATA[<h2 id="MiniKube和Kubectl"><a href="#MiniKube和Kubectl" class="headerlink" title="MiniKube和Kubectl"></a>MiniKube和Kubectl</h2><p>Minikube is a lightweight Kubernetes implementation that creates a VM on your local machine and deploys a simple cluster containing only one node. </p><p>The Minikube CLI provides basic bootstrapping operations for working with your cluster, including start, stop, status, and delete.</p><h4 id="start-a-minikube"><a href="#start-a-minikube" class="headerlink" title="start a minikube"></a>start a minikube</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> minikube version</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> minikube start</span></span><br></pre></td></tr></table></figure><h4 id="cluster-info"><a href="#cluster-info" class="headerlink" title="cluster info"></a>cluster info</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl cluster-info <span class="comment">#Details of the cluster and it's health status</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes <span class="comment"># view the nodes in the cluster.</span></span></span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><strong>kubectl get</strong> - list resources</li><li><strong>kubectl describe</strong> - show detailed information about a resource</li><li><strong>kubectl logs</strong> - print the logs from a container in a pod</li><li><strong>kubectl exec</strong> - execute a command on a container in a pod</li></ul><h4 id="create-a-deployment"><a href="#create-a-deployment" class="headerlink" title="create a deployment"></a>create a deployment</h4><p>一个Pod中有一个或者多个容器，一个k8s deployment 可以检查Pod的健康情况而且在Pod重启后可以重新启动Pod。deployment 是一种推荐的用来创建和伸缩Pod的方式。</p><p>deployment可以指导k8s如何创建和更新你的应用实例。</p><p>使用kubectl run命令来创建一个管理Pod的的deployment。我们需要提供deployment的名字和image的所在地。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run nginx-deployment --image=nginx --port=80</span><br></pre></td></tr></table></figure><h5 id="查看所有deployment"><a href="#查看所有deployment" class="headerlink" title="查看所有deployment"></a>查看所有deployment</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments</span><br></pre></td></tr></table></figure><h5 id="查看pod"><a href="#查看pod" class="headerlink" title="查看pod"></a>查看pod</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide #(-o wide 会显示IP等信息)</span><br></pre></td></tr></table></figure><p>当创建一个deployment的时候，k8s会自动的创建一个Pod。</p><p>一个Pod 是K8s的抽象，代表了一个或者多个容器，还有一些共享的资源。</p><p>一个Pod中的容器共享一个IP地址和端口空间</p><p>Pod是K8S平台上自动的单元，当我们在K8S平台上创建了Deployment，Deployment会自动创建Pod.Each Pod is tied to the Node where it is scheduled, and remains there until termination (according to restart policy) or deletion. In case of a Node failure, identical Pods are scheduled on other available Nodes in the cluster.</p><h4 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure><p>在主机和k8s集群之间设置代理，然后可以直接通过代理的方法访问API。</p><h4 id="Create-a-service"><a href="#Create-a-service" class="headerlink" title="Create a service"></a>Create a service</h4><p>一个Pod终将死亡，Pod是有生命周期的，当一个工作节点死亡后，上面运行的Pod也会消失。</p><p>Service是一种抽象，定义了一系列Pod和策略。</p><p>默认情况下，一个Pod只能通过K8S集群中的内部IP地址访问到。如果想让容器可以在外部访问到的话，可以把Pod暴露成一个k8s的Service。</p><p>可以使用<code>kubectl expose 命令</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment hello --type=LoadBalancer</span><br></pre></td></tr></table></figure><h5 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube service hello</span><br></pre></td></tr></table></figure><p>Service 使用labels 和selector 来匹配Pod.labels 是附着在Object上的键值对。lables 可以在创建的时候也可以在创建后附着在Object上。而且他们可以在任意时刻被修改。</p><p><strong>deployment会自动的创建标签给Pod</strong>,然后可以用Label来查询Pod的列表。(使用-l 参数)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -l run=nginx</span><br></pre></td></tr></table></figure><p>可以采用相同的方式获取service。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get service -l run=nginx</span><br></pre></td></tr></table></figure><p>应用一个<strong>new</strong> label 可以使用 （注意是new label ，并不是修改已有的Label）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label pod $POD_NAME app=v1</span><br></pre></td></tr></table></figure><h4 id="enable-插件"><a href="#enable-插件" class="headerlink" title="enable 插件"></a>enable 插件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube addons list</span><br></pre></td></tr></table></figure><h4 id="clean-up"><a href="#clean-up" class="headerlink" title="clean up"></a>clean up</h4><p>Now you can clean up the resources you created in your cluster:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete service hello-node</span><br><span class="line">kubectl delete deployment hello-node</span><br></pre></td></tr></table></figure><p>删除的时候，label 也可以派上用场。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete service -l run=kubernetes-bootcamp</span><br></pre></td></tr></table></figure><p>Optionally, force removal of the Docker images created:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi hello-node:v1 hello-node:v2 -f</span><br></pre></td></tr></table></figure><p>Optionally, stop the Minikube VM:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minikube stop</span><br><span class="line">eval $(minikube docker-env -u)</span><br></pre></td></tr></table></figure><p>Optionally, delete the Minikube VM:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube delete# optional</span><br></pre></td></tr></table></figure><h4 id="运行多个应用"><a href="#运行多个应用" class="headerlink" title="运行多个应用"></a>运行多个应用</h4><p>前面，我们创建了一个deployment，然后把它暴露成一个服务，deploymnet只为我们的App创建了一个Pod.当流量增加的时候，我们应该扩容我们的应用。</p><p>使用kubectl scale 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployments/kubernetes-bootcamp --replicas=4</span><br></pre></td></tr></table></figure><p>缩容的话只需要把 replicas 的数值设为1即可。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DockerFile</title>
      <link href="/2018/05/17/DockerFile/"/>
      <url>/2018/05/17/DockerFile/</url>
      
        <content type="html"><![CDATA[<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>分为四部分，基础镜像信息，维护者信息，镜像操作指令和容器启动时执行指令。例如下面的file</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>第一行必须指令基于的基础镜像</span><br><span class="line">From ubuntu</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>维护者信息</span><br><span class="line">MAINTAINER docker_user  docker_user@mail.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>镜像的操作指令</span><br><span class="line">apt/sourcelist.list</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y ngnix </span><br><span class="line">RUN echo "\ndaemon off;"&gt;&gt;/etc/ngnix/nignix.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>容器启动时执行指令</span><br><span class="line">CMD /usr/sbin/ngnix</span><br></pre></td></tr></table></figure><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul><li>from 指令</li></ul><p>DockerFile第一条必须为From指令。如果同一个DockerFile创建多个镜像时，可使用多个From指令（每个镜像一次）</p><ul><li>MAINTAINER</li></ul><p>格式为<code>maintainer  指定维护者的信息 邮箱</code></p><ul><li>RUN</li></ul><p>RUN命令用来执行命令行命令。格式有两种</p><p>1 Shell格式：<code>RUN&lt;命令&gt;</code> 就像直接在命令行中输入的命令一样。</p><p>2 Exec格式 <code>RUN[&quot;可执行文件&quot;，“参数1”，“参数2”]</code></p><ul><li>CMD命令</li></ul><p>支持三种格式：</p><p>CMD [“executable” ,”Param1”, “param2”]使用exec执行，推荐<br>CMD command param1 param2，在/bin/sh上执行<br>CMD [“Param1”, “param2”] 提供给ENTRYPOINT做默认参数。</p><p>每个容器只能执行一条CMD命令，多个CMD命令时，只最后一条被执行。</p><ul><li>EXPOSE</li></ul><p>格式为 EXPOSE […] 。</p><p>告诉Docker服务端容器暴露的端口号，供互联系统使用。在启动Docker时，可以通过-P,主机会自动分配一个端口号转发到指定的端口。使用-P，则可以具体指定哪个本地端口映射过来</p><p>例如：<br>EXPOSE 22 80 8443</p><ul><li>ENV</li></ul><p>格式为 <code>ENV &lt;key&gt; &lt;value&gt;</code> 。 指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。</p><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV PG_MAJOR 9.3</span><br><span class="line">ENV PG_VERSION 9.3.4</span><br><span class="line">RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span><br><span class="line">ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH1234</span><br></pre></td></tr></table></figure><ul><li>ADD </li></ul><p>格式为 <code>ADD 文件/URL 路径</code> 。</p><p>该命令将复制指定的文件到容器中的 。 其中 可以是Dockerfile所在目录的一个相对路径；也可以是一个URL；还可以是一个tar文件（如果是tar,则自动解压为目录）。</p><ul><li>COPY</li></ul><p>格式为 <code>COPY 原路径 目标路径</code>  。</p><p>复制本地主机的 （为Dockerfile所在目录的相对路径）到容器中的 。</p><p>当使用本地目录为源目录时，推荐使用 COPY 。</p><ul><li>ENTRYPOINT</li></ul><p>两种格式：</p><p>ENTRYPOINT [“executable”, “param1”, “param2”]<br>ENTRYPOINT command param1 param2 （shell中执行）。<br>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。</p><p>每个Dockerfile中只能有一个 ENTRYPOINT ，当指定多个时，只有最后一个起效。</p><ul><li>VOLUME</li></ul><p>格式为 VOLUME [“/data”] 。</p><p>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p><ul><li>USER</li></ul><p>格式为 <code>USER &lt;用户名&gt;</code> 。</p><p>指定运行容器时的用户名或UID，后续的 RUN 也会使用指定用户。</p><p>当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如： RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres 。要临时获取管理员权限可以使用 gosu ，而不推荐 sudo 。</p><p>12、WORKDIR</p><p>格式为 <code>WORKDIR 工作路径目录</code> 。</p><p>为后续的 RUN 、 CMD 、 ENTRYPOINT 指令配置工作目录。</p><p>可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如</p><p>WORKDIR /a<br>WORKDIR b<br>WORKDIR c<br>RUN pwd<br>则最终路径为 /a/b/c 。</p><ul><li>ONBUILD</li></ul><p>格式为 <code>ONBUILD [INSTRUCTION]</code> 。</p><p>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p><p>例如，Dockerfile使用如下的内容创建了镜像 image-A 。</p><p>[…]<br>ONBUILD ADD . /app/src<br>ONBUILD RUN /usr/local/bin/python-build –dir /app/src<br>[…]<br>如果基于A创建新的镜像时，新的Dockerfile中使用 FROM image-A 指定基础镜像时，会自动执行 ONBUILD 指令内容，等价于在后面添加了两条指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM image-A</span><br><span class="line">#Automatically run the following</span><br><span class="line">ADD . /app/src</span><br><span class="line">RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">使用 ONBUILD 指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild 。</span><br></pre></td></tr></table></figure><h2 id="Docker-build"><a href="#Docker-build" class="headerlink" title="Docker build"></a>Docker build</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build . -f envoy.Dockerfile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Machine</title>
      <link href="/2018/05/15/Dockermachine/"/>
      <url>/2018/05/15/Dockermachine/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><p>Docker machine 是docker 官方编排项目之一，它可以帮助我们在远程的机器上安装Docker,或者在虚拟机host上直接安装虚拟机并在虚拟机中安装Docker.我们还可以通过docker-machine命令来管理这些虚拟机和Docker。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Docker Machine 支持多种后端驱动，包括虚拟机，本地主机和云平台。</p><h4 id="创建本地主机实例"><a href="#创建本地主机实例" class="headerlink" title="创建本地主机实例"></a>创建本地主机实例</h4><ul><li>VirtualBox驱动</li></ul><p>使用virtualBox类型的驱动，创建一台Docker 主机，命名为test。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker-machine create -d virtualbox test //默认使用boot2docker的镜像创建虚拟机。</span><br></pre></td></tr></table></figure><p>有下面一些可以加入的参数，来配置主机或者主机上的Docker。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--engine-opt dns=114.114.114.114 配置Docker 的默认DNS.</span><br><span class="line">--engine-registry-mirror https://registry.docker-cn.com 配置Docker仓库镜像</span><br><span class="line">--virtualbox-memory 2048 配置主机内存</span><br><span class="line">--virtualbox-cpu-count 2 配置主机CPU</span><br></pre></td></tr></table></figure><ul><li>macOS xhyve驱动</li></ul><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-15%20%E4%B8%8A%E5%8D%8811.01.49.png" alt=""></p><h4 id="远程主机上安装Docker"><a href="#远程主机上安装Docker" class="headerlink" title="远程主机上安装Docker"></a>远程主机上安装Docker</h4><p>通过Docker-machine命令可以轻松的在远程主机上安装Docker。但是有三个前提条件，1在目标主机上创建一个用户并加入sudo组，为该用户设置sudo 操作不需要输入密码。把本地用户的ssh public key 添加到目标主机上。</p><p>比如我们要在远程主机上添加一个名为 nick 的用户并加入 sudo 组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo adduser nick</span><br><span class="line"><span class="meta">$</span> sudo usermod -a -G sudo nick</span><br></pre></td></tr></table></figure><p>然后设置 sudo 操作不需要输入密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo visudo</span><br></pre></td></tr></table></figure><p>把下面一行内容添加到文档的最后并保存文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nick   ALL=(ALL:ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>最后把本地用户的 ssh public key 添加到目标主机上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-copy-id -i ~/.ssh/id_rsa.pub nick@xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure><p>这几步操作的主要目的是获得足够的权限可以远程的操作目标主机。</p><p>安装命令</p><p>在本地运行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker-machine create -d generic \</span><br><span class="line">    --generic-ip-address=xxx.xxx.xxx.xxx \</span><br><span class="line">    --generic-ssh-user=nick \</span><br><span class="line">    --generic-ssh-key ~/.ssh/id_rsa \</span><br><span class="line">    krdevdb</span><br></pre></td></tr></table></figure><p>使用<code>docker-machine ls</code>命令查看当前可管理的主机列表。</p><p>然后执行 <code>eval $(docker-machine env 远程主机Docker名字)</code> 命令，就可以通过本地的客户端操作远程主机上的 Docker daemon 了。</p><h4 id="切换管理不同的主机"><a href="#切换管理不同的主机" class="headerlink" title="切换管理不同的主机"></a>切换管理不同的主机</h4><p>只需要输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval $(docker-machine env 新主机Docker名字)# 即可切换。</span><br></pre></td></tr></table></figure><p>要管理本地主机，需要重新开启一个终端就好。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper入门</title>
      <link href="/2018/05/12/ZooKeeper%E5%85%A5%E9%97%A8/"/>
      <url>/2018/05/12/ZooKeeper%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>zookeeper是一个中间件，用来提供协调服务。作为分布式系统，发挥其优势，可以为大数据服务。支持Java,提供Java和C语言的客户端API。</p><h3 id="zookeeper-入门"><a href="#zookeeper-入门" class="headerlink" title="zookeeper 入门"></a>zookeeper 入门</h3><h4 id="zookeeper的特性"><a href="#zookeeper的特性" class="headerlink" title="zookeeper的特性"></a>zookeeper的特性</h4><ul><li>一致性：数据一致性， 数据按照顺序分批入库。</li><li>原子性：事务要么成功，要么失败，不会局部化。</li><li>单一视图：客户端连接集群中任一zk节点， 数据都是一致的。</li><li>可靠性： 每次对zk的操作状态都会保存在服务端</li><li>实时性：客户端可以读取到zk服务端的最新数据</li></ul><h4 id="zookeeper-目录结构"><a href="#zookeeper-目录结构" class="headerlink" title="zookeeper 目录结构"></a>zookeeper 目录结构</h4><ul><li>bin 目录  可执行文件目录</li><li>conf 存放配置文件，其中我们需要修改zk.cfg</li><li>contrib 附件的一些功能</li><li>Dist-maven mvn编译后的目录</li><li>docs 文档</li><li>lib 需要依赖的jar包</li><li>recipes 案例demo代码</li></ul><h4 id="zoo-cfg-配置"><a href="#zoo-cfg-配置" class="headerlink" title="zoo.cfg 配置"></a>zoo.cfg 配置</h4><ul><li>tickTime: 用于计算的时间单元，比如session超时：N*tickTime</li><li>initLimit 用于集群，允许从节点连接并同步到master节点的初始化连接时间，以tickTime的倍数来表示。</li><li>syncLimit 用于集群，master主节点与从节点之间发送信息，请求和应答时间长度。（心跳机制）</li><li>Datadir : 数据目录</li><li>Datalogdir 日志目录</li><li>clientPort 连接服务器的服务器端口，默认是2181</li></ul><h4 id="Zookeeper-基本数据模型"><a href="#Zookeeper-基本数据模型" class="headerlink" title="Zookeeper 基本数据模型"></a>Zookeeper 基本数据模型</h4><p><strong>zookeeper服务器一般是一个集群，维护一个数据模型，这个模型是树形的，然后客户端可以访问，修改，删除这个树状的数据模型中的数据。每一个目录下都是zookeeper用来保存的数据。</strong></p><p>是一个树形结构，类似前端开发的tree.js组件。</p><p>zookeeper的数据模型可以理解为linux/unix的文件目录。</p><p>每一个节点都是成为znode,它可以由子节点，也可以有数据。</p><p>每个节点可以分为临时节点和永久节点，临时节点在客户端断开后消失。</p><p>每个zk节点都有各自的版本号，可以通过命令行来显示节点信息。</p><p>每当节点数据发生变化，那么该节点的版本号就会累加（乐观锁）。</p><p>删除/修改过时节点，版本号不匹配则会报错。</p><p>每个zk节点存储的数据不宜过大，几k即可。</p><p>节点可以设置权限acl,可以通过权限来限制用户的访问。</p><h4 id="zk的作用体现"><a href="#zk的作用体现" class="headerlink" title="zk的作用体现"></a>zk的作用体现</h4><ul><li>master节点选举，主节点挂了以后，从节点就会接手工作，并且保证这个节点是唯一的，这也是所谓首脑模式，从而保证我们的集群是高可用的。</li><li>统一配置文件管理，即只需要部署一台服务器，就可以把相同的配置文件同步更新到其他所有服务器，此操作在云计算中用的特别多。</li><li>发布与订阅，类似消息队列，dubbo发布者把数据存在znode上，订阅者会读取这个数据。</li><li>提供了分布式锁，分布式环境中不同进程之间争夺资源，类似于多线程中的锁。</li><li>集群管理，集群中保证数据的强一致性。</li></ul><h3 id="Zookeeper-的使用"><a href="#Zookeeper-的使用" class="headerlink" title="Zookeeper 的使用"></a>Zookeeper 的使用</h3><h4 id="zk特性-session的基本原理"><a href="#zk特性-session的基本原理" class="headerlink" title="zk特性 -session的基本原理"></a>zk特性 -session的基本原理</h4><ul><li>客户端与服务端之间的连接存在会话</li><li>每个会话都可以设置一个超时时间</li><li>心跳结束，session则过期。</li><li>session过期，则临时节点znode会被抛弃</li><li>心跳机制，客户端向服务端ping请求</li></ul><h4 id="zk常用命令行操作-（-表示的可选）"><a href="#zk常用命令行操作-（-表示的可选）" class="headerlink" title="zk常用命令行操作 （[]表示的可选）"></a>zk常用命令行操作 （[]表示的可选）</h4><p>通过./zKCli.sh打开zk的客户端进行命令行后台。</p><p>Help 命令查看所有命令。</p><ul><li>ls与 ls2命令 （ls2 =ls+stat）</li></ul><p>ls 加目录 表示查看目录列表</p><p>stat 加目录 显示具体信息</p><p>ls2 =ls+stat</p><ul><li>Get  与stat 命令</li></ul><p>stat 就是status的意思，就是显示状态信息。</p><p>Get 读取当前节点的数据</p><ul><li><code>create (-s 创建顺序节点）(-e创建临时节点) path data acl</code></li></ul><ul><li>set path data [version可选]  修改节点的值</li><li>delete path [version]  删除节点的值（set 和delete的版本号都是乐观锁的机制）</li></ul><h4 id="zk特性-watcher-机制"><a href="#zk特性-watcher-机制" class="headerlink" title="zk特性 -watcher 机制"></a>zk特性 -watcher 机制</h4><ul><li>针对每一个节点的操作，都会有一个监督者，这个监督者就是watcher 。</li><li>当监控的某个对象发生了变化，则触发了watcher 事件。</li><li>zk中的watcher是一次性的，当触发后就会立即销毁。</li><li>父节点，子节点，增删改查都能够触发其watcher。</li><li>针对不同类型的操作，触发的watcher事件也不同。</li></ul><h4 id="watcher-命令行"><a href="#watcher-命令行" class="headerlink" title="watcher 命令行"></a>watcher 命令行</h4><p>通过get path [watch] 设置watcher 。</p><p>父节点增删改查的操作触发watcher 。</p><p>子节点的增删改查的操作触发watcher。</p><p><code>get 目录 watch</code> 设置父节点事件</p><p>创建父节点会触发 NodeCreated事件</p><p>修改父节点数据触发 NodeDataChanged事件</p><p>删除父节点触发：NodeDeleted事件</p><p><code>ls 目录 watch 为父节点创建watch</code>在此目录下的子节点增删改查都会触发事件</p><h4 id="watch-使用场景"><a href="#watch-使用场景" class="headerlink" title="watch 使用场景"></a>watch 使用场景</h4><ul><li>统一资源配置</li></ul><h3 id="ACL-access-cintrol-lists-权限控制"><a href="#ACL-access-cintrol-lists-权限控制" class="headerlink" title="ACL access cintrol lists 权限控制"></a>ACL access cintrol lists 权限控制</h3><p>针对节点可以设置相关读写等权限，目的是为了保障数据安全性。</p><p>权限permissions可以指定不同的权限范围以及角色</p><h4 id="ACL-命令行"><a href="#ACL-命令行" class="headerlink" title="ACL 命令行"></a>ACL 命令行</h4><ul><li>getAcl 获取某个节点的acl权限信息<code>getacl path acl</code></li><li>setAcl 设置某个节点的acl权限信息<code>setacl path acl</code></li><li>Addauth 输入认证授权信息，注册时输入明文密码（登录） 但是在zk的系统里，密码是以加密的形式存在的。</li><li>zk的ACL通过[scheme:id :permissions]来构成权限列表。scheme代表采用的某种权限机制，id代表允许访问的用户。permissions代表权限组合字符串。</li></ul><h3 id="zookeeper-集群搭建"><a href="#zookeeper-集群搭建" class="headerlink" title="zookeeper 集群搭建"></a>zookeeper 集群搭建</h3><p>主从节点，心跳机制（选举模式）</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树遍历的通用写法</title>
      <link href="/2018/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E9%80%9A%E7%94%A8%E5%86%99%E6%B3%95/"/>
      <url>/2018/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E9%80%9A%E7%94%A8%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树遍历的通用写法"><a href="#二叉树遍历的通用写法" class="headerlink" title="二叉树遍历的通用写法"></a>二叉树遍历的通用写法</h2><p>二叉树的前中后序遍历的通用写法。</p><p>使用一个栈模拟遍历的操作。</p><p>首先声明树的结构体和命令的结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        val=x;</span><br><span class="line">        left=<span class="literal">NULL</span>;</span><br><span class="line">        right=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    TreeNode* node;</span><br><span class="line">    Command(<span class="built_in">string</span> s,TreeNode* node):s(s),node(node)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Command 结构体有两个成员，分别是执行的操作和执行的节点。</p><p>在前序遍历中，知道每到达一个节点，先打印这个节点，然后遍历左节点，然后遍历右节点，所以将这三条命令推入栈中，因为是栈，所以先推入遍历右节点的命令，然后推入遍历左节点的命令，最后再推入打印当前节点的命令。</p><p>后序遍历和中序遍历就只需要更改else中推入三条命令的顺序就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">前序遍历</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Command&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">stack</span>.push(Command(<span class="string">"go"</span>,root));</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Command command =<span class="built_in">stack</span>.top();</span><br><span class="line">        <span class="built_in">stack</span>.pop();</span><br><span class="line">        <span class="keyword">if</span>(command.s==<span class="string">"print"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(command.node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;<span class="comment">//如果是go,就模拟系统推入三条命令。</span></span><br><span class="line">            assert(command.s==<span class="string">"go"</span>);</span><br><span class="line">            <span class="keyword">if</span>(command.node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(Command(<span class="string">"go"</span>,command.node-&gt;right));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(command.node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(Command(<span class="string">"go"</span>,command.node-&gt;left));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>.push(Command(<span class="string">"print"</span>,command.node));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">中序遍历</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Command&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">stack</span>.push(Command(<span class="string">"go"</span>,root));</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Command command =<span class="built_in">stack</span>.top();</span><br><span class="line">        <span class="built_in">stack</span>.pop();</span><br><span class="line">        <span class="keyword">if</span>(command.s==<span class="string">"print"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(command.node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert(command.s==<span class="string">"go"</span>);</span><br><span class="line">            <span class="keyword">if</span>(command.node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(Command(<span class="string">"go"</span>,command.node-&gt;right));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>.push(Command(<span class="string">"print"</span>,command.node));</span><br><span class="line">            <span class="keyword">if</span>(command.node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(Command(<span class="string">"go"</span>,command.node-&gt;left));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">后序遍历</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Command&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">stack</span>.push(Command(<span class="string">"go"</span>,root));</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Command command =<span class="built_in">stack</span>.top();</span><br><span class="line">        <span class="built_in">stack</span>.pop();</span><br><span class="line">        <span class="keyword">if</span>(command.s==<span class="string">"print"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(command.node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert(command.s==<span class="string">"go"</span>);</span><br><span class="line">            <span class="built_in">stack</span>.push(Command(<span class="string">"print"</span>,command.node));</span><br><span class="line">            <span class="keyword">if</span>(command.node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(Command(<span class="string">"go"</span>,command.node-&gt;right));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(command.node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(Command(<span class="string">"go"</span>,command.node-&gt;left));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 概述</title>
      <link href="/2018/05/08/K8S/"/>
      <url>/2018/05/08/K8S/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubernetes概述"><a href="#Kubernetes概述" class="headerlink" title="Kubernetes概述"></a>Kubernetes概述</h2><p><a href="https://www.kubernetes.org.cn/" target="_blank" rel="noopener"><strong>Kubernetes</strong></a>是一个开源的基于容器技术的分布式架构领先方案。目的是实现资源管理的自动化，以及跨多个数据中心的资源利用率的最大化。</p><p>Kubernetes是一个开放的开发平台，不限于任何一种语言，没有限定任何一种编程接口，不论哪种语言编写的服务，都可以毫不困难的映射为kubernetes的service。并通过标准的TCP协议进行交互。同时，它具有完备的集群管理能力，包括多层次的安全防护和准入机制，多租户应用支撑能力，透明的服务注册和发现机制，内建智能的负载均衡器，强大的故障发现和自我修复能力，服务滚动升级和在线扩容能力。</p><p>在K8s中，Service是分布式集群架构的核心，一个service对象拥有如下关键特征。</p><ul><li>拥有一个唯一指定的名字（比如MySQL-server）</li><li>拥有一个虚拟IP和端口号。</li><li>能够提供某种远程服务能力</li><li>被映射到了提供这种服务能力的一组容器应用上。</li></ul><p>Service的服务进程目前都基于Socket通信方式来对外提供服务。同时，容器提供了强大的隔离功能，所以有必要把为Service提供服务的这组进程放入容器中进行隔离，因此，k8s设计了Pod对象，将每个服务进程包装到对应的Pod中，使其成为Pod中运行的一个容器，为了建立Service和Pod间的关联关系，k8s首先给每个Pod贴一个标签，给运行MYSQL的pod贴上name=mysql标签，给运行PHP的贴上name=php,然后给对应的Service定义标签选择器，比如MYSQL Service 的标签选择器的选择条件为name =mysql ,意为该service要作用于所有包含name=mysql Label 的Pod上。这样一来，就巧妙了的解决了Service 与Pod的关联问题。</p><p>Pod运行在一个我们称之为节点(Node)的环境中，这个节点既可以是物理机，也可以是私有云或者公有云中的一个虚拟机。通常一个节点中运行几百个Pod。其次，每个Pod里运行着一个特殊的被称之为Pause的容器，其他容器则称为业务容器，这些业务容器共享Pause容器的网络栈和Volume挂载卷。因此他们的通信和数据交换更为高效。只有提供服务的一组Pod才能被映射成一个服务。</p><p>在集群管理方面，k8s将集群中的机器划为一个Master节点和一群工作节点（Node）。在Master节点运行着集群管理相关的一组进程，这些进程实现了整个集群的资源管理，Pod调度，弹性伸缩，安全控制，系统监控等管理功能。</p><h4 id="基本概念与术语"><a href="#基本概念与术语" class="headerlink" title="基本概念与术语"></a>基本概念与术语</h4><p><strong>pod中是一个容器多个容器，因为一个pod可能会出现故障，所以一组pod组成一个Service,来提供服务</strong>。</p><p>k8s中大部分概念如Node,Pod,Replication Controller,Service 等都可以看做一种资源对象，几乎所有的资源对象都可以通过k8s提供的kubectl工具执行增删改查操作并将其保存在etcd中持久化存储。从这个角度看，k8s其实是一个高度自动化的资源控制系统。它通过跟踪对比etcd库里保存的“资源期望状态与当前环境中的“实际资源状态”的差异来实现自动控制和自动纠错的高级功能。</p><h5 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h5><p>Master指的是集群控制节点，每个k8s集群中需要一个Master来负责整个集群的管理和控制。基本上k8s所有的控制指令都是发给他。它来负责具体的执行过程。</p><p>Master节点上运行着一组关键进程ouu</p><ul><li>K8s API Server 提供HTTP Rest 接口的关键服务进程，是k8s里所有资源的增删改查的唯一入口。也是集群控制的入口进程。o</li><li>K8s Controller Manager，k8s里所有资源对象的自动化控制中心。</li><li>k8s Scheduler 负责资源调度的进程，相当于公交公司的”调度室“。</li></ul><p>其中，Master 节点中往往还启动了一个etcd Server 进程，因为k8s 里的所有资源对象的数据全都是保存在etcd中的。</p><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>除了Master ,集群中的其他机器都被称为Node 节点，Node节点是k8s集群中的工作负载节点，每个Node都会被Master 分配一些工作负载。当某个Node宕机后，其上的工作负载会被Master自动转移到其他节点上去。</p><p>Node节点上运行着以下关键进程。</p><ul><li>kubelet 负责Pod对应的容器的创建，启停等任务。同时与Master密切合作，实现集群管理的基本功能。</li><li>Kube-proxy 实现k8s Service 的通信与负载均衡机制的重要组件。</li><li>docker engine  docker 引擎，负责本地的容器创建和管理工作。</li></ul><p>Node节点可以在运行期间动态的添加到k8s集群中。</p><h5 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h5><p>Pod就像是豌⾖荚⼀样， 它由⼀个或者多个容器组成（ 例如Docker容器） ， 它们共享容器存储、 ⽹络和容器运⾏配置项。 Pod中的容器总是被同时调度， 有共同的运⾏环境。 你可以把单个Pod想象成是运⾏独⽴应⽤的“逻辑主机”——其中运⾏着⼀个或者多个紧密耦合的应⽤容器——在有容器之前， 这些应⽤都是运⾏在⼏个相同的物理机或者虚拟机上。</p><p>Pod 是k8s 最重要的概念，Pod是kubernetes中你可以创建和部署的最⼩也是最简单位。 ⼀个Pod代表着集群中运⾏的⼀个进程。Pod中封装着应⽤的容器（ 有的情况下是好⼏个容器) ，存储、独⽴的⽹络IP， 管理容器如何运⾏的策略选项。 Pod代表着部署的⼀个单位：kubernetes中应⽤的⼀个实例， 可能由⼀个或者多个容器组合在⼀起共享<br>资源。每个Pod都有一个特殊的被称为”根容器“的Pause 容器。Pause 容器对应的镜像属于k8s 平台的一部分，除了Pause 容器，每个Pod 还包含了一个或多个紧密相关的用户业务容器。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8A%E5%8D%8810.01.41.png" width="50%"></p><p>Pod 的出现原因</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8A%E5%8D%8810.05.21.png" alt=""></p><p>Pod 有两种类型，普通Pod 及静态Pod。静态的Pod 并不存放在k8s 的 etcd 存储里，而是存放在某个具体的Node 上的一个具体文件中。并且只有在此Nod 上启动运行。而普通Pod 一旦被创建，就会被放入到etcd 中存储。随后被master 调度到某个具体的Node  上并进行绑定。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8A%E5%8D%8810.19.49.png" alt=""></p><p>Pod中的应⽤可以共享⽹络空间（ IP地址和端⼝） ， 因此可以通过 localhost 互相发现。 因此， pod中的应⽤必须协调端⼝占⽤。 每个pod都有⼀个唯⼀的IP地址， 跟物理机和其他pod都处于⼀个扁平的⽹络空间中， 它们之间可以直接连通。</p><p>k8s中所有的资源对象都可以用yaml  或者JSON格式的文件来定义或者定义。</p><h5 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h5><p>一个label 是一个key =value 的键值对。key 和value 都由自己来定义，label 可以附加到各种资源对象上，如Node,Pod, Service,RC 等。一个资源对象可以定义任意数量的Label。同一个Label 也可以被天剑到任意数量的资源对象上去。Label 通常在资源对象定义时确定，也可以在对象创建后动态添加或者删除。</p><p>可以通过给指定的资源对象捆绑一个或多个不同的Label 来实现多维度的资源分组管理功能。以便于灵活，方便的进行资源管理。</p><p>Label Selector 可以被类比为SQL语句中的where 查询语句。</p><h5 id="Replication-Controller-RC"><a href="#Replication-Controller-RC" class="headerlink" title="Replication Controller (RC)"></a>Replication Controller (RC)</h5><p>简单来说，RC 定义了一个期望的场景，即声明某种Pod 的副本数量在任意时刻都符合某个预期值。所以RC 的定义包括如下几个部分</p><ul><li>Pod期待的副本数</li><li>用于筛选目标Pod 的Label Selector</li><li>当Pod 的副本数量小于预期数量的时候，用于创建新Pod的Pod 模板。</li></ul><h5 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h5><p>1.2版本引入的新概念，引入的目的是为了更好的解决Pod的编排问题，为此，Deployment 在内部使用了Replica Set 来实现目的。可以看作是RC 的一次升级。</p><h5 id="Horizontal-Pod-Autoscaler-HPA"><a href="#Horizontal-Pod-Autoscaler-HPA" class="headerlink" title="Horizontal Pod Autoscaler (HPA)"></a>Horizontal Pod Autoscaler (HPA)</h5><p>意思是Pod 横向自动扩容，与之前的RC, Deployment 一样，也是属于一种k8s 资源对象，通过追踪分析RC 控制的所有目标Pod 的负载均衡变化情况，来确定是否需要针对性的调整目标Pod 的副本数。</p><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>k8s中的每个service其实就是我们经常提起的微服务架构中的一个”微服务“，之前的Pod,RC等资源对象其实都是为”服务“做”嫁衣“的。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8A%E5%8D%8810.50.02.png" alt=""></p><p>在K8S的世界里，虽然每个Pod都会被分配一个单独的IP地址，但是这个IP会随着pod的销毁而消失，这就引出了一个问题，如果有一组pod组成一个集群来提供服务，该如何访问，service就是用来解决这个问题的核心概念，<strong>一个Service可以看做是一组提供相同服务的pod的对外访问接口，Service作用于哪些Pod是通过label selector 来定义的。</strong></p><p>前面虽然创建了Pod，但是在k8s中，Pod的IP会随着pod的重启而变化，并不建议直接拿pod的IP来交互，那如何访问这些pod提供的服务呢，使用service，service为一组pod提供一个统一的入口，并为他们提供负载均衡和自动服务发现。</p><p>pod的IP地址是docker daemon根据docker0网桥的IP地址段进行分配的，但service的Cluster IP地址是kubernetes系统中的虚拟IP地址，由系统动态分配。 Service的ClusterIP地址相对于pod的IP地址来说相对稳定，service被创建时即被分配IP地址，在销毁该service之前，这个IP地址都不会再变化。<br>由于service对象在Cluster IP Range池中分配到的IP只能在内部访问，所以其他pod都可以无障碍地访问到它。但如果这个service作为前端服务，准备为集群外的客户端提供服务，我们就需要给这个服务提供公共IP了。</p><p>Service定义了一个服务的访问入口地址，前端的应用通过这个入口地址访问其背后的一组由Pod 副本组成的集群实例，Service 与其后端Pod 副本集群之间则通过 label selector 来实现无缝对接。而RC的作用实际上是保证Service 的服务能力和服务质量始终处于预期的标准。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%885.10.54.png" alt=""></p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>命名空间在很多情况下用于<strong>实现多租户的资源隔离</strong>，Namespace 通过将集群内部的资源对象”分配“到不同的NameSpace 中，形成逻辑上分组的不同项目，小组或用户组。便于不同的分组在共享使用整个集群的资源的同时还能被分别管理。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JPA &amp;&amp; Spring Data JPA</title>
      <link href="/2018/05/08/JPA%20&amp;&amp;%20Spring%20Data%20JPA/"/>
      <url>/2018/05/08/JPA%20&amp;&amp;%20Spring%20Data%20JPA/</url>
      
        <content type="html"><![CDATA[<h2 id="JPA-amp-amp-Spring-Data-JPA"><a href="#JPA-amp-amp-Spring-Data-JPA" class="headerlink" title="JPA &amp;&amp; Spring Data JPA"></a>JPA &amp;&amp; Spring Data JPA</h2><p>  JPA（Java Persistence API )是用于管理Java EE 和JavaSE 环境中得到持久化，以及对象、关系映射的Java API</p><p>实现有EclipseLink, Hibernetes, Apache OpenJPA。</p><h5 id="jpa-核心概念"><a href="#jpa-核心概念" class="headerlink" title="jpa 核心概念"></a>jpa 核心概念</h5><h5 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h5><ul><li><p>实体表示关系数据库中的表</p></li><li><p>每个实体实例对应于该表中的行</p></li><li><p>类必须用javax.persistence.Entity 注解</p></li><li><p>类必须有一个public 或protected 无参数的构造函数</p></li><li>实体实例被当作值以分离对象方式进行传递，必须实现Serializable 接口</li><li>唯一的对象标识符：简单主键，复合主键</li></ul><h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><ul><li>一对一</li><li>一对多</li><li>多对一</li><li>多对多</li></ul><h5 id="EntityManager"><a href="#EntityManager" class="headerlink" title="EntityManager"></a>EntityManager</h5><ul><li>定义用于与持久性上下文进行交互的方法</li><li>创建和删除持久实体实例，通过实体的主键查找实体</li><li>允许在实体上运行查询</li></ul><h3 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h3><p>是spring data 家族的一部分</p><p>对基于JPA的数据访问层的增强支持</p><h4 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h4><p>CurdRepository</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20181029193754.png" alt=""></p><p>PagingAndSortingRepository</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20181029193859.png" alt=""></p><h4 id="自定义接口"><a href="#自定义接口" class="headerlink" title="自定义接口"></a>自定义接口</h4><p>根据方法名创建查询</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20181029194021.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>127*.Word Ladder</title>
      <link href="/2018/05/06/leetcode127/"/>
      <url>/2018/05/06/leetcode127/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time.</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p><strong>Note:</strong></p><ul><li>Return 0 if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">return its length 5.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure><hr><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>给两个单词和一个字典，使用字典中有的单词，求从一个单词到另一个单词的最少的转换步骤。<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> start, <span class="built_in">string</span> end, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;dict)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it=find(dict.begin(),dict.end(),end);</span><br><span class="line">            <span class="keyword">if</span>(it==dict.end()) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//若字典里没有最终元素，直接返回0.</span></span><br><span class="line">            <span class="keyword">return</span> BFS(start,end,dict);</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="built_in">string</span> start,<span class="built_in">string</span> end,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;dict1)</span></span>&#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict(dict1.begin(),dict1.end());</span><br><span class="line">            <span class="comment">// 存放单词和单词所在层次</span></span><br><span class="line">            <span class="built_in">queue</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">            q.push(make_pair(start,<span class="number">1</span>));</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">            visited.insert(start);</span><br><span class="line">            <span class="comment">// 广搜</span></span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; cur = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="built_in">string</span> word = cur.first;</span><br><span class="line">                <span class="keyword">int</span> len = word.size();</span><br><span class="line">                <span class="comment">// 变换一位字符</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function"><span class="built_in">string</span> <span class="title">newWord</span><span class="params">(word)</span></span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;++j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        newWord[i] = <span class="string">'a'</span> + j;</span><br><span class="line">                        <span class="keyword">if</span>(newWord == end)</span><br><span class="line">                        &#123;</span><br><span class="line">                            found = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">return</span> cur.second+<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 判断是否在字典中并且是否已经访问过</span></span><br><span class="line">                        <span class="keyword">if</span>(dict.count(newWord) &gt; <span class="number">0</span> &amp;&amp; visited.count(newWord) == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            visited.insert(newWord);</span><br><span class="line">                            q.push(make_pair(newWord,cur.second+<span class="number">1</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//while</span></span><br><span class="line">            <span class="keyword">if</span>(!found)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>类似于leetcode279题，转换成图，然后对图使用BFS进行求解。</p><p><strong>在set中存在某个元素可以用count函数&gt;1来表示</strong></p><p>vector判存在用find函数。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>279**. Perfect Squares</title>
      <link href="/2018/05/06/leetcode279/"/>
      <url>/2018/05/06/leetcode279/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p><p>For example, given <em>n</em> = <code>12</code>, return <code>3</code> because <code>12 = 4 + 4 + 4</code>; given <em>n</em> = <code>13</code>, return <code>2</code> because <code>13 = 4 + 9</code>.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter" target="_blank" rel="noopener">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p></li></ul><a id="more"></a><h5 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h5><p>给定一个正整数，找到最少的平方数可以组成的个数。</p><p>比如12 可以由12个1组成（1是平方数），也可以由3个4组成，也可以由一个9，三个1组成，最少的是3个4.所以返回3.</p><h5 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(n&gt;<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push(make_pair( n, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">bool</span>&gt; visited(n+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">    visited[n] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> num =q.front().first;</span><br><span class="line">        <span class="keyword">int</span> step =q.front().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">return</span> step;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; num-i*i&gt;=<span class="number">0</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[num-i*i] )</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(make_pair(num-i*i, step+<span class="number">1</span>));</span><br><span class="line">                visited[num-i*i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给出一个正整数n,寻找最少的完全平方数，使他们的和为n。</p><p>对问题建模，把整个问题转化为一个图论问题，从n到0，每个数字表示一个节点，如果两个数字x到y相差一个完全平方数，则连接一条边，就得到了一个无权图，原问题就转换为求这个无权图中从n到0的最短路径。</p><p> <img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%883.25.10.png" alt=""></p><p>加入n为12，首先把12入队，然后把最大的11入队，然后把8入队，然后把3入队，他们入队的同时，step都为1。然后取11，再把10入队，7入队，2入队，他们的step都为2，然后对于8，把7入队，4入队。step=2,对于3，把2入队。step=2.因为他们的速度都是相同的，所以只要有一个数num==0,此时的step就是最小的step，所以直接返回即可。</p><p>同时，为了防止重复入队，设置一个vector,重复的就不用再入队了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 数据管理</title>
      <link href="/2018/05/05/Docker%20%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
      <url>/2018/05/05/Docker%20%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h2><p>在容器中管理数据主要有两种方式，分别是数据卷(Volumes)和挂载主机目录(Bind mounts)。</p><h3 id="数据卷-使用–mount参数"><a href="#数据卷-使用–mount参数" class="headerlink" title="数据卷(使用–mount参数)"></a>数据卷(使用–mount参数)</h3><p>数据卷是一个可供一个或者多个容器使用的特殊目录，它绕过UFS,可以提供很多有用的特性。</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立刻生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认会一直存在，即使容器被删除</li></ul><h4 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker volume create my-vol</span><br><span class="line"><span class="meta">#</span> 查看所有的数据卷</span><br><span class="line"><span class="meta">$</span> docker volume ls</span><br><span class="line"><span class="meta">#</span> 查看数据卷的信息</span><br><span class="line"><span class="meta">$</span> docker volume inspect my-vol</span><br></pre></td></tr></table></figure><h4 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h4><p>在用docker run命令的时候，使用—mount标记来将数据卷挂载到容器里。在一次docker run可以挂载多个数据卷。</p><p>下面创建一个ubuntu容器，并加载<code>myvol1</code>数据卷到容器的<code>/bin</code> 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>docker run -d -it --mount source=myvol1,target=/bin  ubuntu</span><br></pre></td></tr></table></figure><h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker volume rm my-vol</span><br></pre></td></tr></table></figure><p> 如果需要在删除容器的同时移除数据卷，可以在删除容器时使用 <code>docker rm -v</code> .</p><p>无主的数据卷可能会占用很多空间，要清理请使用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker volume prune</span><br></pre></td></tr></table></figure><h3 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h3><h4 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h4><p>使用<code>--mount</code>标记可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -d -P --name web --mount type=bind,source=/src/webapp,target=/opt/webapp training/webapp python app.py</span><br><span class="line">上面的命令加载主机的/src/webapp 目录到容器的 /opt/webapp目录。本地目录的路径必须是决定路径。</span><br></pre></td></tr></table></figure><h4 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h4><p><code>--mount</code>标记也可以从主机挂载单个文件到容器中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run --rm -it --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history ubuntu bash</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符编码</title>
      <link href="/2018/04/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>/2018/04/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><h4 id="为何需要字符编码"><a href="#为何需要字符编码" class="headerlink" title="为何需要字符编码"></a>为何需要字符编码</h4><p>所有的信息都必须表示为一个二进制的字符串，每一个二进制位(bit)有0或者1两种状态。那么在存储时，字符A到底对应什么二进制字符串呢，这时就需要一个规则，这个规则可以将字符映射到唯一一个二进制字符串，这就是编码。</p><h4 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h4><p>美国定制的一种编码，一共规定了128个字符的编码，只有7位，所以只占用了一个字节的后面7位，最前面的1位统一为0，总共才有128个字符编码，一个字节都没有用完，于是，开始利用最高位，利用最高位进行编码的方式就称为非ASCII编码，如ISO-8859-1编码。</p><p>常见的ASCII码有：</p><p><code>0是空字符</code> <code>48是数字0</code> <code>65是大写字母A</code> <code>97是小写字母a</code></p><h4 id="ISO-8859-1"><a href="#ISO-8859-1" class="headerlink" title="ISO-8859-1"></a>ISO-8859-1</h4><p>是在 ASCII 码基础上又制定了一些标准用来扩展ASCII编码，即 <code>00000000(0)~01111111(127)</code> 与ASCII的编码一样，对 <code>10000000(128)~11111111(255)</code>这一段进行了编码，如将字符§编码成 10100111(167)。ISO-8859-1编码也是单字节编码，最多能够表示256个字符。Latin1是ISO-8859-1的别名，有些环境下写作Latin-1。但是，即使能够表示256个字符，对中文而言，还是太少了，一个字节肯定不够，必须用多个字节表示。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用 ISO8859-1编码来表示。而且在很多协议上，默认使用该编码。</p><h4 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h4><p>GB2312其对所收录字符进行了”分区”处理，共94个区，区从1（十进制）开始，一直到94（十进制），每区含有94个位，位从1（十进制）开始，一直到94（十进制），共8836（94 * 94）个码位，这种表示方式也称为区位码，GB2312是双字节编码，其中高字节表示区，低字节表示位。各区具体说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01-09区收录除汉字外的682个字符，有164个空位（9 * 94 - 682）。</span><br><span class="line">10-15区为空白区，没有使用。</span><br><span class="line">16-55区收录3755个一级汉字（简体），按拼音排序。</span><br><span class="line">56-87区收录3008个二级汉字（简体），按部首/笔画排序。</span><br><span class="line">88-94区为空白区，没有使用。</span><br></pre></td></tr></table></figure><p>　　那么根据区位码如何算出GBK2312编码呢？区位码的表示范围为0101 - 9494（包含了空的区位码）。<a href="http://www.qqxiuzi.cn/zh/hanzi-gb2312-bianma.php" target="_blank" rel="noopener">点击这里</a>，查看中GB2312编码区位码。之后只需要按照如下规则进行转化即可。</p><p>　　1. 将区（十进制）转化为十六进制。</p><p>　　2. 将转化的十六进制加上A0，得到GB2312编码的高字节。</p><p>　　3. 将位（十进制）转化为十六进制。</p><p>　　4. 将转化的十六进制加上A0，得到GB2312编码的低字节。</p><p>　　5. 组合区和位，区在高字节，位在低字节。</p><p>　　6. 得到GB2312编码。</p><p>GB2312用两个字节编码，采用分区编码，总共编码的中文个数为6763（3755 + 3008）。这些汉字只是最常用的汉字，已经覆盖中国大陆99.75%的使用频率。但是，还有一些汉字在GB2312中没有被编码，如’镕’字，在GB2312中就没有被编码，这样就导致了问题，随之就出现了主流的GBK编码。</p><h4 id="BIG5"><a href="#BIG5" class="headerlink" title="BIG5"></a>BIG5</h4><p>BIG5采用双字节编码，使用两个字节来表示一个字符。高位字节使用了0x81-0xFE，低位字节使用了0x40-0x7E，及0xA1-0xFE。该编码是繁体中文字符集编码标准，共收录13060个中文字，其中有二字为重复编码，即“兀、兀”（A461及C94A)和“嗀、嗀”(DCD1及DDFC)。具体的分区如下：　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8140-A0FE 保留给使用者自定义字符（造字区）</span><br><span class="line">A140-A3BF 标点符号、希腊字母及特殊符号。其中在A259-A261，收录了度量衡单位用字：兙兛兞兝兡兣嗧瓩糎。</span><br><span class="line">A3C0-A3FE 保留。此区没有开放作造字区用。</span><br><span class="line">A440-C67E 常用汉字，先按笔划再按部首排序。</span><br><span class="line">C6A1-F9DC 其它汉字。</span><br><span class="line">F9DD-F9FE 制表符。</span><br></pre></td></tr></table></figure><p><a href="http://www.qqxiuzi.cn/zh/hanzi-big5-bianma.php" target="_blank" rel="noopener">点击这里</a>，查看BIG5编码。注意，BIG5编码与GBK编码没有什么关系。</p><h4 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h4><p>GBK编码扩展了GB2312，完全兼容GB2312编码（如’李’字的GBK、GB2312编码均为C0EE），但其不兼容BIG5编码（’長’字的BIG5编码为AAF8，GBK编码为E94C，’李’字的BIG5编码为A7F5 不等于C0EE），即如果使用GB2312编码，使用GBK解码是完全正常的，但是如果使用BIG5编码，使用GBK解码，会出现乱码。相比于GB2312编码，GBK编码了更多汉字，如’镕’字。GBK编码依然采用双字节编码方案，其编码范围：8140－FEFE，剔除xx7F码位，共23940个码位。能表示 21003 个汉字。<a href="http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php" target="_blank" rel="noopener">点击这里</a>，查看GBK编码。<a href="http://www.qqxiuzi.cn/bianma/zifuji.php" target="_blank" rel="noopener">点击这里</a>，可以查询中文的其他编码。在GBK之后又出现了GB18030编码，但是没有形成主流，故不做介绍，至此，中文编码的问题已经讲解完成。那么问题又来了，大陆网民与在海峡两岸网民交流时，若都使用GBK编码，则没有问题，若一方使用GBK编码，一方使用BIG5编码，那么就会出现乱码问题，这是在海峡两岸网民交流，如果漂洋过海进行交流呢？那就更容易出现乱码问题，这时候我们可能想，要是有一套全世界都通用的编码就好了，那就是Unicode。</p><h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>Unicode是指一张表，里面包含了可能出现的所有字符，每个字符对应一个数字，这个数字称为码点(Code Point)，如字符’H’的码点为72（十进制），字符’李’的码点为26446（十进制）。Unicode表包含了1114112个码点，即从000000（十六进制） - 10FFFF（十六进制）。地球上所有字符都可以在Unicode表中找到对应的唯一码点。<a href="http://unicode-table.com/cn/" target="_blank" rel="noopener">点击这里</a>，查询字符对应的码点。Unicode将码空间划分为17个平面，从00 - 10（十六进制，最高两位），即从0 - 16（十进制），每个平面有65536个码点（2^16），其中最重要的是第一个Unicode平面(码位从0000 - FFFF)，包含了最常用的字符，该平面被称为基本多语言平面（Basic Multilingual Plane），缩写为BMP，其他平面称为辅助平面(Supplementary Planes)，在基本多文种平面內， 从D800到DFFF之间的码位区段是永久保留不映射到字符的， 因此UTF-16编码巧妙的利用了这保留下来的码位来对辅助平面内的字符进行编码，这点后面进行讲解。Unicode只是一个符号集，只规定的字符所对应的码点，并没有指定如何存储，如何进行存储出现了不同的编码方案，关于Unicode编码方案主要有两条主线：UCS和UTF。UTF主线由Unicode Consortium进行维护管理，UCS主线由ISO/IEC进行维护管理。</p><ul><li>UCS</li></ul><p>　　UCS全称为”Universal Character Set”，在UCS中主要有UCS-2和UCS-4。</p><p>　　1. UCS-2</p><p>　　UCS-2是定长字节的，固定使用2个字节进行编码，从0000（十六进制）- FFFF（十六进制）的码位范围，对应第一个Unicode平面。采用BOM(Byte Order Mark)机制，该机制作用如下：1. 确定字节流采用的是大端序还是小端序。2. 确定字节流的Unicode编码方案。</p><p>　　2. UCS-4</p><p>　　UCS-4是定长字节的，固定使用4个字节进行编码。也采用了BOM机制。</p><ul><li>UTF</li></ul><p>　　UTF全称为”Unicode Transformation Format”，在UTF中主要有UTF-8，UTF-16和UTF-32。</p><p>　　1. UTF-8</p><p>　　UTF-8是一种变长编码方式，使用1-4个字节进行编码。UTF-8完全兼容ASCII，<strong>对于ASCII中的字符，UTF-8采用的编码值跟ASCII完全一致</strong>。UTF-8是Unicode一种具体的编码实现。UTF-8是在互联网上使用最广的一种Unicode的编码规则，因为这种编码有利于节约网络流量（因为变长编码，而非统一长度编码）。关于Unicode码点如何转化为UTF-8编码，可以参照如下规则：</p><p>　　① 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。</p><p>　　② 对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p><p>　　总结的编码规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　　　  Unicode符号范围　　                 | 　　UTF-8编码方式</span><br><span class="line">　　　　     (十六进制) (十进制)　　　　        | 　　（二进制）</span><br><span class="line">　　----------------------------------------------------------------------------------------------------</span><br><span class="line">　　  0000 0000-0000 007F (0-127)           | 　　 0xxxxxxx</span><br><span class="line">　　  0000 0080-0000 07FF (128-2047)        | 　　 110xxxxx 10xxxxxx</span><br><span class="line">　　  0000 0800-0000 FFFF (2048-65535)      | 　   1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">　　  0001 0000-0010 FFFF (65536-1114111)   | 　　 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p>　　说明：字符’A’的Unicode码点为65（十进制），根据上表，在第一行范围，则字符’A’的UTF-8编码为01000001，中文字符’李’的Unicode码点为26446（十进制），二进制为01100111 01001110，十六进制为674E。根据上表，在第三行范围，则将’李’二进制代码从低位到高位依次填入x中，不足的填入0。得到UTF-8编码为11100110 10011101 10001110，即E69D8E（十六进制）。</p><p>　　由上述编码规则可知，0000 0000 - 0000 FFFF（第一行到第三行）为Unicode第一个平面（基本多语言平面），而0001 0000 - 10 FFFF（第四行）为Unicode其他平面（辅助平面）。在基本多语言平面对应了绝大多数常用的字符。对于大于65535（十进制）的码点，即在辅助平面上的码点，需要使用4个字节来进行UTF-8编码。</p><p>　　2. UTF-16</p><p>　　UTF-8是不定长的编码，使用1、2、3、4个字节编码，而UTF-16则只使用2或4个字节编码。UTF-16也是Unicode一种具体的编码实现。关于Unicode如何转化为UTf-16编码规则如下</p><p>　　① 若Unicode码点在第一平面（BPM）中，则使用2个字节进行编码。 </p><p>　　② 若Unicode码点在其他平面（辅助平面），则使用4个字节进行编码。</p><p>　　关于辅助平面的码点编码更详细解析如下：辅助平面码点被编码为一对16比特（四个字节）长的码元, 称之为代理对(surrogate pair), 第一部分称为高位代理(high surrogate)或前导代理(lead surrogates)，码位范围为：D800-DBFF. 第二部分称为低位代理(low surrogate)或后尾代理(trail surrogates)， 码位范围为：DC00-DFFF。注意，高位代理的码位从D800到DBFF，而低位代理的码位从DC00到DFFF，总共恰好为D800-DFFF，这部分码点在第一平面内是保留的，不映射到任何字符，所以UTF-16编码巧妙的利用了这点来进行码点在辅助平面内的4字节编码。</p><p>　　说明：字符’A’的Unicode码点为65（十进制），十六进制表示为41，在第一平面。根据规则，UTF-16采用2个字节进行编码。那么问题又来了，知道了采用两个字节编码，并且我们也知道计算机是以字节为单位进行存储，这两个字节应该表示为00 41(十六进制)？或者是41 00（十六进制）呢？这就引出了一个问题，需要用到之前提及的BOM机制来解决。</p><p>　　表示为00 41意味着采用了大端序（Big endian），而表示为41 00意味着采用了小端序。那么计算机如何知道存储的字符信息采用了大端序还是小端虚呢？这就需要加入一些控制信息，具体是采用大端序，则在文件前加入FE FF，采用小端序，则在文件前加入FF FE。这样，当计算开始读取时发现前两个字节为FE FF，就表示之后的信息采用的是小端序，反之，则是大端序。</p><p>　　字符 <img src="https://images2015.cnblogs.com/blog/616953/201603/616953-20160325091936011-35053941.png" alt="img">（无法显示，只能截图显示），其Unicode码点为65902（十进制），十六进制为1016E，很显然，已经超出了第一平面（BMP）所能表示的范围。其在辅助平面内，根据规则，UTF-16采用4个字节进行编码。然而其编码不是简单扩展为4个字节（00 01 01 6E），而是采用如下规则进行计算。</p><p>　　① 使用Unicode码位减去100000（十六进制），得到的值扩展20位（因为Unicode最大为10 FF FF（十六进制），减去1 00 00（十六进制）后，得到的结果最大为0FFF FF（十六进制），即为20位，不足20位的，在高位加一个0，扩展至20位即可）。</p><p>　　② 将步骤一得到的20位，按照高十位和低十位进行分割。</p><p>　　③ 将步骤二的高十位扩展至2个字节，再加上D800（十六进制），得到高位代理或前导代理。取值范围是D800 - 0xDBFF。</p><p>　　④ 将步骤二的低十位扩展至2个字节，再加上DC00（十六进制），得到低位代理或后尾代理。取值范围是DC00 - 0xDFFF。</p><blockquote><p><a href="https://www.cnblogs.com/leesf456/p/5317574.html" target="_blank" rel="noopener">https://www.cnblogs.com/leesf456/p/5317574.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RestTemplate 使用指南</title>
      <link href="/2018/04/24/RestTemplate%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2018/04/24/RestTemplate%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="RestTemplate-使用指南"><a href="#RestTemplate-使用指南" class="headerlink" title="RestTemplate 使用指南"></a>RestTemplate 使用指南</h2><p>RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率。</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><h4 id="获取JSON字符串"><a href="#获取JSON字符串" class="headerlink" title="获取JSON字符串"></a>获取JSON字符串</h4><p>使用<code>getForEntity()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">String fooResourceUrl = <span class="string">"http://localhost:8080/spring-rest/foos"</span>;</span><br><span class="line">ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(fooResourceUrl + <span class="string">"/1"</span>, String.class);</span><br><span class="line">assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));</span><br></pre></td></tr></table></figure><p>通过<code>getForEntity()</code>我们可以获取到完整的<code>HTTP response</code>，因此可以通过检测状态码来判断请求是否真正执行成功。也可以通过<code>getBody()</code>方法获取返回的具体内容，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">JsonNode root = mapper.readTree(response.getBody());</span><br><span class="line">JsonNode name = root.path(<span class="string">"name"</span>);</span><br><span class="line">assertThat(name.asText(), notNullValue());</span><br></pre></td></tr></table></figure><h4 id="获取POJO对象"><a href="#获取POJO对象" class="headerlink" title="获取POJO对象"></a>获取POJO对象</h4><p>直接将请求映射为一个POJO对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 这里省略了getters和setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = restTemplate.getForObject(userResourceUrl + <span class="string">"/1"</span>, User.class);</span><br></pre></td></tr></table></figure><h3 id="获取Headers"><a href="#获取Headers" class="headerlink" title="获取Headers"></a>获取Headers</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpHeaders httpHeaders = restTemplate.headForHeaders(fooResourceUrl);</span><br></pre></td></tr></table></figure><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p><code>RestTemplate</code>提供了三个API用来创建资源，它们分别是<code>postForLocation()</code>、 <code>postForObject()</code>和<code>postForEntity()</code>。<code>postForLocation()</code>返回新创建资源的URI，<code>postForObject()</code>则返回新创建的资源本身。</p><h4 id="postForObject方法"><a href="#postForObject方法" class="headerlink" title="postForObject方法"></a>postForObject方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClientHttpRequestFactory requestFactory = getClientHttpRequestFactory();</span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate(requestFactory);</span><br><span class="line">HttpEntity&lt;Foo&gt; request = <span class="keyword">new</span> HttpEntity&lt;&gt;(<span class="keyword">new</span> Foo(<span class="string">"bar"</span>));</span><br><span class="line">Foo foo = restTemplate.postForObject(fooResourceUrl, request, Foo.class);</span><br></pre></td></tr></table></figure><h4 id="postForLocation-方法"><a href="#postForLocation-方法" class="headerlink" title="postForLocation 方法"></a>postForLocation 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpEntity&lt;Foo&gt; request = <span class="keyword">new</span> HttpEntity&lt;&gt;(<span class="keyword">new</span> Foo(<span class="string">"bar"</span>));</span><br><span class="line">URI location = restTemplate.postForLocation(fooResourceUrl, request);</span><br></pre></td></tr></table></figure><h4 id="exchange方法"><a href="#exchange方法" class="headerlink" title="exchange方法"></a>exchange方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">HttpEntity&lt;User&gt; request = <span class="keyword">new</span> HttpEntity&lt;&gt;(<span class="keyword">new</span> User(<span class="string">"CD826"</span>));</span><br><span class="line">ResponseEntity&lt;User&gt; response = restTemplate.exchange(userResourceUrl, HttpMethod.POST, request, User.class);  </span><br><span class="line">User user = response.getBody();</span><br></pre></td></tr></table></figure><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User updatedInstance = <span class="keyword">new</span> User(<span class="string">"newName"</span>);</span><br><span class="line">updatedInstance.setId(createResponse.getBody().getId());</span><br><span class="line">String resourceUrl = userResourceUrl + <span class="string">'/'</span> + createResponse.getBody().getId();</span><br><span class="line">HttpEntity&lt;User&gt; requestUpdate = <span class="keyword">new</span> HttpEntity&lt;&gt;(updatedInstance, headers);</span><br><span class="line">template.exchange(resourceUrl, HttpMethod.PUT, requestUpdate, Void.class);</span><br></pre></td></tr></table></figure><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String entityUrl = fooResourceUrl + <span class="string">"/"</span> + existingResource.getId();</span><br><span class="line">restTemplate.delete(entityUrl);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8之StreamAPI &amp; Optional</title>
      <link href="/2018/04/23/Java8%E4%B9%8BStreamAPI%20&amp;%20Optional/"/>
      <url>/2018/04/23/Java8%E4%B9%8BStreamAPI%20&amp;%20Optional/</url>
      
        <content type="html"><![CDATA[<h2 id="Java8之StreamAPI-amp-Optional"><a href="#Java8之StreamAPI-amp-Optional" class="headerlink" title="Java8之StreamAPI &amp; Optional"></a>Java8之StreamAPI &amp; Optional</h2><h3 id="流的基本概念"><a href="#流的基本概念" class="headerlink" title="流的基本概念"></a>流的基本概念</h3><h4 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h4><p>流是Java8引入的全新概念，它用来处理集合中的数据，暂且可以把它理解为一种高级集合。</p><p>集合操作一般十分麻烦，若要对集合进行筛选，投影，则需要写大量的代码，而流以声明的形式操作集合，就像SQL语句，只需要告诉流需要对集合进行什么操作，它就会自动进行操作，并将执行结果返回。</p><p>因此，流的集合操作对代码编写者来说是透明的，只需要向流下达命令，就会自动把结果返回，操作过程完全由Java处理，因此可以根据当前的硬件环境选择最优的方法处理。</p><h4 id="流的特点"><a href="#流的特点" class="headerlink" title="流的特点"></a>流的特点</h4><ul><li>只能遍历一次</li></ul><p>可以把流想象成一条流水线，流水线的源头是我们的数据源，数据源中的元素依次被输送到流水线上，然后可以在流水线上对元素进行各种操作。一旦元素走到了流水线的另一头，那么这些元素就被消费掉了。这时就只能重新获取一个流重新遍历一遍。</p><ul><li>采用内部迭代方式</li></ul><p>若要对集合进行处理，则需我们手写处理代码，这就叫做外部迭代。而要对流进行处理，我们只需告诉流我们需要什么结果，处理过程由流自行完成，这就称为内部迭代。</p><h4 id="流的操作种类"><a href="#流的操作种类" class="headerlink" title="流的操作种类"></a>流的操作种类</h4><p>分两种，分别中间操作和终端操作。</p><ul><li><p>中间操作</p><p>当数据源中的数据上了流水线后，这个过程对数据进行的所有操作都称为中间操作。中间操作仍然会返回一个流对象，因此多个中间操作可以串联起来形成一个流水线。</p></li><li><p>终端操作</p><p>当所有中间操作完成后，若要将数据从流水线上拿下来，则需要进行终端操作。终端操作将返回一个执行结果，就是需要的数据。</p></li></ul><h4 id="流的操作过程"><a href="#流的操作过程" class="headerlink" title="流的操作过程"></a>流的操作过程</h4><p>三步，1准备一个数据源 2执行中间操作（中间操作可以有多个，串联起来形成流水线）3执行终端操作（执行终端操作后本次流程结束，获得一个执行结果）</p><h3 id="流的使用"><a href="#流的使用" class="headerlink" title="流的使用"></a>流的使用</h3><h4 id="1获取流"><a href="#1获取流" class="headerlink" title="1获取流"></a>1获取流</h4><p>在使用流之前，首先需要拥有一个数据源，并通过StreamAPI提供的一些方法获取该数据源的流对象。数据源可以有多种形式：</p><ol><li>集合</li></ol><p>这种数据源比较常用，通过<code>stream()</code>方法即可获取流对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; list =<span class="keyword">new</span> ArrayList&lt;person&gt;();</span><br><span class="line">Stream&lt;Person&gt; stream =list.stream();</span><br></pre></td></tr></table></figure><p>2 数组</p><p>通过Arrays类提供的静态函数stream()获取数组的流对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names =&#123;<span class="string">"chaimm"</span>,<span class="string">"peter"</span>,<span class="string">"john"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream =Arrays.stream(names);</span><br></pre></td></tr></table></figure><p>3.值</p><p>直接将几个值变成流对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream =Stream.of(<span class="string">"chaium"</span>,<span class="string">"peter"</span>,<span class="string">"john"</span>);</span><br></pre></td></tr></table></figure><p>4.文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Stream lines = Files.lines(Paths.get(“文件路径名”),Charset.defaultCharset()))&#123; </span><br><span class="line"><span class="comment">//可对lines做一些操作 </span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2筛选filter"><a href="#2筛选filter" class="headerlink" title="2筛选filter"></a>2筛选filter</h4><p>filter函数接收一个Lambda表达式作为参数，该表达式返回boolean，在执行过程中，流将元素逐一输送给filter，并筛选出执行结果为true的元素。<br>如，筛选出所有学生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result = list.stream()</span><br><span class="line">                    .filter(Person::isStudent)</span><br><span class="line">                    .collect(toList());</span><br></pre></td></tr></table></figure><h4 id="3去重distinct"><a href="#3去重distinct" class="headerlink" title="3去重distinct"></a>3去重distinct</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result =list.stream().distinct().collect(toList());</span><br></pre></td></tr></table></figure><h4 id="4截取"><a href="#4截取" class="headerlink" title="4截取"></a>4截取</h4><p>截取流的前N个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result =list.stream().limit(<span class="number">3</span>).collect(toList());</span><br></pre></td></tr></table></figure><h4 id="5-跳过"><a href="#5-跳过" class="headerlink" title="5 跳过"></a>5 跳过</h4><p>跳过流的前N个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result =list.stream().skip(<span class="number">3</span>).collect(toList());</span><br></pre></td></tr></table></figure><h4 id="6-映射"><a href="#6-映射" class="headerlink" title="6 映射"></a>6 映射</h4><p>对流中的每个元素执行一个函数，使得元素转换成另一种类型输出，流会将每一个元素输送给map函数，并执行map中的lamdba表达式，最后将执行结果存入一个新的流中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result =list.stream().map(Person::getName).collect(toList());</span><br></pre></td></tr></table></figure><h4 id="7-是否匹配任一元素"><a href="#7-是否匹配任一元素" class="headerlink" title="7 是否匹配任一元素"></a>7 是否匹配任一元素</h4><p>anymatch用于判断流中是否存在至少一个元素满足指定的条件，这个判断条件通过Lambda表达式传递给anyMatch，执行结果为boolean类型。<br>如，判断list中是否有学生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = list.stream()</span><br><span class="line">            .anyMatch(Person::isStudent);</span><br></pre></td></tr></table></figure><h4 id="8-是否匹配所有元素"><a href="#8-是否匹配所有元素" class="headerlink" title="8 是否匹配所有元素"></a>8 是否匹配所有元素</h4><p>allMatch用于判断流中的所有元素是否都满足指定条件，这个判断条件通过Lambda表达式传递给anyMatch，执行结果为boolean类型。<br>如，判断是否所有人都是学生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = list.stream()</span><br><span class="line">            .allMatch(Person::isStudent);</span><br></pre></td></tr></table></figure><h4 id="9-是否未匹配所有元素"><a href="#9-是否未匹配所有元素" class="headerlink" title="9 是否未匹配所有元素"></a>9 是否未匹配所有元素</h4><p>noneMatch与allMatch恰恰相反，它用于判断流中的所有元素是否都不满足指定条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = list.stream()</span><br><span class="line">            .noneMatch(Person::isStudent);</span><br></pre></td></tr></table></figure><h4 id="10-获取任一元素findAny"><a href="#10-获取任一元素findAny" class="headerlink" title="10 获取任一元素findAny"></a>10 获取任一元素findAny</h4><p>findAny能够从流中随便选一个元素出来，它返回一个Optional类型的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Person&gt; person = list.stream()</span><br><span class="line">                                    .findAny();</span><br></pre></td></tr></table></figure><h5 id="Optional介绍"><a href="#Optional介绍" class="headerlink" title="Optional介绍"></a>Optional介绍</h5><p>Optional是Java8新加入的一个容器，这个容器只存1个或0个元素，它用于防止出现NullpointException，它提供如下方法：</p><ul><li>isPresent()<br>判断容器中是否有值。</li><li>ifPresent(Consume lambda)<br>容器若不为空则执行括号中的Lambda表达式。</li><li>T get()<br>获取容器中的元素，若容器为空则抛出NoSuchElement异常。</li><li>T orElse(T other)<br>获取容器中的元素，若容器为空则返回括号中的默认值。</li></ul><h4 id="11-获取第一个元素findFirst"><a href="#11-获取第一个元素findFirst" class="headerlink" title="11 获取第一个元素findFirst"></a>11 获取第一个元素findFirst</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Person&gt; person = list.stream()</span><br><span class="line">                                    .findFirst();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Java类的配置</title>
      <link href="/2018/04/21/%E5%9F%BA%E4%BA%8EJava%E7%B1%BB%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/04/21/%E5%9F%BA%E4%BA%8EJava%E7%B1%BB%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="基于Java类的配置"><a href="#基于Java类的配置" class="headerlink" title="基于Java类的配置"></a>基于Java类的配置</h2><p>基于Java配置选项，可以编写大多数的Spring不用配置XML，但有几个基于Java的注释的帮助下解释。</p><h4 id="Configuration-amp-Bean-注解"><a href="#Configuration-amp-Bean-注解" class="headerlink" title="@Configuration &amp; @Bean 注解:"></a>@Configuration &amp; @Bean 注解:</h4><p>带有 <strong>@Configuration</strong> 的注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源(<strong>相当于XML中的beans</strong>)。<strong>@Bean</strong> 注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。最简单可行的 @Configuration 类如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> HelloWorld <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码等价于以下的XML配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"com.tutorialspoint.HelloWorld"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里，带有 @Bean 注解的方法名称作为 bean 的 ID，它创建并返回实际的 bean。你的配置类可以声明多个 @Bean。一旦定义了配置类，你就可以使用 <em>AnnotationConfigApplicationContext</em> 来加载并把他们提供给 Spring 容器，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ApplicationContext ctx = </span><br><span class="line">   <span class="keyword">new</span> AnnotationConfigApplicationContext(HelloWorldConfig.class); </span><br><span class="line">   HelloWorld helloWorld = ctx.getBean(HelloWorld.class);<span class="comment">//返回类型是真正的Bean。</span></span><br><span class="line">   helloWorld.setMessage(<span class="string">"Hello World!"</span>);</span><br><span class="line">   helloWorld.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以加载各种配置类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   AnnotationConfigApplicationContext ctx = </span><br><span class="line">   <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">   ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">   ctx.register(AdditionalConfig.class);</span><br><span class="line">   ctx.refresh();</span><br><span class="line">   MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">   myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><code>HelloWorldConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> HelloWorld <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>HelloWorld.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String message;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message  = message;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Your Message : "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainApp.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ApplicationContext ctx = </span><br><span class="line">      <span class="keyword">new</span> AnnotationConfigApplicationContext(HelloWorldConfig.class);</span><br><span class="line">      HelloWorld helloWorld = ctx.getBean(HelloWorld.class);</span><br><span class="line">      helloWorld.setMessage(<span class="string">"Hello World!"</span>);</span><br><span class="line">      helloWorld.getMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦你完成了创建所有的源文件并添加所需的额外的库后，我们就可以运行该应用程序。你应该注意这里不需要配置文件。如果你的应用程序一切都正常，将输出以下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your Message : Hello World!</span><br></pre></td></tr></table></figure><h4 id="注入Bean的依赖性"><a href="#注入Bean的依赖性" class="headerlink" title="注入Bean的依赖性"></a>注入Bean的依赖性</h4><p>当 @Beans 依赖对方时，表达这种依赖性非常简单，只要有一个 bean 方法调用另一个，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Foo(bar());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Bar <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Bar();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Import-注解"><a href="#Import-注解" class="headerlink" title="@Import 注解:"></a>@Import 注解:</h4><p><strong>@import</strong> 注解允许从另一个配置类中加载 @Bean 定义。考虑 ConfigA 类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigA</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> A(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在另一个 Bean 声明中导入上述 Bean 声明，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(ConfigA.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigB</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> B <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> A(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当实例化上下文时，不需要同时指定 ConfigA.class 和 ConfigB.class，只有 ConfigB 类需要提供，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ApplicationContext ctx = </span><br><span class="line">   <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigB.class);</span><br><span class="line">   <span class="comment">// now both beans A and B will be available...</span></span><br><span class="line">   A a = ctx.getBean(A.class);</span><br><span class="line">   B b = ctx.getBean(B.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h4><p>@Bean 注解支持指定任意的初始化和销毁的回调方法，就像在 bean 元素中 Spring 的 XML 的初始化方法和销毁方法的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// initialization logic</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// destruction logic</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>, destroyMethod = <span class="string">"cleanup"</span> )</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定 Bean 的范围：</p><p>默认范围是单实例，但是你可以重写带有 @Scope 注解的该方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存穿透与缓存雪崩</title>
      <link href="/2018/04/17/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
      <url>/2018/04/17/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存穿透与缓存雪崩"><a href="#缓存穿透与缓存雪崩" class="headerlink" title="缓存穿透与缓存雪崩"></a>缓存穿透与缓存雪崩</h2><p>设计一个缓存系统，不得不考虑的问题就是缓存穿透，缓存击穿与失效时的雪崩效应。</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 总结</title>
      <link href="/2018/04/16/Maven%20%E6%80%BB%E7%BB%93/"/>
      <url>/2018/04/16/Maven%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven-总结"><a href="#Maven-总结" class="headerlink" title="Maven 总结"></a>Maven 总结</h2><h4 id="Maven-是什么？"><a href="#Maven-是什么？" class="headerlink" title="Maven 是什么？"></a>Maven 是什么？</h4><p>Maven 是一个项目管理和整合工具。Maven 为开发者提供了一套完整的构建生命周期框架。开发团队几乎不用花多少时间就能够自动完成工程的基础构建配置，因为 Maven 使用了一个标准的目录结构和一个默认的构建生命周期。</p><p>在有多个开发团队环境的情况下，Maven 能够在很短的时间内使得每项工作都按照标准进行。因为大部分的工程配置操作都非常简单并且可复用，在创建报告、检查、构建和测试自动配置时，Maven 可以让开发者的工作变得更简单。</p><p>Maven 能够帮助开发者完成以下工作：构建，文档生成，报告，依赖，SCMs，发布，分发，邮件列表。</p><p>总的来说，Maven 简化了工程的构建过程，并对其标准化。它无缝衔接了编译、发布、文档生成、团队合作和其他任务。Maven 提高了重用性，负责了大部分构建相关的任务。</p><h4 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h4><p>POM 代表工程对象模型。它是使用 Maven 工作时的基本组建，是一个 xml 文件。它被放在工程根目录下，文件命名为 pom.xml。POM 包含了关于工程和各种配置细节的信息，Maven 使用这些信息构建工程。所有的 POM 文件需要 <strong>project</strong> 元素和三个必须的字段：<strong>groupId, artifactId,version</strong>。在仓库中的工程标识为 <strong>groupId:artifactId:version</strong></p><p>groupid代表工程组的标识，一个组织中唯一。artifactid是工程的标识，通常是工程的名称。version 是工程的版本号。</p><h4 id="构建生命周期"><a href="#构建生命周期" class="headerlink" title="构建生命周期"></a>构建生命周期</h4><p>构建生命周期是一组阶段的序列（sequence of phases），每个阶段定义了目标被执行的顺序。这里的阶段是生命周期的一部分。举例说明，一个典型的 Maven 构建生命周期是由以下几个阶段的序列组成的。</p><ul><li><strong>验证（validate）</strong> - 验证项目是否正确，所有必要的信息可用</li><li><strong>编译（compile）</strong> - 编译项目的源代码</li><li><strong>测试（test）</strong> - 使用合适的单元测试框架测试编译的源代码。这些测试不应该要求代码被打包或部署</li><li><strong>打包（package）</strong> - 采用编译的代码，并以其可分配格式（如JAR）进行打包。</li><li><strong>验证（verify）</strong> - 对集成测试的结果执行任何检查，以确保满足质量标准</li><li><strong>安装（install）</strong> - 将软件包安装到本地存储库中，用作本地其他项目的依赖项</li><li><strong>部署（deploy）</strong> - 在构建环境中完成，将最终的包复制到远程存储库以与其他开发人员和项目共享。</li></ul><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>在 Maven 的术语中，仓库是一个位置（place），例如目录，可以存储所有的工程 jar 文件、library jar 文件、插件或任何其他的工程指定的文件。Maven 仓库有三种类型：本地(local),中央(central),远程(remote)</p><h5 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h5><p>Maven 本地仓库是机器上的一个文件夹。它在你第一次运行任何 maven 命令的时候创建。</p><p>Maven 本地仓库保存你的工程的所有依赖（library jar、plugin jar 等）。当你运行一次 Maven 构建，Maven 会自动下载所有依赖的 jar 文件到本地仓库中。它避免了每次构建时都引用存放在远程机器上的依赖文件。Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。</p><h5 id="中央仓库"><a href="#中央仓库" class="headerlink" title="中央仓库"></a>中央仓库</h5><p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。中央仓库的关键概念：这个仓库由 Maven 社区管理。不需要配置。需要通过网络才能访问。</p><h5 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h5><p>如果 Maven 在中央仓库中也找不到依赖的库文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p><h4 id="Maven的搜索顺序"><a href="#Maven的搜索顺序" class="headerlink" title="Maven的搜索顺序"></a>Maven的搜索顺序</h4><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><ul><li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中已被将来引用。</li><li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库已被将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li></ul><h4 id="Maven插件"><a href="#Maven插件" class="headerlink" title="Maven插件"></a>Maven插件</h4><p>Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven 插件通常被用来：</p><ul><li>创建 jar 文件</li><li>创建 war 文件</li><li>编译代码文件</li><li>代码单元测试</li><li>创建工程文档</li><li>创建工程报告</li></ul><p>插件通常提供了一个目标的集合，并且可以使用下面的语法执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn [plugin-name]:[goal-name]</span><br><span class="line"><span class="meta">#</span> 执行“plugin-name”插件的“goal-name”目标（或者称为动作）</span><br><span class="line"><span class="meta">#</span>用户可以通过两种方式调用Maven插件目标。</span><br><span class="line"><span class="meta">#</span>第一种方式是将插件目标与生命周期阶段（lifecycle phase）绑定，这样用户在命令行只是输入生命周期阶段而已，例如Maven默认将maven-compiler-plugin的compile目标与compile生命周期阶段绑定，因此命令mvn compile实际上是先定位到compile这一生命周期阶段，然后再根据绑定关系调用maven-compiler-plugin的compile目标。</span><br><span class="line"><span class="meta">#</span>第二种方式是直接在命令行指定要执行的插件目标，例如mvnarchetype:generate 就表示调用maven-archetype-plugin的generate目标，这种带冒号的调用方式与生命周期无关。</span><br></pre></td></tr></table></figure><table><thead><tr><th>插件</th><th>描述</th></tr></thead><tbody><tr><td>clean</td><td>构建之后清理目标文件。删除目标目录。</td></tr><tr><td>compiler</td><td>编译 Java 源文件。</td></tr><tr><td>surefile</td><td>运行 JUnit 单元测试。创建测试报告。</td></tr><tr><td>jar(package)</td><td>从当前工程中构建 JAR 文件。</td></tr><tr><td>war</td><td>从当前工程中构建 WAR 文件。</td></tr><tr><td>javadoc</td><td>为工程生成 Javadoc。</td></tr><tr><td>antrun</td><td>从构建过程的任意一个阶段中运行一个 ant 任务的集合。</td></tr></tbody></table><table><thead><tr><th><strong>Maven命令列表</strong></th><th></th></tr></thead><tbody><tr><td><strong>mvn –version</strong></td><td>显示版本信息</td></tr><tr><td><strong>mvn clean</strong></td><td>清理项目生产的临时文件,一般是模块下的target目录</td></tr><tr><td><strong>mvn compile</strong></td><td>编译源代码，一般编译模块下的src/main/java目录</td></tr><tr><td><strong>mvn package</strong></td><td>项目打包工具,会在模块下的target目录生成jar或war等文件</td></tr><tr><td><strong>mvn test</strong></td><td>测试命令,或执行src/test/java/下junit的测试用例.</td></tr><tr><td><strong>mvn install</strong></td><td>将打包的jar/war文件复制到你的本地仓库中,供其他模块使用</td></tr><tr><td><strong>mvn deploy</strong></td><td>将打包的文件发布到远程参考,提供其他人员进行下载依赖</td></tr><tr><td><strong>mvn site</strong></td><td>生成项目相关信息的网站</td></tr><tr><td><strong>mvn eclipse:eclipse</strong></td><td>将项目转化为Eclipse项目</td></tr><tr><td><strong>mvn dependency:tree</strong></td><td>打印出项目的整个依赖树</td></tr><tr><td><strong>mvn archetype:generate</strong></td><td>创建Maven的普通java项目</td></tr><tr><td><strong>mvn tomcat:run</strong></td><td>在tomcat容器中运行web应用</td></tr><tr><td><strong>mvn jetty:run</strong></td><td>调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用</td></tr></tbody></table><h4 id="Maven创建工程"><a href="#Maven创建工程" class="headerlink" title="Maven创建工程"></a>Maven创建工程</h4><p>Maven 使用<strong>原型（archetype）</strong>插件创建工程。要创建一个简单的 Java 应用，我们将使用 maven-archetype-quickstart 插件。在下面的例子中，将在 \MVN 文件夹下创建一个基于 maven 的 java 应用工程。打开命令控制台，跳转到 \MVN 目录，并执行下面的 <strong>mvn</strong> 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> \MVN&gt;mvn archetype:generate</span><br><span class="line">-DgroupId=com.companyname.bank </span><br><span class="line">-DartifactId=consumerBanking </span><br><span class="line">-DarchetypeArtifactId=maven-archetype-quickstart </span><br><span class="line">-DinteractiveMode=false</span><br></pre></td></tr></table></figure><h4 id="Maven构建-amp-测试工程"><a href="#Maven构建-amp-测试工程" class="headerlink" title="Maven构建&amp;测试工程"></a>Maven构建&amp;测试工程</h4><p>打开命令控制台，跳转到 \MVN\consumerBanking 目录下，并执行以下 <strong>mvn</strong> 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\MVN\consumerBanking&gt;mvn clean package #package的作用是打包</span><br></pre></td></tr></table></figure><p>Maven 将开始构建工程。</p><p>已经构建了你的工程并创建了最终的 jar 文件，下面是要学习的关键概念：</p><ul><li>我们给了 maven 两个目标，首先清理目标目录（clean），然后打包工程构建的输出为 jar（package）文件。</li><li>打包好的 jar 文件可以在 <code>demo\target</code>中获得，名称为 demo-1.0-SNAPSHOT.jar。</li><li>测试报告存放在 demo\target\surefire-reports 文件夹中。</li><li>Maven 编译源码文件，以及测试源码文件。</li><li>接着 Maven 运行测试用例。</li><li>最后Maven创建工程包。</li></ul><h4 id="编译工程"><a href="#编译工程" class="headerlink" title="编译工程"></a>编译工程</h4><p>当添加了一个文件后，可以输入下面的命令重新编译文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean compile</span><br></pre></td></tr></table></figure><h4 id="Maven中添加外部依赖"><a href="#Maven中添加外部依赖" class="headerlink" title="Maven中添加外部依赖"></a>Maven中添加外部依赖</h4><p>当远程仓库和中央仓库中都没有相关依赖时，可以手动添加jar包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;\src\lib\ldapjdk.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Maven工程文档"><a href="#Maven工程文档" class="headerlink" title="Maven工程文档"></a>Maven工程文档</h4><p>在Demo项目目录下执行<code>mvn site</code>生成工程文档，打开 \demo\target\site 文件夹。点击 index.html 就可以看到文档了。</p><h4 id="Maven工程模板"><a href="#Maven工程模板" class="headerlink" title="Maven工程模板"></a>Maven工程模板</h4><h2 id="Maven-工程模板"><a href="#Maven-工程模板" class="headerlink" title="Maven - 工程模板"></a>Maven - 工程模板</h2><p>Maven 使用原型（Archetype）概念为用户提供了大量不同类型的工程模版（614 个）。Maven 使用下面的命令帮助用户快速创建 java 项目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate</span><br></pre></td></tr></table></figure><p>原型是一个 Maven 插件，它的任务是根据模板创建一个项目结构。我们将使用 quickstart 原型插件创建一个简单的 java 应用程序。</p><p>打开命令控制台，跳转到 <strong>\ MVN</strong> 目录并执行以下 <strong>mvn</strong> 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\MVN&gt;mvn archetype:generate</span><br></pre></td></tr></table></figure><p>Maven 将开始处理，并要求选择所需的原型</p><h3 id="mvn-compile与mvn-install、mvn-deploy的区别"><a href="#mvn-compile与mvn-install、mvn-deploy的区别" class="headerlink" title="mvn compile与mvn install、mvn deploy的区别"></a>mvn compile与mvn install、mvn deploy的区别</h3><ol><li>mvn compile，编译类文件</li><li>mvn install，包含mvn compile，mvn package，然后上传到本地仓库</li><li>mvn deploy,包含mvn install,然后，上传到本地仓库</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 网络和存储管理</title>
      <link href="/2018/04/11/Docker%20%E7%BD%91%E7%BB%9C%E5%92%8C%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2018/04/11/Docker%20%E7%BD%91%E7%BB%9C%E5%92%8C%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-网络和存储管理"><a href="#Docker-网络和存储管理" class="headerlink" title="Docker 网络和存储管理"></a>Docker 网络和存储管理</h2><h3 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h3><p>网络是虚拟化技术中最复杂的部分，也是Docker 应用中的一个重要环节。Docker中的网络主要解决容器与容器，容器与外部网络，外部网络与容器之间互相通信的问题。</p><h4 id="Docker-通信方式"><a href="#Docker-通信方式" class="headerlink" title="Docker 通信方式"></a>Docker 通信方式</h4><p>在默认情况下，Docker 使用网桥(二层设备)+NAT的通信模型。如下图所示：<br><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-10%2010-20-05%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>Docker启动时会默认自动创建网桥设备Docker0 ，实际上是一个Linux的bridge，可以理解为一个软件交换机它会在挂载到它的网口之间进行转发,同时，Docker随机分配一个本地未占用的私有网段中的一个地址给docker0接口，比如典型的<code>172.17.42.1</code>，掩码是255.255.0.0，此后启动的容器内的网口也会自动分配一个同一个网段的地址。</p><p>当Docker启动容器时，会创建一对veth虚拟网络设备（当数据包发送到一个接口时，另外一个借口也可以收到相同的数据包），这对接口一端在容器内，即eth0,另一端在本地被挂载到docker0网桥，名称以veth开头。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker就创建了主机和所有容器之间一个虚拟共享网络。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-10%2014-49-54%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>为了解决容器与外部网络之间的通信，Docker引入了NAT.</p><h3 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h3><h4 id="网络设置参数"><a href="#网络设置参数" class="headerlink" title="网络设置参数"></a>网络设置参数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-b/--bridge: 指定Docker 使用的网桥设备</span><br><span class="line">--bip  指定网桥设备docker0的IP和掩码。</span><br><span class="line">--dns 配置容器的DNS</span><br></pre></td></tr></table></figure><h3 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h3><p>容器中可以运行一些网络应用，，要让外部也可以访问这些应用，可以通过-P或者-p参数来指定端口映射。使用-P标记时，Docker会随机映射一个49000-49900的端口到内部容器开放的网络端口。</p><p>-p可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器，支持的格式有<code>IP:hostport:containerPort</code></p><p>可以使用<code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址。</p><h3 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h3><p>Docker 容器一旦删除，容器本身对应的rootfs文件系统就会被删除，容器中的所有数据也将随之删除。但有时候，想要数据不随容器删除而删除，还有时候，希望同一台Host容器之间可以共享数据。</p><p>为此，Docker提供了数据卷，数据卷除了可以持久化数据，还可以用于容器之间共享数据。</p><p>数据卷是一个可以供一个或者多个容器使用的特殊目录，它绕过UFS,可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷会默认一直存在，即使容器被删除。</li></ul><h4 id="创建并查看一个数据卷"><a href="#创建并查看一个数据卷" class="headerlink" title="创建并查看一个数据卷"></a>创建并查看一个数据卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker volume create my-vol #创建一个数据卷</span><br><span class="line"><span class="meta">$</span> docker volume ls #查看所有数据卷</span><br><span class="line"><span class="meta">$</span> docker volume inspect my-vol #查看指定数据卷信息</span><br><span class="line"><span class="meta">$</span> docker volume rm my-vol #删除数据卷</span><br></pre></td></tr></table></figure><h5 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h5><p>在用docker run命令的时候，使用 <code>--mount</code>标记来将数据卷挂载到容器里，在一个docker run中可以挂载多个数据卷。</p><p>下面创建一个名为web的容易，并加载一个数据卷到容器的、webapp目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -d -P --name web --mount source=my-vol,target=/webapp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 镜像管理&amp;仓库管理</title>
      <link href="/2018/04/11/Docker%20%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/"/>
      <url>/2018/04/11/Docker%20%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-镜像管理-amp-仓库管理"><a href="#Docker-镜像管理-amp-仓库管理" class="headerlink" title="Docker 镜像管理&amp;仓库管理"></a>Docker 镜像管理&amp;仓库管理</h2><p>创建容器时需要指定使用哪个镜像，新容器创建后，不依赖镜像就可以运行。使用<code>docker images</code> 可以查找到本机已有的所有镜像。</p><p>每个镜像也有唯一的标示ImageID，和容器的<code>Container ID</code>一样，默认128位，可以使用前16位的缩略形式。</p><h4 id="镜像的分层"><a href="#镜像的分层" class="headerlink" title="镜像的分层"></a>镜像的分层</h4><p>通过docker images  可以看到每个镜像的大小都很大，但是镜像所占的磁盘空间之和远远小于所有镜像之和。原因是镜像采用了分层机制，相同部分独立成层，只需要存储一份就可以了。大大节省了镜像空间。比如wordpress和mysql都是基于ubuntu系统构建的，那么就只需要一个ubuntu的镜像分层，再次基础上再根据wordpress 和mariadb各自不同1部分构建各自的独立分层。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-09%2017-02-30%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>Docker 的镜像通过联合文件系统将各层文件系统叠加在一起，在用户看来就像一个完整的文件系统。例如某个镜像有两层，第一层有三个文件夹，第二层有两个文件夹，使用联合文件系统叠加后，用户可以看到五个文件夹，感觉不到分层的存在。</p><p>通过<code>docker history</code>可以查询镜像分了多少层，每一层做了什么操作。</p><p>对于分层的Docker 镜像有两个特性，一个是已有的分层只能读不能修改，另一个是上层镜像的优先级高于底层镜像。</p><p> 下面举一个例子:</p><p>镜像B和镜像C都是在镜像A的基础上搭建起来的，镜像A有一个文件a.txt.内容为“HELLO WORLD”,从用户的视角来看，镜像B和镜像C都可以看到文件a.txt，且内容都是“HELLO,WORLD”,这时镜像B想要修改a.txt的内容为“hello docker”如果我们允许直接对镜像A中的文件a.txt进行修改，那么C看到的内容也会发生改变，这对C来说，是不可接受的，所以已有的分层都是不能修改的，要修改的话，只能通过在镜像B的基础上新增加一个分层B’,存储修改后的a.txt，利用上层镜像的优先级高于底层镜像原则，新增加的分层B’中的a.txt会覆盖原有镜像A的a.txt,从用户的视角，就会看到修改后的a.txt的内容为HELLO docker, 而镜像C看到的还是hello world</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-10%2009-26-08%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-10%2009-29-58%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>每行都以一个关键字为行首，如果一行内容过长，它使用’\’把多行连接在一起。</p><p>第一行使用关键字FROM,表示新的镜像是从Ubuntu这个基础镜像开始构建的，MAINTAINER:指定该镜像的创建者 ENV:设置环境变量。</p><p>RUN:运行shell命令 多条命令用&amp;&amp;连接。</p><p>COPY 将编译机本地文件拷贝到镜像文件系统中。</p><p>EXPOSE:指定监听的端口</p><p>ENTRYPOINT: 欲执行命令，创建镜像时不执行，等到使用该镜像创建容器，容器启动后才执行的命令。</p><h4 id="项目中的镜像分层"><a href="#项目中的镜像分层" class="headerlink" title="项目中的镜像分层"></a>项目中的镜像分层</h4><p>将两个项目gitlab和Redmine两个项目的所有镜像分层放一起来看，可以发现：</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-10%2009-41-49%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><ul><li>每个镜像加一个可写层形成容器，多个容器组合在一起，对外提供某些特殊功能的服务。</li><li>基于同一个镜像只需要增加一个可写层，就可以为不同项目创建各自需要的容器。</li></ul><h2 id="Docker-仓库管理"><a href="#Docker-仓库管理" class="headerlink" title="Docker 仓库管理"></a>Docker 仓库管理</h2><p>仓库主要用于镜像的存储，它是Docker镜像分发，部署的关键，实际应用中，由开发者或者运维制作好应用程序镜像，然后上传到镜像仓库，Docker 守护进程再从仓库拉取镜像，然后运行相应的镜像。</p><h3 id="镜像公有仓库"><a href="#镜像公有仓库" class="headerlink" title="镜像公有仓库"></a>镜像公有仓库</h3><h4 id="登录DockerHub"><a href="#登录DockerHub" class="headerlink" title="登录DockerHub"></a>登录DockerHub</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker login</span><br><span class="line">Username:</span><br><span class="line">Password:</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li>上传镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker push ubuntu1404-baseimage:1.0</span><br></pre></td></tr></table></figure><ul><li>搜索镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker search centos</span><br></pre></td></tr></table></figure><ul><li>下载镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker pull</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 容器管理</title>
      <link href="/2018/04/11/Docker%20%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2018/04/11/Docker%20%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-容器管理"><a href="#Docker-容器管理" class="headerlink" title="Docker 容器管理"></a>Docker 容器管理</h2><p>每个容器被创建后，都会分配一个CONTAINER ID作为容器的唯一标示。后续对容器的所有操作，都是通过这个ID来完成的。ID默认128位，但是对于大多数主机来说，前16位就足够保证唯一性。</p><p>虽然CONTAINER ID能保证唯一性，但是很难记忆，所以创建容器时，可以用 –name参数给容器起一个别名。</p><h4 id="查询容器信息"><a href="#查询容器信息" class="headerlink" title="查询容器信息"></a>查询容器信息</h4><p>通过docker inspect 可以查询容器的所有基本信息，包括运行情况，存储位置，配置参数，网络设置等。</p><p>同时可以用docker logs 查看容器日志</p><p>使用 docker stats 查看容器所占用的系统资源</p><h4 id="容器内部命令"><a href="#容器内部命令" class="headerlink" title="容器内部命令"></a>容器内部命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec +容器名 +容器内执行的命令</span><br></pre></td></tr></table></figure><p>比如查询MyWordPress 容器内启动了哪些进程，执行的命令和结果是</p><p><code>$ docker exec  MyWordPress ps aux</code></p><p>如果希望在容器内连续执行多条命令，可以加上<code>-it</code>参数，相当于以root身份进入容器内，可以连续执行命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker exec -it MywordPress /bin/bash</span><br></pre></td></tr></table></figure><h4 id="多容器管理"><a href="#多容器管理" class="headerlink" title="多容器管理"></a>多容器管理</h4><p>假如一个服务需要多个进程组成，就需要创建多个容器组成一个系统，相互分工和配合来对外提供完整的服务。</p><p>在同一台主机下，docker run 命令提供 <code>--link</code>选项建立容器间的互联。</p><p>但有一个前提条件，使用<code>-- link containerA</code> 创建容器B时，容器A必须已经创建并且启动运行。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 安装WordPress</title>
      <link href="/2018/04/11/Docker%20%E5%AE%89%E8%A3%85WordPress/"/>
      <url>/2018/04/11/Docker%20%E5%AE%89%E8%A3%85WordPress/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-安装WordPress"><a href="#Docker-安装WordPress" class="headerlink" title="Docker 安装WordPress"></a>Docker 安装WordPress</h2><p>使用两行命令安装WordPress</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run --name db --env MYSQL_ROOT_PASSWORD=example -d mariadb</span><br><span class="line"><span class="meta">$</span> docker run --name MyWordPress --link db:mysql -p 8080:80 -d wordpress</span><br></pre></td></tr></table></figure><p>docker run是一条指令，后面的所有内容 都是Docker指令的参数</p><p>这条指令的含义是启动一个mariadb数据库(MYSQL数据库的一个分支)，数据库管理员的名字设置为example,让这个数据库运行在后台，给它取了一个唯一的名字db进行标示。</p><p>通过参数的最后一部分<code>mariadb</code>来告诉docker run启动的是一个<code>mariadb</code>数据库。</p><p><code>-d</code>参数把启动的<code>mariadb</code>数据库设置到后台运行，如果没有该参数，该进程就会在前台运行。</p><p><code>--name db</code>参数，给这个运行的mariadb数据库起一个名字，如果要启动多个数据库，可以通过名字进行定位。</p><p>第二条指令中<code>--link db:mysql</code>把wordpress和数据库建立了连接。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 三次握手与四次挥手</title>
      <link href="/2018/04/08/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2018/04/08/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-三次握手与四次挥手"><a href="#TCP-三次握手与四次挥手" class="headerlink" title="TCP 三次握手与四次挥手"></a>TCP 三次握手与四次挥手</h2><h3 id="常用的熟知端口号"><a href="#常用的熟知端口号" class="headerlink" title="常用的熟知端口号"></a>常用的熟知端口号</h3><table><thead><tr><th>应用程序</th><th>FTP</th><th>TFTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>HTTP</th><th>SSH</th><th>MYSQL</th></tr></thead><tbody><tr><td>熟知端口</td><td>21,20</td><td>69</td><td>23</td><td>25</td><td>53</td><td>80</td><td>22</td><td>3306</td></tr><tr><td>传输层协议</td><td>TCP</td><td>UDP</td><td>TCP</td><td>TCP</td><td>UDP</td><td>TCP</td><td></td></tr></tbody></table><h4 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h4><p>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。 </p><h4 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="TCP报文首部"></a>TCP报文首部</h4><ol><li>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</li><li>序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</li><li>确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</li><li>数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；</li><li>保留，占6位，保留今后使用，但目前应都位0；</li><li>紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</li><li>确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；</li><li>推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</li><li>复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</li><li>同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；</li><li>终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；</li><li>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li><li>检验和，占2字节，校验首部和数据这两部分；</li><li>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</li><li>选项，长度可变，定义一些其他的可选的参数。</li></ol><h4 id="TCP-标志位"><a href="#TCP-标志位" class="headerlink" title="TCP 标志位"></a>TCP 标志位</h4><p>SYN：代表请求创建连接，所以在三次握手中前两次要SYN=1，表示这两次用于建立连接。</p><p>FIN：表示请求关闭连接，在四次分手时，我们发现FIN发了两遍。这是因为TCP的连接是双向的，所以一次FIN只能关闭一个方向。</p><p>ACK：代表确认接受，从上面可以发现，不管是三次握手还是四次分手，在回应的时候都会加上ACK=1，表示消息接收到了，并且在建立连接以后的发送数据时，都需加上ACK=1,来表示数据接收成功。</p><p>seq:序列号，什么意思呢？当发送一个数据时，数据是被拆成多个数据包来发送，序列号就是对每个数据包进行编号，这样接受方才能对数据包进行再次拼接。</p><p>初始序列号是随机生成的，这样不一样的数据拆包解包就不会连接错了。（例如：两个数据都被拆成1，2，3和一个数据是1，2，3一个是101，102，103，很明显后者不会连接错误）</p><p>ack:这个代表下一个数据包的编号，这也就是为什么第二请求时，ack是seq+1，</p><h3 id="TCP-连接的建立"><a href="#TCP-连接的建立" class="headerlink" title="TCP 连接的建立"></a>TCP 连接的建立</h3><blockquote><p><strong>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</strong></p></blockquote><ol><li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li><li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同步位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li><li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li><li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li><li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 </li></ol><p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-08%2021-12-08%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h4 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？"></a>为什么TCP客户端最后还要发送一次确认呢？</h4><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h3 id="TCP-连接的释放"><a href="#TCP-连接的释放" class="headerlink" title="TCP 连接的释放"></a>TCP 连接的释放</h3><blockquote><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</p></blockquote><ol><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ol><p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-08%2021-22-15%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>(客户端多等待2MSL<strong>两个最长报文段寿命</strong>)</p><h4 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h4><blockquote><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p><p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p></blockquote><h4 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h4><blockquote><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 </p><p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p></blockquote><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><blockquote><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归的时间复杂度分析</title>
      <link href="/2018/04/08/%E9%80%92%E5%BD%92%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2018/04/08/%E9%80%92%E5%BD%92%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="递归的时间复杂度分析"><a href="#递归的时间复杂度分析" class="headerlink" title="递归的时间复杂度分析"></a>递归的时间复杂度分析</h2><h4 id="递归中进行一次递归调用的复杂度分析"><a href="#递归中进行一次递归调用的复杂度分析" class="headerlink" title="递归中进行一次递归调用的复杂度分析"></a>递归中进行一次递归调用的复杂度分析</h4><p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-10%2013-00-20%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>这种情况下，当没有找到target时，或者在左半部分递归继续寻找，或者在右半部分继续寻找，也就是在一次递归中，最多再进行一次递归调用，这时，时间复杂度就是递归的最大深度。（同时，处理时是O(1)的）</p><p>总结：如果在递归函数中，只进行一次递归调用，递归深度为depth,在每个递归函数中，时间复杂度为T,则总体时间复杂度为O(T*depth)。</p><h4 id="递归中进行多次递归调用"><a href="#递归中进行多次递归调用" class="headerlink" title="递归中进行多次递归调用"></a>递归中进行多次递归调用</h4><p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-10%2014-22-56%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>此时主要需要关注调用的次数，可以画一颗递归树，像上图一样的，节点的个数就是调用的次数。</p><p>所以这个函数是<code>2^0+2^1+2^2+2^3+2^4+...+2^n</code>=O(2^n)</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-10%2014-28-14%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>在归并排序中，每次处理的元素规模是逐渐变小的，当有8个元素时，树只有三层。每一层处理的规模都是8（8，4+4，2+2+2+2）所以总体是O(nlogn)</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC定时任务</title>
      <link href="/2018/04/06/SpringMVC%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/04/06/SpringMVC%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC-定时任务"><a href="#SpringMVC-定时任务" class="headerlink" title="SpringMVC 定时任务"></a>SpringMVC 定时任务</h2><p>在SpringMVC里使用spring的定时任务非常的简单。主要步骤如下：</p><p>一：在XML中加入task的命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xmlns:task="http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">task</span>"   </span></span><br><span class="line"><span class="tag"><span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">task</span> <span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">task</span>/<span class="attr">spring-task-4.1.xsd</span>&gt;</span><span class="tag">&lt;/<span class="name">xmlns:task</span>&gt;</span></span><br></pre></td></tr></table></figure><p>二：启用注解驱动的定时任务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">scheduler</span>=<span class="string">"myScheduler"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>三：配置定时任务的线程池</p><p>推荐配置一个线程池，若不配置的话多任务下就会有问题。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"myScheduler"</span> <span class="attr">pool-size</span>=<span class="string">"5"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>四：就是写定时任务方法了</p><p>@Scheduled 注解为定时任务，cron表达式里写执行的时机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ATask</span> <span class="keyword">implements</span> <span class="title">IATask</span></span>&#123;  </span><br><span class="line">       <span class="meta">@Scheduled</span>(cron=<span class="string">"0/10 * *  * * ? "</span>)   <span class="comment">//每10秒执行一次      </span></span><br><span class="line">       <span class="meta">@Override</span>      </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aTask</span><span class="params">()</span></span>&#123;      </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">20</span>);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">            DateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);    </span><br><span class="line">            System.out.println(sdf.format(DateTime.now().toDate())+<span class="string">"*A任务每10秒执行一次进入测试"</span>);      </span><br><span class="line">       &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTask</span> <span class="keyword">implements</span> <span class="title">IBTask</span></span>&#123;  </span><br><span class="line">       <span class="meta">@Scheduled</span>(cron=<span class="string">"0/5 * *  * * ? "</span>)   <span class="comment">//每5秒执行一次      </span></span><br><span class="line">       <span class="meta">@Override</span>   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bTask</span><span class="params">()</span></span>&#123;     </span><br><span class="line">             DateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);                 System.out.println(sdf.format(DateTime.now().toDate())+<span class="string">"*********B任务每5秒执行一次进入测试"</span>);      </span><br><span class="line">       &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring的定时任务默认是单线程<strong>，</strong>多个任务执行起来时间会有问题（B任务会因为A任务执行起来需要20S而被延后20S执行），如下图所示：</p><p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-04-08%2010-56-32%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=0i/PNPD04Jmv+2jaQJCHSDQ44U1hPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI1NzQ4Mjk1JnQ9MTUyMzE1NjI5NSZyPTE0OTY3NDQxOTYmZj0vMjAxOC0wNC0wOCUyMDEwLTU2LTMyJUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""></p><p>当配置了线程池以后，B任务就不会A任务执行而延后了。</p><h4 id="cron-表达式"><a href="#cron-表达式" class="headerlink" title="cron 表达式"></a>cron 表达式</h4><p>一个cron表达式有至少6个（也可能7个）有空格分隔的时间元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">按顺序依次为</span><br><span class="line">      1  秒（0~59）</span><br><span class="line">      2  分钟（0~59）</span><br><span class="line">      3 小时（0~23）</span><br><span class="line">      4  天（0~31）</span><br><span class="line">      5 月（0~11）</span><br><span class="line">      6  星期（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）</span><br><span class="line">      7.年份（1970－2099）</span><br><span class="line">      其中每个元素可以是一个值(如6),一个连续区间(9-12),一个间隔时间(8-18/4)(/表示每隔4小时),一个列表(1,3,5),通配符。由于"月份中的日期"和"星期中的日期"这两个元素互斥的,必须要对其中一个设置?.</span><br><span class="line"> 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点</span><br><span class="line">       0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时</span><br><span class="line">       0 0 12 ? * WED 表示每个星期三中午12点</span><br><span class="line">       "0 0 12 * * ?" 每天中午12点触发 </span><br><span class="line">       "0 15 10 ? * *" 每天上午10:15触发 </span><br><span class="line">       "0 15 10 * * ?" 每天上午10:15触发 </span><br><span class="line">       "0 15 10 * * ? *" 每天上午10:15触发 </span><br><span class="line">       "0 15 10 * * ? 2005" 2005年的每天上午10:15触发 </span><br><span class="line">       "0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发 </span><br><span class="line">       "0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发 </span><br><span class="line">       "0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 </span><br><span class="line">       "0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发 </span><br><span class="line">       "0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发 </span><br><span class="line">       "0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发 </span><br><span class="line">       "0 15 10 15 * ?" 每月15日上午10:15触发 </span><br><span class="line">       "0 15 10 L * ?" 每月最后一日的上午10:15触发 </span><br><span class="line">       "0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发 </span><br><span class="line">       "0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发 </span><br><span class="line">       "0 15 10 ? * 6#3" 每月的第三个星期五上午10:15触发 </span><br><span class="line">       有些子表达式能包含一些范围或列表</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Compose</title>
      <link href="/2018/04/06/Docker%20Compose/"/>
      <url>/2018/04/06/Docker%20Compose/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Docker compose 是Docker官方编排的项目之一，负责快速的部署分布式应用。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>负责实现对Docker容器集群的快速编排。从功能上看，跟openstack中的Heat十分类似。</p><p>Compose定位是定义和运行多个Docker 容器的应用。</p><p>通过一个Dockerfile模板文件，可以让用户很方便的定义一个单独的应用容器，但是很多情况下，需要多个容器相互配合来完成某项任务，Compose刚好满足了这样的需求。</p><p>它允许用户通过一个单独的<code>docker-compose.yml</code>模板文件来定义一组相关联的应用容器为一个项目。</p><p>Compose中有两个重要的概念，分别是</p><ul><li>服务：一个应用的容器，实际上也可以包括若干运行相同镜像的容器实例。</li><li>项目：由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml中定义。</li></ul><p>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><p>可见，一个项目可以由多个服务(容器)关联而成，Compose面向项目进行管理。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>编写一个app.py文件用来记录页面访问次数，然后编写Dockerfile文件。,</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span>-alpine</span><br><span class="line"><span class="keyword">ADD</span> . /code</span><br><span class="line">WORDDIR /code</span><br><span class="line">RUN pip install redis flask</span><br><span class="line">CMD ["python","app.py"]</span><br></pre></td></tr></table></figure><p>然后编写docker-compose.yml文件，这是Compose使用的主模板文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line"><span class="attr">web:</span></span><br><span class="line"><span class="attr">build:</span> <span class="string">.</span></span><br><span class="line"><span class="string">port</span> <span class="string">:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line"><span class="attr">redis:</span> </span><br><span class="line"><span class="attr">image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure><p>运行compose项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker-compose up</span><br></pre></td></tr></table></figure><h3 id="Compose-命令说明"><a href="#Compose-命令说明" class="headerlink" title="Compose 命令说明"></a>Compose 命令说明</h3><p>对于Compose来说，大部分的命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p><p>执行<code>docker-compose [COMMAND] --help</code> 或者<code>docker-compose help [COMMAND]</code></p><p>可以查看具体某个命令的使用格式。</p><ul><li>build 是构建项目中的服务容器</li><li>config验证compose文件格式是否正确</li><li>down命令停止up命令所启动的容器，并移除网络</li><li>exec进入指定的容器</li><li>help获得一个命令的帮助</li><li>images列出compose文件中包含的镜像</li><li>Kill 强行停止服务容器</li><li>logs 查看服务容器的输出</li><li>pause 暂停一个服务容器</li><li>port 打印某个容器端口所映射的公共端口</li><li>ps 列出项目中目前的所有容器</li><li>pull 拉取服务依赖的镜像</li><li>push 推送服务依赖的镜像到Docker 镜像仓库</li><li>restart 重启项目中的服务</li><li>rm 删除所有停止的服务容器</li><li>run 在指定服务上执行一个命令</li><li>scale设置指定服务运行的容器个数</li><li>start 启动已经存在的服务容器</li><li>stop 停止已经处于运行状态的容器，但是不删除它。</li><li>top 查看各个容器内运行的进程</li><li>up 自动完成构建容器，重新创建服务，启动服务，并关联服务相关容器的一系列操作。</li></ul><h3 id="Compose-模板文件"><a href="#Compose-模板文件" class="headerlink" title="Compose 模板文件"></a>Compose 模板文件</h3><p>模板文件是使用compose的核心，默认文件名是docker-compose.yml。格式是YAML</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">webapp:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">example/web</span></span><br><span class="line"><span class="attr">port:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"80:80"</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"/data"</span></span><br></pre></td></tr></table></figure><h5 id="build"><a href="#build" class="headerlink" title="build"></a>build</h5><p>指定Dockerfile 所在文件夹的路径。Compose 将会利用它来自动构建这个镜像，然后使用这个镜像。</p><h5 id="command"><a href="#command" class="headerlink" title="command"></a>command</h5><p>覆盖容器启动后默认执行的命令。</p><h5 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h5><p>自定义DNS服务器，可以是一个值，也可以是一个列表。</p><h5 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h5><p>挂载一个tmpfs文件系统到容器</p><h5 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h5><p>从文件中获取环境变量</p><h5 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h5><p>设置环境变量</p><h5 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h5><p>暴露端口，但是不映射到宿主机，只被连接的服务访问。</p><h5 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h5><p>存储敏感数据</p><h5 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h5><p>暴露端口信息</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="/2018/04/06/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/04/06/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><p><strong>意图：</strong>避免请求发送者与接收者（链）耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p><strong>何时使用：</strong>在处理消息的时候以过滤很多道。</p><p><strong>如何解决：</strong>拦截的类都实现统一接口。</p><p><strong>关键代码：</strong>Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p><p><strong>应用实例：</strong> 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</p><p><strong>优点：</strong> 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。</p><p><strong>缺点：</strong> 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。</p><p><strong>使用场景：</strong> 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p><p><strong>注意事项：</strong>在 JAVA WEB 中遇到很多应用。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们创建抽象类 <em>AbstractLogger</em>，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 <em>AbstractLogger</em>。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。(也就是说，这三个记录器就是链上的处理者)</p><p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-04-04%2011-37-02%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=D4Tm9TAFb/+mrfn7nV7z0/1QTuxhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI1NDA1MDY2JnQ9MTUyMjgxMzA2NiZyPTE0NzgyOTEyMTEmZj0vMjAxOC0wNC0wNCUyMDExLTM3LTAyJUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""></p><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h4><p>创建抽象的记录器类。</p><p><em>AbstractLogger.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line">   <span class="comment">//责任链中的下一个元素</span></span><br><span class="line">   <span class="keyword">protected</span> AbstractLogger nextLogger;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.nextLogger = nextLogger;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.level &lt;= level)&#123;</span><br><span class="line">         write(message);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(nextLogger !=<span class="keyword">null</span>)&#123;</span><br><span class="line">         nextLogger.logMessage(level, message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>创建扩展了该记录器类的实体类。</p><p><em>ConsoleLogger.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConsoleLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;        </span><br><span class="line">      System.out.println(<span class="string">"Standard Console::Logger: "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>ErrorLogger.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;        </span><br><span class="line">      System.out.println(<span class="string">"Error Console::Logger: "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>FileLogger.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;        </span><br><span class="line">      System.out.println(<span class="string">"File::Logger: "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。</p><p><em>ChainPatternDemo.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AbstractLogger <span class="title">getChainOfLoggers</span><span class="params">()</span></span>&#123;</span><br><span class="line">      AbstractLogger errorLogger = <span class="keyword">new</span> ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">      AbstractLogger fileLogger = <span class="keyword">new</span> FileLogger(AbstractLogger.DEBUG);</span><br><span class="line">      AbstractLogger consoleLogger = <span class="keyword">new</span> ConsoleLogger(AbstractLogger.INFO);</span><br><span class="line">      errorLogger.setNextLogger(fileLogger);</span><br><span class="line">      fileLogger.setNextLogger(consoleLogger);</span><br><span class="line">      <span class="keyword">return</span> errorLogger;    </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line">      loggerChain.logMessage(AbstractLogger.INFO, <span class="string">"This is an information."</span>);</span><br><span class="line">      loggerChain.logMessage(AbstractLogger.DEBUG, <span class="string">"This is an debug level information."</span>);</span><br><span class="line">      loggerChain.logMessage(AbstractLogger.ERROR, <span class="string">"This is an error information."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h4><p>验证输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Standard Console::Logger: This is an information.</span><br><span class="line">File::Logger: This is an debug level information.</span><br><span class="line">Standard Console::Logger: This is an debug level information.</span><br><span class="line">Error Console::Logger: This is an error information.</span><br><span class="line">File::Logger: This is an error information.</span><br><span class="line">Standard Console::Logger: This is an error information.</span><br></pre></td></tr></table></figure><blockquote><p><a href="http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络问题总结</title>
      <link href="/2018/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络问题总结"><a href="#计算机网络问题总结" class="headerlink" title="计算机网络问题总结"></a>计算机网络问题总结</h2><h4 id="HTTP-TCP-IP的用途区别"><a href="#HTTP-TCP-IP的用途区别" class="headerlink" title="HTTP,TCP,IP的用途区别"></a>HTTP,TCP,IP的用途区别</h4><p>http负责将什么样的数据送给对方，同时，http接收端负责解释这些数据的真正含义</p><p>TCP负责将客户的数据按序送到客户指定的目的地，如果有丢失，则负责重传。</p><p>IP协议负责TCP输入的客户目的地，根据一定的策略将数据送到目的地。IP协议无法保证对端一定活着，IP是不够智能的，只能简单的运送，无法解决丢包重传，重新排序，流量控制等复杂的操作。如果没有上层的Tcp协议，应用层的协议就要无时无刻不盯着自己发送的数据包，超时就重传。乱序则排序，把这些功能抽象出来就是TCP的作用。</p><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>socket函数是<strong>操作系统内核将“TCP/IP协议栈 + 底层网卡”抽象出来的一个个用户友好的函数，用于操纵本地的“TCP/IP协议栈 + 底层网卡”与远端的服务器/主机完成通信的任务。</strong></p><h4 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h4><p>所谓数据帧（Data frame），就是数据链路层的协议数据单元，它包括三部分：帧头，数据部分，帧尾。其中，帧头和帧尾包含一些必要的控制信息，比如同步信息、地址信息、差错控制信息等；数据部分则包含网络层传下来的数据，比如IP数据包。</p><h4 id="链路层和网络层的关系"><a href="#链路层和网络层的关系" class="headerlink" title="链路层和网络层的关系"></a>链路层和网络层的关系</h4><p>数据链路层提供直连两个设备之间的通信功能。与此相比，作为网络层的IP则负责在没有直连的两个网络之间进行通信传输。</p><p>好比一个人要去很远的地方旅行，其中要坐汽车，要坐火车，要坐船。同时他做了一个规划表，详细制定了几点到几点应该坐什么交通工具从哪到哪。</p><p>在他买了机票，汽车票，船票后，他们都只在特定的区间是有效的。所以就相当于它们都只负责某一个区间的通信运输，而那个详细的规划表就相当于IP,它负责将数据包发送到最终的地址。</p><p>如果只有车票没有行程表，没法到达目的地，因为不知道什么时候该换乘，也不知道下一段路坐什么车，而光有行程表没有车票也不行，因为没法乘坐交通工具。（图解TCPIP /117页）</p><p>也就是网络层知道该往哪条路走(路由选择)(一到路由器就知道下段路该往哪走)，具体在这条链路上怎么走由链路层决定。</p><p>(我的理解：链路层以上的层都是说明了数据该走到哪，走到以后怎么解析，而真正说明怎么走的就是链路层协议规定的内容)</p><h4 id="包传递过程中哪些不变，哪些变"><a href="#包传递过程中哪些不变，哪些变" class="headerlink" title="包传递过程中哪些不变，哪些变"></a>包传递过程中哪些不变，哪些变</h4><p>帧经过交换机时，其源、目标MAC是不会变的，一句话：二层转发不改变帧的MAC地址、IP地址；<br>帧经过路由器时，进行路由转发，IP地址是不会变的，但MAC地址必定会变。</p><h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><p>主要负责物理层面上的互连的，节点之间的通信传输，例如与一个以太网相连的两个节点之间的通信。将01序列划分为具有意义的数据帧送给对端。</p><p>链路层的协议有许多种，但是有三个基本的问题，那就是封装成帧，透明传输，差错控制。</p><ul><li>封装成帧</li></ul><p>数据链路层的主要工作是添加一个帧头部和帧尾部，不同的数据链路层协议可能格式不同，但是基本的格式都试类似的：</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-08%2021-53-14%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>这里的数据部分，一般有一个最大程度，我们称为MTU，在MAC里一般是1500个字节，当数据是由可打印的ASC2码组成的文件时，可以使用特殊的帧定字符来标明一个帧的开始和结束。比如使用SOH(Start Of Header)–0x01和EOT(End Of Transmission)–0x04来表示，这样数据链路层就可以识别出帧的开始和结束。</p><ul><li>透明传输</li></ul><p>如果我们提供任何数据输入，数据链路层都可以成功传递，那么我们称之为透明传输，即数据链路层的功能对于网络层和上层是透明的。</p><ul><li>错误检测</li></ul><p>现实的通信链路都不会是理想的，这就是说，传输过程中有可能1变成0,0变成1，这种情况就叫做比特差错。数据链路层提供了<strong>循环冗余检验CRC</strong>方法来检测比特差错，其主要使用了帧检验序列FCS来检测比特错误。发送数据前先计算帧的数据部分得出FCS添加在数据部分后，接收端收到数据后添加上FCS后计算验证。</p><p>需要注意的是数据链路层并没有向网络层提供可靠传输服务，传输差错一类是比特差错，还有一类是帧丢失、帧重复或帧失序。完整的传输错误控制是在TCP中实现的。</p><h4 id="物理层怎么传"><a href="#物理层怎么传" class="headerlink" title="物理层怎么传"></a>物理层怎么传</h4><p>物理层只需要把数据从物理相连的链路上传就行了，连到哪，就走到哪，只有到了设备,也就是到了可识别协议的设备的时候,才会有选择路径的说法。</p><h4 id="最后的地址怎么找到"><a href="#最后的地址怎么找到" class="headerlink" title="最后的地址怎么找到"></a>最后的地址怎么找到</h4><p>通过IP地址可以找到目的地在哪一个网络，然后找到这个网络后，就需要通过MAC地址进行广播找到最终的终端。</p><h4 id="MAC地址与IP地址"><a href="#MAC地址与IP地址" class="headerlink" title="MAC地址与IP地址"></a>MAC地址与IP地址</h4><p>MAC寻址中参考的表叫做地址转发表，IP寻址中参考的表叫做路由控制表。</p><p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-04-04%2015-31-13%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=9lWQM3ujpISO409F0zqt6h25vK9hPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI1NDE5MTA1JnQ9MTUyMjgyNzEwNSZyPTkwNzk4MDI1NiZmPS8yMDE4LTA0LTA0JTIwMTUtMzEtMTMlRTUlQjElOEYlRTUlQjklOTUlRTYlODglQUElRTUlOUIlQkUucG5nJmI9dHdv" alt=""></p><h4 id="交换机与路由器"><a href="#交换机与路由器" class="headerlink" title="交换机与路由器"></a>交换机与路由器</h4><p>网桥也就是两层交换机，是从数据链路层上延长网络的设备。</p><p>路由器也就是三层交换机，是通过网络层转发分组数据的设备。</p><p>4-7层交换机 处理传输层以上各层网络传输的设备</p><h4 id="包首部"><a href="#包首部" class="headerlink" title="包首部"></a>包首部</h4><p>每一个包首部中至少都会包含两部分信息，一个是发送端接受端地址，另一个上层的协议类型。</p><p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-04-04%2016-10-55%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=BlugcJjoBveu52J1ZnI5rRbPX+FhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI1NDIxNDc4JnQ9MTUyMjgyOTQ3OCZyPTgyMDQyNjMyOSZmPS8yMDE4LTA0LTA0JTIwMTYtMTAtNTUlRTUlQjElOEYlRTUlQjklOTUlRTYlODglQUElRTUlOUIlQkUucG5nJmI9dHdv" alt=""></p><h4 id="数据链路的作用"><a href="#数据链路的作用" class="headerlink" title="数据链路的作用"></a>数据链路的作用</h4><p>各个设备在数据传输时，链路层和物理层必不可少，众所周知，计算机以二进制0,1来表示信息，然而实际的通信媒介之间处理的却是电压的高低，光的闪灭以及电波的强弱等信号。把这些信号与二进制的0,1进行转换正是物理层的责任。</p><p>数据链路层的处理也不是单纯的01序列，链路层把他们集合为一个叫做帧的块，然后再进行传输。</p><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>mac地址用于识别<strong>数据链路中</strong>互联的节点。48位</p><h4 id="数据链路有哪些"><a href="#数据链路有哪些" class="headerlink" title="数据链路有哪些"></a>数据链路有哪些</h4><p>有以太网，无线通信，PPP(点对点，即1对1连接计算机)的方式。</p><p>ATM,POS,FDDI等。</p><p>这些链路协议相当于运输工具，就相当于士兵运货物从海南到北京，其中可能要用船，可能的地方只能骑马，有的地方可以开越野车，（就相当于不同的链路协议）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 使用SSR</title>
      <link href="/2018/04/04/Linux%20%E4%BD%BF%E7%94%A8SSR/"/>
      <url>/2018/04/04/Linux%20%E4%BD%BF%E7%94%A8SSR/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-使用SSR"><a href="#Linux-使用SSR" class="headerlink" title="Linux 使用SSR"></a>Linux 使用SSR</h2><h3 id="Shadowsocks-与-Shadowsocksr-区别"><a href="#Shadowsocks-与-Shadowsocksr-区别" class="headerlink" title="Shadowsocks 与 Shadowsocksr 区别"></a>Shadowsocks 与 Shadowsocksr 区别</h3><p>SS是原版，SSR是原版基础上衍生出来的第三方版本，兼容原版协议，比原版多了一些伪装功能（协议和混淆）。<br>SSR 主要特点是增加了一些人性化功能，比如服务器连接统计、连接管理、协议转换、多重代理等。</p><h3 id="下载SSR客户端"><a href="#下载SSR客户端" class="headerlink" title="下载SSR客户端"></a>下载SSR客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ssrbackup/shadowsocksr</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>进入刚才clone下来的文件夹， 有一个文件 <code>user-config.json</code> ，这个就是配置文件的模板，我们可以复制一份到/etc/shadowsocks.json，然后对这个文件进行配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="attr">"server_ipv6"</span>: <span class="string">"::"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>: <span class="number">8388</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>: <span class="number">1080</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"m"</span>,</span><br><span class="line">    <span class="attr">"method"</span>: <span class="string">"aes-128-ctr"</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"auth_aes128_md5"</span>,</span><br><span class="line">    <span class="attr">"protocol_param"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"obfs"</span>: <span class="string">"tls1.2_ticket_auth_compatible"</span>,</span><br><span class="line">    <span class="attr">"obfs_param"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"speed_limit_per_con"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"speed_limit_per_user"</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    "additional_ports" : &#123;&#125;, // only works under multi-user mode</span><br><span class="line">    "additional_ports_only" : false, // only works under multi-user mode</span><br><span class="line">    "timeout": 120,</span><br><span class="line">    "udp_timeout": 60,</span><br><span class="line">    "dns_ipv6": false,</span><br><span class="line">    "connect_verbose_info": 0,</span><br><span class="line">    "redirect": "",</span><br><span class="line">    "fast_open": false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要用到的配置是下面的这几个选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;server_port&quot;:8388,        //端口</span><br><span class="line">&quot;password&quot;:&quot;password&quot;,     //密码</span><br><span class="line"> &quot;protocol&quot;:&quot;origin&quot;,       //协议插件</span><br><span class="line"> &quot;obfs&quot;:&quot;http_simple&quot;,      //混淆插件</span><br><span class="line"> &quot;method&quot;:&quot;aes-256-cfb&quot;,    //加密方式</span><br></pre></td></tr></table></figure><p>具体的服务器，密码，端口从SS帐号提供商那里获取</p><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>进入到shadowsocksr/shadowsocks/目录里面，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python local.py -c /etc/ssr.json</span><br></pre></td></tr></table></figure><p>出现下面的提示,说明运行成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-10-17 12:30:49 INFO     local.py:50 local start with protocol[auth_chain_a] password [Ck6295iFwq] method [none] obfs [tls1.2_ticket_auth] obfs_param []</span><br><span class="line">2017-10-17 12:30:49 INFO     local.py:54 starting local at 127.0.0.1:1080</span><br><span class="line">2017-10-17 12:30:49 INFO     asyncdns.py:324 dns server: [(&apos;127.0.1.1&apos;, 53)]</span><br><span class="line">2017-10-17 12:30:57 INFO     util.py:85 loading libcrypto from libcrypto.so.1.0.0</span><br></pre></td></tr></table></figure><h4 id="结合SwitchyOmega-使用"><a href="#结合SwitchyOmega-使用" class="headerlink" title="结合SwitchyOmega 使用"></a>结合SwitchyOmega 使用</h4><p>上面的步骤其中的配置项有两个要注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;local_address&quot;: &quot;127.0.0.1&quot;,                            </span><br><span class="line">&quot;local_port&quot;: 1080,</span><br></pre></td></tr></table></figure><p>说明SSR客户端运行本地的127.0.0.1 IP， 监听端口1080<br>所以再SwitchyOmega里面的配置就是</p><p>上网的时候选择这个配置，就可以正常访问网页了</p><h3 id="终端走代理路径"><a href="#终端走代理路径" class="headerlink" title="终端走代理路径"></a>终端走代理路径</h3><p>在终端中直接运行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://proxyAddress:port</span><br></pre></td></tr></table></figure><p>这个办法的好处是简单直接，并且影响面很小（只对当前终端有效，退出就不行了）。</p><p>如果你用的是ss代理，在当前终端运行以下命令，那么<code>wget</code> <code>curl</code> 这类网络命令都会经过ss代理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.jianshu.com/p/c336fd0bdfbe" target="_blank" rel="noopener">https://www.jianshu.com/p/c336fd0bdfbe</a></p><p><a href="https://blog.fazero.me/2015/09/15/%E8%AE%A9%E7%BB%88%E7%AB%AF%E8%B5%B0%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">https://blog.fazero.me/2015/09/15/%E8%AE%A9%E7%BB%88%E7%AB%AF%E8%B5%B0%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IaaS、PaaS、SaaS</title>
      <link href="/2018/04/04/IaaS%E3%80%81PaaS%E3%80%81SaaS/"/>
      <url>/2018/04/04/IaaS%E3%80%81PaaS%E3%80%81SaaS/</url>
      
        <content type="html"><![CDATA[<h2 id="IaaS、PaaS、SaaS"><a href="#IaaS、PaaS、SaaS" class="headerlink" title="IaaS、PaaS、SaaS"></a>IaaS、PaaS、SaaS</h2><h4 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h4><p>本地部署就是服务器，平台，成品软件全都要自己搞好。</p><h4 id="IaaS-基础设施即服务"><a href="#IaaS-基础设施即服务" class="headerlink" title="IaaS 基础设施即服务"></a>IaaS 基础设施即服务</h4><p>基础设施即服务，是云服务里最重要也是最基础的一块，经常提到的云计算，云存储，和CDN加速等，都属于这个领域。</p><p>有了IaaS，可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。</p><p>一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat.不过这些公司又都有自己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。</p><h4 id="PaaS-平台即服务"><a href="#PaaS-平台即服务" class="headerlink" title="PaaS 平台即服务"></a>PaaS 平台即服务</h4><p>PaaS的价值在于，它可以提供软件开发(包括APP)所需的基础功能模块，特别是非核心，但是又有普遍需求的模块，例如通讯，存储，推送。这对一些创业公司来说，尤其有用，按需使用云端的功能模块既可以免去繁琐的开发维护工作，又能提升客户体验。</p><p>第二层就是所谓的PaaS，某些时候也叫做中间件。公司所有的开发都可以在这一层进行，节省了时间和资源。</p><p>PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。</p><p>一些大的PaaS提供者有Google App Engine,Microsoft Azure，Force.com,Heroku，Engine Yard。最近兴起的公司有AppFog,Mendix和Standing Cloud.</p><h4 id="SaaS-软件即服务"><a href="#SaaS-软件即服务" class="headerlink" title="SaaS 软件即服务"></a>SaaS 软件即服务</h4><p>第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器上的应用都可以通过网络来运行，就是SaaS了。</p><p>你消费的服务完全是从网页如Netflix,MOG,Google Apps,Box.net,Dropbox或者苹果的iCloud那里进入这些分类。尽管这些网页服务是用作商务和娱乐或者两者都有，但这也算是云技术的一部分。</p><p>一些用作商务的SaaS应用包括Citrix的Go To Meeting，Cisco的WebEx，Salesforce的CRM，ADP，Workday和SuccessFactors。</p><p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-04-03%2021-48-48%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=k59pONdhh4ST3NnT+mZK0tD5QF5hPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI1MzU1NDE3JnQ9MTUyMjc2MzQxNyZyPTkyMTE1Mjc1NiZmPS8yMDE4LTA0LTAzJTIwMjEtNDgtNDglRTUlQjElOEYlRTUlQjklOTUlRTYlODglQUElRTUlOUIlQkUucG5nJmI9dHdv" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2018/04/03/ThreadLocal/"/>
      <url>/2018/04/03/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h4 id="ThreadLocal-是什么"><a href="#ThreadLocal-是什么" class="headerlink" title="ThreadLocal 是什么"></a>ThreadLocal 是什么</h4><p>threadLocal ，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程都可以访问自己内部的副本变量。</p><p>先看ThreadLocal 类提供的几个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span> <span class="params">(T value)</span></span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>get() 方法是用来获取ThreadLocal 在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove() 用来移除当前线程中变量的副本，initialValue()是一个protect方法，一般是用来在使用时进行重写的，它是一个延迟加载方法。</p><p>首先，它是一个数据结构，有点像HashMap，可以保存<code>&quot;key : value&quot;</code>键值对，但是一个ThreadLocal只能保存一个，并且各个线程的数据互不干扰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; localName = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">localName.set(<span class="string">"wkn"</span>);</span><br><span class="line">String name = localName.get();</span><br></pre></td></tr></table></figure><p>在线程1中初始化了一个ThreadLocal对象localName，并通过set方法，保存了一个值 <code>wkn</code>，同时在线程1中通过 <code>localName.get()</code>可以拿到之前设置的值，但是如果在线程2中，拿到的将是一个null。</p><p>下面是<code>set(T value)</code>和<code>get()</code>方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Thread t =Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map =getMap(t);</span><br><span class="line">  <span class="keyword">if</span>(map!=<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>,value);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      createMap(t,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Thread t= Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map =getMap(t);</span><br><span class="line">  <span class="keyword">if</span>(map!=<span class="keyword">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        ThreadLocalMap.Entry e =map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span>(e!=<span class="keyword">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            T result =(T)e.value;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，每个线程中都有一个 <code>ThreadLocalMap</code>数据结构，当执行set方法时，其值是保存在当前线程的 <code>threadLocals</code>变量中，当执行set方法中，是从当前线程的 <code>threadLocals</code>变量获取。</p><p>所以在线程1中set的值，对线程2来说是摸不到的，而且在线程2中重新set的话，也不会影响到线程1中的值，保证了线程之间不会相互干扰。</p><h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><p>从名字上看，可以猜到它也是一个类似HashMap的数据结构，但是在ThreadLocal中，并没实现Map接口。</p><p>在ThreadLocalMap中，也是初始化一个大小16的Entry数组，Entry对象用来保存每一个key-value键值对，只不过这里的key永远都是ThreadLocal对象，通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLoalMap中。</p><p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-30%2017-09-06%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=rCkbAp/lBrLQ9Z9n21SKrAs2DzRhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0OTkyOTg4JnQ9MTUyMjQwMDk4OCZyPTE4MzQ4OTkxNjkmZj0vMjAxOC0wMy0zMCUyMDE3LTA5LTA2JUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""></p><p>这里需要注意的是，<strong>ThreadLoalMap的Entry是继承WeakReference</strong>，和HashMap很大的区别是，Entry中没有next字段，所以就不存在链表的情况了。</p><h4 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h4><p>没有链表结构，那发生hash冲突了怎么办？先看看ThreadLoalMap中插入一个key-value的实现。</p><p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-30%2017-14-09%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=bsVVhFGjyFt/qDTiL6BaXflMlYRhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0OTkzMjYwJnQ9MTUyMjQwMTI2MCZyPTMwNDQ5NTIyMiZmPS8yMDE4LTAzLTMwJTIwMTctMTQtMDklRTUlQjElOEYlRTUlQjklOTUlRTYlODglQUElRTUlOUIlQkUucG5nJmI9dHdv" alt=""></p><p>每个ThreadLocal对象都有一个hash值 <code>threadLocalHashCode</code>，每初始化一个ThreadLocal对象，hash值就增加一个固定的大小 <code>0x61c88647</code>。（也就是每有一个ThreadLocal对象，第一次为0的话，第二个的Hashcodee就是0x61c88647,第三个就是0x61c88647*2）</p><p>在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置i，过程如下： 1、如果当前位置是空的，那么正好，就初始化一个Entry对象放在位置i上； 2、不巧，位置i已经有Entry对象了，如果这个Entry对象的key正好是即将设置的key，那么重新设置Entry中的value； 3、很不巧，位置i的Entry对象，和即将设置的key没关系，那么只能找下一个空位置；</p><p>这样的话，在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该位置Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置</p><p>可以发现，set和get如果冲突严重的话，效率很低，因为ThreadLoalMap是Thread的一个属性，所以即使在自己的代码中控制了设置的元素个数，但还是不能控制其它代码的行为.</p><h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>当使用ThreadLocal保存一个value时，会在ThreadLocalMap中的数组插入一个Entry对象，按理说key-value都应该以强引用保存在Entry对象中，但在ThreadLocalMap的实现中，key被保存到了WeakReference对象中。</p><p>这就导致了一个问题，ThreadLocal在没有外部强引用时，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><h4 id="内存泄露解决方法"><a href="#内存泄露解决方法" class="headerlink" title="内存泄露解决方法"></a>内存泄露解决方法</h4><p>手动调用remove方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>REST与RESTful与RestTemplate</title>
      <link href="/2018/04/02/REST%E4%B8%8ERESTful/"/>
      <url>/2018/04/02/REST%E4%B8%8ERESTful/</url>
      
        <content type="html"><![CDATA[<h2 id="REST与RESTful与RestTemplate"><a href="#REST与RESTful与RestTemplate" class="headerlink" title="REST与RESTful与RestTemplate"></a>REST与RESTful与RestTemplate</h2><p>REST – REpresentational State Transfer 直接翻译：表现层状态转移。</p><p>用一句话概括：</p><p><strong>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</strong></p><p>REST 不是rest这个单词，而是几个单词的缩写，</p><ul><li>REST描述的是网络中client和server的一种交互形式，REST本身不实用，实用的是如何设计RESTful API(REST风格的API)</li><li>Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说是整个网络处理的核心。</li><li>用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转：GET    用来获取资源，POST  用来新建资源（也可以用于更新资源），PUT    用来更新资源，DELETE  用来删除资源。</li><li>Server和Client之间传递某资源的一个表现形式，比如用JSON，XML传输文本，或者用JPG，WebP传输图片等。当然还可以压缩HTTP传输时的数据（on-wire data compression）</li><li>用 HTTP Status Code传递Server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。</li></ul><h4 id="为什么要用RESTful结构呢？"><a href="#为什么要用RESTful结构呢？" class="headerlink" title="为什么要用RESTful结构呢？"></a>为什么要用RESTful结构呢？</h4><p>“古代”网页是前端后端融在一起的，比如之前的PHP，JSP等。在之前的桌面时代问题不大，但是近年来移动互联网的发展，各种类型的Client层出不穷，RESTful可以通过一套统一的接口为 Web，iOS和Android提供服务。另外对于广大平台来说，比如Facebook platform，微博开放平台，微信公共平台等，它们不需要有显式的前端，只需要一套提供服务的接口，于是RESTful更是它们最好的选择。在RESTful架构下：<br><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-29%2011-39-33%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=SojQ6cVvNFfAysn6k5O3k+L9od9hPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0ODg2ODA4JnQ9MTUyMjI5NDgwOCZyPTE4NTk4MDYxOTgmZj0vMjAxOC0wMy0yOSUyMDExLTM5LTMzJUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""></p><h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p>借助RestTemplate, Spring应用能够方便地使用REST资源。Spring的RestTemplate访问使用了模板方法的设计模式。模版方法将过程中与特定实现相关的部分委托给接口,而这个接口的不同实现定义了接口的不同行为.</p><p>RestTemplate定义了36个与REST资源交互的方法，其中的大多数都对应于HTTP的方法。 这里面只有11个独立的方法，其中有十个有三种重载形式，而第十一个则重载了六次，这样一共形成了36个方法。</p><ul><li><p><code>delete()</code> 在特定的URL上对资源执行HTTP DELETE操作</p></li><li><p><code>exchange()</code> 在URL上执行特定的HTTP方法，返回包含对象的ResponseEntity，这个对象是从响应体中 映射得到的</p></li><li><p><code>execute()</code> 在URL上执行特定的HTTP方法，返回一个从响应体映射得到的对象</p></li><li><p><strong><code>getForEntity()</code></strong> 发送一个HTTP GET请求，返回的ResponseEntity包含了响应体所映射成的对象</p></li><li><p><strong><code>getForObject()</code></strong> 发送一个HTTP GET请求，返回的请求体将映射为一个对象</p></li><li><p><strong><code>postForEntity()</code></strong> POST 数据到一个URL，返回包含一个对象的ResponseEntity，这个对象是从响应体中映射得 到的</p></li><li><p><strong><code>postForObject()</code></strong> POST 数据到一个URL，返回根据响应体匹配形成的对象</p></li><li><p><code>headForHeaders()</code> 发送HTTP HEAD请求，返回包含特定资源URL的HTTP头</p></li><li><p><code>optionsForAllow()</code> 发送HTTP OPTIONS请求，返回对特定URL的Allow头信息</p></li><li><p><code>postForLocation()</code> POST 数据到一个URL，返回新创建资源的URL</p></li><li><p><code>put()</code> PUT 资源到特定的URL.</p><p>​</p></li></ul><blockquote><p><a href="https://blog.csdn.net/itguangit/article/details/78825505" target="_blank" rel="noopener">https://blog.csdn.net/itguangit/article/details/78825505</a></p><p><a href="https://www.zhihu.com/question/28557115/answer/48094438" target="_blank" rel="noopener">https://www.zhihu.com/question/28557115/answer/48094438</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 详解</title>
      <link href="/2018/04/01/HTTP%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/04/01/HTTP%20%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-详解"><a href="#HTTP-详解" class="headerlink" title="HTTP 详解"></a>HTTP 详解</h2><p>HTTP协议是<code>Hyper Text Transfer Protocol</code>（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p><p>HTTP是一个基于<code>TCP/IP</code>通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由<code>Content-Type</code>加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>支持B/S及C/S模式。</li></ul><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</p><p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p><p><code>http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</code></p><p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p><ul><li>协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</li><li>域名部分：该URL的域名部分为“<a href="http://www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用" target="_blank" rel="noopener">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a></li><li>端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</li><li>虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</li><li>文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</li><li>锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</li><li>参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li></ul><h4 id="URL-与URI"><a href="#URL-与URI" class="headerlink" title="URL 与URI"></a>URL 与URI</h4><p>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</p><p>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</p><h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p><p>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</p><h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h4><p>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p><h4 id="HTTP之状态码"><a href="#HTTP之状态码" class="headerlink" title="HTTP之状态码"></a>HTTP之状态码</h4><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><p>1xx：指示信息–表示请求已接收，继续处理</p><p>2xx：成功–表示请求已被成功接收、理解、接受</p><p>3xx：重定向–要完成请求必须进行更进一步的操作</p><p>4xx：客户端错误–请求有语法错误或请求无法实现</p><p>5xx：服务器端错误–服务器未能实现合法的请求</p><h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET     请求指定的页面信息，并返回实体主体。</span><br><span class="line">HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</span><br><span class="line">PUT     从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE      请求服务器删除指定的页面。</span><br><span class="line">CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">OPTIONS     允许客户端查看服务器的性能。</span><br><span class="line">TRACE     回显服务器收到的请求，主要用于测试或诊断。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 配置国内加速器</title>
      <link href="/2018/04/01/Docker%20%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%8A%A0%E9%80%9F%E5%99%A8/"/>
      <url>/2018/04/01/Docker%20%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%8A%A0%E9%80%9F%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-配置国内加速器"><a href="#Docker-配置国内加速器" class="headerlink" title="Docker 配置国内加速器"></a>Docker 配置国内加速器</h2><ul><li><p>登录阿里开发者平台<a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com/search.html</a></p></li><li><p>点击创建我的容器镜像</p></li><li><p>注册/登录后，进入Docker 镜像仓库 (<a href="https://cr.console.aliyun.com/#/imageList)，选中加速器" target="_blank" rel="noopener">https://cr.console.aliyun.com/#/imageList)，选中加速器</a> Tab</p></li><li><p>这里可以看到，系统已经为我们生成了一个专属加速器地址：<a href="https://xxxxx.mirror.aliyuncs.com" target="_blank" rel="noopener">https://xxxxx.mirror.aliyuncs.com</a></p></li><li><p>可以通过修改daemon配置文件<code>/etc/docker/daemon.json</code>来使用加速器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://uuc927qz.mirror.aliyuncs.com"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 入门</title>
      <link href="/2018/04/01/Docker/"/>
      <url>/2018/04/01/Docker/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker使用Google公司推出的Go语言进行开发实现,基于Linux内核<code>cgroup,namespace,</code>以及<code>AUFS</code>类的<code>Union    FS</code>等技术,对进程进行封装隔离,属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程,因此也称其为容器。最初实现是基于<code>LXC</code>,从0.7版本以后开始去除<code>LXC</code>,转而使用自行开发的<code>libcontainer</code>,从    1.11    开始,则进一步演进为使用<code>runC</code>和<code>containerd</code>。</p><p>Docker    在容器的基础上,进行了进一步的封装,从文件系统、网络互联到进程隔离等等,极大的简化了容器的创建和维护。使得Docker技术比虚拟机技术更为轻便、快捷。</p><p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-29%2015-47-41%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=nnf9xuxoNJdGq6uhUXkJ3my3chBhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0OTAxNzAzJnQ9MTUyMjMwOTcwMyZyPTI3MjIxMDIzNyZmPS8yMDE4LTAzLTI5JTIwMTUtNDctNDElRTUlQjElOEYlRTUlQjklOTUlRTYlODglQUElRTUlOUIlQkUucG5nJmI9dHdv" alt=""></p><p>下面的图片比较了Docker和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后,在其上运行一个完整操作系统,在该系统上再运行所需应用进程;而容器内的应用进程直接运行于宿主的内核,容器内没有自己的内核,而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-29%2015-49-01%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=hKO5rZFL59/Lo4EuYXOhYJGxe89hPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0OTAxNzU0JnQ9MTUyMjMwOTc1NCZyPTM0NzYxMzMwJmY9LzIwMTgtMDMtMjklMjAxNS00OS0wMSVFNSVCMSU4RiVFNSVCOSU5NSVFNiU4OCVBQSVFNSU5QiVCRS5wbmcmYj10d28=" alt=""></p><h3 id="Docker-的好处"><a href="#Docker-的好处" class="headerlink" title="Docker 的好处"></a>Docker 的好处</h3><p>Docker可以更高效的利用系统资源，拥有更快的启动时间，有一致的运行环境，可以进行持续交付和部署。可以进行更轻松的迁移，更轻松的维护和扩展。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Docker包括三个基本概念，分别是镜像（image），容器(Container)，仓库(Repository).</p><ul><li><p>镜像</p><p>操作系统分内核和用户空间，对Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像(Image),就相当于是一个     root     文件系统。比如官方镜像ubuntu:16.04就包含了完整的一套    Ubuntu    16.04最小系统的root文件系统。<br>Docker镜像是一个特殊的文件系统,除了提供容器运行时所需的程序、库、资源、配置等文件外,还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。镜像不包含任何动态数据,其内容在构建之后也不会被改变。</p></li><li><p>Docker容器</p><p>镜像(Image)和容器(Container)的关系,就像是面向对象程序设计中的      类和    实例    一样,镜像是静态的定义,容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br>容器的实质是进程,但与直接在宿主执行的进程不同,容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间,甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里,使用起来,就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p></li></ul><p>前面讲过镜像使用的是分层存储,容器也是如此。每一个容器运行时,是以镜像为基础层,在其上创建一个当前容器的存储层,我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</p><p>容器存储层的生存周期和容器一样,容器消亡时,容器存储层也随之消亡。因此,任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照    Docker最佳实践的要求,容器不应该向其存储层内写入任何数据,容器存储层要保持无状态化。所有的文件写入操作,都应该使用数据(Volume)、或者绑定宿主目录,在这些位置的读写会跳过容器存储层,直接对宿主(或网络存储)发生读写,其性能和稳定性更高。<br>数据卷的生存周期独立于容器,容器消亡,数据卷不会消亡。因此,使用数据卷后,容器删除或者重新运行之后,数据却不会丢失。</p><ul><li><p>Docker Registry</p><p>镜像构建完成后,可以很容易的在当前宿主机上运行,但是,如果需要在其它服务器上使用这个镜像,我们就需要一个集中的存储、分发镜像的服务,DockerRegistry    就是这样的服务。<br>一个DockerRegistry中可以包含多个仓库(    Repository);每个仓库可以包含多个标签(Tag);每个标签对应一个镜像。</p></li></ul><p>通常,一个仓库会包含同一个软件不同版本的镜像,而标签就常用于对应该软件的各个版本。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签,将以latest作为默认标签。</p><p>最常使用的Registry公开服务是官方的DockerHub,这也是默认的Registry,并拥有大量的高质量的官方镜像。</p><h3 id="使用Docker镜像"><a href="#使用Docker镜像" class="headerlink" title="使用Docker镜像"></a>使用Docker镜像</h3><p>Docker运行容器前需要本地存在对应的镜像,如果本地不存在该镜像,Docker    会从镜像仓库下载该镜像。</p><h4 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search Java</span><br></pre></td></tr></table></figure><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>从Docker镜像仓库获取镜像的命令是<code>docker pull</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockerpull [选项] DockerRegistry地址:端口号/仓库名:标签</span><br></pre></td></tr></table></figure><p>比如下载一个Ubuntu镜像就是<code>docker pull ubuntu:16.04</code>上面的命令中没有给出    Docker镜像仓库地址,因此将会从    DockerHub获取镜像。而镜像名<br>称是    ubuntu:16.04 ,因此将会获取官方镜像library/ubuntu仓库中标签为16.04的镜像。</p><h4 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h4><p>要想列出已经下载下来的镜像,可以使用<code>docker image ls</code>命令。</p><p><code>docker image ls</code>列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于    Docker镜像是多层存储结构,并且可以继承，复用,因此不同镜像可能会因为使用相同的基础镜像,从而拥有共同的层。由于Docker使用UnionFS,相同的层只需要保存一份即可,因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>上面的镜像列表中,还可以看到一个特殊的镜像,这个镜像既没有仓库名,也没有标签,均为<code>&lt;none&gt;</code> 。:<br>这个镜像原本是有镜像名和标签的,原来为<code>mongo:3.2</code> ,随着官方镜像维护,发布了新版本后,重新<code>docker pull mongo:3.2</code>时, <code>mongo:3.2</code>这个镜像名被转移到了新下载的镜像身上,而旧的镜像上的这个名称则被取消,从而成为了<code>&lt;none&gt;</code> 。除了<code>docker    pull</code>可能导致这种情况, <code>docker build</code>也同样可以导致这种现象。由于新旧镜像同名,旧镜像名称被取消,从而出现仓库名、标签均为    <code>&lt;none&gt;</code>    的镜像。这类无标签镜像也被称为虚悬镜像<br><code>(danglingimage)</code>    ,可以用下面的命令专门显示这类镜像:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -f dangling=true</span><br></pre></td></tr></table></figure><h4 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h4><p>使用<code>docker image rm</code>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt;...]</span><br></pre></td></tr></table></figure><h4 id="利用commit-理解镜像构成"><a href="#利用commit-理解镜像构成" class="headerlink" title="利用commit 理解镜像构成"></a>利用commit 理解镜像构成</h4><p>镜像是多层存储,每一层是在前一层的基础上进行的修改;而容器同样也是多层存储,是在以镜像为基础层,在其基础上加一层作为容器运行时的存储层。</p><p>下面以定制一个web服务器为例子，讲解镜像如何构建。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>这条命令会用    nginx镜像启动一个容器,命名为webserver     ,并且映射了80    端口,这样我们可以用浏览器去访问这个nginx服务器。<br>如果是在    Linux本机运行的Docker,那么可以直接访问:<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a>;<br>直接用浏览器访问的话,我们会看到默认的    Nginx    欢迎页面。</p><p>我们在运行一个容器的时候(不适用卷的话)，我们做的任何修改都会被记录于容器存储层里。而Docker提供了<code>docker commit</code>可以将容器的存储层保存下载成为镜像。也就是，在原来镜像的基础上，再叠加上容器的存储层，并构成新的镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockercommit[选项]&lt;容器ID或容器名&gt;[&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker commit\</span><br><span class="line">--author "Tao Wang&lt;twang2218@gmail.com&gt;" \</span><br><span class="line">--message "修改了默认网页"\</span><br><span class="line">webserver \</span><br><span class="line">nginx:v2</span><br><span class="line">sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span><br></pre></td></tr></table></figure><h4 id="使用Dockerfile-定制镜像"><a href="#使用Dockerfile-定制镜像" class="headerlink" title="使用Dockerfile 定制镜像"></a>使用Dockerfile 定制镜像</h4><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本,用这个脚本来构建定制镜像,那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是    Dockerfile</p><p>Dockerfile是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,因此每一条指令的内容,就是描述该层应当如何构建。</p><h3 id="操作Docker容器"><a href="#操作Docker容器" class="headerlink" title="操作Docker容器"></a>操作Docker容器</h3><p>容器是独立运行的一个或一组应用,以及它们的运行态环境。对应的,虚拟机可以理解为模拟运行的一整套操作系统(提供了运行态环境和其他系统环境)和跑在上面的应用。</p><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>启动容器有两种方式,一种是基于镜像新建一个容器并启动,另外一个是将在终止状态(stopped)的容器重新启动。</p><h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>所需要主要命令是<code>docker run</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>dockerrunubuntu:14.04 /bin/echo 'Hello world'</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>dockerrun-t -i ubuntu:14.04/bin/bash</span><br><span class="line">-t 选项让docker分配一个伪终端，并绑定到容器的标准输入上，-i则让容器的标准输入保持打开。</span><br></pre></td></tr></table></figure><p>有许多选型，常见的选项有 <code>-d</code>表示后台运行，<code>-P</code>随机端口映射，<code>-p</code>指定端口映射</p><p>当使用<code>docker run</code>来创建容器时，Docker在后台运行的标准操作包括</p><p>检查本地是否存在指定的镜像,不存在就从公有仓库下载、利用镜像创建并启动一个容器、分配一个文件系统,并在只读的镜像层外面挂载一层可读写层、从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去、从地址池配置一个ip地址给容器、执行用户指定的应用程序、执行完毕后容器被终止。</p><h4 id="进入容器内部"><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec # 在一个运行的容器中运行命令</span><br><span class="line">docker exec -it 容器名 /bin/sh</span><br></pre></td></tr></table></figure><h4 id="docker-网络类型"><a href="#docker-网络类型" class="headerlink" title="docker 网络类型"></a>docker 网络类型</h4><p>主要有bridge ,Host None</p><p>bridge是桥接模式，使用虚拟的网卡，和主机隔离，容器有独立的IP和端口。</p><p>Host 使用宿主机的网卡等。 </p><p>当使用bridge模式时，就需要进行端口的映射技术，这样当访问主机的某个端口时，实际上就是访问容器上的某个端口。</p><blockquote><p>Docker 端口映射</p><p>在启动容器时，如果不配置宿主机器与虚拟机的端口映射，外部程序是无法访问虚拟机的，因为没有端口。</p><p>端口映射的Docker指令是</p><p>Docker run -p ip:hostport:containerPort redis</p><p>使用-p参数会分配宿主机的端口映射到虚拟机。<br>IP表示主机的IP地址。<br>hostPort表示宿主机的端口。(redis的启动端口）<br>containerPort表示虚拟机(容器)的端口。 </p></blockquote><h4 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps # 列出运行中的容器</span><br></pre></td></tr></table></figure><h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop  id#停止容器</span><br></pre></td></tr></table></figure><h4 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill id</span><br></pre></td></tr></table></figure><h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p><code>docker  start</code> 命令，将一个已经终止的容器启动运行。</p><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm id</span><br></pre></td></tr></table></figure><h4 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h4><p>更多时候，需要让Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时,可以通过添加<code>-d</code>参数来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d ubuntu:17.10 /bin/sh -c "while true; do echo hello world; sleep 1; done"</span><br><span class="line">77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure><p>要获取容器的输出信息,可以通过     <code>docker container logs</code>    命令。</p><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>Docker 官方维护了一个公共仓库Docker Hub.</p><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p>可以通过<code>docker search</code> 命令来查找官方仓库中的镜像，并利用<code>docker pull</code>命令把它下载到本地。</p><h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>用户也可以在登录后通过<code>docker push</code>命令来将自己的镜像推送到<code>Docker Hub</code>。<br>以下命令中的<code>username</code>替换为<code>Docker</code>账号用户名。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>客户端负载均衡Spring Cloud Ribbon</title>
      <link href="/2018/03/29/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1Spring%20Cloud%20Ribbon/"/>
      <url>/2018/03/29/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1Spring%20Cloud%20Ribbon/</url>
      
        <content type="html"><![CDATA[<h2 id="客户端负载均衡Spring-Cloud-Ribbon"><a href="#客户端负载均衡Spring-Cloud-Ribbon" class="headerlink" title="客户端负载均衡Spring Cloud Ribbon"></a>客户端负载均衡Spring Cloud Ribbon</h2><p><code>Spring cloud Ribbon</code>是一个基于HTTP 和TCP的客户端负载均衡工具。它基于<code>Netflix Ribbon</code>实现。通过Spring Cloud 的封装，可以轻松的将面向服务的REST模板请求自动转换成客户端负载均衡的服务调用。<code>Spring Cloud Ribbon</code>虽然是一个工具类框架，它不像服务注册中心，配置中心，API网关那样需要独立部署，但是它几乎存在于每一个<code>Spring Cloud</code>构建的微服务和基础设施中。因为微服务间的调用，API网关的请求转发等内容，实际上都是通过Ribbon来实现的。</p><p>Ribbon 通常在服务消费者上使用。</p><h4 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h4><p>负载均衡在系统架构中是一个非常重要，并且不得不实施的内容。因为负载均衡是对系统的高可用，网络压力的缓解和处理能力扩容的重要手段之一。通过所说的负载均衡都是在服务端负载均衡。硬件负载均衡主要通过在服务器节点之间安装专门用于负载均衡的设备。软件负载均衡则通过在服务器上安装一些具有负载均衡功能或模块的软件来完成请求分发工作。</p><p>硬件负载均衡的设备或者软件负载均衡的软件模块都会维护一个可用的服务器清单，通过心跳检测来剔除故障的服务器节点以保证清单中都是可以正常访问的服务端节点。当客户端发送请求到负载均衡的设备的时候，该设备按照某种算法从维护的可用服务器清单中取出一台服务器的地址，然后进行转发。</p><p>客户端负载均衡和服务端负载均衡的最大不同点在于服务清单所存储的位置。客户端负载均衡中，所有客户端节点都维护着自己要访问的服务端清单，而这些服务端的清单来自服务注册中心，例如eureka.同服务端负载均衡的架构类似，在客户端负载均衡也需要心跳去维护服务端清单的健康性。这个步骤需要与服务注册中心配合完成。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务治理 Spring Cloud Eureka</title>
      <link href="/2018/03/28/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%20Spring%20Cloud%20Eureka/"/>
      <url>/2018/03/28/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%20Spring%20Cloud%20Eureka/</url>
      
        <content type="html"><![CDATA[<h2 id="服务治理-Spring-Cloud-Eureka"><a href="#服务治理-Spring-Cloud-Eureka" class="headerlink" title="服务治理 Spring Cloud Eureka"></a>服务治理 Spring Cloud Eureka</h2><p><code>Spring Cloud Eureka</code>是Spring Cloud Netflix 微服务套件中的一部分，基于<code>Netflix Eureka</code> 做了二次封装，主要负责完成微服务架构中的服务治理功能。</p><h4 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h4><p>服务治理是微服务架构中最为核心和基础的模块，主要用来实现各个微服务实例的自动化注册与发现。</p><p>最开始构建微服务系统的时候可能服务并不多，可以通过做一些静态配置来完成服务的调用，但是当业务发展，静态配置变得越来越难以维护，面对不断发展的业务，我们的集群规模，服务的位置，服务的命名都有可能发生变化。为了解决微服务架构中服务实例维护问题，产生了大量服务治理框架与产品，这些框架与产品的实现都围绕着服务注册与服务发现机制来完成微服务应用实例的自动化管理。</p><ul><li>服务注册</li></ul><p>服务治理框架中，通常有一个注册中心，每个服务单元向注册中心登记自己的服务，将主机与端口号，版本号，通信协议等一些附加信息告知注册中心。注册中心按服务名分类组织服务清单。</p><ul><li>服务发现</li></ul><p>在服务治理框架下运作，服务间的调用不再通过指定具体的实例地址来实现。而是通过向服务名发起请求调用来实现(这样，当这个服务有多个实例时，就可以负载均衡的找到空闲的实例)。所以服务调用方在调用服务提供方接口的时候，并不知道具体的服务实例位置，因此，调用方需要向服务注册中心咨询服务，并获取所有服务的实例清单。以实现对具体服务实例的访问。</p><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>用来实现服务注册与发现，既包含了服务端组件，也包含了客户端组件，都用Java语言编写。</p><p>Eureka服务端，也称为服务注册中心，同其他服务注册中心一样，都支持高可用配置。依托强一致性提供良好的服务实例可用性。应对多种不同的故障场景。</p><p>Eureka客户端(服务提供者，服务消费者)，主要处理服务的<strong>注册</strong>与<strong>发现</strong>，客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，应用程序运行时，Eureka客户端向注册中心自身提供的服务并周期性的发送心跳来更新它的服务租约。同时，也能从服务端查询当前注册的服务信息并把他们缓存到本地并周期性的刷新服务状态。</p><p>Eureka中有三个核心角色，分别是服务注册中心，服务提供者，以及服务消费者。</p><p>服务注册中心也就是Eureka提供的服务端，提供服务注册与发现的功能，也就是前面的eureka-server.</p><p>服务提供者是提供服务的应用，可以是Spring Boot应用，也可以是其他技术平台遵循Eureka通信机制的应用，他将自己的服务注册到Eureka,以供其他应用发现。</p><p>服务消费者从服务注册中心获取服务列表，从而使消费者可以知道去何处调用其所需要的服务。</p><p><strong>很多时候，Eureka客户端既是服务提供者又是服务消费者</strong></p><h3 id="Eureka配置"><a href="#Eureka配置" class="headerlink" title="Eureka配置"></a>Eureka配置</h3><ul><li>制定注册中心</li></ul><p>主要通过<code>eureka.client.serviceUrl</code>参数实现。它的配置值存储在HashMap中。并且设置有一组默认值，默认值的key为<code>defaultZone</code>,value=<code>http://localhost:8761/eureka/</code>。</p><ul><li>元数据</li></ul><p>元数据是eureka客户端在向服务注册中心发送注册请求时，用于描述自身服务信息的对象，其中包括了一些标准化的元数据，比如服务名称，实例名称，实例IP,实例端口等用于服务治理的重要信息。</p><ul><li>实例名配置</li></ul><p>实例名，即InstanceInfo中的instanceId参数，，它是区分同一服务中不同实例的唯一标识。原生实现中，采用主机名作为默认值。我们可以采用下面的方法使用不同的端口开启同一个服务的多个实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.instace.instanceId=$&#123;spring.application.name&#125;:$&#123;random.int&#125;</span><br></pre></td></tr></table></figure><p>通过加随机数的方式来区别不同的实例，从而实现在同一个主机上，不指定端口就能够启动多个实例。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMq入门</title>
      <link href="/2018/03/27/RabbitMq/"/>
      <url>/2018/03/27/RabbitMq/</url>
      
        <content type="html"><![CDATA[<h2 id="RabbitMq"><a href="#RabbitMq" class="headerlink" title="RabbitMq"></a>RabbitMq</h2><p>RabbitMq 是一个消息队列，它接受并传递消息，可以认为它是一个邮局，但是它不传递纸，传递的是二进制的数据块，也就是消息。</p><p>有一些rabbitMq的术语，生产者值得是发送消息的人，队列指的是rabbitMq里面的一个消息盒子，消息都存储在这个队列里，队列受主机的内存和硬盘限制。实质上就是一个很大的消息缓冲区。许多生产者可以把消息都放入这个队列中，需要消费者可以从这个队列中取出消息。通常情况下，消费者，生产者，和消息队列三者都不在一个主机上。</p><h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h4><p>这里写两个程序，生产者发送一个单个的消息，然后消费者接受消息然后把他们打印。</p><p>RabbitMq支持许多种协议，这里使用的是AMQP 0-9-1,是一个开源的广泛使用的消息协议。<code>The RabbitMQ Java client is also in the central Maven repository, with the groupId **com.rabbitmq** and the artifactId **amqp-client**</code>.</p><p>下面用send代表生产者，用recv代表消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    <span class="comment">//设定RabbitMq的主机名</span></span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    <span class="comment">//创建一个连接</span></span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    <span class="comment">//创建一个通道</span></span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    <span class="comment">//指定一个队列</span></span><br><span class="line">        <span class="comment">//参数1 queue ：队列名</span></span><br><span class="line">        <span class="comment">// 参数2 durable ：是否持久化</span></span><br><span class="line">        <span class="comment">// 参数3 exclusive ：仅创建者可以使用的私有队列，断开后自动删除</span></span><br><span class="line">        <span class="comment">// 参数4 autoDelete : 当所有消费客户端连接断开后，是否自动删除队列</span></span><br><span class="line">        <span class="comment">// 参数5 arguments</span></span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">     <span class="comment">// basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body)</span></span><br><span class="line">        <span class="comment">// 参数1 exchange ：交换器</span></span><br><span class="line">        <span class="comment">// 参数2 routingKey ： 路由键</span></span><br><span class="line">        <span class="comment">// 参数3 props ： 消息的其他参数</span></span><br><span class="line">        <span class="comment">// 参数4 body ： 消息体</span></span><br><span class="line">    channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">    System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分开介绍：</p><p>建立一个到服务器的连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">Connection connection = factory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br></pre></td></tr></table></figure><p>Connection抽象了socket连接，主要帮助我们关心协议的版本沟通和认证。这里连接到的队列是本地的机器，如果想连接其他的机器的话应该填写具体的名字或者是IP地址。</p><p>接下来，创建一个通道(channel),绝大部分API方法需要通过调用它来完成。</p><p>为了发送信息，我们需要声明一个queue来帮助我们发送，然后我们就开始发送信息了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br></pre></td></tr></table></figure><p>声明一个队列是幂等的，它只会在不存在的时候创建，消息的内容是一个二进制的数组，最后关闭通道(channel)和连接(connection)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><p>以上就是我们的发送者。RabbitMQ会把消息推送给接收者，所以不同于只发了一条信息的发送者，我们会让接收者一直监听消息并打印出来。</p><p>下面是消息的接收者，消费者从rabbitmq中拉取消息，需要持续的监听队列并打印其中的消息。</p><p>和生产者一样，我们打开一个连接和一个channel，然后声明一个我们将要去消费的队列，需要注意的是要和生产者生产的队列对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="work-queues"><a href="#work-queues" class="headerlink" title="work queues"></a>work queues</h4><p>创建一个工作队列来分发任务到不同的执行单元中。</p><p>工作队列的主要思想就是避免避免占资源的任务的长时间阻塞，导致后面的任务的长时间等待。我们安排这个任务一会再做。我们把任务概述成信息然后发送到消息队列中，一个后台的工作单元将会取出这个任务然后执行它。当有许多个工作单元时，任务在他们之间是分享的。这个概念在Web应用中十分的有用。</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>前面部分中我们发送了一个Helloworld,现在我们发送字符串来代表复杂的信息，并用<code>Thread.sleep</code>来代替复杂的信息。我们用字符串后面的<code>.</code>的个数来代替这个任务需要执行的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String message = getMessage(argv);</span><br><span class="line">channel.basicPublish(<span class="string">""</span>, <span class="string">"hello"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String[] strings)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    <span class="keyword">return</span> joinStrings(strings, <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">joinStrings</span><span class="params">(String[] strings, String delimiter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = strings.length;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    StringBuilder words = <span class="keyword">new</span> StringBuilder(strings[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        words.append(delimiter).append(strings[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> words.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后的消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">    System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork(message);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">" [x] Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">true</span>; <span class="comment">// acknowledgment is covered below</span></span><br><span class="line">channel.basicConsume(TASK_QUEUE_NAME, autoAck, consumer);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(String task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch: task.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'.'</span>) Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h5><p>使用工作队列的一个好处就是它能够并行的处理队列。如果堆积了很多任务，我们只需要添加更多的工作者（workers）就可以了，扩展很简单。</p><p>首先，我们先同时运行两个 worker实例，它们都会从队列中获取消息，到底是不是这样呢？我们看看。</p><p>然后需要打开三个终端，两个用来运行 worker程序，这两个终端就是我们的两个消费者(consumers)—C1 和 C2。</p><p>默认来说，RabbitMQ 会按顺序得把消息发送给每个消费者（consumer）。平均每个消费者都会收到同等数量得消息。这种发送消息得方式叫做——轮询（round-robin）。试着添加三个或更多得工作者（workers）。</p><h5 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h5><p>当处理一个比较耗时得任务的时候，你也许想知道消费者（consumers）是否运行到一半就挂掉。当前的代码中，当消息被 RabbitMQ 发送给消费者（consumers）之后，马上就会在内存中移除。这种情况，你只要把一个工作者（worker）停止，正在处理的消息就会丢失。同时，所有发送到这个工作者的还没有处理的消息都会丢失。</p><p>我们不想丢失任何任务消息。<strong>如果一个工作者（worker）挂掉了，我们希望任务会重新发送给其他的工作者（worker）</strong>。</p><p><strong>为了防止消息丢失，RabbitMQ 提供了消息响应（acknowledgments）</strong>。消费者会通过一个 ack（响应），告诉RabbitMQ已经收到并处理了某条消息，然后RabbitMQ就会释放并删除这条消息。</p><p>如果消费者（consumer）挂掉了，没有发送响应，RabbitMQ 就会认为消息没有被完全处理，然后重新发送给其他消费者（consumer）。这样，及时工作者（workers）偶尔的挂掉，也不会丢失消息。</p><p><strong>消息是没有超时这个概念的</strong>；当工作者与它断开的时候，RabbitMQ 会重新发送消息。这样在处理一个耗时非常长的消息任务的时候就不会出问题了。</p><p>消息响应默认是开启的。之前的例子中我们可以使用 no_ack=True 标识把它关闭。当它为false时，当工作者（worker）完成了任务，就发送一个响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>); <span class="comment">// accept only one unack-ed message at a time (see below)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork(message);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">" [x] Done"</span>);</span><br><span class="line">      channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(TASK_QUEUE_NAME, autoAck, consumer);</span><br></pre></td></tr></table></figure><p>运用上面的代码，即使杀死一个任务，也不会丢失消息。</p><h5 id="忘记确认"><a href="#忘记确认" class="headerlink" title="忘记确认"></a>忘记确认</h5><p>一个很容易犯的错误就是忘了 basic_ack，后果很严重。消息在你的程序退出之后就会重新发送，如果它不能够释放没响应的消息，RabbitMQ 就会占用越来越多的内存。</p><p>为了排除这种错误，你可以使用 rabbitmqctl 命令，输出 messages_unacknowledged 字段：</p><h5 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h5><p>如果你没有特意告诉 RabbitMQ，那么在它退出或者崩溃的时候，将会丢失所有队列和消息。为了确保信息不会丢失，有两个事情是需要注意的：我们必须把“队列”和“消息”设为持久化。</p><p>首先，为了不让队列消失，需要把队列声明为持久化（durable）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">channel.queueDeclare(<span class="string">"hello"</span>, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>尽管这行代码本身是正确的，但是仍然不会正确运行。因为我们已经定义过一个叫hello 的非持久化队列。RabbitMq 不允许你使用不同的参数重新定义一个队列，它会返回一个错误。但我们现在使用一个快捷的解决方法——用不同的名字，例如task_queue。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">channel.queueDeclare(<span class="string">"task_queue"</span>, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>这个queue_declare必须在生产者（producer）和消费者（consumer）对应的代码中修改。这时候，我们就可以确保在 RabbitMq 重启之后 queue_declare 队列不会丢失。另外，我们需要把我们的消息也要设为持久化——将 delivery_mode 的属性设为2。</p><h5 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h5><p>你应该已经发现，它仍旧没有按照我们期望的那样进行分发。比如有两个工作者（workers），处理奇数消息的比较繁忙，处理偶数消息的比较轻松。然而RabbitMQ 并不知道这些，它仍然一如既往的派发消息。</p><p>这是因为 RabbitMQ 只管分发进入队列的消息，不会关心有多少消费者(consumer)没有作出响应。它盲目的把第 n-th 条消息发给第 n-th 个消费者。</p><p>我们可以使用 basic.qos 方法，并设置 prefetch_count=1。这样是告诉RabbitMQ，再同一时刻，不要发送超过1条消息给一个工作者（worker），直到它已经处理了上一条消息并且作出了响应。这样，RabbitMQ 就会把消息分发给下一个空闲的工作者（worker）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>分发一个消息给多个消费者（consumers）。这种模式被称为“发布／订阅”。</p><p>为了描述这种模式，将会构建一个简单的日志系统。它包括两个程序，第一个程序负责发送日志消息，第二个程序负责获取消息并输出内容。</p><p>在我们的这个日志系统中，所有正在运行的接收方程序都会接受消息。我们用其中一个接收者（receiver）把日志写入硬盘中，另外一个接受者（receiver）把日志输出到屏幕上。</p><p>最终，日志消息被广播给所有的接受者（receivers）。</p><p><strong>RabbitMQ 消息模型的核心理念是</strong>：发布者（producer）不会直接发送任何消息给队列。事实上，发布者（producer）甚至不知道消息是否已经被投递到队列。</p><p>发布者（producer）只需要把消息发送给一个<strong>交换机（exchange）</strong>。交换机非常简单，它一边从发布者方接收消息，一边把消息推送到队列。交换机必须知道如何处理它接收到的消息，是应该推送到指定的队列还是是多个队列，或者是直接忽略消息。这些规则是通过交换机类型（exchange type）来定义的。</p><p>有几个可供选择的交换机类型：直连交换机(direct), 主题交换机(topic), 头交换机(headers)和 扇型交换机(fanout)。我们在这里主要说明最后一个—-扇型交换机（fanout）。先创建一个fanout类型的交换机，命名为logs：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">"logs"</span>, <span class="string">"fanout"</span>);</span><br></pre></td></tr></table></figure><p>扇型交换机（fanout）很简单，它把消息发送给它所知道的所有队列。这正是我们的日志系统所需要的。</p><p>现在，我们就可以发送消息到一个具名交换机了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish( <span class="string">"logs"</span>, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure><h5 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h5><p>给一个队列命名是很重要的——我们需要把工作者（workers）指向正确的队列。如果你打算在发布者（producers）和消费者（consumers）之间共享同队列的话，给队列命名是十分重要的。</p><p>但是这并不适用于我们的日志系统。我们打算接收所有的日志消息，而不仅仅是一小部分。我们关心的是最新的消息而不是旧的。为了解决这个问题，我们需要做两件事情。</p><p>首先，当我们连接上 RabbitMQ 的时候，我们需要一个全新的、空的队列。我们可以手动创建一个随机的队列名，或者让服务器为我们选择一个随机的队列名（推荐）。我们只需要在调用 queueDeclare 方法的时候，不提供 queue 参数就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure><p>这时候我们可以通过 result.method.queue 获得已经生成的随机队列名。它可能是这样子的：amq.gen-U0srCoW8TsaXjNh73pnVAw==。</p><p>第二步，当与消费者（consumer）断开连接的时候，这个队列应当被立即删除。exclusive 标识符即可达到此目的.</p><h5 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h5><p>我们已经创建了一个扇型交换机（fanout）和一个队列。现在我们需要告诉交换机如何发送消息给我们的队列。交换器和队列之间的联系我们称之为绑定(binding)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind(queueName, <span class="string">"logs"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure></p><p>现在，logs 交换机将会把消息添加到我们的队列中。</p><h5 id="绑定列表"><a href="#绑定列表" class="headerlink" title="绑定列表"></a>绑定列表</h5><p>你可以使用 <code>rabbitmqctl list_bindings</code> 列出所有现存的绑定。</p><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">交换器与队列之间的连接叫做绑定，每一个绑定都有一个绑定键，叫做binding key，当消息发送过来时，消息会带有一个路由的标识，叫做routing key，交换器会根据这两个值来决定将消息发给哪个队列。</span><br><span class="line">- direct 根据生产者传过来的路由键是否等于绑定键，来决定发送的队列</span><br><span class="line">- topic 根据生产者传过来的路由键是否匹配一定的表达式，来决定</span><br><span class="line">- fanout 发送给知道的全部队列，会忽略路由键。</span><br><span class="line">- headers 根据消息的头信息来决定消息发送给哪个队列。</span><br></pre></td></tr></table></figure><hr><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>我们打算新增一个功能 —— 使得它能够只订阅消息的一个子集。例如，我们只需要把严重的错误日志信息写入日志文件（存储到磁盘），但同时仍然把所有的日志信息输出到控制台中。</p><h4 id="绑定-1"><a href="#绑定-1" class="headerlink" title="绑定"></a>绑定</h4><p>前面的例子，我们已经创建过绑定（bindings），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=exchange_name,queue=queue_name)</span><br></pre></td></tr></table></figure><p>绑定（binding）是指交换机（exchange）和队列（queue）的关系。可以简单理解为：这个队列（queue）对这个交换机（exchange）的消息感兴趣。</p><p>绑定的时候可以带上一个额外的 routing_key 参数。为了避免与basic_publish的参数混淆，我们把它叫做绑定键（binding key）。以下是如何创建一个带绑定键的绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=exchange_name,</span><br><span class="line">                   queue=queue_name,</span><br><span class="line">                   routing_key=<span class="string">'black'</span>)</span><br></pre></td></tr></table></figure><p>绑定键的意义取决于交换机（exchange）的类型。我们之前使用过的扇型交换机（fanout exchanges）会忽略这个值。</p><h5 id="直连交换机"><a href="#直连交换机" class="headerlink" title="直连交换机"></a>直连交换机</h5><p>我们的日志系统广播所有的消息给所有的消费者（consumers）。我们打算扩展它，使其基于日志的严重程度进行消息过滤。例如我们也许只是希望将比较严重的错误（error）日志写入磁盘，以免在警告（warning）或者信息（info）日志上浪费磁盘空间。</p><p>我们使用的扇型交换机（fanout exchange）没有足够的灵活性 —— 它能做的仅仅是广播。</p><p>我们将会使用直连交换机（direct exchange）来代替。路由的算法很简单 —— 交换机将会对绑定键（binding key）和路由键（routing key）进行精确匹配，从而确定消息该分发到哪个队列。</p><p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-27%2016-55-10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=X2MAXP8ssLktyMD9BBHes0qsvCxhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NzMyOTQ0JnQ9MTUyMjE0MDk0NCZyPTEyNTYyMTg3MTAmZj0vMjAxOC0wMy0yNyUyMDE2LTU1LTEwJUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""></p><p>在这个场景中，我们可以看到直连交换机 X 和两个队列进行了绑定。第一个队列使用 orange 作为绑定键，第二个队列有两个绑定，一个使用 black 作为绑定键，另外一个使用 green。</p><p>这样以来，当路由键为 orange 的消息发布到交换机，就会被路由到队列 Q1。路由键为 black 或者 green 的消息就会路由到 Q2。其他的所有消息都将会被丢弃。</p><h4 id="多个绑定"><a href="#多个绑定" class="headerlink" title="多个绑定"></a>多个绑定</h4><p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-27%2017-02-39%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=BX5GArkS2warxv6ICYDEzrvxq51hPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NzMzMzgzJnQ9MTUyMjE0MTM4MyZyPTE5NDg0NTAwMzImZj0vMjAxOC0wMy0yNyUyMDE3LTAyLTM5JUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""></p><p>多个队列使用相同的绑定键是合法的。这个例子中，我们可以添加一个 X 和 Q1 之间的绑定，使用 black 绑定键。这样一来，直连交换机就和扇型交换机的行为一样，会将消息广播到所有匹配的队列。带有 black 路由键的消息会同时发送到 Q1 和 Q2。</p><h5 id="发送日志"><a href="#发送日志" class="headerlink" title="发送日志"></a>发送日志</h5><p>我们将会发送消息到一个直连交换机，把日志级别作为路由键。这样接收日志的脚本就可以根据严重级别来选择它想要处理的日志。我们先看看发送日志。我们需要创建一个交换机（exchange）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.exchange_declare(exchange=<span class="string">'direct_logs'</span>,</span><br><span class="line">                         exchange_type=<span class="string">'direct'</span>)</span><br></pre></td></tr></table></figure><p>然后我们发送一则消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">'direct_logs'</span>,</span><br><span class="line">                      routing_key=severity,</span><br><span class="line">                      body=message)</span><br></pre></td></tr></table></figure><p>我们先假设 “severity” 的值是 info、warning、error 中的一个。</p><h5 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h5><p>处理接收消息的方式和之前差不多，只有一个例外，我们将会为我们感兴趣的每个严重级别分别创建一个新的绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> severity in severities:</span><br><span class="line">    channel.queue_bind(exchange=<span class="string">'direct_logs'</span>,</span><br><span class="line">                       queue=queue_name,</span><br><span class="line">                       routing_key=severity)</span><br></pre></td></tr></table></figure><h3 id="主题交换机"><a href="#主题交换机" class="headerlink" title="主题交换机"></a>主题交换机</h3><p>我们改进了我们的日志系统。我们使用直连交换机替代了扇型交换机，从只能盲目的广播消息改进为有可能选择性的接收日志。</p><p>尽管直连交换机能够改善我们的系统，但是它也有它的限制—-没办法基于多个标准执行路由操作。</p><p>在我们的日志系统中，我们不只希望订阅基于严重程度的日志，同时还希望订阅基于发送来源的日志。Unix 工具 <a href="http://en.wikipedia.org/wiki/Syslog" target="_blank" rel="noopener">syslog</a>就是同时基于严重程度 -severity (info/warn/crit…) 和 设备 -facility (auth/cron/kern…) 来路由日志的。</p><p>如果这样的话，将会给予我们非常大的灵活性，我们既可以监听来源于 “cron” 的严重程度为 “critical errors” 的日志，也可以监听来源于 “kern” 的所有日志。</p><p>为了实现这个目的，接下来我们学习如何使用另一种更复杂的交换机 —— 主题交换机。</p><p>发送到主题交换机（topic exchange）的消息不可以携带随意什么样子的路由键（routing_key），它的路由键必须是一个由.分隔开的词语列表。这些单词随便是什么都可以，但是最好是跟携带它们的消息有关系的词汇。以下是几个推荐的例子：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”。词语的个数可以随意，但是不要超过 255 字节。</p><p>绑定键也必须拥有同样的格式。主题交换机背后的逻辑跟直连交换机很相似 —— 一个携带着特定路由键的消息会被主题交换机投递给绑定键与之想匹配的队列。但是它的绑定键和路由键有两个特殊应用方式：</p><ul><li>星号用来表示一个单词</li><li>井号用来表示任意数量的单词</li></ul><p><img src="http://two-1252095801.cosgz.myqcloud.com/2018-03-27%2017-10-21%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?sign=GR5WD6Fevzoj0mkBDiqNz/gnybVhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTI0NzMzODM0JnQ9MTUyMjE0MTgzNCZyPTEzMTU2MjkyNDUmZj0vMjAxOC0wMy0yNyUyMDE3LTEwLTIxJUU1JUIxJThGJUU1JUI5JTk1JUU2JTg4JUFBJUU1JTlCJUJFLnBuZyZiPXR3bw==" alt=""></p><p>这个例子里，我们发送的所有消息都是用来描述小动物的。发送的消息所携带的路由键是由三个单词所组成的，这三个单词被两个.分割开。路由键里的第一个单词描述的是动物的手脚的利索程度，第二个单词是动物的颜色，第三个是动物的种类。所以它看起来是这样的： <code>&lt;celerity&gt;.&lt;colour&gt;.&lt;species&gt;</code></p><p>我们创建了三个绑定：Q1 的绑定键为<code>.orange.</code>，Q2 的绑定键为 <code>..rabbit</code> 和 <code>lazy.#</code> 。</p><p>这三个绑定键被可以总结为：</p><ul><li>Q1 对所有的桔黄色动物都感兴趣。</li><li>Q2 则是对所有的兔子和所有懒惰的动物感兴趣。</li></ul><p>一个携带有 <code>quick.orange.rabbit</code> 的消息将会被分别投递给这两个队列。携带着 <code>lazy.orange.elephant</code> 的消息同样也会给两个队列都投递过去。另一方面携带有 <code>quick.orange.fox</code>的消息会投递给第一个队列，携带有 <code>lazy.brown.fox</code> 的消息会投递给第二个队列。携带有 <code>lazy.pink.rabbit</code> 的消息只会被投递给第二个队列一次，即使它同时匹配第二个队列的两个绑定。携带着 <code>quick.brown.fox</code> 的消息不会投递给任何一个队列。</p><p>如果我们违反约定，发送了一个携带有一个单词或者四个单词<code>orange</code> or <code>quick.orange.male.rabbit</code>的消息时，发送的消息不会投递给任何一个队列，而且会丢失掉。</p><p>但是另一方面，即使 <code>lazy.orange.male.rabbit</code> 有四个单词，他还是会匹配最后一个绑定，并且被投递到第二个队列中。</p><p>主题交换机是很强大的，它可以表现出跟其他交换机类似的行为</p><p>当一个队列的绑定键为 “#”（井号） 的时候，这个队列将会无视消息的路由键，接收所有的消息。</p><p>当 * (星号) 和 # (井号) 这两个特殊字符都未在绑定键中出现的时候，此时主题交换机就拥有的直连交换机的行为。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装ZooKeeper</title>
      <link href="/2018/03/26/Linux%20%E5%AE%89%E8%A3%85ZooKeeper/"/>
      <url>/2018/03/26/Linux%20%E5%AE%89%E8%A3%85ZooKeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-安装ZooKeeper"><a href="#Linux-安装ZooKeeper" class="headerlink" title="Linux 安装ZooKeeper"></a>Linux 安装ZooKeeper</h2><ol><li><p>下载zookeeper二进制安装包</p></li><li><p>解压下载的ZooKeeper</p></li><li><p>用mv命令修改zookeeper-3.4.8 为zookeeper</p></li><li><p>用cd命令进入zookeeper/conf文件夹</p></li><li><p>用cp 命令拷贝一个zoo_samle.cfg 改名为zoo.cfg</p></li><li><p>然后用gedit zoo.cfg命令打开编辑zoo.cfg文件</p></li><li><p>使用超级管理员打开环境变量文件<code>/etc/profile</code>。</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export ZOOKEEPER_HOME=/home/corn1ng/software/zookeeper</span><br><span class="line">PATH=$ZOOKEEPER_HOME/bin:$PATH</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure></li><li><p>进入zookeeper/bin运行./zkServer.sh start即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringIoC容器详解</title>
      <link href="/2018/03/26/Spring%20Ioc%20%E5%AE%B9%E5%99%A8/"/>
      <url>/2018/03/26/Spring%20Ioc%20%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Ioc-容器"><a href="#Spring-Ioc-容器" class="headerlink" title="Spring Ioc 容器"></a>Spring Ioc 容器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="IoC容器和依赖反转模式"><a href="#IoC容器和依赖反转模式" class="headerlink" title="IoC容器和依赖反转模式"></a>IoC容器和依赖反转模式</h4><p>如果合作对象的引用或依赖关系的管理由具体对象来完成，会导致代码的高度耦合和可测试性的降低，这对复杂的面向对象设计非常不利， 对象的依赖关系常常体现在数据和方法的依赖上，这些依赖关系可以通过把对象的依赖注入交给框架或IoC容器来完成，这种方法可以在解耦代码的同时提高代码的可测试性。</p><p>依赖控制反转的实现有很多种方式，在Spring 中，IoC容器是实现这个模式的载体，它可以在<strong>对象生成或初始化时</strong>直接将数据注入到对象中，也可以通过将对象引用注入到对象数据域的方式来注入对方法调用的依赖，这种依赖注入是可以递归的，对象被逐层注入。</p><p><strong>通过IoC容器，对象依赖关系的管理被反转了，转到IoC容器中来了，对象之间的依赖关系由IoC容器进行管理，并由IoC容器完成对象的注入，这样就很大程度上简化了开发。把应用从复杂的对象依赖关系管理中解放出来。</strong></p><h3 id="IOC设计实现"><a href="#IOC设计实现" class="headerlink" title="IOC设计实现"></a>IOC设计实现</h3><p>springIOC设计中，有两个主要的容器系列，一个是实现<code>BeanFactory</code> 接口的简单容器系列，他们只实现了容器的基本功能，另一个<code>ApplicationContext</code>应用上下文，作为容器的高级形态而存在，它在简单容器的基础上，增加了许多面向框架的特性，同时对应用环境做了许多适配。</p><p>作为IOC容器，需要为他的具体实现指定基本的功能规范，这个功能规范的设计表现为接口类<code>BeanFactory</code>,它体现了Spring为提供给用户使用的Ioc容器所设定的<strong>最基本的功能规范</strong>。也就说说，一个IoC容器最基本的就是要实现BeanFactory中定义的接口。</p><p>同时，Spring还通过定义<code>BeanDefinition</code>来管理基于Spring的应用中的各种对象以及它们之间的相互依赖关系，<code>BeanDefinition</code>抽象了我们对于Bean的定义，是让容器起作用的主要数据类型。IoC容器是用来管理对象依赖关系的，对于IOC容器来说，<code>BeanDefinition</code> 就是对依赖反转模式中管理的对象依赖关系的数据抽象。也是实现依赖反转功能的核心数据结构。</p><p>下图是IoC容器中的主要接口设计</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%884.34.07.png" alt=""></p><p>从<code>Beanfactory</code>到<code>HierarchicalBeanFactory</code>到<code>ConfigurableBeanFacotry</code> ，是一条<code>BeanFactory</code>的设计路径，其中，<code>BeanFactory</code>接口定义了基本的Ioc容器的规范，比如<code>getBean()</code>这样的Ioc容器的基本方法，<code>HierarchicalBeanFactory</code>在原来的接口基础上，增加了<code>getparentBeanFactory()</code>的接口功能，使BeanFactory具备了双亲IoC容器的管理功能。在<code>ConfigurableBeanFacotry</code>中，主要定义了一些对<code>Beanfactory</code>的配置功能。</p><p>还有一条主线是以<code>ApplicationContext</code>应用上下文接口为核心的接口设计。这里的主要接口设计有从<code>BeanFactory</code>到<code>ListableBeanFatory</code>,再到<code>ApplicationContext</code>,再到我们常用的<code>WebApplicationContext</code>或者<code>ConfigurableApplicationContext</code>接口。我们常用的应用上下文基本都是<code>ConfigurableApplicationContext</code>或者<code>WebApplicationContext</code>的实现。</p><h4 id="Beanfactory的应用场景"><a href="#Beanfactory的应用场景" class="headerlink" title="Beanfactory的应用场景"></a>Beanfactory的应用场景</h4><p>BeanFactory提供的是最基本的Ioc容器的功能，这些功能定义，我们可以在接口BeanFactory中看到。Beanfactory接口设计了getBean方法，这个方法是使用Ioc容器API的主要方法，通过这个方法，可以取得Ioc容器中管理的Bean.Bean 的取得是通过指定名字来索引的。下面是BeanFactory 接口中的方法。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%884.41.51.png" alt=""></p><p>这里定义的只是一系列的接口方法，通过不同的Bean检索方法，可以方便的从容器中取出需要的Bean。这些检索方法代表的是最为基本的容器入口。</p><h4 id="BeanFactory容器设计原理"><a href="#BeanFactory容器设计原理" class="headerlink" title="BeanFactory容器设计原理"></a>BeanFactory容器设计原理</h4><p>以<code>XMLBeanFactory</code>为例，简单说明Ioc容器的设计原理。<br>在spring中，实际上是把<code>DefaultListableBeanFactory</code>作为一个默认的功能完整的Ioc容器来使用的，以<code>XMLBeanFactory</code>继承了<code>DefaultListableBeanFactory</code>容器的功能的同时，增加了新的功能，也就是它是一个可以读取以XML文件方式定义的BeanDefinition的Ioc容器。对这些XML方式定义的信息的处理并不是由XmlBeanFactory直接完成的，而是初始化了一个XmlBeanDefinitionReader对象，有了这个Reader对象，那些以XML方式定义的BeanDefinition就有了处理的地方。可以看到，对这些XML形式的信息的处理实际上是由这个XmlBeanDefinitionReader来完成的。<br><strong>构造<code>XMLBeanFactory</code>这个容器的时候，需要指定<code>BeanDefinition</code>的信息来源，而这个消息来源需要封装成Spring中的<code>Resource</code>类来给出。<code>Resource</code>是Spring用来封装IO操作的类。</strong><br>XMLBeanFactory的功能是建立在DefaultListableBeanFacory 这个基本容器的基础上的，并在这个容器的基础上实现了其他诸如XML读取的附加功能。</p><p>下面是编程方式使用DeaultListableBeanFactory的代码，从中可以看到IoC容器使用的一些基本过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource res =<span class="keyword">new</span> ClassPathResource(<span class="string">"beans.xml"</span>);</span><br><span class="line">DefaultListableBeanFactory factory=<span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader =<span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">reader.loadBeanDefinitions(res);</span><br></pre></td></tr></table></figure><h4 id="ApplicationContext应用场景"><a href="#ApplicationContext应用场景" class="headerlink" title="ApplicationContext应用场景"></a>ApplicationContext应用场景</h4><p><code>ApplicationContext</code>是一个高级形态意义的IoC容器。提供了以下新特性：</p><ul><li>支持不同的信息源（扩展了MessageSource接口，可以支持国际化）</li><li>访问资源</li><li>支持应用事件</li><li>提供了附加服务</li></ul><h3 id="IOC容器的初始化过程"><a href="#IOC容器的初始化过程" class="headerlink" title="IOC容器的初始化过程"></a>IOC容器的初始化过程</h3><p>Ioc容器的初始化是由<code>refresh</code>方法来启动。这个方法标志着Ioc正式启动。具体来说，这个过程包括了<code>BeanDefinition</code>的Resource定位，载入和注册三个基本过程。</p><p><font color="0e0e0e">第一个过程是Resource定位过程</font>。指的是<code>BeanDefinition</code>的资源定位，它由<code>ResourceLoader</code>提供统一的<code>Resource接口</code>来完成。这个<code>Resource</code>对各种形式的<code>BeanDefinition</code>的使用都提供了统一的接口。</p><p>具体来说，首先是定义一个<code>Resource</code>来定位容器使用的<code>BeanDefinition</code>,这时使用的是<code>ClassPathResource</code>,这意味着Spring会在类路径中去寻找以文件形式存在的<code>BeanDefinition</code>信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource res =<span class="keyword">new</span> ClassPathResource(<span class="string">"beans.xml"</span>);</span><br></pre></td></tr></table></figure><p>这里定义的Resource并不能直接的使用。Spring通过<code>BeanDefinitionReader</code>来对这些信息进行处理。以<code>FileSystemApplicationContext</code>为例，对<code>BeanDefinition</code>资源定位的过程，最初是由<code>refresh</code>来<strong>触发</strong>的，这个<code>refresh()</code>的调用是在<code>FileSystemApplicationContext</code>的构造函数中启动的。</p><p>定位过程完成后，就为<code>BeanDefinition</code>的载入创造了IO操作的条件，但是具体的数据还没有开始读入。相当于用水桶去打水，这时候水源就已经找到了。</p><p><font color="0e0e0e">第二个过程就是<code>BeanDefinition</code>的载入与解析。</font></p><p>对Ioc容器来说，这个载入过程，相当于把定义的<code>BeanDefinition</code>在Ioc容器中转化为一个Spring内部表示的数据结构的过程。Ioc容器对Bean的管理和依赖，都是通过对其持有的<code>BeanDefinition</code>进行各种相关操作完成的。这些<code>BeanDefinition</code>数据在Ioc容器中通过一个<code>HashMap</code>来保持和维护。</p><p>首先，先回到IoC容器的初始化入口，也就是看下Ioc容器的初始化方法<code>refresh()</code>。它的调用标志着容器初始化的开始。这些初始化兑现就是BeanDefinition数据。</p><p>对容器的启动来说，refresh 是一个很重要的方法，</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%885.25.48.png" alt=""></p><p>Refresh 非常像重启动容器，就像重启动计算机那样，在建立好当前的IoC容器以后，开始了对容器的初始化过程，比如BeanDefinition的载入。</p><p>BeanDefinition 的载入分为两部分，首先通过调用XML的解析器得到document对象，但这些document对象并没有按照Spring 的bean规则进行解析，在完成通用的XML解析以后，才是按照Spring 的Bean规则进行解析的地方，这个按照Spring的Bean规则进行解析的过程是在documentReader 中实现的。具体的Spring BeanDefinition的解析是在BeanDifinitionParserDelegate中完成的，这个类里包含了对各种Spring Bean 定义规则的处理。</p><p><font color="0e0e0e">第三个过程就是<code>BeanDefinition</code>在Ioc容器中的注册</font>这个过程是通过调用BeanDefinitionRegistry接口的实现来完成的，这个注册过程把载入过程中解析得到的BeanDefinition向IoC容器进行注册，实际在内部，是通过将BeanDefinition注入到一个HashMap 中去。</p><p>载入解析完成后，用户定义的<code>BeanDefinition</code>信息已经在Ioc容器中建立起了自己的数据结构以及相应的数据表示。但是这些数据还不能供IOc容器直接使用，需要在IOc容器中对这些<code>BeanDefinition</code>数据进行注册。注册为IoC容器提供了更加友好的使用方式，在<code>DefaultListableBeanFactory</code>中，通过<code>HashMap</code>来持有载入的<code>BeanDefinition</code>的。注册过程实际上就是把解析到<code>BeanDefinition</code>设置到HashMap中去。</p><p>完成了BeanDefinition的注册，就完成了IOc容器的初始化过程。</p><h3 id="IOC容器的依赖注入"><a href="#IOC容器的依赖注入" class="headerlink" title="IOC容器的依赖注入"></a>IOC容器的依赖注入</h3><p>假设当前Ioc容器已经载入了用户定义的Bean信息，开始分析依赖注入的原理，首先，注意到依赖注入的过程是用户第一次向Ioc容器索要Bean时触发的，当然也有例外，也就是可以在<code>BeanDefinition</code>信息中通过控制lazy-init属性来让容器完成对Bean的预实例化。这个预实例化实际上也是一个完成依赖注入的过程。但是他是在初始化的过程中完成的。</p><p>在Ioc容器基本接口中，有一个<code>getBean()</code>的接口定义，这个接口的实现就是触发依赖注入的地方。<code>getBean()</code>方法最终是通过调用<code>doGetBean来实现的</code>。<br><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8B%E5%8D%886.04.07.png" alt=""></p><blockquote><p>spring技术内幕55page</p></blockquote><p>主要的逻辑就是先尝试从缓存中去取得Bean,若取到，则不需要重复的创建。然后对容器中的BeanDefinition是否存在进行检查，检查是否能在当前的BeanFactory中取得需要的Bean,如果当前的工厂取不到，就从双亲BeanFactory中去取。如果还取不到，就沿着链一直往上取。然后根据Bean的名字取得BeanDefinition。接着获取当前Bean的所有依赖Bean，这样会触发getBean的递归调用，直到取到一个没有任何依赖的Bean为止。最后对创建的Bean进行类型检查，如果没有问题，则返回这个新创建的Bean.</p><p>依赖注入的发生就是在容器中的BeanDefinition数据已经建立好的前提下进行的。重点来说，<code>getBean()</code>是依赖注入的起点，<code>getBean()</code>调用<code>doGetBean</code>,<code>doGetBean</code>调用<code>createBean</code>,<code>createBean</code>不仅生成了需要的Bean,还对Bean初始化进行了处理。Bean对象根据BeanDefinition要求的定义生成。</p><p><code>CreateBean</code>中调用<code>doCreateBean</code>来生成需要的Bean.真正的创建Bean是由<code>createBeanInstance</code>来完成的。在<code>createBeanInstance</code>中，生成了Bean所包含的Java对象，这个对象的生成有多种不同的形式，可以通过工厂方法形成，也可以通过容器的autowired特性生成。Spring中生成对象的默认类是<code>SimpleInstantiationStrategy</code>类，它提供了两种实例化Java对象的方法，一种是通过BeanUtils，它使用了JVM的反射功能，一种是通过前面提到的CGLIB来生成。</p><p>通过前面的描述，实例化Bean就已经完成了，接下来就要处理这些Bean的依赖关系，完成整个依赖注入过程。这个过程涉及对各种Bean对象的属性的处理过程。这些依赖关系处理的依据就是已经解析到的BeanDefinition.</p><p>在<code>docreatBean</code>中的<code>poulateBean</code>就是处理Bean之间依赖关系的类.</p><p><code>populateBean</code>中对属性注入使用了<code>applyPropertyValues()</code> 这个方法。方法中主要通过 <code>BeanDefinitionResolver</code> 来对BeanDefinition进行解析,然后注入到Property 中。</p><p>在配置Bean的属性的时候，属性可能有多种类型，我们再进行注入的时候，不同的属性类型我们不可能一概而论的进行处理，集合类型的属性和非集合类型具备很大的差别，对不同的类型应该有不同的解析处理过程，故该方法流程中首先判断value的类型然后在分别调用 <code>resolveManagedList()</code>、 <code>resolveManagedSet()</code> 、 <code>resolveManagedMap()</code>等方法进行具体的解析。</p><p>在完成这个解析过程后，已经为依赖注入准备好了条件，这是真正把Bean对象设置到它所依赖的另一个Bean的属性中去的地方，其中出来的属性是各种各样的，依赖注入的发生是在BeanWrapper 的setPropertyValues中实现的，具体的完成却是在BeanWrapper的子类BeanWrapperImpl中实现的。</p><p>通过Bean的创建和对象依赖注入后，这个Bean已经不是简单的Java对象了，该Bean系列以及Bean之间的依赖关系建立好以后，通过IOC容器的相关接口方法，就可以非常方便的进行上层调用了。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC Conveter 和Formatter</title>
      <link href="/2018/03/25/SpringMVC%20Conveter%20%E5%92%8CFormatter/"/>
      <url>/2018/03/25/SpringMVC%20Conveter%20%E5%92%8CFormatter/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC-Conveter-和Formatter"><a href="#SpringMVC-Conveter-和Formatter" class="headerlink" title="SpringMVC Conveter 和Formatter"></a>SpringMVC Conveter 和Formatter</h2><h3 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h3><p>Spring的Converter可以将一种类型转换成另一种类型。在使用时，必须编写一个实现org.springframework.core.convert.converter.Converter接口的java类。这个接口的声明如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(S var1)</span></span>;</span><br><span class="line">&#125;<span class="comment">//S表示源类型，T表示目标类型。</span></span><br></pre></td></tr></table></figure><p>下面是一个将String类型转换为Date类型的Converter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(StringToDateConverter.class);</span><br><span class="line">    <span class="keyword">private</span> String datePattern;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringToDateConverter</span><span class="params">(String datePattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.datePattern = datePattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(datePattern);</span><br><span class="line">            dateFormat.setLenient(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> dateFormat.parse(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid date format. Please use this pattern\""</span> + datePattern + <span class="string">"\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使用Spring MVC应用程序定制的Converter，需要在配置文件中添加一个conversionService bean。Bean的类名称必须为org.springframework.context.support.ConversionServiceFactoryBean。这个bean必须包含一个converters属性，它列出要在应用程序中使用的所有定制Converter。下面bean声明注册了上面StringToDateConverter。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.converter.StringToDateConverter"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"datePattern"</span> <span class="attr">value</span>=<span class="string">"yyyy-MM-dd"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后，还需要给annotation-driven元素的conversion-service属性赋上bean名称，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h3><p>Formatter和Converter一样，也是将一种类型转换成另一种类型。但是，Formatter的源类型必须是一个String。<br>在使用时，必须编写一个实现org.springframework.format.Formatter接口的java类。这个接口的声明如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formatter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">print</span><span class="params">(T var1, Locale var2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">parse</span><span class="params">(String var1, Locale var2)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的T表示输入字符串要转换的目标类型。<br>parse方法利用指定的Locale将一个String解析成目标类型。print方法相反，它是返回目标对象的字符串表示法。<br>下面展示了一个将String类型转换成Date类型的Formatter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.format.Formatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String datePattern;</span><br><span class="line">    <span class="keyword">private</span> SimpleDateFormat dateFormat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DateFormatter</span><span class="params">(String datePattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dateFormat = dateFormat;</span><br><span class="line">        dateFormat = <span class="keyword">new</span> SimpleDateFormat(datePattern);</span><br><span class="line">        dateFormat.setLenient(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String s, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(datePattern);</span><br><span class="line">            dateFormat.setLenient(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> dateFormat.parse(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid date format. Please use this pattern\""</span> + datePattern + <span class="string">"\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">(Date date, Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使用Spring MVC应用程序定制的Formatter，需要在配置文件中添加一个conversionService bean。Bean的类名称必须为org.springframework.format.support.FormattingConversionServiceFactoryBean。这个bean可以用一个formatters属性注册Formatter，用一个converters属性注册Converter。下面bean声明注册了上面DateFormatter。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"formatters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"app06a.formatter.DateFormatter"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"datePattern"</span> <span class="attr">value</span>=<span class="string">"yyyy-MM-dd"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后，还需要给annotation-driven元素的conversion-service属性赋上bean名称，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用Registrar注册Formatter"><a href="#用Registrar注册Formatter" class="headerlink" title="用Registrar注册Formatter"></a>用Registrar注册Formatter</h3><p>注册Formatter的另一种方法是使用Registrar。<br>下面就用Registrar来注册前面的DateFormatter。<br>先需要实现org.springframework.format.FormatterRegistrar接口，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.format.FormatterRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.format.FormatterRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFormatterRegistrar</span> <span class="keyword">implements</span> <span class="title">FormatterRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String datePattern;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyFormatterRegistrar</span><span class="params">(String datePattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.datePattern = datePattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFormatters</span><span class="params">(FormatterRegistry formatterRegistry)</span> </span>&#123;</span><br><span class="line">        formatterRegistry.addFormatter(<span class="keyword">new</span> DateFormatter(datePattern));</span><br><span class="line">        <span class="comment">//register more formatters here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了Registrar，就不需要在Spring MVC配置文件中注册Formatter，只要在配置文件中注册Registrar就行，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"formatterRegistrars"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"app06a.formatter.MyFormatterRegistrar"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"datePattern"</span> <span class="attr">value</span>=<span class="string">"yyyy-MM-dd"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="选择Converter还是Formatter"><a href="#选择Converter还是Formatter" class="headerlink" title="选择Converter还是Formatter"></a>选择Converter还是Formatter</h3><p>Converter是一般工具，可以将一种类型转换成另一种类型。例如，将String转换成Date，或者将Long转换成Date。Converter既可以用在web层，也可以用在其它层中。<br>Formatter只能将String转成成另一种java类型。例如，将String转换成Date，但它不能将Long转换成Date。所以，Formatter适用于web层。为此，在Spring MVC应用程序中，选择Formatter比选择Converter更合适。</p><blockquote><p><a href="https://segmentfault.com/a/1190000005708254" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005708254</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式基本理论</title>
      <link href="/2018/03/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/"/>
      <url>/2018/03/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式基本理论"><a href="#分布式基本理论" class="headerlink" title="分布式基本理论"></a>分布式基本理论</h2><p>在计算机领域，分布式一致性是一个相当重要且被广泛探索与论证的问题。</p><p>终端用户在使用不同计算机产品时对于数据一致性的需求是不一样的。</p><ul><li>有些系统，既要快速的响应用户，同时还要保证系统的数据对于任意客户端都是真实可靠的，就像火车站的售票系统。</li><li>有些系统，需要为用户保证绝对可靠的数据安全，虽然在数据一致性上存在延时，但是最终务必保证严格的一致性，就像银行的转账系统。</li><li>有些系统，虽然向用户展示了一些错误的数据，但是在整个系统的使用过程中，一定会在某一个流程上对系统数据进行精确无误的检查，从而避免用户发生不必要的损失，就像网购系统。</li></ul><h3 id="分布一致性的提出"><a href="#分布一致性的提出" class="headerlink" title="分布一致性的提出"></a>分布一致性的提出</h3><p>在分布式系统中要解决的一个重要问题就是数据的复制。在我们的日常开发经验中，相信很多开发人员都遇到过这样的问题：假设客户端C1将系统中的一个值K由V1更新为V2，但客户端C2无法立即读取到K的最新值，需要在一段时间之后才能读取到。这很正常，因为数据库复制之间存在延时。</p><p>分布式系统对于数据的复制需求一般都来自于以下两个原因：</p><p>1、为了增加系统的可用性，以防止单点故障引起的系统不可用</p><p>2、提高系统的整体性能，通过负载均衡技术，能够让分布在不同地方的数据副本都能够为用户提供服务。</p><p>数据复制在可用性和性能方面给分布式系统带来的巨大好处是不言而喻的，然而数据复制所带来的一致性挑战，也是每一个系统研发人员不得不面对的。</p><p>所谓分布一致性问题，是指在分布式环境中引入数据复制机制之后，不同数据节点之间可能出现的，并无法依靠计算机应用程序自身解决的数据不一致的情况。简单讲，数据一致性就是指在对一个副本数据进行更新的时候，必须确保也能够更新其他的副本，否则不同副本之间的数据将不一致。</p><p>那么如何解决这个问题？一种思路是”<strong>既然是由于延时动作引起的问题，那我可以将写入的动作阻塞，直到数据复制完成后，才完成写入动作</strong>“。没错，这似乎能解决问题，而且有一些系统的架构也确实直接使用了这个思路。但这个思路在解决一致性问题的同时，又带来了新的问题：写入的性能。如果你的应用场景有非常多的写请求，那么使用这个思路之后，后续的写请求都将会阻塞在前一个请求的写操作上，导致系统整体性能急剧下降。</p><p>总得来说，我们无法找到一种能够满足分布式系统所有系统属性的分布式一致性解决方案。因此，如何既保证数据的一致性，同时又不影响系统运行的性能，是每一个分布式系统都需要重点考虑和权衡的。于是，一致性级别由此诞生：</p><p>1、强一致性</p><p>这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大</p><p>2、弱一致性</p><p>这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</p><p>3、最终一致性</p><p>最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型。</p><h3 id="分布式环境中的各种问题"><a href="#分布式环境中的各种问题" class="headerlink" title="分布式环境中的各种问题"></a>分布式环境中的各种问题</h3><p>分布式系统在其出现之初就伴随着诸多难题和挑战。</p><p>1、通信异常</p><p>从集中式向分布式演变的过程中，必然引入网络因素，由于网络本身的不可靠性，因此也引入了额外的问题。分布式系统需要在各个节点之间进行网络通信，因此每次网络通信都会伴随着网络不可用的风险，网络光纤、路由器或是DNS等硬件设备或是系统不可用都会导致最终分布式系统无法顺利完成一次网络通信。另外，即使分布式系统各个节点之间的网络通信能够正常进行，其延时也会大于单机操作。通常我们认为现代计算机体系结构中，单机内存访问的延时在纳秒数量级（通常是10ns），而正常的一次网络通信的延迟在0.1~1ms左右（相当于内存访问延时的105倍），如此巨大的延时差别，也会影响到消息的收发过程，因此消息丢失和消息延迟变得非常普遍</p><p>2、网络分区</p><p><strong>当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点之间能够正常通信，而另一些节点则不能—-我们将这个现象称为网络分区</strong>。当网络分区出现时，分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本需要整个分布式系统才能完成的功能，包括对数据的事物处理，这就对分布式一致性提出了非常大的挑战</p><p>3、三态</p><p>上面两点，我们已经了解到在分布式环境下，网络可能会出现各式各样的问题，因此分布式系统的每一次请求与响应，存在特有的三态概念，即<strong>成功、失败、超时</strong>。在传统的单机系统中，应用程序在调用一个函数之后，能够得到一个非常明确的响应：成功或失败。而在分布式系统中，由于网络是不可靠的，虽然在绝大部分情况下，网络通信也能够接受到成功或失败的响应，当时当网络出现异常的情况下，就可能会出现超时现象，通常有以下两种情况：</p><p>（1）由于网络原因，该请求并没有被成功地发送到接收方，而是在发送过程中就发生了消息丢失现象</p><p>（2）该请求成功地被接收方接收后，进行了处理，但是在将响应反馈给发送方的过程中，发生了消息丢失现象</p><p>当出现这样的超时现象时，网络通信的发起方是无法确定当前请求是否被成功处理的</p><p>4、节点故障</p><p>节点故障则是分布式环境下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或”僵死”现象，通常根据经验来说，每个节点都有可能出现故障，并且每天都在发生。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>随着分布式计算的发展，事物在分布式计算领域也得到了广泛的应用。在单机数据库中，我们很容易能够实现一套满足ACID特性的事物处理系统，但在分布式数据库中，数据分散在各台不同的机器上，如何对这些数据进行分布式的事物处理具有非常大的挑战。</p><p>分布式事物是指事物的参与者、支持事物的服务器、资源服务器以及事物管理器分别位于分布式系统的不同节点上，通常一个分布式事物中会涉及对多个数据源或业务系统的操作。</p><p>可以设想一个最典型的分布式事物场景：一个跨银行的转账操作涉及调用两个异地的银行服务，其中一个是本地银行提供的取款服务，另一个则是目标银行提供的存款服务，这两个服务本身是无状态并且相互独立的，共同构成了一个完整的分布式事物。如果从本地银行取款成功，但是因为某种原因存款服务失败了，那么就必须回滚到取款之前的状态，否则用户可能会发现自己的钱不翼而飞了。</p><p>从这个例子可以看到，一个分布式事务可以看做是多个分布式的操作序列组成的，例如上面例子的取款服务和存款服务，通常可以把这一系列分布式的操作序列称为子事物。因此，分布式事务也可以被定义为一种嵌套型的事物，同时也就具有了ACID事物特性。但由于在分布式事务中，各个子事物的执行是分布式的，因此要实现一种能够保证ACID特性的分布式事物处理系统就显得格外复杂。</p><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>一个经典的分布式系统理论。CAP理论告诉我们：<strong>一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance*）这三个基本需求，最多只能同时满足其中两项</strong>。</p><p><strong>1、一致性</strong></p><p>在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一直的状态。</p><p>对于一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据进行了更新操作并且更新成功后，却没有使得第二个节点上的数据得到相应的更新，于是在对第二个节点的数据进行读取操作时，获取的依然是老数据（或称为脏数据），这就是典型的分布式数据不一致的情况。在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都可以读取到其最新的值，那么这样的系统就被认为具有强一致性</p><p><strong>2、可用性</strong></p><p>可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里的重点是”有限时间内”和”返回结果”。</p><p>“有限时间内”是指，对于用户的一个操作请求，系统必须能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。另外，”有限的时间内”是指系统设计之初就设计好的运行指标，通常不同系统之间有很大的不同，无论如何，对于用户请求，系统必须存在一个合理的响应时间，否则用户便会对系统感到失望。</p><p>“返回结果”是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出队请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。</p><p>3、分区容错性</p><p>分区容错性约束了一个分布式系统具有如下特性：<strong>分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障</strong>。</p><p>网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络）中，由于一些特殊的原因导致这些子网络出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区。</p><p>既然一个分布式系统无法同时满足一致性、可用性、分区容错性三个特点，所以我们就需要抛弃一样：</p><p><img src="http://images2015.cnblogs.com/blog/801753/201511/801753-20151107213219867-1667011131.png" alt="img"></p><p>用一张表格说明一下：</p><table><thead><tr><th><strong>选    择</strong></th><th><strong>说    明</strong></th></tr></thead><tbody><tr><td>CA</td><td>放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择</td></tr><tr><td>AP</td><td>放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此</td></tr><tr><td>CP</td><td>放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用</td></tr></tbody></table><p>需要明确的一点是，对于一个分布式系统而言，分区容错性是一个最基本的要求。因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统架构师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡。</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。BASE理论的核心思想是：<strong>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</strong>。接下来看一下BASE中的三要素：</p><p><strong>1、基本可用</strong></p><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性—-注意，这绝不等价于系统不可用。比如：</p><p>（1）响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒</p><p>（2）系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面</p><p><strong>2、软状态</strong></p><p>软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</p><p><strong>3、最终一致性</strong></p><p>最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><p>总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，<strong>它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态</strong>。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2018/03/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/03/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="匹配定长的字符"><a href="#匹配定长的字符" class="headerlink" title="匹配定长的字符"></a>匹配定长的字符</h3><p>在正则表达式中,如果直接给出字符,就是精确匹配,</p><p>用<code>\d</code>可以匹配一个数字.</p><p><code>\w</code>可以匹配一个字母或者数字.</p><p><code>.</code>可以匹配任意字符.</p><h3 id="匹配变长的字符"><a href="#匹配变长的字符" class="headerlink" title="匹配变长的字符"></a>匹配变长的字符</h3><p>要匹配变长的字符，在正则表达式中.</p><p>用<code>*</code>表示任意个字符（包括0个）.</p><p>用<code>+</code>表示至少一个字符.</p><p>用<code>?</code>表示0个或1个字符.</p><p>用<code>{n}</code>表示n个字符.</p><p>用<code>{n,m}</code>表示n-m个字符.</p><h4 id="例子-d-3-s-d-3-8"><a href="#例子-d-3-s-d-3-8" class="headerlink" title="例子\d{3}\s+\d{3,8}"></a>例子<code>\d{3}\s+\d{3,8}</code></h4><ol><li><code>\d{3}</code>表示匹配3个数字，例如<code>&#39;010&#39;</code>；</li><li><code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>&#39; &#39;</code>，<code>&#39; &#39;</code>等；</li><li><code>\d{3,8}</code>表示3-8个数字，例如<code>&#39;1234567&#39;</code>。</li></ol><p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p><p>如果要匹配<code>&#39;010-12345&#39;</code>这样的号码呢？由于<code>&#39;-&#39;</code>是特殊字符，在正则表达式中，要用<code>&#39;\&#39;</code>转义，所以，上面的正则是<code>\d{3}\-\d{3,8}</code>。</p><h3 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h3><p>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：</p><ul><li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li><li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>&#39;a100&#39;</code>，<code>&#39;0_Z&#39;</code>，<code>&#39;Py3000&#39;</code>等等；</li><li><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</li><li><code>[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li></ul><p><code>A|B</code>可以匹配A或B，所以<code>(P|p)ython</code>可以匹配<code>&#39;Python&#39;</code>或者<code>&#39;python&#39;</code>。</p><p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p><p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p><p>所以<code>py</code>也可以匹配<code>&#39;python&#39;</code>，但是加上<code>^py$</code>就变成了整行匹配，就只能匹配<code>&#39;py&#39;</code>了。</p><h2 id="Python-中的正则匹配式"><a href="#Python-中的正则匹配式" class="headerlink" title="Python 中的正则匹配式"></a>Python 中的正则匹配式</h2><h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><p>由于Python的字符串本身也用<code>\</code>转义，因此使用Python的<code>r</code>前缀，就不用考虑转义的问题了.下面是一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">r'ABC\-001'</span> <span class="comment"># Python的字符串</span></span><br><span class="line"><span class="comment"># 对应的正则表达式字符串不变：</span></span><br><span class="line"><span class="comment"># 'ABC\-001'</span></span><br></pre></td></tr></table></figure><p><code>match()</code>方法判断是否匹配，如果匹配成功，返回一个<code>Match</code>对象，否则返回<code>None</code>。常见的判断方法就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test = <span class="string">'用户输入的字符串'</span></span><br><span class="line"><span class="keyword">if</span> re.match(<span class="string">r'正则表达式'</span>, test):</span><br><span class="line">    print(<span class="string">'ok'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'failed'</span>)</span><br></pre></td></tr></table></figure><h3 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h3><p>用正则表达式切分字符串比用固定的字符更灵活，下面是正常的切分代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a b   c'</span>.split(<span class="string">' '</span>)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><p>无法识别连续的空格，下面正则表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\s+'</span>, <span class="string">'a b   c'</span>)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><p>无论多少个空格都可以正常分割。加入<code>,</code>试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'[\s\,]+'</span>, <span class="string">'a,b, c  d'</span>)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure><p>再加入<code>;</code>试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'[\s\,\;]+'</span>, <span class="string">'a,b;; c  d'</span>)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="comment"># 上面的正则表示\s,逗号,分号都至少有一个的话都可以当分隔符.</span></span><br></pre></td></tr></table></figure><p>如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是要提取的分组（Group）。比如：</p><p><code>^(\d{3})-(\d{3,8})$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>, <span class="string">'010-12345'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">9</span>), match=<span class="string">'010-12345'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)</span><br><span class="line"><span class="string">'010-12345'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)</span><br><span class="line"><span class="string">'010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)</span><br><span class="line"><span class="string">'12345'</span></span><br></pre></td></tr></table></figure><p>如果正则表达式中定义了组，就可以在<code>Match</code>对象上用<code>group()</code>方法提取出子串来。</p><p>注意到<code>group(0)</code>永远是原始字符串，<code>group(1)</code>、<code>group(2)</code>……表示第1、2、……个子串。</p><p>提取子串非常有用。来看一个更凶残的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="string">'19:05:30'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$'</span>, t)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()</span><br><span class="line">(<span class="string">'19'</span>, <span class="string">'05'</span>, <span class="string">'30'</span>)</span><br></pre></td></tr></table></figure><p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$'</span></span><br></pre></td></tr></table></figure><p>对于<code>&#39;2-30&#39;</code>，<code>&#39;4-31&#39;</code>这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p><h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^(\d+)(0*)$'</span>, <span class="string">'102300'</span>).groups()</span><br><span class="line">(<span class="string">'102300'</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p><p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^(\d+?)(0*)$'</span>, <span class="string">'102300'</span>).groups()</span><br><span class="line">(<span class="string">'1023'</span>, <span class="string">'00'</span>)</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p><ol><li>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</li><li>用编译后的正则表达式去匹配字符串。</li></ol><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 编译:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone = re.compile(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>)</span><br><span class="line"><span class="comment"># 使用：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone.match(<span class="string">'010-12345'</span>).groups()</span><br><span class="line">(<span class="string">'010'</span>, <span class="string">'12345'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone.match(<span class="string">'010-8086'</span>).groups()</span><br><span class="line">(<span class="string">'010'</span>, <span class="string">'8086'</span>)</span><br></pre></td></tr></table></figure><p>编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。</p><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143193331387014ccd1040c814dee8b2164bb4f064cff000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143193331387014ccd1040c814dee8b2164bb4f064cff000</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC的理解</title>
      <link href="/2018/03/19/rpc/"/>
      <url>/2018/03/19/rpc/</url>
      
        <content type="html"><![CDATA[<h2 id="RPC的理解"><a href="#RPC的理解" class="headerlink" title="RPC的理解"></a>RPC的理解</h2><p>由于各服务部署在不同机器，服务间的调用免不了网络通信过程，服务消费方每调用一个服务都要写一坨网络通信相关的代码，不仅复杂而且极易出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloWorldService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    publicStringsayHello(Stringmsg)&#123;</span><br><span class="line">        Stringresult=<span class="string">"helloworld "</span>+msg;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         HelloWorldService helloWorldService = <span class="keyword">new</span> HelloWorldServiceImpl();</span><br><span class="line">         helloWorldService.sayHello(<span class="string">"test"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果有一种方式能让我们像调用本地服务一样调用远程服务，而让调用者对网络通信这些细节透明，那么将大大提高生产力，比如服务消费方在执行helloWorldService.sayHello(“test”)时，实质上调用的是远端的服务。这种方式其实就是RPC（Remote Procedure Call Protocol.</p><p>要让网络通信细节对使用者透明，我们自然需要对通信细节进行封装，我们先看下一个RPC调用的流程：</p><p><img src="/var/folders/ct/h7tl_b_x7b15_v0n1lbm07lm0000gn/T/abnerworks.Typora/image-20180725201551974.png" alt="image-20180725201551974"></p><ul><li>1）服务消费方（client）调用以本地调用方式调用服务；</li><li>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>3）client stub找到服务地址，并将消息发送到服务端；</li><li>4）server stub收到消息后进行解码；</li><li>5）server stub根据解码结果调用本地的服务；</li><li>6）本地服务执行并将结果返回给server stub；</li><li>7）server stub将返回结果打包成消息并发送至消费方；</li><li>8）client stub接收到消息，并进行解码；</li><li>9）服务消费方得到最终结果。</li></ul><p>RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。</p><p>client stub 就是RPC调用中用于转换参数的代码，进行RPC调用的两端都要装相应的RPC函数库，而stub 就是RPC函数库中用于保证数据在两端一致的代码。</p><h4 id="透明化RPC"><a href="#透明化RPC" class="headerlink" title="透明化RPC"></a>透明化RPC</h4><p>怎么封装通信细节才能让用户像以本地调用方式调用远程服务呢？对java来说就是使用代理！java代理有两种方式：1） jdk 动态代理；2）字节码生成。尽管字节码生成方式实现的代理更为强大和高效，但代码不易维护，大部分公司实现RPC框架时还是选择动态代理方式。</p><p>下面简单介绍下动态代理怎么实现我们的需求。我们需要实现RPCProxyClient代理类，代理类的invoke方法中封装了与远端服务通信的细节，消费方首先从RPCProxyClient获得服务提供方的接口，当执行helloWorldService.sayHello(“test”)方法时就会调用<code>invoke</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCProxyClient</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">reflect</span>.<span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RPCProxyClient</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj=obj;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到被代理对象;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> java.lang.reflect.Proxy.newProxyInstance(obj.getClass().getClassLoader(),</span><br><span class="line">                obj.getClass().getInterfaces(), <span class="keyword">new</span> RPCProxyClient(obj));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用此方法执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//结果参数;</span></span><br><span class="line">        Object result = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// ...执行通信相关逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         HelloWorldService helloWorldService = (HelloWorldService)RPCProxyClient.getProxy(HelloWorldService.class);</span><br><span class="line">         helloWorldService.sayHello(<span class="string">"test"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机 举例与JIT</title>
      <link href="/2018/03/07/JVM%E4%B8%BE%E4%BE%8B%E4%B8%8EJIT/"/>
      <url>/2018/03/07/JVM%E4%B8%BE%E4%BE%8B%E4%B8%8EJIT/</url>
      
        <content type="html"><![CDATA[<h2 id="宏观看JVM"><a href="#宏观看JVM" class="headerlink" title="宏观看JVM"></a>宏观看JVM</h2><p>先来看一个简单的Java程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="comment">//.....各种get/set方法/toString</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setName(<span class="string">"person"</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>.java文件通过词法分析器，token流，语法分析器，语法树，语义分析器，注解抽象语法树，字节码生成器等步骤将.java文件变为字节码文件</code></p><h4 id="编译时期—语法糖"><a href="#编译时期—语法糖" class="headerlink" title="编译时期—语法糖"></a>编译时期—语法糖</h4><p>语法糖可以看做是<strong>编译器实现的一些小把戏</strong>,这些小把戏可能会使得效率大提升。</p><p>最值得说明的就是泛型，泛型只会在Java源码中存在，编译过后会被替换为原来的原生类型了，这个过程也被称为泛型擦除。</p><h3 id="JVM-实现跨平台"><a href="#JVM-实现跨平台" class="headerlink" title="JVM 实现跨平台"></a>JVM 实现跨平台</h3><p>.class文件是不能直接运行的，不像C语言(编译cpp后生成的exe是可以直接运行的)</p><p>这些.class文件是要交给JVM来解析运行。</p><h3 id="class文件和JVM"><a href="#class文件和JVM" class="headerlink" title="class文件和JVM"></a>class文件和JVM</h3><p>前面例子中的两个文件都会被直接加载到JVM中吗。并不会</p><p>虚拟机规范则是严格规定了有且只有5种情况必须<strong>立即对类进行“初始化”</strong>(class文件加载到JVM中)：</p><ul><li>创建类的实例(new 的方式)。访问某个类或接口的静态变量，或者对该静态变量赋值，调用类的静态方法</li><li>反射的方式</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类，直接使用java.exe命令来运行某个主类（包含main方法的那个类）</li><li>当使用JDK1.7的动态语言支持时(….)</li></ul><p>所以说</p><p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，<strong>则在需要的时候才加载</strong>。这当然就是为了<strong>节省内存开销</strong>。</p><h4 id="如何将类加载到JVM"><a href="#如何将类加载到JVM" class="headerlink" title="如何将类加载到JVM"></a>如何将类加载到JVM</h4><p>class 文件通过类的加载器装载到jvm中的。</p><p>默认三种类加载器。</p><p>各个加载器的工作责任：</p><ul><li>1）Bootstrap ClassLoader：负责加载$JAVA_HOME中jre/lib/<strong>rt.jar</strong>里所有的class，由C++实现，不是ClassLoader子类</li><li>2）Extension ClassLoader：负责加载java平台中<strong>扩展功能</strong>的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包</li><li>3）App ClassLoader：负责记载<strong>classpath</strong>中指定的jar包及目录中class</li></ul><p><strong>类加载器在成功加载某个类之后，会把得到的java.lang.Class 类的实例缓存起来，下次再请求加载该类加载的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载</strong></p><h4 id="类加载的详细过程"><a href="#类加载的详细过程" class="headerlink" title="类加载的详细过程"></a>类加载的详细过程</h4><p>加载器加载到jvm中，接下来其实又分了<strong>好几个步骤</strong>：</p><ul><li>加载，查找并加载类的二进制数据，在Java堆中也<strong>创建一个java.lang.Class类的对象</strong>。</li><li>连接，连接又包含三块内容：验证、准备、初始化。<ul><li>1）验证，文件格式、元数据、字节码、符号引用验证；</li><li>2）准备，为类的静态变量分配内存，并将其初始化为默认值；</li><li>3）解析，把类中的符号引用转换为直接引用</li></ul></li><li>初始化，为类的静态变量赋予正确的初始值。</li></ul><h4 id="JIT即时编译器"><a href="#JIT即时编译器" class="headerlink" title="JIT即时编译器"></a>JIT即时编译器</h4><p>一般我们想，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，解析器解析。</p><p>实际上。JVM会把字节码重新编译优化，生成机器码，让CPU直接执行，这样编出来的代码效率会更高。编译也是要花时间的，JVM一般会对热点代码做编译，非热点代码直接解析就好了。</p><blockquote><p>热点代码就是1 多次调用的方法 2 多次执行的循环体</p></blockquote><p>使用热点探测来检测是否为热点代码，热点探测有两种方式：采样和计数器</p><p>目前HotSpot使用的是<strong>计数器的方式</strong>，它为每个方法准备了两类计数器：</p><ul><li>方法调用计数器（Invocation  Counter）</li><li>回边计数器（Back  EdgeCounter）。</li><li>在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，<strong>当计数器超过阈值溢出了，就会触发JIT编译</strong>。</li></ul><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-14%20%E4%B8%8A%E5%8D%8812.00.10.png" alt=""></p><h4 id="回到例子"><a href="#回到例子" class="headerlink" title="回到例子"></a>回到例子</h4><p>按我们程序来走，我们的PersonTest.class 文件会被AppClassLoader加载器加载到JVM中。随后发现了要使用Peron这个类，所以Person.class 文件会被APPClassLoader加载器加载到JVM中。</p><h3 id="类加载完该干什么"><a href="#类加载完该干什么" class="headerlink" title="类加载完该干什么"></a>类加载完该干什么</h3><h4 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h4><p>堆：<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存</p><p>虚拟机栈：虚拟机栈描述的是<strong>Java方法执行的内存模型</strong>：每个方法被执行的时候都会同时创建一个<strong>栈帧</strong>（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息</p><p>本地方法栈：本地方法栈则是为虚拟机使用到的<strong>Native方法服务</strong>。</p><p>方法区：存储已<strong>被虚拟机加载的类元数据信息</strong>(元空间)</p><p>程序计数器：当前线程所执行的字节码的<strong>行号指示器</strong></p><h4 id="例子中的流程"><a href="#例子中的流程" class="headerlink" title="例子中的流程"></a>例子中的流程</h4><p>1、通过<code>java.exe</code>运行<code>PersonTest.class</code>，随后被加载到JVM中，<strong>元空间存储着类的信息</strong>(包括类的名称、方法信息、字段信息..)。</p><p>2、然后JVM找到PersonTest的主函数入口(main)，为main函数创建栈帧，开始执行main函数</p><p>3、main函数的第一条命令是<code>Person person = new Person();</code>就是让JVM创建一个Person对象，但是这时候方法区中没有Person类的信息，所以JVM马上加载PErson类，把Person类的类型信息放到方法区中(元空间)</p><p>4、加载完Person类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的Person实例分配内存, 然后调用构造函数初始化Person实例，这个<strong>Person实例持有着指向方法区的Person类的类型信息</strong>（其中包含有方法表，java动态绑定的底层实现）的引用</p><p>5、当使用<code>person.setName(&quot;Person&quot;);</code>的时候，JVM<strong>根据person引用找到Person对象</strong>，然后根据Person对象持有的引用定位到方法区中Person类的类型信息的<strong>方法表</strong>，获得<code>setName()</code>函数的字节码的地址</p><p>6、为<code>setName()</code>函数创建栈帧，开始运行<code>setName()</code>函数</p><h2 id="JVM之JIT"><a href="#JVM之JIT" class="headerlink" title="JVM之JIT"></a>JVM之JIT</h2><h4 id="just-in-time"><a href="#just-in-time" class="headerlink" title="just in time"></a>just in time</h4><p>just in time 编译，也叫做运行时编译，不同于C/C++语言直接被翻译成机器指令，Java把Java的源文件翻译成了class文件，而class文件中全都是Java字节码，那么，JVM在加载了这些class文件之后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。</p><p>还有一种，就是把这些Java字节码重新编译优化，生成机器码，让CPU直接执行，这样编出来额代码效率会更高，通常，我们不必把所有的Java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码，这种调用最频繁的Java方法就是常说的热点方法。</p><p>这种在运行时按需编译的方式就是just in time</p><h4 id="主要技术点"><a href="#主要技术点" class="headerlink" title="主要技术点"></a>主要技术点</h4><p>JIT的主要技术点，从大的框架来说，非常简单，就是申请一块既有写权限，又有执行权限的内存，然后把你要编译的Java方法，翻译成机器码，写到这块内存里，当再需要调用原来的Java方法时，就转向调用这块内存。</p><h4 id="HotSpot-编译"><a href="#HotSpot-编译" class="headerlink" title="HotSpot 编译"></a>HotSpot 编译</h4><p>当JVM执行代码时，它并不立即开始编译代码，主要有两个原因：</p><p>首先，如果这段代码本身在将来只会被执行一次，那么从本质上来看，编译就是在浪费精力，因为直接解释执行相对于编译这段代码并执行代码来说，要快很多。</p><p>当然，如果一段代码频繁的调用方法，或者是一个循环，也就是这段代码被执行多次，那么编译就非常值得了，Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能，所以当字节码被 JIT 编译为机器码的时候，要说它是编译执行的也可以。也就是说，运行时，部分代码可能由 JIT 翻译为目标机器指令（以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行。</p><p>第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 运行和编译的过程</title>
      <link href="/2018/03/03/Java%20%E8%BF%90%E8%A1%8C%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/03/03/Java%20%E8%BF%90%E8%A1%8C%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-运行和编译的过程"><a href="#Java-运行和编译的过程" class="headerlink" title="Java 运行和编译的过程"></a>Java 运行和编译的过程</h2><p>Java程序从源文件创建到程序运行要经过两大步骤：1、源文件由编译器编译成字节码（ByteCode）（编译）  2、字节码由java虚拟机解释运行。（运行）因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言（ “semi-interpreted” language）。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>通过以下这个java程序，来说明java程序从编译到最后运行的整个流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainApp.java  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal(<span class="string">"Cat"</span>);  </span><br><span class="line">        animal.printName();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//Animal.java  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> String name;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Animal:"</span>+name);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>编译</p><p>创建完源文件之后，程序会先被编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用。编译后的字节码文件格式主要分为两部分：<strong>常量池</strong>和<strong>方法字节码</strong>。常量池记录的是代码出现过的所有token(类名，成员变量名等等)以及符号引用（方法引用，成员变量引用等等）；方法字节码放的是类中各个方法的字节码。</p></li><li><p>运行</p></li></ul><p>java类运行的过程大概可分为两个过程：1、类的加载  2、类的执行。需要说明的是：<strong>JVM主要在程序第一次主动使用类的时候，才会去加载该类</strong> 。也就是说，JVM并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。</p><pre><code>下面是程序运行期的详细步骤：</code></pre><ol><li>在编译好java程序得到MainApp.class文件后，在命令行上敲java AppMain。系统就会启动一个jvm进程，jvm进程从classpath路径中找到一个名为AppMain.class的二进制文件，将MainApp的类信息加载到运行时数据区的方法区内，这个过程叫做MainApp类的加载。</li><li>然后JVM找到AppMain的主函数入口，开始执行main函数。</li><li>main函数的第一条命令是Animal  animal = new Animal(“Cat”);就是让JVM创建一个Animal对象，但是这时候方法区中没有Animal类的信息，所以JVM马上加载Animal类，把Animal类的类型信息放到方法区中。<strong>（new的时候才会加载）</strong></li><li>加载完Animal类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的Animal实例分配内存, 然后调用构造函数初始化Animal实例，这个Animal实例持有着指向方法区的Animal类的类型信息（其中包含有方法表，java动态绑定的底层实现）的引用。</li><li>当使用animal.printName()的时候，JVM根据animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息的方法表，获得printName()函数的字节码的地址。</li><li>开始运行printName()函数。</li></ol><h4 id="类加载简述"><a href="#类加载简述" class="headerlink" title="类加载简述"></a>类加载简述</h4><ul><li>(1) 装载：查找和导入Class文件；</li></ul><ul><li>(2) 链接：把类的二进制数据合并到JRE中；<ul><li>(a)校验：检查载入Class文件数据的正确性；</li><li>(b)准备：给类的静态变量分配存储空间；</li><li>(c)解析：将符号引用转成直接引用；</li></ul></li><li>(3) 初始化：对类的静态变量，静态代码块执行初始化操作</li></ul><p><strong>Java程序可以动态扩展是由运行期动态加载和动态链接实现的；比如：如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现(多态)，解析过程有时候还可以在初始化之后执行；比如：动态绑定(多态)。运行时动态加载需要加载的对象（反射）</strong></p><blockquote><p><a href="https://www.cnblogs.com/qiumingcheng/p/5398610.html" target="_blank" rel="noopener">https://www.cnblogs.com/qiumingcheng/p/5398610.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用架构演进</title>
      <link href="/2018/02/28/%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/"/>
      <url>/2018/02/28/%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="应用架构演进"><a href="#应用架构演进" class="headerlink" title="应用架构演进"></a>应用架构演进</h2><h4 id="传统垂直应用架构"><a href="#传统垂直应用架构" class="headerlink" title="传统垂直应用架构"></a>传统垂直应用架构</h4><p>06年前，比较流行的有LAMP架构，MVC架构(Spring，Struts，Hibernate)，厚重的EJB企业架构也流行了很长一段时间。他们都属于垂直应用架构，技术比较单一，学习成本低，开发上手快，因此很长一段时间都处于统治地位。</p><p>举例说明MVC的垂直架构的示意图如下所示：</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180228201842.png" alt=""></p><p>通常MVC架构的应用代码会统一打包成一个war包，部署在Tomcat等web容器中。不同的应用功能之间通过本地API进行调用，基本不存在跨进程的远程服务调用。</p><p>但是，垂直架构的缺点十分突出，主要表现在复杂应用的维护成本高，部署效率逐渐的降低，团队协作效率差，部分公共功能重复开发，代码重复率居高不下，系统可靠性不断的变差，新功能上线的周期越来越长。</p><h4 id="RPC-架构"><a href="#RPC-架构" class="headerlink" title="RPC 架构"></a>RPC 架构</h4><p>RPC全称Remote Procedure Call,是一种进程间的通信方式，允许像调用本地服务一样调用远程服务，它的具体实现方式可以不同，例如Spring 的HTTP Invoker,Facebook 的Thrift 二进制私有协议通信。</p><p>06年后，随着移动互联网的发展，远程分布式调用已经成为主流，RPC框架也犹如雨后春笋。RPC框架的普及标志着传统垂直应用架构时代的终结。</p><h5 id="RPC-框架原理"><a href="#RPC-框架原理" class="headerlink" title="RPC 框架原理"></a>RPC 框架原理</h5><p>RPC 框架的目标就是让远程过程调用更加简单，透明，RPC框架负责屏蔽底层的传输方式(TCP 或UDP), 序列化方式(XML,JSON,二进制)和通信细节。框架的使用者只需要知道了解谁在什么位置提供了什么样的远程服务接口即可，开发者不需要关心底层通信细节和调用过程。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180228203828.png" alt=""></p><p>RPC 框架实现的技术核心点有</p><ul><li>远程服务提供者需要以某种形式提供服务调用相关的信息，包括但是不限于服务接口定义，数据结构，或者中间态的服务定义文件。</li><li>远程代理对象：服务调用者调用的服务实际上是远程服务的本地代理，对于Java语言来说，它的实现就是JDK的动态代理，通过动态代理的拦截机制，将本地调用封装成远程服务调用。</li><li>通信：RPC框架与具体的协议无关，</li><li>序列化：远程通信，需要将对象转化为二进制码流进行网络传输，不同的序列化框架，支持的数据类型，数据包大小，异常类型，性能等都不同。一般好的框架都支持多种序列化方式。</li></ul><p>业界主流的RPC框架有Facebook的Thrift,Google的gRPC等。</p><h5 id="RPC框架的挑战"><a href="#RPC框架的挑战" class="headerlink" title="RPC框架的挑战"></a>RPC框架的挑战</h5><p>在大规模服务化之前，应用可能只是通过RPC框架，简单的暴露和引用远程服务，通过配置简单的URL地址进行远程服务调用，当服务越来越多时，服务URL配置管理越来越困难，    硬件负载均衡器的单点压力也越来越大，此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。</p><p>随着业务的发展，服务间的依赖错综复杂，甚至分不清哪个应用需要在哪个应用之前启动，同时，服务的调用量越来越大，服务的容量问题也就暴露出来了。服务上线容易下线难，上线前的审批，下线通知，需要统一的服务生命周期管理泪流成进行管控，不同的服务安全权限不同，如何保证敏感服务不被误调用。服务化之后，服务治理问题，单凭RPC框架是无法解决的。</p><h4 id="SOA-面向服务的架构-可以说RPC是SOA架构的一种实现"><a href="#SOA-面向服务的架构-可以说RPC是SOA架构的一种实现" class="headerlink" title="SOA 面向服务的架构(可以说RPC是SOA架构的一种实现)"></a>SOA 面向服务的架构(可以说RPC是SOA架构的一种实现)</h4><p>SOA 是一种粗粒度，松耦合的以服务为中心的架构，接口之间通过明确的协议和接口进行通信。SOA帮助工程师们站在一个新的高度理解企业级架构中各种组件的开发和部署形式。相对于传统的非服务化架构，SOA能够更加从容的应对复杂企业系统集成和需求的快速变化。</p><p>它的设计原则主要有服务可复用，服务共享一个标准契约，服务是松耦合的，服务是底层逻辑的抽象，服务是可组合的，可编排的，服务是无状态的。所以SOA服务治理是关键。</p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构（MSA）是一种服务化架构风格，通过将功能分散到各个分散的服务中以实现对解决方案的解耦。</p><p>主要特征有，原子服务，专注于做一件事，高密度部署(重要的服务可以独立进程部署)，敏捷交付，微自治(服务足够小，功能单一，可以独立打包，部署，升级)</p><h3 id="微服务对比SOA"><a href="#微服务对比SOA" class="headerlink" title="微服务对比SOA"></a>微服务对比SOA</h3><ul><li>服务拆分粒度：SOA首先要解决的就是异构应用的服务化，微服务强调的是独舞拆分要尽可能的小，最好是独立的原子服务</li><li>服务依赖：传统的SOA服务，由于需要重用已有的资产，存在大量的服务间依赖：微服务的设计理念是服务自治，功能单一独立，，避免依赖其他服务产生耦合，耦合会带来更高的复杂度。</li><li>服务规模：传统的SOA服务粒度较大，多数会采用将多个服务合并打成war包的方案，因此服务实例数比较有限，微服务强调尽可能的拆分，同时，很多服务会独立部署，这也会导致服务规模急剧增加，对服务治理和运维带来新挑战。</li><li>架构差异 微服务化后，服务数量的激增会引起架构质量属性的变化，例如企业集成总线ESB逐渐被P2P虚拟总线替换，为了保证高性能，低时延，需要高性能的分布式服务框架保证微服务架构的实施。</li></ul><p>用一张图概括服务化架构演进图如下：</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180228215337.png" alt=""></p><p>(RPC算是SOA的一种简单实现)</p><blockquote><p>分布式服务框架原理与实践</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机字节码执行引擎</title>
      <link href="/2018/02/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
      <url>/2018/02/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>虚拟机的执行引擎由自己事先，所以可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。</p><p>在不同的虚拟机事先中，执行引擎在执行Java代码的时候可能会产生解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择，也可能两种兼备。但是从外观看来，大家都是一样的，输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</p><h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p>栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构,它是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程,都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p><p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候,栈帧中需要多大的局部变量表,多深的操作数栈都已经完全确定了,并且写入到方法表的Code属性之中 ,因此一个栈帧需要分配多少内存,不会受到程序运行期变量数据的影响,而仅仅取决于具体的虚拟机实现。</p><p>一个线程中的方法调用链可能会很长,很多方法都同时处于执行状态。对于执行引擎来说,在活动线程中,只有位于栈顶的栈帧才是有效的,称为当前栈帧(Current Stack Frame),与这个栈帧相关联的方法称为当前方法(Current Method)。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。</p><ul><li>局部变量表</li></ul><p>局部变量表(Local Variable Table)是一组变量值存储空间,用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时,就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。局部变量表建立在线程的堆栈上，时线程私有的数据。</p><ul><li>操作数栈</li></ul><p>操作数栈也常称为操作栈，同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型.</p><p>当一个方法刚刚开始执行的时候,这个方法的操作数栈是空的,在方法的执行过程中,会有各种字节码指令往操作数栈中写入和提取内容,也就是出栈/入栈操作。例如,在做算术运算的时候是通过操作数栈来进行的,又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。</p><ul><li>动态连接</li></ul><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用,持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。Class文件的常量池中存有大量的符号引用,字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用,这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用,这部分称为动态连接。</p><ul><li>方法返回地址</li></ul><p>当一个方法开始执行后,只有两种方式可以退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令,这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为调用者),是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定,这种退出方法的方式称为正常完成出口。<br>另外一种退出方式是,在方法执行过程中遇到了异常,并且这个异常没有在方法体内得到处理,无论是Java虚拟机内部产生的异常,还是代码中使用athrow字节码指令产生的异常,只要在本方法的异常表中没有搜索到匹配的异常处理器,就会导致方法退出,这种退出方法的方式称为异常完成出口。一个方法使用异常完成出口的方式退出,是不会给它的上层调用者产生任何返回值的。<br>无论采用何种退出方式,在方法退出之后,都需要返回到方法被调用的位置,程序才能继续执行,方法返回时可能需要在栈帧中保存一些信息,用来帮助恢复它的上层方法的执行状态。一般来说,方法正常退出时,调用者的PC计数器的值可以作为返回地址,栈帧中很可能会保存这个计数器值。而方法异常退出时,返回地址是要通过异常处理器表来确定的,栈帧中一般不会保存这部分信息。</p><ul><li>附加信息</li></ul><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中,例如与调试相关的信息,这部分信息完全取决于具体的虚拟机实现,这里不再详述。在实际开发中,一般会把动态连接、方法返回地址与其他附加信息全部归为一类,称为栈帧信息。</p><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p><strong>方法调用并不等同于方法执行,方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法),暂时还不涉及方法内部的具体运行过程。在程序运行时,进行方法调用是最普遍、最频繁的操作,但前面已经讲过,Class文件的编译过程中不包含传统编译中的连接步骤,一切方法调用在Class文件里面存储的都只是符号引用,而不是方法在实际运行时内存布局中的入口地址(相当于之前说的直接引用)。这个特性给Java带来了更强大的动态扩展能力,但也使得Java方法调用过程变得相对复杂起来,需要在类加载期间,甚至到运行期间才能确定目标方法的直接引用。</strong></p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用。在类加载的解析阶段，会将其中一部分符号引用转化为直接引用，这种解析能成立的前提是方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。这类方法的调用称为解析。</p><p><strong>在Java中，符合编译期可知，运行期不可变这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，他们都适合在类加载阶段进行解析。</strong></p><p>解析调用一定是一个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用。不会延迟到运行期再去完成。</p><h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><p>静态分派</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man =<span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure><p> Human 称为变量的静态类型，Man称为变量的实际类型，静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是装载编译期可知的，而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p><p>在重载中，编译器的重载是通过参数的静态类型而不是实际类型作为判定依据的。而静态类型在编译期是可知的，所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，典型应用就是重载。</p><p>动态分派</p><p>动态分派与重写有密切关联。</p><h4 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h4><p><strong>动态语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期。比如,js,php,python,ruby,lua，相对的，在编译期就进行类型检查过程的语言就是最常用的静态类型语言。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer56*数组中只出现一次的两个数字</title>
      <link href="/2018/02/13/JZoffer56/"/>
      <url>/2018/02/13/JZoffer56/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(data.size()&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> myxor=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            myxor =myxor^data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((myxor &amp; flag) == <span class="number">0</span>) flag &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); ++ i )&#123;</span><br><span class="line">            <span class="keyword">if</span>((flag &amp; data[i]) == <span class="number">0</span>) *num2 ^= data[i];</span><br><span class="line">            <span class="keyword">else</span> *num1 ^= data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>经典的位运算题目。首先把所有数字异或起来，两个相同的数字异或等于0，所以最终的结果是两个只有一个的数字异或得到的结果。然后，不断的移位找到第一个为1的位置（在这个位置上，两个只有1个的数是不相同的），然后重新遍历数组根据这一位来遍历，分成两个数组，然后每个数组之间异或，得到的就是两个数字。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer54 二叉搜索树的第K大节点</title>
      <link href="/2018/02/12/JZoffer54/"/>
      <url>/2018/02/12/JZoffer54/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个二叉搜索树，请找出第k大的节点。（leetcode230）</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Kth</span><span class="params">(TreeNode* pRoot,<span class="keyword">int</span>&amp; target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode* t=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left)  t=Kth(pRoot-&gt;left,target);</span><br><span class="line">        target--;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            t =pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">NULL</span> &amp;&amp; pRoot-&gt;right) t =Kth(pRoot-&gt;right,target);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>||k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            TreeNode* node = Kth(pRoot,k);</span><br><span class="line">            <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>一道递归题，在参数传递的问题上想了很久，也试了很久，</p><p>因为要在递归中传递要得到的节点，所以在递归开始先设置一个空指针，经过运算，最后返回这个指针。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer46 把数字翻译成字符串</title>
      <link href="/2018/02/12/JZoffer46/"/>
      <url>/2018/02/12/JZoffer46/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个数字，按照如下规则把他翻译成字符串，0翻译成a,1翻译成b,……….11 翻译成l，25翻译成z,这样一个数字可能有多种翻译方式，请计算一个数字有多少种翻译的方法。</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> numberstring =to_string(number);</span><br><span class="line">    <span class="keyword">int</span> mysize =numberstring.size();</span><br><span class="line">    <span class="keyword">int</span>* dp = <span class="keyword">new</span> <span class="keyword">int</span>[mysize];</span><br><span class="line">    dp[mysize]=<span class="number">0</span>;</span><br><span class="line">    dp[mysize<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> g =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mysize<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> digit1 = numberstring[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> digit2 = numberstring[i+<span class="number">1</span>]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> covered =digit1*<span class="number">10</span>+digit2;</span><br><span class="line">        <span class="keyword">if</span>(covered&gt;=<span class="number">10</span>&amp;&amp;covered&lt;=<span class="number">25</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> g =<span class="number">0</span>;</span><br><span class="line">        dp[i]= dp[i+<span class="number">1</span>]+g*dp[i+<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>一道简单的动态规划题，从前往后算会算很多重复的数字，所以选择从后往前算避免重复的数字，</p><p>自下而上，动态规划，从最小的问题开始 ：<br>f(r)表示以r为开始（r最小取0）到最右端所组成的数字能够翻译成字符串的种数。对于长度为n的数字，f(n)=0,f(n-1)=1,求f(0)。<br>递推公式为 f(r-2) = f(r-1)+g(r-2,r-1)*f(r)；<br>其中，如果r-2，r-1能够翻译成字符，则g(r-2,r-1)=1，否则为0。<br>因此，对于12258：<br>f(5) = 0<br>f(4) = 1<br>f(3) = f(4)+0 = 1<br>f(2) = f(3)+f(4) = 2<br>f(1) = f(2)+f(3) = 3<br>f(0) = f(1)+f(2) = 5</p><p>对于12258 ，其中的258 来说，到2的时候，<code>f(2)</code> 有<code>25+8(即 1 * f(4) )</code> 和<code>2 +58(即 f(3) )</code>.</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer*43 1-n整数中1出现的次数</title>
      <link href="/2018/02/11/JZoffer43/"/>
      <url>/2018/02/11/JZoffer43/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i=i*<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a =n/i;</span><br><span class="line">            b =n%i;</span><br><span class="line">            result = result + (a+<span class="number">8</span>)/<span class="number">10</span>*i + (a % <span class="number">10</span>==<span class="number">1</span>)*(b+<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="comment">//(a % 10==1)*(b+1)是某位为1时计算后缀时用。其他情况都为0.</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>感觉很难想的一道题，觉得有点绕。</p><p>参考了leetcode上相同题的解法。整体思路是把每一位中1的个数加起来就是最终的个数。</p><p>通过使用一个 位置乘子i 遍历数字的位置, i 分别为1,10,100,1000…etc.（i&lt;=n）</p><p>以3141592为例，先把这个数字分成两个部分，比如当i=1的时候，就是a=3141592,b=无，以此来分析个位数的1的个数，当i=1时，看n的最后一位为2，2是大于1的，所以有314160（314159+1）个数【还有一种情况就是最后一位是0或者1，就只有314159个数了，所以代码中的+8就是为了判断是否大于1】</p><p>当i=100的时候，a=31415,b=92, 因为5是大于1的，所以有3142*100个数。（100是100-199共100个数）。</p><p>比较特殊的是遍历位为1的时候，i=1000,a =3141, b=592, 因为是1&lt;2，所以前面首先有 314*1000个数（1000-1999）然后要把 计算后缀</p><p>即<code>（n/i%10==1）</code>判断第i位是否为1，若为1，则加上（b+1），若不为1，则只计算前缀。（若计算2的个数，可以改为<code>（n/m%10==2）*(b+1)</code>，若计算3的个数，可以改为<code>（n/m%10==3）*(b+1)</code>…以此类推</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机类加载机制</title>
      <link href="/2018/02/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/02/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用，虚拟机如何加载这些class文件呢？</p><p>Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知class的结构信息：如构造函数，树形和方法等。</p><p>虚拟机把<strong>描述类的数据</strong>从class文件<strong>加载到内存</strong>，<strong>并对数据进行校验</strong>、 <strong>转换解析和初始化</strong>， 最终形成可以被虚拟机直接使用的Java类型， 这就是虚拟机的类加载机制。</p><p>在Java语言里面， 类型的加载、 连接和初始化过程都是在程序运行期间完成的， 这种策略虽然会令类加载时稍微增加一些性能开销， 但是会为Java应用程序提供高度的灵活性， <strong>Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的</strong> 。 例如， 如果编写一个面向接口的应用程序， 可以等到运行时再指定其实际的实现类。</p><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>类从被加载到虚拟机内存中开始， 到卸载出内存为止， 它的整个生命周期包括： 加载（Loading）、 验证（Verification） 、 准备（Preparation） 、 解析（Resolution） 、 初始化（Initialization） 、 使用（Using） 和卸载（Unloading） 7个阶段。 其中验证、 准备、 解析3个部分统称为连接。</p><p> <img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180211111459.png" alt=""></p><p>加载、 验证、 准备、 初始化和卸载这5个阶段的顺序是确定的， 类的加载过程必须按照这种顺序按部就班地开始， 而解析阶段则不一定： 它在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定） 。 </p><p>虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化” （而加载、 验证、 准备自然需要在此之前开始）:</p><p>1） 遇到new、 getstatic、 putstatic或invokestatic这4条字节码指令时， 如果类没有进行过初始化，则需要先触发其初始化。 生成这4条指令的最常见的Java代码场景是： 使用new关键字实例化对象的时候、 读取或设置一个类的静态字段（被final修饰、 已在编译期把结果放入常量池的静态字段除外） 的时候， 以及调用一个类的静态方法的时候。<br>2） 使用java.lang.reflect包的方法对类进行反射调用的时候， 如果类没有进行过初始化， 则需要先触发其初始化。<br>3） 当初始化一个类的时候， 如果发现其父类还没有进行过初始化， 则需要先触发其父类的初始化。<br>4） 当虚拟机启动时， 用户需要指定一个要执行的主类（包含main（） 方法的那个类） ， 虚拟机会先初始化这个主类。<br>5） 当使用JDK 1.7的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、 REF_putStatic、 REF_invokeStatic的方法句柄， 并且这个方法句柄所对应的类没有进行过初始化， 则需要先触发其初始化。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>“加载” 是“类加载” （Class Loading） 过程的一个阶段， 在加载阶段， 虚拟机需要完成以下3件事情：1通过一个类的全限定名来获取定义此类的二进制字节流。2将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。3在内存中生成一个代表这个类的java.lang.Class对象， 作为方法区这个类的各种数据的访问入口。</p><p>获取二进制字节流有许多种方法，从ZIP包中读取， 这很常见， 最终成为日后JAR、 EAR、 WAR格式的基础。从网络中获取， 这种场景最典型的应用就是Applet。运行时计算生成， 这种场景使用得最多的就是动态代理技术。等等</p><p>相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确的说是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。</p><p>加载阶段完成后， 虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中， 方法区中的数据存储格式由虚拟机实现自行定义， 虚拟机规范未规定此区域的具体数据结构。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步， 这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求， 并且不会危害虚拟机自身的安全。主要有文件格式验证，元数据验证，字节码验证，符号引用验证。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式<strong>为类变量分配内存并设置类变量初始值</strong>的阶段， 这些变量所使用的内存都将在方法区中进行分配。 这个阶段中有两个容易产生混淆的概念需要强调一下， 首先， 这时候进行内存分配的仅包括类变量（被static修饰的变量） ， 而不包括实例变量， 实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次， 这里所说的初始值“通常情况” 下是数据类型的零值。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，</p><p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。因此符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p><p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能够间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</p><p>因为在编译时并不知道引用类的实际内存地址，因此只能用符号引用代替。直接引用就是实际的内存地址。</p><p>解析动作主要针对类或接口，字段，类方法，接口方法，方法类型，方法句柄，和调用点限定符7类符号引用进行。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类初始化阶段是类加载过程的最后一步， 前面的类加载过程中， 除了在加载阶段用户应用程序可以通过自定义类加载器参与之外， 其余动作完全由虚拟机主导和控制。 到了初始化阶段， 才真正开始执行类中定义的Java程序代码（或者说是字节码） 。<br>在准备阶段， 变量已经赋过一次系统要求的初始值， 而在初始化阶段， 则根据程序员通过程序制定的主观计划去初始化类变量和其他资源， 或者可以从另外一个角度来表达： 初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code> 方法的过程。 </p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流” 这个动作放到Java虚拟机外部去实现， 以便让应用程序自己决定如何去获取所需要的类。<strong> 实现这个动作的代码模块称为</strong>“类加载器“**</p><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作， 但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类， 都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性， 每一个类加载器， 都拥有一个独立的类名称空间。 这句话可以表达得更通俗一些： 比较两个类是否“相等” ， 只有在这两个类是由同一个类加载器加载的前提下才有意义， 否则， 即使这两个类来源于同一个Class文件， 被同一个虚拟机加载， 只要加载它们的类加载器不同， 那这两个类就必定不相等。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>从Java虚拟机的角度来讲， 只存在两种不同的类加载器： 一种是启动类加载器（Bootstrap ClassLoader） ，这个类加载器使用C++语言实现， 是虚拟机自身的一部分； 另一种就是所有其他的类加载器， 这些类加载器都由Java语言实现， 独立于虚拟机外部， 并且全都继承自抽象类java.lang.ClassLoader。</p><p>从开发人员的角度看，类加载器还可以划分成以下三种系统提供的类加载器。</p><ul><li>启动器加载器，这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的， 并且是虚拟机识别的（仅按照文件名识别， 如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载） 类库加载到虚拟机内存中。 </li><li>扩展类加载器 这个加载器由sun.misc.Launcher $ExtClassLoader实现， 它负责加载＜JAVA_HOME＞\lib\ext目录中的， 或者被java.ext.dirs系统变量所指定的路径中的所有类库， 开发者可以直接使用扩展类加载器。</li><li>应用程序加载器 这个类加载器由sun.misc.Launcher $App-ClassLoader实现。 由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值， 所以一般也称它为系统类加载器。 它负责加载用户类路径（ClassPath） 上所指定的类库， 开发者可以直接使用这个类加载器， 如果应用程序中没有自定义过自己的类加载器， 一般情况下这个就是程序中默认的类加载器。</li></ul><p>应用程序由这三种类加载器互相配合进行加载，如果有必要，还可以加入自己定义的类加载器。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180211163304.png" alt=""></p><p>上图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型，双亲委派模型要求除了顶层的启动类加载器外， 其余的类加载器都应当有自己的父类加载器。 这里类加载器之间的父子关系一般不会以继承（Inheritance） 的关系来实现， 而是都使用<strong>组合（Composition)</strong>关系来复用父加载器的代码。</p><p>它并不是一个强制性的约束模型， 而是Java设计者推荐给开发者的一种类加载器实现方式。</p><p>双亲委派模型的工作过程是： 如果一个类加载器收到了类加载的请求， 它首先不会自己去尝试加载这个类， 而是把这个请求委派给父类加载器去完成， 每一个层次的类加载器都是如此， 因此所有的加载请求最终都应该传送到顶层的启动类加载器中， 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时， 子加载器才会尝试自己去加载。</p><p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，例如类Java.lang.Object ,它存放在rt.jar上，无论哪一个类加载器都要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机类文件结构概述</title>
      <link href="/2018/02/10/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2018/02/10/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>由于虚拟机的快速发展，编写的程序编译成二进制本地机器码已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的，平台中立的格式作为程序编译后的存储格式。</p><h3 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h3><p>Java中与平台无关的理想最终实现在操作系统的应用层上，SUN公司和其他厂商发布了许多可以运行在不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现程序一次编写，到处运行。</p><p>Java虚拟机不和包括Java在内的任何语言绑定，它<strong>只与class文件这种特定的二进制文件格式所关联</strong>。Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑， Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束， 但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。 作为一个通用的、 机器无关的执行平台， 任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。 例如， 使用Java编译器可以把Java代码编译为存储字节码的Class文件， 使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件， 虚拟机并不关心Class的来源是何种语言。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180209101117.png" alt=""></p><h3 id="class-类文件的结构（字节码文件的结构）"><a href="#class-类文件的结构（字节码文件的结构）" class="headerlink" title="class 类文件的结构（字节码文件的结构）"></a>class 类文件的结构（字节码文件的结构）</h3><p>任何一个Class文件都对应着唯一一个类或接口的定义信息，但是反过来说，类或接口不一定都得定义在文件里，（例如类或接口也可以直接通过类加载器直接生成）</p><p>Class文件是一组以8位字节为基础单位的二进制流。各个数据项目按顺序紧凑排列在Class文件中。中间没有添加任何分隔符。当遇到大于8位字节的数据项时，会按照高位在前的方式分割成若干个8位字节进行存储。</p><p>Class文件采用一种类似于C语言结构体的伪结构来存储数据。这种伪结构只有两种数据类型，<strong>无符号数和表</strong>。无符号数属于基本的数据类型，以u1,u2,u4,u8 来分别代表1个字节，2个字节，4个字节，和8个字节的无符号数。无符号数可以用来描述数字，索引引用，数量值或者按照UTF8编码构成字符串值。 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性的以<code>_info</code>结尾。表用于描述有层次关系的复合结构的数据，整个class文件本质上就是一张表。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180209102348.png" alt=""></p><p>无论是无符号数还是表，当需要描述同一类型但是数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的结合。</p><h4 id="详细分析字节码文件"><a href="#详细分析字节码文件" class="headerlink" title="详细分析字节码文件"></a>详细分析字节码文件</h4><p>把字节码文件用二进制方式打开，然后根据虚拟机的规范可以确定对应的字段什么意思，具体分析如下：</p><h5 id="魔数与class文件的版本"><a href="#魔数与class文件的版本" class="headerlink" title="魔数与class文件的版本"></a>魔数与class文件的版本</h5><p>每个class文件的头4个字节成为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。紧跟着魔数的4个字节存储的是class文件的版本号，第5，6字节是次版本号，7，8 字节是主版本号。</p><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>紧跟着主次版本号的是常量池入口，常量池可以理解为Class文件之中的资源仓库。它是class文件结构中与其他项目关联最多的数据类型，也是占空间最大的项目之一。</p><p>因为常量池中常量数量不固定，所以常量池的入口需要放置一项u2类型的数据。代表常量池容量计数值。容量计数是从1开始的。</p><p>常量池中主要存放两大类常量，<strong>字面量和符号引用</strong>，字面量比较接近于Java语言层面的常量概念，如文本字符串，声明为final的常量值等，符号引用（编译原理方面的概念）则主要包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。 </p><p><strong>Java代码在进行Javac编译的时候，没有连接的步骤，而是在虚拟机加载Class文件的时候进行动态连接，也就是说，在Class文件中不会保存各个方法和字段的最终内存布局，因此这些字段，方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析，翻译到具体的内存地址中。</strong></p><p>常量池中每一项常量都是一个表，一共有14种类型的常量，每种常量都有它自己的结构，根绝它的结构把二进制的字节码往后一直翻译成对应的人可以看懂的字节码文件就好了。</p><h5 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h5><p>常量池结束后，紧接着的两个字节代表访问标志，用于识别一些类或者接口层次的访问信息。包括了这个Class 是类还是接口，是否定义为public 类型，是否定位为abstract 类型，如果是类的话，是否被声明为final等。</p><h5 id="类索引，父类索引与接口索引集合"><a href="#类索引，父类索引与接口索引集合" class="headerlink" title="类索引，父类索引与接口索引集合"></a>类索引，父类索引与接口索引集合</h5><p>类索引与父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合。class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。对于接口索引集合，入口的第一项是一个u2类型的接口计数器表示数量。例如类索引的u2值是0x0001,就标识类的名字就是常量池中index=1的常量名。</p><h5 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h5><p>字段表用于描述接口或者类中声明的变量，包括类级变量以及实例级变量，但是不包括方法内部声明的局部变量。一个变量需要有好多修饰，比如private ,infal ,static 等等，具体格式如图。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180209122038.png" alt=""></p><h5 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h5><p>采用和字段表完全一样的描述方式。</p><h5 id="属性表集合（上面表中的attribute-info）"><a href="#属性表集合（上面表中的attribute-info）" class="headerlink" title="属性表集合（上面表中的attribute_info）"></a>属性表集合（上面表中的attribute_info）</h5><p>在class文件，字段表，方法表都<em>可以</em>携带自己的属性表集合，以用于描述某些场景专有的信息。</p><p>主要的属性有Code(在方法表使用，含义是Java代码编译成的字节码指令)，ConstantValue(字段表使用，含义是final关键字定义的常量值)，Exceptions(方法表中使用，含义是方法抛出的异常)等等。</p><p>比如Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合中（前面表中的arrtibute_info）。Code属性也有自己的表结构。</p><p>###字节码指令简介</p><p>Java虚拟机的指令由一个字节长度的，代表着某种特定操作含义的数字以及跟随其中的0至多个代表此操作所需参数而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>138. Copy List with Random Pointer</title>
      <link href="/2018/02/08/leetcode138/"/>
      <url>/2018/02/08/leetcode138/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>复制链表。<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        RandomListNode* tou =pHead;</span><br><span class="line">        RandomListNode* tou2=pHead;</span><br><span class="line">        RandomListNode* tou3 =pHead;</span><br><span class="line">        <span class="keyword">while</span>(tou!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* node =<span class="keyword">new</span> RandomListNode(tou-&gt;label);</span><br><span class="line">            node-&gt;random =<span class="literal">NULL</span>;</span><br><span class="line">            RandomListNode* mynext =tou-&gt;next;</span><br><span class="line">            tou-&gt;next =node;</span><br><span class="line">            node-&gt;next =mynext;</span><br><span class="line">            tou=tou-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tou2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* node =tou2-&gt;random;</span><br><span class="line">            <span class="keyword">if</span>(node)</span><br><span class="line">            &#123;</span><br><span class="line">                tou2-&gt;next-&gt;random =node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tou2=tou2-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomListNode *pCloneHead = pHead-&gt;next;</span><br><span class="line">        RandomListNode *tmp;</span><br><span class="line">        <span class="keyword">while</span>(tou3-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp=tou3-&gt;next;</span><br><span class="line">            tou3-&gt;next =tmp-&gt;next;</span><br><span class="line">            tou3 =tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>三步，第一步把每个结点插入原来结点的后面，第二步遍历去加上random指针，第三步要把两个彻底分开。（！！ ！ 第三步必须是把彻底分开两个链表，两个链表完全没重合，要不然通不过。）</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer34二叉树中和为某一值的路径</title>
      <link href="/2018/02/08/JZoffer34/"/>
      <url>/2018/02/08/JZoffer34/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; results;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; one;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> results;</span><br><span class="line">        DFS(one,expectNumber,<span class="number">0</span>,root,results);</span><br><span class="line"><span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; one,<span class="keyword">int</span> expect,<span class="keyword">int</span> sum,TreeNode* node,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; results)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        one.push_back(node-&gt;val);</span><br><span class="line">        sum = sum+node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left==<span class="literal">NULL</span>&amp;&amp;node-&gt;right==<span class="literal">NULL</span>&amp;&amp;sum == expect)</span><br><span class="line">        &#123;</span><br><span class="line">            results.push_back(one);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(one,expect,sum,node-&gt;left,results);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(one,expect,sum,node-&gt;right,results);</span><br><span class="line">        &#125;</span><br><span class="line">        one.pop_back();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用DFS,一定要记住首先判断根结点，要不然牛客上一直报错（段错误:您的程序发生段错误，可能是数组越界，堆栈溢出（比如，递归调用层数太多）等情况引起）。</p><p>其他就是一个DFS解决就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer31栈的压入，弹出序列</title>
      <link href="/2018/02/08/JZoffer31/"/>
      <url>/2018/02/08/JZoffer31/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; pushV.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(pushV[i]);</span><br><span class="line">            <span class="keyword">while</span>(j &lt; popV.size() &amp;&amp; st.top() == popV[j])</span><br><span class="line">            &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>pushV是弹入栈的元素，popV是弹出栈的元素，首先无条件先把pushV中一个元素弹进入。</p><p>然后和popV中的元素进行对比，不等的话就一直弹pushV，等的话就移动popV到下一个元素，并弹出pushV的元素。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer*30包含min 函数的栈</title>
      <link href="/2018/02/08/JZoffer30/"/>
      <url>/2018/02/08/JZoffer30/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; smin;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        st.push(value);</span><br><span class="line">        <span class="keyword">if</span>(smin.empty())</span><br><span class="line">            smin.push(value);</span><br><span class="line">        <span class="keyword">if</span>(smin.top()&gt;value)</span><br><span class="line">            smin.push(value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            smin.push(smin.top());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        smin.pop();</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> smin.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用一个辅助栈，当往正常栈push元素时，如果辅助栈为空，就往辅助栈push元素，如果辅助栈的栈顶比当前要push的元素大，就往辅助栈push这个元素，如果辅助栈栈顶比push的元素小，就再push 栈顶的最小元素。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer*28对称的二叉树</title>
      <link href="/2018/02/07/JZoffer28/"/>
      <url>/2018/02/07/JZoffer28/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> is(pRoot,pRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is</span><span class="params">(TreeNode* p1,TreeNode* p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="literal">NULL</span>&amp;&amp;p2!=<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1!=<span class="literal">NULL</span>&amp;&amp;p2==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="literal">NULL</span>&amp;&amp;p2==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val==p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> is(p1-&gt;left,p2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>当以中右左的顺序和中左右的顺序遍历二叉树都得到相同的结果时就是对称的了。</p><p>接下来就是怎么写递归的问题了。这里等于NULL要单独列出来，因为有一种情况是</p><p><code>7 7 7 7 7 7</code> 三层，分别按顺序1个，2个，3个数字，是不对称的，所以要把NULL也算上。 </p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer*26树的子结构</title>
      <link href="/2018/02/07/JZoffer26/"/>
      <url>/2018/02/07/JZoffer26/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1==<span class="literal">NULL</span>||pRoot2==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> equalNode(pRoot1,pRoot2)</span><br><span class="line">            ||HasSubtree(pRoot1-&gt;left,pRoot2)</span><br><span class="line">            ||HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">equalNode</span><span class="params">(TreeNode* p1,TreeNode* p2)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(p2==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span>(p1==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span>(p1-&gt;val==p2-&gt;val)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> equalNode(p1-&gt;left,p2-&gt;left)&amp;&amp;equalNode(p1-&gt;right,p2-&gt;right);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>网上看到的解法，写的不要太好。equalNode递归判断是否匹配。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机内存区域</title>
      <link href="/2018/02/07/Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2018/02/07/Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域这些区域都有自己的用途，创建，销毁时间。  如下图所示：</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180206225209.png" alt=""></p><ul><li>程序计数器</li></ul><p>这是一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>因为在任意一个确定的时刻，一个处理器只能执行一条线程中的指令，为了线程切换后能回到正确的执行位置，每条线程都需要一个独立的程序计数器。称这类内存区域为线程私有的内存。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><ul><li>Java 虚拟机栈</li></ul><p>Java虚拟机栈也是<strong>线程私有</strong>的，生命周期和线程相同，虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>虚拟机栈中的局部变量表就是广义上划分内存为堆和栈中的栈，局部变量表里存放了编译期可知的各种基本数据类型，对象引用类型，它不等于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置。</p><p>虚拟机规范中，这个区域规定了两种异常状况，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出Stack Overflowerror异常，如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出outofmemoryError 异常。</p><p> (每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为<strong>静态解析</strong>。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为<strong>动态连接</strong>。)</p><ul><li>本地方法栈</li></ul><p>本地方法栈为虚拟机使用到的native方法服务。</p><ul><li>Java堆</li></ul><p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。Java堆还是垃圾收集器管理的主要区域，Java堆可以细分为新生代和老年代，再细致有 eden空间，From Survivor 空间， To Survivor 空间。 Java堆可以处在物理上不连续的内存空间，只需逻辑上连续即可。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><ul><li>方法区</li></ul><p>方法区也是<strong>线程共享的内存区域</strong>，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。也称为“永久代”</p><ul><li>运行时常量池</li></ul><p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、 字段、 方法、 接口等描述信息外， 还有一项信息是常量池（Constant Pool Table） ， 用于存放编译期生成的各种字面量和符号引用， 这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><h3 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>虚拟机遇到一条new指令后，首先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析，初始化。如果没有，就必须先执行相应的类加载过程。</p><p>类加载检查完成后，虚拟机将为新生对象分配内存，对象所需内存大小在<strong>类加载</strong>完成后便可确定下来，为对象分配内存就是把一块确定大小的内存从Java堆中划分出来。有两种主要的分配方式分别是<code>指针碰撞</code>和<code>空闲列表</code></p><p>假设堆内存是绝对规整的，所有用过的内存都放在一边，空闲的放在另一边，中间放着一个指针作为分界点的指示器，，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这就是指针碰撞，如果不规整，虚拟机就必须维护一个列表，记录哪些内存块是可用的，这种称为空闲列表。</p><p>内存分配完成后，虚拟机需要将分配的内存空间都初始化为零值。接下来要对对象进行必要的设置，例如这个对象是哪一个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。这些信息都存放在对象的对象头中。</p><p>上述步骤完成后，虚拟机角度，一个新对象已经产生了。但是从程序员角度，执行new指令后会接着执行<code>&lt;init&gt;</code>方法，把对象按照程序员意愿进行初始化，这样一个可用对象才算最终产生。</p><p><strong>new 一个才会在堆中产生一个对象</strong></p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对齐填充。</p><p> 对象头包括两部分信息， 第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode） 、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等。32位虚拟机和64位虚拟机分别占32bit和64bit.也称为mark word。对象头的另外一部分是类型指针， 即<strong>对象指向它的类元数据的指针， 虚拟机通过这个指针来确定这个对象是哪个类的实例。 </strong></p><p>实例数据部分是对象真正存储的有效信息， 也是在程序代码中所定义的各种类型的字段内容。 无论是从父类继承下来的， 还是在子类中定义的， 都需要记录起来。 这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响 </p><p>第三部分对齐填充并不是必然存在的， 也没有特别的含义， 它仅仅起着占位符的作用。</p><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>建立对象是为了使用对象， <strong>Java程序需要通过栈上的reference数据来操作堆上的具体对象。</strong>主要的访问对象方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。</p><ul><li>使用句柄</li></ul><p>Java堆中将会划分出一块内存来作为句柄池， reference中存储的就是对象的句柄地址， 而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180207093350.png" alt=""></p><ul><li>直接指针访问</li></ul><p>reference中存储的直接就是对象地址。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180207100039.png" alt=""></p><p>SUN HotSpot 虚拟机选择的第二种。</p><p>两种方式各有优势，使用句柄最大好处就是reference存放的是稳定的句柄地址，对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p><p>使用直接指针访问方式最大的好处就是速度快。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机GC与内存分配</title>
      <link href="/2018/02/07/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
      <url>/2018/02/07/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="垃圾收集器和内存分配策略"><a href="#垃圾收集器和内存分配策略" class="headerlink" title="垃圾收集器和内存分配策略"></a>垃圾收集器和内存分配策略</h2><p>程序计数器、 虚拟机栈、 本地方法栈3个区域随线程而生， 随线程而灭。这几个区域的内存分配和回收都具备确定性， 在这几个区域内就不需要过多考虑回收的问题， 因为方法结束或者线程结束时， 内存自然就跟随着回收了。Java堆不一样，一个接口中的多个实现类需要的内存可能不一样， 一个方法中的多个分支需要的内存也可能不一样， 我们只有在程序处于运行期间时才能知道会创建哪些对象， 这部分内存的分配和回收都是动态的， 垃圾收集器所关注的是这部分内存。</p><h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><h4 id="引用计数器算法"><a href="#引用计数器算法" class="headerlink" title="引用计数器算法"></a>引用计数器算法</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1，引用失效时，计数器就减1，任何时刻计数器为0的对象就是不可能再被使用的。</p><p>这种方法实现简单，判断效率高，但是主流虚拟机没有采用这种方法，因为它很难解决对象之间相互循环引用的问题。</p><h4 id="可达性分析方法"><a href="#可达性分析方法" class="headerlink" title="可达性分析方法"></a>可达性分析方法</h4><p>这个算法的基本思路就是通过一系列的称为“GC Roots” 的对象作为起始点， 从这些节点开始向下搜索， 搜索所走过的路径称为引用链 ， 当一个对象到GC Roots没有任何引用链相连（用图论的话来说， 就是从GC Roots到这个对象不可达） 时， 则证明此对象是不可用的。 </p><p>在Java中，可以作为GC roots 的对象包括以下几种。</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在JDK 1.2以前， Java中的引用的定义很传统： 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址， 就称这块内存代表着一个引用。 这种定义很纯粹， 但是太过狭隘， 一个对象在这种定义下只有被引用或者没有被引用两种状态， 对于如何描述一些“食之无味， 弃之可惜” 的对象就显得无能为力。</p><p>在JDK 1.2之后， Java对引用的概念进行了扩充， 将引用分为强引用 、 软引用 、 弱引用 、 虚引用4种， 这4种引用强度依次逐渐减弱。</p><p>强引用就是程序代码中普遍存在的 new生成的对象的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><p>软引用是用来描述一些还有用但是非必需的对象，对于软引用关联的对象，在系统要发生内存溢出异常之前，将会把这些对象列进回收范围内进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><p>弱引用也用来描述非必需对象，但是强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，垃圾收集器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。</p><p>虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p><h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><p>即使在可达性分析算法中不可达的对象， 也并非是“非死不可” 的， 要真正宣告一个对象死亡， 至少要经历两次标记过程： 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链， 那它将会被第一次标记并且进行一次筛选， 筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有覆盖finalize()方法， 或者finalize()方法已经被虚拟机调用过， 虚拟机将这两种情况都视为“没有必要执行” 。就直接进行GC.</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区也就是HotSpot虚拟机中的永生代也有一定的垃圾收集，主要回收两部分内容，废弃常量和无用的类。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>最基础的收集算法就是标记清除算法，分为标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。主要不足有两个，一是效率，标记和清除两个过程的效率都不高，另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，会导致以后有较大对象时没有内存分配而又一次触发GC.</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>此方法将内存划分为相等的两块，每次使用其中的一块，当这一块用完了，就将还存活的对象复制到另一块上，然后把已使用过的内存空间一次性清理掉。这样使得每次都是对整个半区进行内存回收，分配时就不用考虑内存碎片的问题，但是代价是内存缩小为了原来的一半。</p><p>现在的商用虚拟机都采用这种收集算法来<strong>回收新生代</strong>。但是进行了一定的改进，不是按照1比1进行划分。将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用一块eden和其中一块Survivor。当回收时，将Eden 和Survivor中还存活的对象一次性复制到另外一块Survivor 中。然后清理掉Eden和Survivor .HotSpot 虚拟机设置的默认比例是<code>8:1:1</code>.当Survivor 空间不够用时，需要依赖其他内存（老年代）进行分配担保。</p><h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>复制收集算法在对象存活率较高时就要进行较多的复制，<strong>所以一般老年代不选用这种算法</strong></p><p>根据老年代特点，有另外一种标记-整理算法，标记过程和前面标记清除过程一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据对象的存活周期的不同将Java堆分为新生代和老年代，根据各个代的特点选择不同的收集算法。新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，所以就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集，而老年代中因为对象存活率高，没有额外的空间对他进行分配担保，就必选使用标记—清理 或者 标记 —整理算法来回收。</p><h3 id="HotSpot-的算法实现"><a href="#HotSpot-的算法实现" class="headerlink" title="HotSpot 的算法实现"></a>HotSpot 的算法实现</h3><p>Hotspot虚拟机在实现上面这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。</p><h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><p>当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机有办法直接得知哪些地方存放着对象引用，在Hotspot虚拟机中，使用一组称为OopMap的数据结构来实现这个目的，在类加载完成的时候，Hotspot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，在GC扫描时，就直接知道这些信息了。</p><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>Hotspot并没有为每条指令都生成oopmap,只有特定的位置记录了这些信息，这些位置称为安全点。即程序执行时并非在所有地方都能停顿下来开始GC,只有在到达安全点时才能暂停。</p><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>安全区域是指在一段代码片段中，引用关系不会发生变化，在这个区域的任何地方开始GC都是安全的，可以把safe region 看做是被扩展了的safepoint.</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集器是内存回收的具体实现。下面讨论的1收集器基于JDK1.7后的HotSpot虚拟机。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180207111724.png" alt=""></p><ul><li>Serial 收集器</li></ul><p>最基本，发展历史最悠久的收集器。单线程收集器。它在进行垃圾收集时，必须暂停所有其他所有的工作线程。直到它收集结束。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180207112122.png" alt=""></p><p>Serial 是运行在Client 模式下的默认新生代收集器，优点是简单高效。</p><ul><li>ParNew 收集器</li></ul><p>Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余和Serial几乎完全一样。是运行在Server模式下的虚拟机中首选的新生代收集器。同时，也只有Serial 和ParNew 能和CMS收集器配合工作。</p><ul><li>Parallel Scavenge 收集器</li></ul><p>使用复制算法的新生代收集器。也是并行的多线程收集器。它的设计目标是达到一个可控制的吞吐量。所以也被成为吞吐量优先的收集器。</p><ul><li>Serial Old 收集器</li></ul><p>Serial 收集器的老年代版本，是一个单线程使用标记-整理算法的收集器。主要给Client模式下的虚拟机使用。</p><ul><li>Parallel Old </li></ul><p>parallel Scaenge 收集器的老年代版本，使用多线程和标记-整理算法。</p><ul><li>CMS收集器(current mark sweep)</li></ul><p>一种以获取最短回收停顿时间为目标的收集器。基于标记清除算法实现。主要有四个步骤，初始标记，并发标记，重新标记，并发清除。其中，<strong>初始标记、 重新标记这两个步骤仍然需要“Stop The World”</strong> 。 初始标记仅仅只是标记一下GC Roots能直接关联到的对象， 速度很快， 并发标记阶段就是进行GC RootsTracing的过程， 而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录， 这个阶段的停顿时间一般会比初始标记阶段稍长一些， 但远比并发标记的时间短。<br>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作， 所以， 从总体上来说， CMS收集器的内存回收过程是与用户线程一起并发执行的。 下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180207121214.png" alt=""></p><p>CMS也有很明显的缺点，主要是1对CPU资源非常敏感，2无法处理浮动垃圾，3，使用标记清除算法会产生大量碎片。</p><ul><li>G1 收集器</li></ul><p>一个面向服务器应用的垃圾收集器，主要有以下优点，并行与并发，分代收集，空间整合(整体上标记整理，局部是复制算法)，可预测的停顿(相比CMS的一大优势)。</p><p>将堆化为多个大小相等的独立区域(region),虽然保留了新生代，老年代的概念，但是新生代老年代不再物理隔离了.它们都是一部分region的集合</p><p>G1 之所以能建立可预测的停顿时间模型,是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集,G1追踪各个region里面的垃圾堆积的价值大小,后台维护一个优先列表,每次根据允许的收集时间,优先回收价值最大的region.</p><p>主要划分为四个步骤</p><p>初始标记- 并发标记- 最终标记 - 筛选回收</p><p>初始标记仅标记一下GC root 能关联到的对象,这个阶段需要停顿,但耗时短</p><p>并发标记是从GC root 进行可达性分析 ,找出存活对象. 耗时长,但是可并发</p><p>最终标记是为了修正并发标记期间因用户程序继续运作导致标记变动的记录 ,需要停顿,但是可多条线程同时执行</p><p>筛选回收 根据各个region的回收价值和成本进行排序.根据用户期望的GC停顿时间来执行回收计划.这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-06%20%E4%B8%8A%E5%8D%889.07.38.png" alt=""></p><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p>对象的内存分配，其实就是往堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能直接分配在老年代中。分配细节取决于当前使用的是哪一种垃圾收集器组合</p><h4 id="对象优先在Eden分区分配"><a href="#对象优先在Eden分区分配" class="headerlink" title="对象优先在Eden分区分配"></a>对象优先在Eden分区分配</h4><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次MInor GC.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Minor GC 也称为新生代GC，指发生在新生代的垃圾收集动作。因为Java对象大多具有朝生夕灭的特点，所以说新生代GC 非常频繁，一般回收速度也很快。</span><br><span class="line">Full GC(Major GC)也称为老年代GC,发生在老年代的GC，比Minor GC 慢10倍以上。基本上也会伴随新生代GC</span><br></pre></td></tr></table></figure><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p><strong>大对象指的是需要大量连续内存空间的Java对象</strong>，最典型的大对象就是那种<strong>很长的字符串以及数组</strong>，大对象对内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾回收以获取足够的连续空间来安置它们。</p><h4 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h4><p>为了在回收时识别哪些对象应放在新生代，哪些应放在老年代，虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC 后仍然存活，并能被Survroir 容纳的话，将被移动到Survrior 空间中，并且对象年龄设置为1，对象在Survrior 中每熬过一次Minor GC 年龄就增加一岁，到达一定程度(默认15岁)就会晋升到老年代中。</p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了能更好的适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代， 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代， 无须等到MaxTenuringThreshold中要求的年龄。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生Minor GC之前， 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间， 如果这个条件成立， 那么Minor GC可以确保是安全的。 如果不成立， 则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。 如果允许， 那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于， 将尝试着进行一次Minor GC， 尽管这次Minor GC是有风险的； 如果小于， 或者HandlePromotionFailure设置不允许冒险， 那这时也要改为进行一次Full GC。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer*19正则表达式匹配</title>
      <link href="/2018/02/06/JZoffer19/"/>
      <url>/2018/02/06/JZoffer19/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="literal">NULL</span>||pattern==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str,pattern);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str==<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'\0'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(*str!=<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'\0'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(*(pattern+<span class="number">1</span>)==<span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*pattern==*str||(*pattern==<span class="string">'.'</span>&amp;&amp;*str!=<span class="string">'\0'</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">                  matchCore(str+<span class="number">1</span>,pattern+<span class="number">2</span>)||</span><br><span class="line">                  matchCore(str+<span class="number">1</span>,pattern)||</span><br><span class="line">                  matchCore(str,pattern+<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> matchCore(str,pattern+<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*str==*pattern||(*pattern==<span class="string">'.'</span>&amp;&amp;*str!=<span class="string">'\0'</span>))</span><br><span class="line">            <span class="keyword">return</span> matchCore(str+<span class="number">1</span>,pattern+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p><a href="https://www.nowcoder.net/questionTerminal/45327ae22b7b413ea21df13ee7d6429c" target="_blank" rel="noopener">https://www.nowcoder.net/questionTerminal/45327ae22b7b413ea21df13ee7d6429c</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer15二进制中一的个数</title>
      <link href="/2018/02/06/JZoffer15/"/>
      <url>/2018/02/06/JZoffer15/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> flag =<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(flag)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(n&amp;flag) count++;</span><br><span class="line">             flag =flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>二进制的位运算一共有5种运算，与，或，异或，左移，右移。</p><p>左移运算符<code>m&lt;&lt;n</code>表示把m左移n位，在左移n位的时候，最左边的n位将被丢弃，同时在最右边补上n个0。例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00001010 &lt;&lt; 2 = 00101000</span><br><span class="line">10001010 &lt;&lt; 3 = 01010000</span><br></pre></td></tr></table></figure><p>右移运算符表示把m右移n位，在右移n位的时候，最右边的n位将被丢弃，同时右移稍微复杂一点，如果数字是一个无符号数值，则用0填补最左边的n位，如果数字是一个有符号数值，则用数字的符号位填补最左边的n位，也就是说，正数右移左边补0，负数右移左边补1.</p><p>回到此题，基本的思路就是让1与每一位异或，如果答案是0，说明原来也是1，这里就出现一个问题，怎么移动位置，可以移动原来的数字，也可以移动1，但是移动原来的数字时，当是负数的时候，因为最高位补1，所以可能会产生死循环，所以应该把1不断的左移。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer*12矩阵中的路径</title>
      <link href="/2018/02/05/JZoffer12/"/>
      <url>/2018/02/05/JZoffer12/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="literal">NULL</span>||rows&lt;<span class="number">1</span>||cols&lt;<span class="number">1</span>||str==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span>* visit= <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,rows*cols);</span><br><span class="line">        <span class="keyword">int</span> pathLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;rows;row++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;cols;col++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(DFS(matrix,rows,cols,row,col,str,pathLength,visit))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] visit;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">char</span>* matrix,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">char</span>* str,<span class="keyword">int</span> index, <span class="keyword">bool</span>* visit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[index]==<span class="string">'\0'</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//死胡同</span></span><br><span class="line">        <span class="keyword">bool</span> hasPath=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(row&gt;=<span class="number">0</span>&amp;&amp;row&lt;rows&amp;&amp;col&gt;=<span class="number">0</span>&amp;&amp;col&lt;cols&amp;&amp;matrix[row*cols+col]==str[index]</span><br><span class="line">           &amp;&amp;!visit[row*cols+col]) <span class="comment">//判断是否有这条路</span></span><br><span class="line">        &#123;</span><br><span class="line">            visit[row*cols+col]=<span class="literal">true</span>;</span><br><span class="line">          <span class="comment">//岔道口</span></span><br><span class="line">            hasPath =DFS(matrix,rows,cols,row,col<span class="number">-1</span>,str,index+<span class="number">1</span>,visit)</span><br><span class="line">                    ||DFS(matrix,rows,cols,row<span class="number">-1</span>,col,str,index+<span class="number">1</span>,visit)</span><br><span class="line">                    ||DFS(matrix,rows,cols,row,col+<span class="number">1</span>,str,index+<span class="number">1</span>,visit)</span><br><span class="line">                    ||DFS(matrix,rows,cols,row+<span class="number">1</span>,col,str,index+<span class="number">1</span>,visit);</span><br><span class="line">            <span class="keyword">if</span>(!hasPath)</span><br><span class="line">            &#123;</span><br><span class="line">                --index;</span><br><span class="line">                visit[row*cols+col]=<span class="literal">false</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>标准DFS写法，很值得借鉴，还有就是用一个<code>rows*cols</code>的一维数组代替了二维数组。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer3数组中重复的数字</title>
      <link href="/2018/02/03/JZoffer3/"/>
      <url>/2018/02/03/JZoffer3/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">while</span>(numbers[i] != i)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])</span><br><span class="line">              &#123;</span><br><span class="line">                  *duplication = numbers[i];</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//swap(numbers[i],numbers[numbers[i]]);</span></span><br><span class="line">              <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">              numbers[i] = numbers[temp];</span><br><span class="line">              numbers[temp] = temp;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>交换数字到自己的位置上，如果不在自己的位置就一直交换。</p><p>这里有一个很容易错的点，智障卡了好久。</p><p>就是交换的时候，因为<code>number[number[i]]</code>中包含了<code>numbers[i]</code>,这两个数是有关联的，所以必须把一个先设出来。 </p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141. Linked List Cycle&amp;142. Linked List Cycle II</title>
      <link href="/2018/01/31/leetcode141/"/>
      <url>/2018/01/31/leetcode141/</url>
      
        <content type="html"><![CDATA[<p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:<br>Can you solve it without using extra space?</p><a id="more"></a><h5 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h5><p>判断一个链表是否有环</p><h5 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *fast=head, *slow=head;</span><br><span class="line">    <span class="keyword">while</span>( slow &amp;&amp; fast &amp;&amp; fast-&gt;next )</span><br><span class="line">    &#123;</span><br><span class="line">        fast=fast-&gt;next-&gt;next;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast==slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>设置一个快指针一个慢指针,开始都指向头,快指针一次有两步,慢指针一次走一步,如果遇到了就是有环,没遇到就是没环.</p><h3 id="Linked-List-Cycle-II"><a href="#Linked-List-Cycle-II" class="headerlink" title="Linked List Cycle II"></a>Linked List Cycle II</h3><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Follow up</strong>:<br>Can you solve it without using extra space?</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>找出循环的开始节点</p><h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow =head;</span><br><span class="line">        ListNode* fast =head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp; fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast =fast-&gt;next-&gt;next;</span><br><span class="line">            slow =slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)   <span class="comment">// there is a cycle</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(head!=slow) <span class="comment">// found the 相遇 location</span></span><br><span class="line">                &#123;</span><br><span class="line">                    head=head-&gt;next;</span><br><span class="line">                    slow=slow-&gt;next;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// there has no cycle</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>需要推导,大意就是先快慢指针往前走,当相遇后,慢指针接着往前,头指针开始动,慢指针和头指针相遇的地方就是循环开始的地方.</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>109*. Convert Sorted List to Binary Search Tree</title>
      <link href="/2018/01/31/leetcode109/"/>
      <url>/2018/01/31/leetcode109/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.cnblogs.com/hellowooorld/p/6624709.html" target="_blank" rel="noopener">https://www.cnblogs.com/hellowooorld/p/6624709.html</a></p></blockquote><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted linked list: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>给定一个链表,生成一个二叉平衡树.<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//利用fast 和 slow 指针 找到链表中点</span></span><br><span class="line">        <span class="keyword">return</span> build(head,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//两个参数分别是链表中左节点的指针,右节点的下一个的指针.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(ListNode* start, ListNode* end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* fast = start;</span><br><span class="line">        ListNode* slow = start;</span><br><span class="line">        <span class="keyword">while</span> (fast != end &amp;&amp; fast-&gt;next != end)<span class="comment">//注意第一次执行的时候end为NULL 没毛病。。</span></span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(slow-&gt;val);</span><br><span class="line">        node-&gt;left = build(start, slow);</span><br><span class="line">        node-&gt;right = build(slow-&gt;next, end);</span><br><span class="line">        <span class="keyword">return</span> node;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用快慢指针找到中间节点，作为根节点，然后左子树即为左边链表部分，右子树即为右边链表部分，递归进行即可。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160. Intersection of Two Linked Lists</title>
      <link href="/2018/01/29/leetcode160/"/>
      <url>/2018/01/29/leetcode160/</url>
      
        <content type="html"><![CDATA[<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure><p>begin to intersect at node c1.</p><p><strong>Notes:</strong></p><ul><li>If the two linked lists have no intersection at all, return <code>null</code>.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><a id="more"></a><h5 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h5><p>找到两个链表中相交的点</p><h5 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 =headA;</span><br><span class="line">        ListNode* p2 =headB;        </span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="literal">NULL</span>||p2==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//if(p1==p2) return p1;</span></span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)</span><br><span class="line">        &#123;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p1==p2)  <span class="keyword">return</span> p1;</span><br><span class="line">            <span class="keyword">if</span>(p1==<span class="literal">NULL</span>) p1 =headB;</span><br><span class="line">            <span class="keyword">if</span>(p2==<span class="literal">NULL</span>) p2 =headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>思路十分巧妙,设置两个指针分别指向第一个链表和第二个链表,然后同时往前,当p1 遍历A到头后去遍历B, p2 遍历B到头后去遍历A. 这样两个指针遍历到的距离就相同了,第一个相等的点就是焦点.</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Linux IO 模型与Java NIO</title>
      <link href="/2018/01/29/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Linux-IO-%E6%A8%A1%E5%9E%8B%E4%B8%8EJava-NIO/"/>
      <url>/2018/01/29/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Linux-IO-%E6%A8%A1%E5%9E%8B%E4%B8%8EJava-NIO/</url>
      
        <content type="html"><![CDATA[<h2 id="深入了解Linux-IO-模型与Java-NIO"><a href="#深入了解Linux-IO-模型与Java-NIO" class="headerlink" title="深入了解Linux IO 模型与Java NIO"></a>深入了解Linux IO 模型与Java NIO</h2><blockquote><p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859</a></p><p><a href="https://www.cnblogs.com/dolphin0520/p/3916526.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3916526.html</a></p></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h4><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><h4 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，<strong>进程的阻塞是进程自身的一种主动行为</strong>，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<strong>当进程进入阻塞状态，是不占用CPU资源的</strong>。</p><h4 id="直接IO与缓存IO"><a href="#直接IO与缓存IO" class="headerlink" title="直接IO与缓存IO"></a>直接IO与缓存IO</h4><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间.如下图所示.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/IMG_20180128_221200.jpg" width="50%"></p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-01%20%E4%B8%8A%E5%8D%8811.19.41.png" alt=""></p><p>直接IO的话，则是少了拷贝到进程缓存区那一步。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-01%20%E4%B8%8A%E5%8D%8811.22.31.png" alt=""></p><p><strong>缓存 I/O 的缺点：</strong><br>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h3 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h3><p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p><ul><li>等待数据准备 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li></ul><p><strong>阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段</strong>，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。</p><p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p><ul><li>阻塞 I/O（blocking IO）</li><li>非阻塞 I/O（nonblocking IO）</li><li>I/O 多路复用（ IO multiplexing）</li><li>信号驱动 I/O（ signal driven IO）// 不常用</li><li>异步 I/O（asynchronous IO）</li></ul><h4 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h4><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-11%2010-47-02%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。标红的这部分过程就是阻塞，直到阻塞结束recvfrom才能返回。</p><p><strong>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</strong></p><h4 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h4><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><p>进程把一个套接字设置成非阻塞是在通知内核，当所请求的I/O操作非得把本进程投入睡眠才能完成时，不要把进程投入睡眠，而是返回一个错误。看看非阻塞的套接字的recvfrom操作如何进行<br><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-11%2010-51-02%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="img"></p><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p><strong>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</strong></p><h4 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h4><p>OS为我们提供了这样一个功能，当某个socket可读或者可写的时候，它可以给你一个通知，这样当配合非阻塞的socket的时候，只有当系统通知我哪个描述符可读了，才去执行read操作。</p><p><strong>虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</strong></p><font color="8000ff">也就是说 阻塞IO中，一个线程A执行到需要从socket中读数据时，需要阻塞在这里，等待内核先把数据加载到内核（第一步），再复制到用户空间（第二步），而在等待的过程中，线程A什么都干不了。而在非阻塞IO中，第一步，需要不断的问内核数据准备好了没，但是不问的时间，就可以执行其他操作了。</font><font color="8000ff">阻塞IO和非阻塞IO的问题都在于，如果有许多socket都要处理，阻塞在一个socket上，后面的socket都无法操作，要想处理多个socket，要有多个线程 ,所以就产生了IO多路复用。</font><font color="8000ff">而IO多路复用中，线程A阻塞在select这样的系统调用上，select函数用线程B不断的轮询所有负责的socket，当有socket有数据需要处理时，select函数会通知用户进程A, 而用户进程A只有在调用select函数的时候才会阻塞，收发消息是不会阻塞的。IO多路复用主要作用就是一个线程就可以负责很多socket。</font><font color="8000ff">select 会一直阻塞，阻塞到有一个socket有数据了，select 就会返回了。就不阻塞在select上了。真正的操作就可以用线程池操作了，（也可以用原来的线程。）</font><font color="8000ff">IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。这样，整个进程就被充分利用起来。</font><p>IO multiplexing就是所说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于<strong>单个process就可以同时处理多个网络连接的IO</strong>。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-11%2010-52-53%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="img"></p><p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><p><strong>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</strong></p><p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>Linux下的asynchronous IO其实用得很少。先看一下它的流程：<br><img src="http://four-1252095801.cosbj.myqcloud.com/2018-04-11%2010-56-05%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="img"></p><p>注意红线标记处说明在调用时就可以立马返回，等函数操作完成会通知我们。</p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><h3 id="Java-中的IO"><a href="#Java-中的IO" class="headerlink" title="Java 中的IO"></a>Java 中的IO</h3><p>　Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。</p><p>多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。</p><p>　在多路复用IO模型中，<strong>会有一个线程不断去轮询多个socket的状态</strong>，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p><p>　在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。</p><p>　　可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。</p><p>　　而多路复用IO模式，<strong>通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。</strong></p><p>　　另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在<strong>多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</strong></p><p>　　不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用之select、poll、epoll</title>
      <link href="/2018/01/29/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/01/29/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="IO多路复用之select、poll、epoll"><a href="#IO多路复用之select、poll、epoll" class="headerlink" title="IO多路复用之select、poll、epoll"></a>IO多路复用之select、poll、epoll</h2><p> 目前支持I/O多路复用的系统调用有 <code>select，pselect，poll，epoll</code>，I/O多路复用就是<strong>通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</strong> <strong>但select，pselect，poll，epoll本质上都是同步I/O</strong>，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><pre><code>与多进程和多线程技术相比，**I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程**，也不必维护这些进程/线程，从而大大减小了系统的开销。</code></pre><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p><ul><li>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。</li><li>当一个客户同时处理多个套接口时，这种情况是可能的，但很少出现。</li><li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li><li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li><li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li></ul><h3 id="select、poll、epoll简介"><a href="#select、poll、epoll简介" class="headerlink" title="select、poll、epoll简介"></a>select、poll、epoll简介</h3><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，<code>其中epoll是Linux所特有，而select则应该是POSIX所规定</code>，一般操作系统均有实现。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p><strong>基本原理：</strong>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p><p>select目前几乎在所有的平台上支持，其<strong>良好跨平台支持</strong>也是它的一个优点。select的一个缺点在于<strong>单个进程能够监视的文件描述符的数量存在最大限制</strong>，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：<br>1、select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.<br>2、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。<br>　　当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。<br>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p><strong>基本原理：</strong><code>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间</code>，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。 </p><p><strong>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：</strong></p><p><code>1）大量的fd的数组被整体复制于用户态和内核地址空间之间</code>，而不管这样的复制是不是有意义。</p><p><code>2）poll还有一个特点是“水平触发”</code>，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。 </p><p><strong>注意：</strong>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，<code>同时连接的大量客户端在一时刻可能只有很少的处于就绪状态</code>，因此随着监视的描述符数量的增长，其效率也会线性下降。</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。<code>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次</code>。</p><p><strong>基本原理：</strong><code>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次</code>。还有一个特点是，<code>epoll使用“事件”的就绪通知方式</code>，通过epoll_ctl注册fd，<code>一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd</code>，epoll_wait便可以收到通知。</p><p><strong>epoll的优点：</strong></p><p><code>1、没有最大并发连接的限制</code>，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</p><p><code>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降</code>。</p><p>　　只有活跃可用的FD才会调用callback函数；<code>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关</code>，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p><p><code>3、内存拷贝</code>，利用mmap()文件映射内存加速与内核空间的消息传递；<code>即epoll使用mmap减少复制开销</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 排序</title>
      <link href="/2018/01/28/Redis%20%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/01/28/Redis%20%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="有序集合的集合操作"><a href="#有序集合的集合操作" class="headerlink" title="有序集合的集合操作"></a>有序集合的集合操作</h3><p>集合类型提供了强大的集合操作命令,但是如果需要排序就要用到有序集合类型.有序集合常见的使用场景是大数据排序,如玩家的排行榜,所以很少会需要获得键中的全部数据</p><h3 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a>sort命令</h3><p>sort命令可以对列表类型,集合类型,和有序集合类型键进行排序.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> sort mylist # 即可排序</span><br></pre></td></tr></table></figure><p><strong>对有序集合类型进行排序时会忽略元素的分数,只针对元素自身的值进行排序.</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> ZADD myzset 50 2 40 3 20 1 60 5</span><br><span class="line">(integer)  4</span><br><span class="line"><span class="meta">redis&gt;</span> SORT myzset</span><br><span class="line">"1"</span><br><span class="line">"2"</span><br><span class="line">"3"</span><br><span class="line">"5"</span><br></pre></td></tr></table></figure><p>sort还可以通过ALPHA参数实现按照字段顺序排序非数字元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> SORT myalphalist ALPHA</span><br></pre></td></tr></table></figure><p>加入DESC进行倒序排列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT mylist DESC</span><br></pre></td></tr></table></figure><p>指定limit 参数来指定返回范围的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT mylist DESC LIMIT 1 2 # 跳过第一个元素获取后面两个元素</span><br></pre></td></tr></table></figure><h4 id="By参数"><a href="#By参数" class="headerlink" title="By参数"></a>By参数</h4><p>很多情况下列表,集合,有序集合中存储的都是代表对象的对象ID,单纯对这些ID排序意义不大,更有用的是根据ID对应的对象的某一个属性进行排序. 这时需要使用BY参数</p><p>by参数的语法为<code>BY参考键</code>其中参考键可以是字符串类型键或者是散列类型键的某一个字段(表示为<code>散列键名-&gt;字段名</code>) 如果使用了BY参数,sort命令将不再按照元素自身的值进行排序,而是对每个元素使用元素的值替换参考键中的第一个<code>*</code>并获取其值,然后依据该值对元素排序.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> sort mylist BY post:*-&gt;time DESC</span><br><span class="line">假设mylist中有元素 12 26 6 2 ,</span><br><span class="line">那么将去寻找 post:12 ,post:26, post:6, post:2 这四个散列键中的time字段的值来决定mylist中元素的排序顺序.</span><br></pre></td></tr></table></figure><p>参考键也可以是字符串类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> LPUSH sortbylist 2 1 3</span><br><span class="line"><span class="meta">redis&gt;</span> SET item:1 50</span><br><span class="line"><span class="meta">redis&gt;</span> SET item:2 100</span><br><span class="line"><span class="meta">redis&gt;</span> SET item:3 75</span><br><span class="line"><span class="meta">redis&gt;</span> SORT sortbylist by item:* DESC</span><br><span class="line">输出 2 3 1</span><br></pre></td></tr></table></figure><h4 id="GET-参数"><a href="#GET-参数" class="headerlink" title="GET 参数"></a>GET 参数</h4><p>GET 参数不影响排序,它的作用是使SORT命令的返回结果不再是元素自身的值,而是GET参数中指定的键值.GET参数的规则和BY参数一样,GET参数也支持字符串类型和散列类型的键,并使用”*” 作为占位符.</p><p>要实现排序后直接返回排序用的值,可以这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> SORT mylist By post:*-&gt;time DESC GET post:*-&gt;time</span><br><span class="line"><span class="meta">#</span> 还可以有多个GET参数</span><br><span class="line"><span class="meta">redis&gt;</span> SORT mylist By post:*-&gt;time DESC GET post:*-&gt;time GET post:*-&gt;name</span><br></pre></td></tr></table></figure><p>GET # 返回元素本身的值.</p><h4 id="STORE-参数"><a href="#STORE-参数" class="headerlink" title="STORE 参数"></a>STORE 参数</h4><p>默认情况下 sort 会直接返回排序结果,如果希望保存排序结果,可以使用STORE 参数,</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性哈希算法</title>
      <link href="/2018/01/26/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2018/01/26/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://www.zsythink.net/archives/1182" target="_blank" rel="noopener">http://www.zsythink.net/archives/1182</a></p></blockquote><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>假设有三台缓存服务器用来缓存图片,三台服务器分别编号为0号,1号,2号.有3万张图片需要缓存,希望将这些图片均匀的分布到三台服务器上,以便平摊缓存的压力. 如果毫无规律的将这么多图片分配到三台服务器时,当再次查找的时候,就需要遍历这三台服务器的所有图片才能找到,这显然需要很长的时间,也就失去了缓存的意义.</p><p>最原始的做法就是进行节点取余,对缓存项的键进行哈希,哈希后使用取余的方法映射到三台服务器的其中一台,这样下次再次取的时候,只要服务器的个数没有变,图片的哈希值没有变,就直接知道了图片缓存在哪台服务器上.</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>缺点很明显,如果增加服务器或者减少服务器,再取余就有很大概率不在原来的服务器上,这样就需要把所有图片重新计算哈希,重新取余来找到该缓存的服务器,这显然是不能接受的.为了解决这个问题,创造了一致性哈希算法.</p><h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p>其实，一致性哈希算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性哈希算法是对2^32取模.</p><p>首先，我们把二的三十二次方想象成一个圆，就像钟表一样，钟表的圆可以理解成由60个点组成的圆，而此处我们把这个圆想象成由2^32个点组成的圆，示意图如下：</p><p><img src="http://www.zsythink.net/wp-content/uploads/2017/02/020717_1707_2.png"></p><p>圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1 .</p><p>回到前面的场景,那么，假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那么，在生产环境中，这三台服务器肯定有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用如下公式示意。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash（服务器A的IP地址） %  2^32</span><br></pre></td></tr></table></figure><p>通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上，同理,B,C 也可以映射到这里.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-27%2019-37-25.png" width="30%"></p><p>到目前为止，我们已经把缓存服务器与hash环联系在了一起，我们通过上述方法，把缓存服务器映射到了hash环上，那么使用同样的方法，我们也可以将需要缓存的对象映射到hash环上。</p><p>假设，我们需要使用缓存服务器缓存图片，而且我们仍然使用图片的名称作为找到图片的key，那么我们使用如下公式可以将图片映射到上图中的hash环上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash（图片名称） %  2^32</span><br></pre></td></tr></table></figure><p>映射后的示意图如下，下图中的橘黄色圆形表示图片.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-27%2019-40-19.png" width="30%"></p><p>同时规定顺时针碰到的第一个服务器就是要缓存的服务器,所以上面的橙色代表的图片就应该缓存在A上.</p><p>一致性哈希算法就是通过这种方法，判断一个对象应该被缓存到哪台服务器上的，<strong>将缓存服务器与被缓存对象都映射到hash环上以后，</strong>从被缓存对象的位置出发，沿顺时针方向遇到的第一个服务器，就是当前对象将要缓存于的服务器，由于被缓存对象与服务器hash后的值是固定的，所以，在服务器不变的情况下，一张图片必定会被缓存到固定的服务器上，那么，当下次想要访问这张图片时，只要再次使用相同的算法进行计算，即可算出这个图片被缓存在哪个服务器上，直接去对应的服务器查找对应的图片即可。</p><h4 id="一致性哈希的优点"><a href="#一致性哈希的优点" class="headerlink" title="一致性哈希的优点"></a>一致性哈希的优点</h4><p>一致性哈希可以解决前面增删服务器时所有图片的图片都乱的问题.</p><p>假设，有四张图片,服务器B出现了故障，我们现在需要将服务器B移除，那么，我们将上图中的服务器B从hash环上移除即可，移除服务器B以前和以后 示意图如下。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-27%2019-50-29.png" width="50%"><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-27%2019-50-55.png" width="50%"></p><p>在服务器B未移除时，图片3应该被缓存到服务器B中，可是当服务器B移除以后，按照之前描述的一致性哈希算法的规则，图片3应该被缓存到服务器C中，因为从图片3的位置出发，沿顺时针方向遇到的第一个缓存服务器节点就是服务器C，也就是说，如果服务器B出现故障被移除时，图片3的缓存位置会发生改变.</p><p>但是，图片4仍然会被缓存到服务器C中，图片1与图片2仍然会被缓存到服务器A中，这与服务器B移除之前并没有任何区别，这就是一致性哈希算法的优点，如果使用之前的hash算法，服务器数量发生改变时，所有服务器的所有缓存在同一时间失效了，而使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失效，前端的缓存仍然能分担整个系统的压力，而不至于所有压力都在同一时间集中到后端服务器上。</p><h4 id="Hash环的倾斜"><a href="#Hash环的倾斜" class="headerlink" title="Hash环的倾斜"></a>Hash环的倾斜</h4><p>在实际的映射中，服务器的映射可能是不均衡的,那么就有可能很多都缓存在同一台服务器上.这就是哈希环的倾斜.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-27%2019-56-36.png" width="40%"></p><h4 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h4><p>如果想要均衡的将缓存分布到3台服务器上，最好能让这3台服务器尽量多的、均匀的出现在hash环上，我们狗仔一些虚拟节点,一个实际节点可以有好多虚拟节点.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-27%2020-00-17.png" width="40%"></p><p>浅蓝色的表示虚拟节点,这样就均衡了.</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分布式理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>82. Remove Duplicates from Sorted List II</title>
      <link href="/2018/01/26/leetcode82/"/>
      <url>/2018/01/26/leetcode82/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p><p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.<br>Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>删除一个有序链表中有重复数字的节点.<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy =<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">      <span class="comment">//申请一个头节点指向head</span></span><br><span class="line">        <span class="keyword">int</span> dup;</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">      <span class="comment">//cur一直指向的是链表中确定存在的值.</span></span><br><span class="line">      <span class="comment">//cur指针先指向头节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next&amp;&amp;cur-&gt;next-&gt;next)</span><br><span class="line">        &#123;<span class="comment">//如果head和head-&gt;next存在则进入循环</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val==cur-&gt;next-&gt;next-&gt;val)</span><br><span class="line">            &#123;<span class="comment">//如果head的值和head-&gt;next的值相同,</span></span><br><span class="line">                dup = cur-&gt;next-&gt;val;<span class="comment">// 把这个值记下来</span></span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val==dup)<span class="comment">//找到最后一个等于dup的地方</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">//修改cur的next域的指向位置.</span></span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur=cur-&gt;next; <span class="comment">//不等的话!!! 给的链表的指针本来是正确的,所以不用修改,只需移动cur到//下一个节点.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先,链表题常用的方法是最前面加一个头节点,但是没有值.</p><p>其次,这种题要知道链表都是建好的.</p><p>cur一直指向的是链表中确定存在的值.这点很重要,如果这个节点不存在,就把cur-&gt;next指向绕过这个节点,若这个节点存在,cur就指向这个节点.然后再判断后面的值.</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. Reverse Linked List&amp;&amp;92. Reverse Linked List II</title>
      <link href="/2018/01/26/leetcode206&amp;&amp;92/"/>
      <url>/2018/01/26/leetcode206&amp;&amp;92/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Reverse a singly linked list.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>反转链表</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;    </span><br><span class="line">        ListNode* prev=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next;<span class="comment">//cur 存在 cur-&gt;next 一定存在.</span></span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>经典算法题,但是写了好久,之前设置了一个头节点,反转的时候没有去掉,结果leetcode一直很奇怪的报超时,</p><p>试了好久才发现是因为头节点的原因</p><p>所以反转链表的时候记住是不需要头节点的.<br><code>//再次验证正常反转链表的时候不需要头结点，要不然反转完最前面多了一个结点。</code></p><h2 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a>92. Reverse Linked List II</h2><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in-place and in one-pass.</p><p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <em>m</em> = 2 and <em>n</em> = 4,</p><p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p><p><strong>Note:</strong><br>Given <em>m</em>, <em>n</em> satisfy the following condition:<br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p><h4 id="大意-1"><a href="#大意-1" class="headerlink" title="大意"></a>大意</h4><p>从给定的左右来反转链表.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* tou =<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        tou-&gt;next = head;</span><br><span class="line">        ListNode* pre =tou;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=m) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> t =n-m;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* p = pre-&gt;next; <span class="comment">//p是第m个节点.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* post = p-&gt;next;</span><br><span class="line">            p-&gt;next =post-&gt;next;</span><br><span class="line">            post-&gt;next =pre-&gt;next;</span><br><span class="line">            pre-&gt;next=post;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tou-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>设置头节点,找到最前面的更新节点.</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的应用</title>
      <link href="/2018/01/25/Redis%20%E5%BA%94%E7%94%A8/"/>
      <url>/2018/01/25/Redis%20%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>Redis客户端执行一条命令分为如下四个过程：1发送命令,2命令排队,3命令执行,4返回结果其中1+4称为Round Trip Time（ RTT,往返时间）Redis提供了批量操作命令（ 例如mget、 mset等） ， 有效地节约RTT。 但大部分命令是不支持批量操作的.</p><p>Pipeline（ 流水线） 机制能改善上面这类问题， 它能将一组Redis命令进行组装， 通过一次RTT传输给Redis， 再将这组Redis命令的执行结果按顺序返回给客户端.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/BBFB95CF-0015-47B9-9581-B778D98A923C.png" width="70%"></p><p>上图是使用了pipeline 执行了n次命令，整个过程需要一个RTT</p><p>Pipeline执行速度一般比逐条执行要快。客户端和服务端的网络延时越大， Pipeline的效果越明显。</p><p>pipeline 和原生批量命令相比，原生批量命令是原子的， Pipeline是非原子的。原生批量命令是一个命令对应多个key， Pipeline支持多个命令。原生批量命令是Redis服务端支持实现的， 而Pipeline需要服务端和客户端的共同实现。</p><h3 id="事务与Lua"><a href="#事务与Lua" class="headerlink" title="事务与Lua"></a>事务与Lua</h3><p>为了保证多条命令组合的原子性， Redis提供了简单的事务功能以及集成Lua脚本来解决这个问题。</p><p>Redis提供了简单的事务功能， 将一组需要一起执行的命令放到multi和exec两个命令之间。 multi命令代表事务开始， exec命令代表事务结束， 它们之间的命令是原子顺序执行的.如果要停止事务的执行， 可以使用discard命令代替exec命令即可。</p><p>有些应用场景需要在事务之前， 确保事务中的key没有被其他客户端修改过， 才执行事务， 否则不执行（ 类似乐观锁） 。 Redis提供了watch命令来解决这类问题.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/45C6C5ED-9BBF-4ED7-9A89-F8559F8E60BD.png"></p><p>可以看到在multi前执行了watch key 命令，在事务期间有客户端修改了key的值，所以事务不会执行。Redis提供了简单的事务， 之所以说它简单， <strong>主要是因为它不支持事务中的回滚特性， 同时无法实现命令之间的逻辑关系计算。</strong></p><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>Redis提供了基于“发布/订阅”模式的消息机制， 此种模式下， 消息发布者和订阅者不进行直接通信， 发布者客户端向指定的频道（ channel） 发布消息， 订阅该频道的每个客户端都可以收到该消息。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/EF0A7529-5032-477A-BBFD-081630DDC5D1.png" width="70%"></p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Redis主要提供了发布消息、 订阅频道、 取消订阅以及按照模式订阅和取消订阅等命令</span><br><span class="line"><span class="meta">#</span> 发布消息</span><br><span class="line">publish channel message  返回订阅者人数</span><br><span class="line"><span class="meta">#</span> 订阅消息</span><br><span class="line">subscribe channel [channel...]</span><br><span class="line"><span class="meta">#</span> 取消订阅</span><br><span class="line">unsubscribe channel</span><br><span class="line"><span class="meta">#</span> 查询至少有一个订阅者的频道</span><br><span class="line">pubsub channels pattern</span><br><span class="line"><span class="meta">#</span> 查看频道订阅数</span><br><span class="line">pubsub numsub channel</span><br><span class="line"></span><br><span class="line">客户端在执行订阅命令之后进入了订阅状态， 只能接收subscribe、psubscribe、 unsubscribe、 punsubscribe的四个命令</span><br></pre></td></tr></table></figure><p>和很多专业的消息队列系统（ 例如Kafka、 RocketMQ） 相比， Redis的发布订阅略显粗糙， 例如无法实现消息堆积和回溯。 但胜在足够简单， 如果当前场景可以容忍的这些缺点， 也不失为一个不错的选择。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis单线程架构与五种数据类型应用</title>
      <link href="/2018/01/25/Redis%20%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
      <url>/2018/01/25/Redis%20%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Redis 单线程架构与五种数据类型应用</p><p>Redis 所有数据都是存放在内存中的，所以把数据放在内存中是Redis速度快的最主要原因。Redis 使用C语言实现的，执行速度相对会更快。Redis 使用了单线程架构，预防了多线程可能产生的竞争问题。</p><h4 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看所有键</span><br><span class="line">keys *</span><br><span class="line"><span class="meta">#</span> 键总数</span><br><span class="line">dbsize</span><br><span class="line"><span class="meta">#</span> 判断键是否存在</span><br><span class="line">exists key</span><br><span class="line"><span class="meta">#</span> 删除键</span><br><span class="line">del key</span><br><span class="line"><span class="meta">#</span> 键过期</span><br><span class="line">expire key second</span><br><span class="line"><span class="meta">#</span> 键的数据结构类型</span><br><span class="line">type key</span><br></pre></td></tr></table></figure><h3 id="单线程架构"><a href="#单线程架构" class="headerlink" title="单线程架构"></a>单线程架构</h3><p>Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。</p><p>因为Redis是单线程来处理命令的， 所以一条命令从客户端达到服务端不会立刻被执行， 所有命令都会进入一个队列中， 然后逐个被执行。</p><h5 id="为什么单线程这么快"><a href="#为什么单线程这么快" class="headerlink" title="为什么单线程这么快"></a>为什么单线程这么快</h5><p>第一， 纯内存访问， Redis将所有数据放在内存中， 内存的响应时长大约为100纳秒， 这是Redis达到每秒万级别访问的重要基础。第二， 非阻塞I/O， Redis使用epoll作为I/O多路复用技术的实现， 再加上Redis自身的事件处理模型将epoll中的连接、 读写、 关闭都转换为事件， 不在网络I/O上浪费过多的时间。第三， 单线程避免了线程切换和竞态产生的消耗。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>批量操作指令MGET key1 key2 和MSET key1 v1 key2 v2 可以有效提高开发效率，没有和有的区别如图</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/2F7AA334-EDCA-4C47-A7AA-3B50BA7FBAD3.png" width="50%"><img src="http://one-1252095801.cosgz.myqcloud.com/304090BC-CC2A-45AB-8521-2D67DE1A5D4A.png" width="50%"></p><p>Redis可以支撑每秒数万的读写操作， 但是这指的是Redis服务端的处理能力， 对于客户端来说， 一次命令除了命令时间还是有网络时间.</p><p>字符串类型的内部编码有3种：·int： 8个字节的长整型。·embstr： 小于等于39个字节的字串。 ·raw： 大于39个字节的字符串。Redis会根据当前值的类型和长度决定使用哪种内部编码实现。</p><h5 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h5><p>1 缓存功能</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/21DE2EDA-4F09-4C97-9D61-C6989500C409.png" width="50%"></p><p>2 计数</p><p>3 共享Session</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/C5D50654-9151-41CC-B8B9-E38CF87F1474.png" width="40%"></p><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>哈希类型的内部编码有两种：<br>·ziplist（ 压缩列表） ： 当哈希类型元素个数小于hash-max-ziplist-entries配置（ 默认512个） 、 同时所有值都小于hash-max-ziplist-value配置（ 默认64字节） 时， Redis会使用ziplist作为哈希的内部实现， ziplist使用更加紧凑的结构实现多个元素的连续存储， 所以在节省内存方面比hashtable更加优秀。<br>·hashtable（ 哈希表） ： 当哈希类型无法满足ziplist的条件时， Redis会使用hashtable作为哈希的内部实现， 因为此时ziplist的读写效率会下降， 而hashtable的读写时间复杂度为O（ 1）</p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>用哈希表缓存用户信息，将每个用户的ID定义为键的后缀，多对field-value 对应每个用户的属性。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表是一种比较灵活的数据结构， 它可以充当栈和队列的角色， 在实际开发上有很多应用场景。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/4AFEB8AB-70DC-48F2-9AA4-8759FE92D333.png" width="50%"><img src="http://one-1252095801.cosgz.myqcloud.com/0F66D454-78F2-45EC-AFC2-E75F5B525739.png" width="50%"></p><p>列表类型有两个特点： 第一、 列表中的元素是有序的， 这就意味着可以通过索引下标获取某个元素或者某个范围内的元素列表.第二、 列表中的元素可以是重复的.</p><p>列表类型的内部编码有两种。·ziplist（ 压缩列表） ： 当列表的元素个数小于list-max-ziplist-entries配置（ 默认512个） ， 同时列表中每个元素的值都小于list-max-ziplist-value配置时（ 默认64字节） ， Redis会选用ziplist来作为列表的内部实现来减少内存的使用。·linkedlist（ 链表） ： 当列表类型无法满足ziplist的条件时， Redis会使用linkedlist作为列表的内部实现。</p><h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><p>1 消息队列 Redis的lpush+brpop命令组合即可实现阻塞队列， 生产者客户端使用lrpush从列表左侧插入元素， 多个消费者客户端使用brpop命令阻塞式的“抢”列表尾部的元素， 多个客户端保证了消费的负载均衡和高可用性</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/62AB18CF-51F0-47D8-8332-CCAF72E3B501.png" width="50%"></p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合中不允许有重复元素， 并且集合中的元素是无序的， 不能通过索引下标获取元素。</p><p>集合类型的内部编码有两种：·intset（ 整数集合） ： 当集合中的元素都是整数且元素个数小于set-maxintset-entries配置（ 默认512个） 时， Redis会选用intset来作为集合的内部实现， 从而减少内存的使用。·hashtable（ 哈希表） ： 当集合类型无法满足intset的条件时， Redis会使用hashtable作为集合的内部实现。</p><h5 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h5><p>集合类型比较典型的使用场景是标签（ tag）</p><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>有序集合中的元素可以排序。 但是它和列表使用索引下标作为排序依据不同的是， 它给每个元素设置一个分数（ score） 作为排序的依据。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/A85B1CB0-AB02-49CE-877B-47AF62CB46C8.png" width="50%"></p><p>该有序集合包含kris、 mike、 frank、 tim、 martin、 tom，它们的分数分别是1、 91、 200、 220、 250、 251， 有序集合提供了获取指定分数和元素范围查询、 计算成员排名等功能.元素不能重复，分数可以重复。</p><p>有序集合类型的内部编码有两种：·ziplist（ 压缩列表） ： 当有序集合的元素个数小于zset-max-ziplistentries配置（ 默认128个） ， 同时每个元素的值都小于zset-max-ziplist-value配置（ 默认64字节） 时， Redis会用ziplist来作为有序集合的内部实现， ziplist可以有效减少内存的使用。·skiplist（ 跳跃表） ： 当ziplist条件不满足时， 有序集合会使用skiplist作为内部实现， 因为此时ziplist的读写效率会下降。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis总结</title>
      <link href="/2018/01/24/Mybatis%E6%80%BB%E7%BB%93/"/>
      <url>/2018/01/24/Mybatis%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Mybatis-入门"><a href="#Mybatis-入门" class="headerlink" title="Mybatis 入门"></a>Mybatis 入门</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="从XML中构建SqlSessionFactory"><a href="#从XML中构建SqlSessionFactory" class="headerlink" title="从XML中构建SqlSessionFactory"></a>从XML中构建SqlSessionFactory</h4><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"org/mybatis/example/mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure><h4 id="从-SqlSessionFactory-中获取-SqlSession"><a href="#从-SqlSessionFactory-中获取-SqlSession" class="headerlink" title="从 SqlSessionFactory 中获取 SqlSession"></a>从 SqlSessionFactory 中获取 SqlSession</h4><p>既然有了 SqlSessionFactory ，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="探究已映射的SQL语句"><a href="#探究已映射的SQL语句" class="headerlink" title="探究已映射的SQL语句"></a>探究已映射的SQL语句</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.mybatis.example.BlogMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在一个 XML 映射文件中，你想定义多少个映射语句都是可以的，这样下来，XML 头部和文档类型声明占去的部分就显得微不足道了。文件的剩余部分具有很好的自解释性。在命名空间“org.mybatis.example.BlogMapper”中定义了一个名为“selectBlog”的映射语句，这样它就允许你使用指定的完全限定名“org.mybatis.example.BlogMapper.selectBlog”来调用映射语句</p><h4 id="作用域与声明周期"><a href="#作用域与声明周期" class="headerlink" title="作用域与声明周期"></a>作用域与声明周期</h4><h5 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h5><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</p><h5 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h5><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><h5 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h5><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理作用域中，比如 Servlet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。</p><h3 id="Mapper-XML文件"><a href="#Mapper-XML文件" class="headerlink" title="Mapper XML文件"></a>Mapper XML文件</h3><p>SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）：</p><ul><li><code>cache</code> – 给定命名空间的缓存配置。</li><li><code>cache-ref</code> – 其他命名空间缓存配置的引用。</li><li><code>resultMap</code> – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</li><li><code>sql</code> – 可被其他语句引用的可重用语句块。</li><li><code>insert</code> – 映射插入语句</li><li><code>update</code> – 映射更新语句</li><li><code>delete</code> – 映射删除语句</li><li><code>select</code> – 映射查询语句</li></ul><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPerson"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"hashmap"</span>&gt;</span></span><br><span class="line">  SELECT * FROM PERSON WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>#{id}</code>会告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中.</p><p>参数:</p><ul><li>id :在命名空间中唯一的标识符，可以被用来引用这条语句。</li></ul><ul><li>parameterType :将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</li><li>resultType: 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。</li><li>resultMap: 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，使用 resultMap 或 resultType，但不能同时使用。</li><li>flushCache: 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。</li><li>useCache: 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。</li><li>timeout: 在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。</li></ul><h4 id="insert-update-和delete"><a href="#insert-update-和delete" class="headerlink" title="insert update 和delete"></a>insert update 和delete</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertAuthor"</span> <span class="attr">parameterType</span>=<span class="string">"domain.blog.Author"</span>  <span class="attr">flushCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">statementType</span>=<span class="string">"PREPARED"</span> <span class="attr">keyProperty</span>=<span class="string">""</span>  <span class="attr">keyColumn</span>=<span class="string">""</span>  <span class="attr">useGeneratedKeys</span>=<span class="string">""</span> <span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateAuthor"</span> <span class="attr">parameterType</span>=<span class="string">"domain.blog.Author"</span> <span class="attr">flushCache</span>=<span class="string">"true"</span> <span class="attr">statementType</span>=<span class="string">"PREPARED"</span> <span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteAuthor"</span> <span class="attr">parameterType</span>=<span class="string">"domain.blog.Author"</span> <span class="attr">flushCache</span>=<span class="string">"true"</span> <span class="attr">statementType</span>=<span class="string">"PREPARED"</span> <span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>parameterType :将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</p></li><li><p>useGeneratedKeys: （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</p></li><li><p>keyProperty: (仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：<code>unset</code>。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</p></li><li><p>如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就OK了。例如，如果上面的 Author 表已经对 id 使用了自动生成的列类型，那么语句可以修改为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertAuthor"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">  insert into Author (username,password,email,bio)</span><br><span class="line">  values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h4><p>这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化. 比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"userColumns"</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 SQL 片段可以被包含在其他语句中，例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t1"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t2"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  from some_table t1</span><br><span class="line">    cross join some_table t2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h4><p>resultMap 元素是 MyBatis 中最重要最强大的元素。 ResultMap 的设计就是简单语句不需要明确的结果映射,而很多复杂语句确实需要描述它们的关系。</p><p>例如下面的Java Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.someapp.model;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String hashedPassword;</span><br><span class="line"> <span class="comment">//省略get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的一个 JavaBean 可以被映射到结果集,就像映射到 HashMap 一样简单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"com.someapp.model.User"</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>这些情况下,MyBatis 会在幕后自动创建一个 ResultMap,基于属性名来映射列到 JavaBean 的属性上。</strong>如果列名没有精确匹配,你可以在列名上使用 select 字句的别名(一个 基本的 SQL 特性)来匹配标签。比如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    user_id(数据库字段)   as "id"(javabean 字段,通过as来自动创建ResultMap),</span><br><span class="line">    user_name           as "username",</span><br><span class="line">    hashed_password     as "hashedPassword"</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是更常用的是下面的自动创建方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"user_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"user_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"hashed_password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="高级结果映射"><a href="#高级结果映射" class="headerlink" title="高级结果映射"></a>高级结果映射</h4><p>how to do  with it ?</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlogDetails"</span> <span class="attr">resultMap</span>=<span class="string">"detailedBlogResultMap"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">       B.id as blog_id,</span><br><span class="line">       B.title as blog_title,</span><br><span class="line">       B.author_id as blog_author_id,</span><br><span class="line">       A.id as author_id,</span><br><span class="line">       A.username as author_username,</span><br><span class="line">       A.password as author_password,</span><br><span class="line">       A.email as author_email,</span><br><span class="line">       A.bio as author_bio,</span><br><span class="line">       A.favourite_section as author_favourite_section,</span><br><span class="line">       P.id as post_id,</span><br><span class="line">       P.blog_id as post_blog_id,</span><br><span class="line">       P.author_id as post_author_id,</span><br><span class="line">       P.created_on as post_created_on,</span><br><span class="line">       P.section as post_section,</span><br><span class="line">       P.subject as post_subject,</span><br><span class="line">       P.draft as draft,</span><br><span class="line">       P.body as post_body,</span><br><span class="line">       C.id as comment_id,</span><br><span class="line">       C.post_id as comment_post_id,</span><br><span class="line">       C.name as comment_name,</span><br><span class="line">       C.comment as comment_text,</span><br><span class="line">       T.id as tag_id,</span><br><span class="line">       T.name as tag_name</span><br><span class="line">  from Blog B</span><br><span class="line">       left outer join Author A on B.author_id = A.id</span><br><span class="line">       left outer join Post P on B.id = P.blog_id</span><br><span class="line">       left outer join Comment C on P.id = C.post_id</span><br><span class="line">       left outer join Post_Tag PT on PT.post_id = P.id</span><br><span class="line">       left outer join Tag T on PT.tag_id = T.id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>resultMap中的子标签</p><p><code>constructor</code> - 类在实例化时,用来注入结果到构造方法中.</p><ul><li><code>idArg</code> - ID 参数;标记结果作为 ID 可以帮助提高整体效能</li><li><code>arg</code> - 注入到构造方法的一个普通结果</li></ul><p><code>id</code> – 一个 ID 结果;标记结果作为 ID 可以帮助提高整体效能</p><p><code>result</code> – 注入到字段或 JavaBean 属性的普通结果</p><p><code>association</code> – 一个复杂的类型关联;许多结果将包成这种类型</p><p><code>collection</code> – 复杂类型的集</p><p><code>discriminator</code> – 使用结果值来决定使用哪个结果映射</p><h5 id="id-result"><a href="#id-result" class="headerlink" title="id result"></a>id result</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>常用属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>property</code></td><td>映射到列结果的 JavaBean的字段或属性。如果匹配的是存在的,和给定名称相同 的 JavaBeans 的属性,那么就会使用。否则 MyBatis 将会寻找给定名称 property 的字段。</td></tr><tr><td><code>column</code></td><td>从数据库中得到的列名,或者是列名的重命名标签。</td></tr><tr><td><code>javaType</code></td><td>一个 Java 类的完全限定名,或一个类型别名(参考上面内建类型别名 的列表) 。如果你映射到一个 JavaBean,MyBatis 通常可以断定类型。 然而,如果你映射到的是 HashMap,那么你应该明确地指定 javaType 来保证所需的行为。</td></tr><tr><td><code>jdbcType</code></td><td>支持的 JDBC 类型列表中的类型。<strong>JDBC 类型是仅仅需要对插入,更新和删除操作可能为空的列进行处理</strong>。这是 JDBC jdbcType 的需要,而不是 MyBatis 的。</td></tr><tr><td><code>typeHandler</code></td><td>我们在前面讨论过默认的类型处理器。使用这个属性,你可以覆盖默认的类型处理器。这个属性值是类的完全限定名或者是一个类型处理 器的实现,或者是类型别名。</td></tr></tbody></table><h5 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">column</span>=<span class="string">"blog_author_id"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>property</code></td><td>映射到列结果的字段或属性。如果匹配的是存在的,和给定名称相同的 property JavaBeans 的属性, 那么就会使用。 否则 MyBatis 将会寻找给定名称的字段。</td></tr><tr><td><code>javaType</code></td><td>一个 Java 类的完全限定名,或一个类型别名</td></tr><tr><td><code>jdbcType</code></td><td>在这个表格之前的所支持的 JDBC 类型列表中的类型。JDBC 类型是仅仅 需要对插入, 更新和删除操作可能为空的列进行处理。这是 JDBC 的需要, jdbcType 而不是 MyBatis 的。</td></tr><tr><td><code>typeHandler</code></td><td>我们在前面讨论过默认的类型处理器。使用这个属性,你可以覆盖默认的 typeHandler 类型处理器。 这个属性值是类的完全限定名或者是一个类型处理器的实现, 或者是类型别名。</td></tr></tbody></table><p>关联中不同的是你需要告诉 MyBatis 如何加载关联。MyBatis 在这方面会有两种不同的 方式:</p><ul><li>嵌套查询:通过执行另外一个 SQL 映射语句来返回预期的复杂类型。</li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>column</code></td><td>来自数据库的类名,或重命名的列标签。</td></tr><tr><td><code>select</code></td><td>另外一个映射语句的 ID,可以加载这个属性映射需要的复杂类型。获取的 在列属性中指定的列的值将被传递给目标 select 语句作为参数。</td></tr><tr><td><code>fetchType</code></td><td>可选的。有效值为 <code>lazy</code>和<code>eager</code>。 如果使用了，它将取代全局配置参数<code>lazyLoadingEnabled</code>。</td></tr></tbody></table><p>示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">column</span>=<span class="string">"author_id"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span> <span class="attr">select</span>=<span class="string">"selectAuthor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAuthor"</span> <span class="attr">resultType</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">  SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>嵌套结果:使用嵌套结果映射来处理重复的联合结果的子集。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">column</span>=<span class="string">"blog_author_id"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span> <span class="attr">resultMap</span>=<span class="string">"authorResult"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"authorResult"</span> <span class="attr">type</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"author_password"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"email"</span> <span class="attr">column</span>=<span class="string">"author_email"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bio"</span> <span class="attr">column</span>=<span class="string">"author_bio"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"domain.blog.Post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"body"</span> <span class="attr">column</span>=<span class="string">"post_body"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>嵌套查询</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">javaType</span>=<span class="string">"ArrayList"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span> <span class="attr">select</span>=<span class="string">"selectPostsForBlog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPostsForBlog"</span> <span class="attr">resultType</span>=<span class="string">"Post"</span>&gt;</span></span><br><span class="line">  SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意那个新的“ofType”属性。这个属性用来区分 JavaBean(或字段)属性类型和集合包含的类型来说是很重要的。所以你可以读出下面这个 映射:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">javaType</span>=<span class="string">"ArrayList"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span> <span class="attr">select</span>=<span class="string">"selectPostsForBlog"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>读作: “在 Post 类型的 ArrayList 中的 posts 的集合。”</p><p>javaType 属性是不需要的,因为 MyBatis 在很多情况下会为你算出来。所以你可以缩短 写法:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span> <span class="attr">select</span>=<span class="string">"selectPostsForBlog"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>嵌套结果</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"body"</span> <span class="attr">column</span>=<span class="string">"post_body"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。MyBatis 3 中的缓存实现的很多改进都已经实现了,使得它更加强大而且易于配置。</p><p>默认情况下是没有开启缓存的,除了局部的 session 缓存,可以增强变现而且处理循环 依赖也是必须的。要开启二级缓存,你需要在你的 SQL 映射文件中添加一行:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>字面上看就是这样。这个简单语句的效果如下:</p><ul><li>映射语句文件中的所有 select 语句将会被缓存。</li><li>映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。</li><li>缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。</li><li>根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。</li><li>缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。</li><li>缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目总结</title>
      <link href="/2018/01/22/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2018/01/22/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="项目总结-不断更新"><a href="#项目总结-不断更新" class="headerlink" title="项目总结(不断更新)"></a>项目总结(不断更新)</h3><p>1 jsp文件在最上面加page指令</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br></pre></td></tr></table></figure><p>2 通过request 访问工程根路径</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%=request.getScheme()+ <span class="string">"://"</span> + request.getServerName()+<span class="string">":"</span>+request.getServerPort()+request.getContextPath()%&gt;</span><br></pre></td></tr></table></figure><p>3 共通jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% </span><br><span class="line">String basePath = request.getScheme() + <span class="string">"://"</span> + request.getServerName() + <span class="string">":"</span> + request.getServerPort() + request.getContextPath();</span><br><span class="line">request.setAttribute(<span class="string">"basePath"</span>,basePath);</span><br><span class="line">%&gt;</span><br><span class="line"><span class="comment">// web.xml 有一个为所有页面引入其他页面的配置</span></span><br><span class="line"> &lt;jsp-config&gt;</span><br><span class="line">&lt;jsp-property-group&gt;</span><br><span class="line">&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</span><br><span class="line">&lt;include-prelude&gt;/WEB-INF/jsp/system/common.jsp&lt;/include-prelude&gt;</span><br><span class="line">&lt;/jsp-property-group&gt;</span><br><span class="line">&lt;/jsp-config&gt;</span><br></pre></td></tr></table></figure><p>4 foreach 的使用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">"$&#123;list&#125;"</span> var=<span class="string">"item"</span> varStatus=<span class="string">"s"</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;$&#123;s.index + 1&#125;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;$&#123;item.title&#125;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;$&#123;item.link&#125;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>5 提交文件</p><p>首先,DTO中有一个Spring 封装的类型字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MultipartFile imgFile;</span><br></pre></td></tr></table></figure><p>然后使用transferTo()方法,里面的参数是File f =new File() 的f</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adDto.getImgFile().transferTo();</span><br></pre></td></tr></table></figure><p>6 真实部署环境</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/6B81C13616A6829F8CF3EC5CF07E1320.jpg" width="70%"></p><p>用户通过app,先访问硬负载,然后访问nginx,nginx都过负载均衡把请求散发到接口服务集群,接口服务集群和数据库服务器之间有一个缓存服务器来避免大量的数据库访问,同时,后台管理服务器由于几乎没有并发可以直接访问数据库服务器,同时,静态资源直接通过nginx来访问来加快访问速度,后台服务器也可以直接访问静态资源,数据库服务器中只保存图片的地址.</p><p>7 spring 读取配置文件的配置@Value注解.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;ad.path&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String path;</span><br></pre></td></tr></table></figure><p>8 返回码的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PageCodeEnum &#123;</span><br><span class="line">    ADD_SUCCESS(<span class="number">1000</span>,<span class="string">"新增成功"</span>),</span><br><span class="line">    ADD_FAIL(<span class="number">1001</span>,<span class="string">"新增失败"</span>);</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY=<span class="string">"pageCode"</span>;</span><br><span class="line">    PageCodeEnum(Integer code,String msg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.code=code;</span><br><span class="line">        <span class="keyword">this</span>.msg=msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回码的思路,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//写入数据库后,同时写入model</span><br><span class="line">model.addAttribute(PageCodeEnum.KEY,PageCodeEnum.ADD_FAIL);</span><br><span class="line">还进入原来的页面,这个页面中有一个hidden,所以在jsp中埋得值接收到了,接收到后,前端js在页面加载前先判断hidden是否为空.就输出了.</span><br></pre></td></tr></table></figure><p>9 缓存要处理的一些常见问题</p><ul><li>集群化部署单机内缓存共享</li></ul><p>1) 利用nginx 的转发规则,配置IPhash,根据请求用户的IP分配服务器</p><p>2) 使用redis 共享缓存</p><ul><li>同一用户高并发的重复请求</li><li>处理缓存失效</li></ul><p>10 Ajax 拿不到枚举类型的里面的值,只能拿到外面的字符串,要想前端ajax获取,可以再封装一层DTO,写一个新的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ApiCodeDto</span><span class="params">(ApiCodeEnum apiCodeEnum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.errno = apiCodeEnum.getErrno();</span><br><span class="line"><span class="keyword">this</span>.msg = apiCodeEnum.getMsg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11 前后端都必须通过JSON格式传输数据. SpringMVC返回ajax 时一定记得加@ResponseBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"aaa"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AppleDto <span class="title">go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AppleDto appleDto =<span class="keyword">new</span> AppleDto(<span class="string">"apple"</span>,<span class="string">"red"</span>);</span><br><span class="line">        System.out.println(<span class="string">"1111"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> appleDto;</span><br><span class="line"><span class="comment">//自动返回JSON</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">       $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">"123"</span>)</span><br><span class="line">           $.ajax(&#123;</span><br><span class="line">               url: <span class="string">"/aaa"</span>,<span class="comment">//请求接口</span></span><br><span class="line">               type: <span class="string">"POST"</span>,<span class="comment">//请求方式</span></span><br><span class="line">               <span class="comment">//请求参数</span></span><br><span class="line">               dataType: <span class="string">"json"</span>,<span class="comment">//响应类型</span></span><br><span class="line">               success: <span class="function"><span class="keyword">function</span>(<span class="params">data, textStatus</span>)</span>&#123;<span class="comment">//访问成功的回调函数，参数是响应，描述状态的字符串</span></span><br><span class="line">                   <span class="built_in">console</span>.log(textStatus)</span><br><span class="line">                   <span class="built_in">console</span>.log(data.name);</span><br><span class="line">               &#125;,</span><br><span class="line">               error: <span class="function"><span class="keyword">function</span>(<span class="params">XMLHttpRequest, textStatus, errorThrown</span>)</span>&#123;<span class="comment">//访问失败的回调函数，参数是XMLHttpRequest对象、错误信息、捕获的错误对象(可选);</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;);</span><br><span class="line">   &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> QA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24. Swap Nodes in Pairs</title>
      <link href="/2018/01/20/leetcode24/"/>
      <url>/2018/01/20/leetcode24/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ol><li><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p><p>Your algorithm should use only constant space. You may <strong>not</strong> modify the values in the list, only nodes itself can be changed.</p></li></ol><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>改变相邻两个节点的顺序.<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        ListNode* prev=dummy;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp;head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* nn=head-&gt;next-&gt;next;</span><br><span class="line">            prev-&gt;next=head-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;next=head;</span><br><span class="line">            head-&gt;next=nn;</span><br><span class="line">            prev=head;</span><br><span class="line">            head=nn; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><img src="http://one-1252095801.cosgz.myqcloud.com/1881516439954_.pic.jpg" alt=""></p><p>指针的赋值操作中,左边指的是某个域,右边指的是某个位置.</p><p>p = q-&gt;next;       //这里是把q-&gt;next指针的值赋予p，即让p指向q-&gt;next指向的位置。</p><p>q-&gt;next = p;       //这里把p赋予q-&gt;next，即把q的next域指向p指向的位置。</p><p>q-&gt;next-&gt;next =p;    //q-&gt;next 这个节点的next域指向p指向的位置</p><p>等式左边没有next, 就指针跟着动 像上面 1和4 ,左边有next ,最后的一个next是指指针域,前面的next找到对应的节点.</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19. Remove Nth Node From End of List</title>
      <link href="/2018/01/20/leetcode19/"/>
      <url>/2018/01/20/leetcode19/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a linked list, remove the <em>n</em>th node from the end of list and return its head.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong><br>Given <em>n</em> will always be valid.<br>Try to do this in one pass.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>给一个链表,n代表从后往前数,删除这个节点,返回删除后的链表.<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number =<span class="number">1</span>;</span><br><span class="line">        ListNode* h=head;</span><br><span class="line">        ListNode* h2 = head;</span><br><span class="line">        <span class="keyword">while</span>(h-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            number++;</span><br><span class="line">            h =h-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> g = number -n+<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span>(g&gt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            h2=h2-&gt;next;</span><br><span class="line">            g--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            h2-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span>(number==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode * i=<span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            h2-&gt;next = h2-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>上面的是自己第一次写的,感觉好麻烦.毕竟扫描了两次,第一次得到总的数量,第二次再进行删除</p><p>实际应该使用双指针,然后就只用进行一次扫描了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode* kuai = head; <span class="comment">//设置快指针</span></span><br><span class="line">        ListNode* man =head; <span class="comment">//设置慢指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            kuai =kuai-&gt;next; <span class="comment">//首先让快指针先走,这样当快指针走到头的时候,</span></span><br><span class="line">          <span class="comment">//刚好慢指针就到了要删除的地方</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(kuai==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;  <span class="comment">// 块指针为空的话,直接返回head-&gt;next;</span></span><br><span class="line">        <span class="keyword">while</span>(kuai-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;<span class="comment">//快慢一起走</span></span><br><span class="line">            kuai =kuai-&gt;next;</span><br><span class="line">            man =man-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        man-&gt;next =man-&gt;next-&gt;next; <span class="comment">//进行删除操作.</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发包和内存模型</title>
      <link href="/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E5%92%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E5%92%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="Java内存模型的基础"><a href="#Java内存模型的基础" class="headerlink" title="Java内存模型的基础"></a>Java内存模型的基础</h3><p>并发编程中，需要处理两个关键问题，线程之间如何通信和线程之间如何同步。通信是指线程之间以何种机制来交换信息，线程间的通信机制有两种，共享内存和消息传递。</p><p>在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信，</p><p>Java的并发采用的是<strong>共享内存模型</strong>，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>Java线程之间的通信由Java内存模型JMM控制，JMM决定一个线程对共此享变量的写入何时对另一个线程可见，从抽象的角度讲，JMM定义了线程和主内存之间的抽象关系。</p><p>Java 内存模型把虚拟机内部划分为线程栈和堆。　每一个运行在Java虚拟机中的线程都有自己的线程栈。线程栈包含了这个线程调用的方法当前执行点相关的信息。一个线程只能访问自己的线程栈。一个线程创建的本地变量对其他线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。所有原始类型的本地变量都存放在线程栈上，因此对其他线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/2017-10-21-2.png" alt=""></p><p>一个本地变量可能是原始类型，这种情况下，它总是待在线程栈上。</p><p>一个本地变量也可能是指向一个对象的一个引用，这种情况下，这个引用存放在线程栈上，对象本身还是在堆中。</p><p>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。</p><p>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</p><p>静态成员变量跟随着类定义一起也存放在堆上。</p><p>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/2017-10-21-3.png" alt=""></p><h4 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens - before规则"></a>happens - before规则</h4><p>JDK5开始，使用happens-before的概念来阐述操作之间的内存可见性，在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，这两个操作可以是一个线程内，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</span><br><span class="line"><span class="number">2</span> 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</span><br><span class="line"><span class="number">3</span> <span class="keyword">volatile</span> 变量规则：对一个<span class="keyword">volatile</span>域的写，happens-before于任意后续对这个<span class="keyword">volatile</span>域的读。</span><br><span class="line"><span class="number">4</span> 传递性：如果A happens-before B B happens-before C 那么A happens-before C</span><br><span class="line"><span class="number">5</span> start()规则：如果线程A执行ThreadB.start()(启动线程B)那么A线程的threadB.start()操作happens-before 线程B中的任意操作。</span><br><span class="line"><span class="number">6</span> join规则：如果线程A执行ThreadB.join()并成功返回，那么B中的任意操作happens-before线程A从ThreadB.join()操作成功返回。</span><br></pre></td></tr></table></figure><p>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行，happens-before仅仅要求前一个操作的结果对后一个操作可见，且前一个操作按顺序排在第二个操作之前。</p><h4 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h4><p>As-if-serial 的意思是 不管怎么重排序，程序的执行结果不能被改变，编译器，runtime和处理器都必须遵守as-if-serial 语义。</p><p>为了遵守as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果，但是，如果操作之前不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><h3 id="顺序一致性（理想化的模型）"><a href="#顺序一致性（理想化的模型）" class="headerlink" title="顺序一致性（理想化的模型）"></a>顺序一致性（理想化的模型）</h3><p>顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参照。</p><p>顺序一致性模型有两大特性1 一个线程中的所有操作必须按照程序的顺序来执行。</p><p>2（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序，在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%888.27.48.png" width="50%"></p><h4 id="volatile-的内存语义"><a href="#volatile-的内存语义" class="headerlink" title="volatile 的内存语义"></a>volatile 的内存语义</h4><ul><li>特性：可见性 原子性</li></ul><p>锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile 变量的读，总是能看到任意线程对这个volatile 变量最后的写入。</p><p>同时，对任意单个volatile变量的读、写具有原子性，但类似volaile++这种复合操作不具有原子性。</p><ul><li>写-读的内存语义</li></ul><p>线程A写一个volatile变量，实质上是线程A向接下来将要读这个变量的某个线程发出了（其对共享变量所做修改的）消息</p><p>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出（在写这个volatile变量之前对共享变量所做修改的）消息。</p><p>线程A写一个volatile变量，随后线程B读这个volatile 变量，这个过程实质上是线程A通过主内存向线程B发送消息。</p><p><strong>内存语义的实现主要通过插入内存屏障来实现</strong></p><h4 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h4><p>锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p><p>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量做修改的）消息</p><p>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息</p><p>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</p><h2 id="Current包的实现"><a href="#Current包的实现" class="headerlink" title="Current包的实现"></a>Current包的实现</h2><p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p><ol><li>A线程写volatile变量，随后B线程读这个volatile变量。</li><li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li></ol><a id="more"></a><p>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p><ol><li>首先，声明共享变量为volatile；</li><li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li><li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li></ol><p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/171111.png" width="50%"></p><p>## </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程之Executor框架</title>
      <link href="/2018/01/19/Executor%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/01/19/Executor%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>Java的线程既是工作单元,也是执行机制。从JDK 5开始,把工作单元与执行机制分离开<br>来。工作单元包括Runnable和Callable,而执行机制由Executor框架提供。</p><a id="more"></a><h3 id="Executor-框架简介"><a href="#Executor-框架简介" class="headerlink" title="Executor 框架简介"></a>Executor 框架简介</h3><h5 id="Executor的两级调度模型"><a href="#Executor的两级调度模型" class="headerlink" title="Executor的两级调度模型"></a>Executor的两级调度模型</h5><p>在HotSpot VM的线程模型中,Java线程(java.lang.Thread)被一对一映射为本地操作系统线程。Java线程启动时会创建一个本地操作系统线程;当该Java线程终止时,这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的CPU。</p><p>在上层,Java多线程程序通常把<strong>应用分解为若干个任务,然后使用用户级的调度器(Executor框架)将这些任务映射为固定数量的线程</strong>;在底层,操作系统内核将这些线程映射到硬件处理器上。这种两级调度模型的示意图如下图所示。从图中可以看出,应用程序通过Executor框架控制上层的调度;而下层的调度由操作系统内核控制,下层的调度不受应用程序的控制。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/171116.png" width="50%"></p><h5 id="Executor框架的结构与成员"><a href="#Executor框架的结构与成员" class="headerlink" title="Executor框架的结构与成员"></a>Executor框架的结构与成员</h5><p>首先是结构: Executor 框架主要由三大部分组成</p><ul><li>任务。包括被执行任务需要实现的接口:Runnable接口或Callable接口。</li><li>任务的执行。包括任务执行机制的核心接口Executor,以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口(<strong>ThreadPoolExecutor</strong>和<strong>ScheduledThreadPoolExecutor</strong>)。</li><li>异步计算的结果。包括接口Future和实现Future接口的FutureTask类。</li></ul><p>下面是类和接口的简介</p><ul><li>Executor是一个接口,它是Executor框架的基础,它将任务的提交与任务的执行分离开来。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然Executor是一个简单的接口,那是它为灵活且强大的异步任务执行框架提供了基础,它提供了一种标准的方法把任务的提交过程和执行过程解耦开来.</p><ul><li>ThreadPoolExecutor是线程池的核心实现类,实现了ExecutorService 接口，用来执行被提交的任务。</li><li>ScheduledThreadPoolExecutor是一个实现类,也实现了ExecutorService 接口，可以在给定的延迟后运行命令,或者定期执行命令。ScheduledThreadPoolExecutor比Timer更灵活,功能更强大。</li><li>Future接口和实现Future接口的FutureTask类,代表异步计算的结果。</li><li>Runnable接口和Callable接口的实现类,都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。</li></ul><p>使用示意图如下:</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-19%20%E4%B8%8A%E5%8D%889.27.19.png" width="70%"></p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/1711161.png" width="60%"></p><h6 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h6><p>主线程首先要创建实现Runnable或者Callable接口的任务对象。工具类Executors可以把一个Runnable对象封装为一个Callable对象(<code>Executors.callable(Runnable task)</code>或<code>Executors.callable(Runnable task,Object resule)</code>)。<br>然后可以把Runnable对象直接交给ExecutorService执行(<code>ExecutorService.execute(Runnable command)</code>);或者也可以把Runnable对象或Callable对象提交给ExecutorService执行(<code>ExecutorService.submit(Runnable task)</code>或<code>ExecutorService.submit(Callable&lt;T&gt;task)</code>)。</p><p>如果执行<code>ExecutorService.submit(...)</code>,ExecutorService将返回一个实现Future接口的对象(到目前为止的JDK中,返回的是FutureTask对象)。由于FutureTask实现了Runnable,程序员也可以创建FutureTask,然后直接交给ExecutorService执行。<br>最后,主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行<code>FutureTask.cancel(boolean mayInterruptIfRunning)</code>来取消此任务的执行。</p><h3 id="框架成员"><a href="#框架成员" class="headerlink" title="框架成员"></a>框架成员</h3><p>介绍Executor框架的主要成员:ThreadPoolExecutor, ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</p><ul><li>ThreadPoolExecutor</li></ul><p>ThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建3种类型的ThreadPoolExecutor:SingleThreadExecutor、FixedThreadPool和CachedThreadPool。</p><p>其中,</p><hr><p>FixedThreadPool是创建固定线程数的API,FixedThreadpool适用于为了满足资源管理的需求,而需要限制当前线程数量的应用场景,适用于负载较重的服务器.使用的队列是LinkedBlcokingQueue。</p><hr><p>singleThreadExecutor是创建单个线程的SingleThreadExecutor的API，使用的队列也是LinkedBlockingQueue。</p><hr><p>CachedThreadPool。创建一个会根据需要创建新线程的CachedThreadPool的API。CachedThreadPool 是大小无界的线程池,适用于执行很多的短期异步任务的小程序,或者是负载较轻的服务器.使用的是SynchronousQueue。</p><hr><ul><li>ScheduledThreadPoolExecutor</li></ul><p>ScheduledThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建2种类型的ScheduledThreadPoolExecutor,如下。<br>1)ScheduledThreadPoolExecutor。包含若干个线程的ScheduledThreadPoolExecutor。<br>2)SingleThreadScheduledExecutor。只包含一个线程的ScheduledThreadPoolExecutor。</p><p>ScheduledThreadPoolExecutor适用于需要多个后台线程执行周期任务,同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景。</p><p>SingleThreadScheduledExecutor 适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。</p><ul><li>Future接口</li></ul><p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。当我们把Runnable接口或Callable接口的实现类提交(submit)给ThreadPoolExecutor或<br>ScheduledThreadPoolExecutor时,ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个FutureTask对象。下面是对应的API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task,T result)</span></span></span><br><span class="line"><span class="function">Future&lt;&gt; <span class="title">submit</span><span class="params">(Runnable task)</span></span></span><br></pre></td></tr></table></figure><p>Java仅仅保证返回的是一个实现了Future接口的对象.返回的可能不一定是FutureTask。</p><ul><li>Runnable 接口和Callable 接口</li></ul><p>Runnable接口和Callable接口的实现类,都可以被ThreadPoolExecutor或Scheduled-<br>ThreadPoolExecutor执行。它们之间的区别是Runnable不会返回结果,而Callable可以返回结果。<br>除了可以自己创建实现Callable接口的对象外,还可以使用工厂类Executors来把一个<br>Runnable包装成一个Callable。</p><p>###ThreadPoolExecutor 详解</p><p>Executor框架最核心的类是ThreadPoolExecutor，它是线程池的实现类，主要由下列四个组件构成。corepool 核心线程池的大小maximusPool 最大线程池的大小Blockingqueue 用来暂存任务的工作队列rejectExecutionHandler 饱和策略</p><p>通过Executors工具类，<strong>里面有三种类型的静态方法来创建三种线程池。</strong></p><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p>可重用固定线程数的线程池，corepoolsize 和maximuspoolsize 都被设置为创建时指定的nThread。当线程数大于corepoolsize时，keepAlivetime 为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将会被终止。fixedThreadPool设置的是立即终止。</p><p>1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。<br>2）在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加入<br>LinkedBlockingQueue。<br>3）线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。</p><p>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。</p><h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p>SingleThreadExecutor 是使用单个Worker线程的Executor.SingleThreadExecutor 的corePoolSize 和maximumPoolSize 被设置为1，其他参数与FixedTheadPool一样，SingleThreadExecutor 也使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列容量为Integer.MAX_VALUE）</p><p>1）如果当前运行的线程数少于corePoolSize（即线程池中无运行的线程），则创建一个新线程来执行任务。<br>2）在线程池完成预热之后（当前线程池中有一个运行的线程），将任务加入LinkedBlockingQueue。<br>3）线程执行完1中的任务后，会在一个无限循环中反复从LinkedBlockingQueue获取任务来执行。</p><h4 id="CachedThreadPool-详解"><a href="#CachedThreadPool-详解" class="headerlink" title="CachedThreadPool 详解"></a>CachedThreadPool 详解</h4><p>CachedThreadPool是一个会根据需要创建线程的线程池，CachedThreadPool的corePoolSize被设置为0，即corePool为空，maximumPoolSize 被设置为Integer.MAX_VALUE,即maximumPool 是无界的，这里把keepAliveTime 设置为60L,意味着CachedThreadPool 中的空闲线程等待新任务的最长时间为60s, 空闲线程超过60s后将会被终止。CachedThreadPool 使用没有容量的SynchronousQueue作为线程池的工作队列，但是CachedThreadPool 的maximumPool 是无界的。这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool 会不断创建新线程，极端情况下，CachedThreadPool 会因为创建过多线程而耗尽CPU和内存资源。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-19%20%E4%B8%8B%E5%8D%8810.06.16.png" width="60%"></p><p>1）首先执行<code>SynchronousQueue.offer(Runnable task)</code>。如果当前maximumPool中有空闲线程正在执行<code>SynchronousQueue.poll（keepAliveTimeTimeUnit.NANOSECONDS)</code>，那么主线程执行offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行，execute()方法执行完成；否则执行下面的步骤2。<br>2）当初始maximumPool为空，或者maximumPool中当前没有空闲线程时，将没有线程执行<code>SynchronousQueue.poll(keepAliveTime，TimeUnit.NANOSECONDS)</code>。这种情况下，步骤1）将失败。此时<code>CachedThreadPool</code>会创建一个新线程执行任务，execute()方法执行完成。<br>3）在步骤2中新创建的线程将任务执行完后，会执行<code>SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS)</code>。这个poll操作会让空闲线程最多在SynchronousQueue中等待60秒钟。如果60秒钟内主线程提交了一个新任务（主线程执行步骤1）），那么这个空闲线程将执行主线程提交的新任务；否则，这个空闲线程将终止。由于空闲60秒的空闲线程会被终止，因此长时间保持空闲的CachedThreadPool不会使用任何资源。</p><p>SynchronousQueue 是一个没有容量的阻塞队列，每个插入操作必须等待另一个线程的对应移除操作，反之亦然。CachedThreadPool 使用SynchronousQueue,把主线城提交的任务<strong>传递</strong>传递给空闲线程执行，CachedThreadPool 中任务传递的示意图如下</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-19%20%E4%B8%8B%E5%8D%8810.13.03.png" width="70%"></p><h3 id="ScheduledThreadPoolExecutor-详解"><a href="#ScheduledThreadPoolExecutor-详解" class="headerlink" title="ScheduledThreadPoolExecutor 详解"></a>ScheduledThreadPoolExecutor 详解</h3><p>ScheduledThreadExecutor 继承自ThreadPoolExecutor,主要用来在给定的延迟之后运行任务，或者定期执行任务，ScheduledThreadPoolExecutor 可以在构造函数中指定多个对应的后台线程数。</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-19%20%E4%B8%8B%E5%8D%8810.25.07.png" width="70%"></p><h3 id="FutureTask-详解"><a href="#FutureTask-详解" class="headerlink" title="FutureTask 详解"></a>FutureTask 详解</h3><p>Future接口和实现Future接口的FutureTask类,代表异步计算的结果。</p><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>FutureTask除了实现Future接口外,还实现了Runnable接口。因此,FutureTask可以交给Executor执行,也可以由调用线程直接执行<code>(FutureTask.run())</code>。根FutureTask.run()方法被执行的时机,<code>FutureTask</code>可以处于下面3种状态。</p><ul><li>1)未启动。FutureTask.run()方法还没有被执行之前,FutureTask处于未启动状态。当创建一个FutureTask,且没有执行FutureTask.run()方法之前,这个FutureTask处于未启动状态。</li><li>2)已启动。FutureTask.run()方法被执行的过程中,FutureTask处于已启动状态。</li><li>3)已完成。FutureTask.run()方法执行完后正常结束,或被取消(FutureTask.cancel(…)),或执行FutureTask.run()方法时抛出异常而异常结束,FutureTask处于已完成状态。</li></ul><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-20%2019-37-03.png" width="60%"></p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-16%2022-30-14.png" alt=""></p><p>当FutureTask 处于未启动或者已启动状态时，执行futureTask.get()方法将导致调用线程阻塞；当FutureTask 处于已完成状态时，执行FutureTask .get()方法会导致调用线程立即返回结果或抛出异常。</p><p>当FutureTask 处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；当FutureTask处于已启动状态时，执行FutureTask.cancel(true) 方法将以中断执行此任务线程的方式来试图停止任务，当FutureTask 处于已启动状态时，执行FutureTask.cancel(false) 方法将不会对正在执行此任务的线程产生影响。当FutureTask处于已完成状态时，执行FutureTask.cancel()方法会返回false.</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-19%20%E4%B8%8B%E5%8D%8810.33.15.png" width="70%"></p><h4 id="FutureTask-的使用-与实现"><a href="#FutureTask-的使用-与实现" class="headerlink" title="FutureTask 的使用 与实现"></a>FutureTask 的使用 与实现</h4><p>可以把FutureTask交给Executor执行，也可以通过ExecutorService.submit()方法返回一个utureTask，然后执行FutureTask.get()方法或FutureTask.cancel()方法，除此之外，还可以单独使用FutureTask。</p><p>FutureTask 的实现是基于AQS的，</p><blockquote><p>参考文献:Java并发编程的艺术</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发包之Future</title>
      <link href="/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8BFuture/"/>
      <url>/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8BFuture/</url>
      
        <content type="html"><![CDATA[<h2 id="Future-模式"><a href="#Future-模式" class="headerlink" title="Future 模式"></a>Future 模式</h2><p>Future模式是多线程开发中一种常见的设计模式,核心思想是异步调用.</p><p>当我们需要调用一个函数方法时,如果这个函数执行很慢,我们就需要等待,但是有时候,可能并不急着要结果,因此,可以先让被调者立即返回.让它在后台慢慢的处理这个请求,对于调用者来说,则可以先处理一些其他任务,在真正需要数据的场合再去尝试获得需要的数据.</p><a id="more"></a><p>对于Future 模式来说,虽然它无法立即给出你需要的数据,但是他会返回一个契约,将来,可以根据这个契约去重新获取你需要的信息.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-19%2013-03-50.png" width="50%"><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-19%2013-06-41.png" width="50%">    </p><p>上面两幅图分别说明了传统的同步方法和Future模式的同步方法.</p><p>Future 模式的主要参与者:</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-19%2014-17-46.png" alt=""></p><h3 id="JDK中的Future-模式"><a href="#JDK中的Future-模式" class="headerlink" title="JDK中的Future 模式"></a>JDK中的Future 模式</h3><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-19%2014-30-50.png" alt=""></p><p>Future 接口<strong>表示一个任务的生命周期,并提供了相应的方法来判断是否已经完成或取消里面的get()方法的行为取决于任务的状态,完成时会返回值或者抛出异常,如果任务没有完成,任务会阻塞直到完成</strong>,  RunnableFuture 继承了Future和Runnable两个接口,其中,run()方法用于构造真实的数据.它有一个具体的实现类FutureTask, FutureTask 有一个内部类Sync,一些实质性的工作,会委托Sync完成.而Sync 最终会调用Callable接口,完成实际数据的组装工作.</p><p>Callable接口类似于Runnable,但是Runnable不会返回结果，并且无法抛出返回结果的异常，并且无法抛出返回结果的异常，而Callable工程更强大一点，被线程执行后，可以返回值，这个返回值可以被future拿到，也就是说，future可以拿到异步执行任务的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureCallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//单纯使用Future接口和Callable接口.</span></span><br><span class="line">        Callable&lt;String&gt; realData =<span class="keyword">new</span> RealData(<span class="string">"a"</span>);</span><br><span class="line">        <span class="comment">//如果申请了FutureTask,即加了下面这句,那么往线程池中必须submit FutureTask类作为Runnable.</span></span><br><span class="line"><span class="comment">//      FutureTask&lt;String&gt; future = new FutureTask&lt;&gt;(realData);</span></span><br><span class="line">        <span class="comment">//如果没有加上面这句,直接submit Callable到线程池,申请一个Future接收就好.</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 执行FutureTask</span></span><br><span class="line">        Future&lt;String&gt; future = es.submit(realData); <span class="comment">//此句建立callable和future的联系.</span></span><br><span class="line">        <span class="comment">//Thread.sleep(300);// 模拟做一些额外的事情</span></span><br><span class="line">        System.out.println(future.get());<span class="comment">// 在需要的时候通过get()方法获得需要的数据.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String para;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String para)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.para=para;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            StringBuffer sb =<span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(para);</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;<span class="comment">// 上述代码实现了Callable接口,它的call()方法会构造我们需要的真实数据并返回,这里用sleep进行模拟.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--more--><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">一个使用Callable和future的读网页的例子，图片另外一个线程读，文字直接主线程读。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureRender</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExcutorService excutor = newFixedThreadPool(<span class="number">10</span>); <span class="comment">//实例化一个线程池。</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span>   <span class="comment">//读取网页</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; ImageInfos =scanforImageInfo(source);</span><br><span class="line">        Callable&lt;List&lt;ImageData&gt; &gt; task =<span class="keyword">new</span> Callable&lt;&gt;()    <span class="comment">//主线程处理文字，另一个线程用来处理图片来加快进度。</span></span><br><span class="line">        &#123;   <span class="function"><span class="keyword">public</span> List&lt;ImageData&gt; <span class="title">call</span><span class="params">()</span>      <span class="comment">//重写Callable中的call方法，相当于runnable的run方法。</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                 List&lt;ImageData&gt; result =<span class="keyword">new</span> ArrayList&lt;ImageData&gt;();</span><br><span class="line">                <span class="keyword">for</span>(ImageInfo imageinfo: iamgeinfos)</span><br><span class="line">                &#123;</span><br><span class="line">                    results.add(imageinfo.download());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> results;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;List&lt;ImageData&gt; &gt; future = excutor.submit(task); <span class="comment">//把任务交给线程池处理，返回值是future类型。</span></span><br><span class="line">        renderText(source);<span class="comment">// 读文本</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            List&lt;ImageData&gt; imageData =future.get();   <span class="comment">//获得线程的返回值。</span></span><br><span class="line">            <span class="keyword">for</span>(ImageData data :imageData)</span><br><span class="line">            &#123;</span><br><span class="line">                renderImage(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.currentThread().interrupt);</span><br><span class="line">            future.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ExecutionException e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FutureTask实现了两个接口，Runnable和Future，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</strong>，那么这个组合的使用有什么好处呢？假设有一个很耗时的返回值需要计算，并且这个返回值不是立刻需要的话，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过Future得到。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者消费者模式与阻塞队列</title>
      <link href="/2018/01/19/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
      <url>/2018/01/19/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="生产者消费者模式与阻塞队列"><a href="#生产者消费者模式与阻塞队列" class="headerlink" title="生产者消费者模式与阻塞队列"></a>生产者消费者模式与阻塞队列</h2><p>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。</p><h4 id="Why-生产者消费者模式"><a href="#Why-生产者消费者模式" class="headerlink" title="Why 生产者消费者模式"></a>Why 生产者消费者模式</h4><p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。<strong>为了解决这种生产消费能力不均衡的问题，所以便有了生产者和消费者模式。</strong></p><h4 id="What-生产者消费者模式"><a href="#What-生产者消费者模式" class="headerlink" title="What 生产者消费者模式"></a>What 生产者消费者模式</h4><p>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p><h4 id="线程池与生产者消费者模式"><a href="#线程池与生产者消费者模式" class="headerlink" title="线程池与生产者消费者模式"></a>线程池与生产者消费者模式</h4><p>Java中的线程池类其实就是一种生产者和消费者模式的实现方式，其实现方式更加高明。生产者把任务丢给线程池，线程池创建线程并处理任务，如果将要运行的任务数大于线程池的基本线程数就把任务扔到阻塞队列里，这种做法比只使用一个阻塞队列来实现生产者和消费者模式显然要高明很多，因为消费者能够处理直接就处理掉了，这样速度更快，而生产者先存，消费者再取这种方式显然慢一些。</p><p>我们的系统也可以使用线程池来实现多生产者消费者模式。比如创建N个不同规模的Java线程池来处理不同性质的任务，比如线程池1将数据读到内存之后，交给线程池2里的线程继续处理压缩数据。线程池1主要处理IO密集型任务，线程池2主要处理CPU密集型任务。</p><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>阻塞队列是一个支持两个附件操作的队列，这两个附加的操作支持阻塞的插入和移除方法。</p><p>阻塞队列常用于生产者，消费着的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程，阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器。</p><p>JDK中提供了7个阻塞队列，分别是</p><ul><li>ArrayBlockingQueue 一个由数组结构组成的有界阻塞队列</li></ul><p>数组实现的有界阻塞队列，按照先进先出原则对元素进行排序。默认不保证线程公平。</p><ul><li>LinkedBlockingQueue 一个由链表结构组成的有界阻塞队列</li></ul><p>链表实现的有界阻塞队列，按照先进先出原则对元素进行排序</p><ul><li>priorityBlockingQueue 一个支持优先级排序的无界阻塞队列</li></ul><p>支持优先级的无界阻塞队列，可以自定义实现CompareTo()方法来指定元素排序规则</p><ul><li>DelayQueue 一个使用优先级队列实现的无界阻塞队列</li></ul><p>支持延时获取元素的无界阻塞队列,即当队列中的元素到达延迟时间时才会被取出。</p><ul><li>SynchronousQueue 一个不存储元素的阻塞队列</li></ul><p>不存储元素的阻塞队列，每一个put操作必须等待一个take操作。否则不能继续添加元素。可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程，队列本身并不存储任何元素，非常适合传递性场景。</p><ul><li>LinkedTransferQueue 一个由链表结构组成的无界阻塞队列</li></ul><p>是一个由链表组成的无界阻塞队列，相对于其他阻塞队列，多了trytransfer 方法和trasnfer方法。</p><p>tansfer方法：如果有消费者正在等待接收元素，transfer可以把生产者传入的元素立刻传输给消费者，如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</p><ul><li>LinkedBlockingDueue 一个由链表结构组成的双向阻塞队列</li></ul><p>双向队列指的是可以从队列的两端插入和移除元素。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发包之FutureTask</title>
      <link href="/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8BFutureTask/"/>
      <url>/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8BFutureTask/</url>
      
        <content type="html"><![CDATA[<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>Future接口和实现Future接口的FutureTask类,代表异步计算的结果.</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在Java中一般通过继承Thread类或者实现Runnable接口这两种方式来创建多线程，但是这两种方式都有个缺陷，就是不能在执行完成后获取执行的结果，因此Java 1.5之后提供了Callable和Future接口，通过它们就可以在任务执行完毕之后得到任务的执行结果。</p><a id="more"></a><h5 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h5><p>对于需要执行的任务需要实现Callable接口，Callable接口定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Callable是个泛型接口，泛型V就是要call()方法返回的类型。Callable接口和Runnable接口很像，都可以被另外一个线程执行，但是正如前面所说的，Runnable不会返回数据也不能抛出异常。</p><h5 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a>Future 接口</h5><p>Future接口代表异步计算的结果，通过Future接口提供的方法可以查看异步计算是否执行完成，或者等待执行结果并获取执行结果，同时还可以取消执行。Future接口的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cancel():cancel()方法用来取消异步任务的执行。如果异步任务已经完成或者已经被取消，或者由于某些原因不能取消，则会返回false。如果任务还没有被执行，则会返回true并且异步任务不会被执行。如果任务已经开始执行了但是还没有执行完成，若mayInterruptIfRunning为true，则会立即中断执行任务的线程并返回true，若mayInterruptIfRunning为false，则会返回true且不会中断任务执行线程。</li><li>isCanceled():判断任务是否被取消，如果任务在结束(正常执行结束或者执行异常结束)前被取消则返回true，否则返回false。</li><li>isDone():判断任务是否已经完成，如果完成则返回true，否则返回false。需要注意的是：任务执行过程中发生异常、任务被取消也属于任务已完成，也会返回true。</li><li>get():获取任务执行结果，如果任务还没完成则会阻塞等待直到任务执行完成。如果任务被取消则会抛出CancellationException异常，如果任务执行过程发生异常则会抛出ExecutionException异常，如果阻塞等待过程中被中断则会抛出InterruptedException异常。</li><li>get(long timeout,Timeunit unit):带超时时间的get()版本，如果阻塞等待过程中超时则会抛出TimeoutException异常。</li></ul><h5 id="FutureTask-1"><a href="#FutureTask-1" class="headerlink" title="FutureTask"></a>FutureTask</h5><p><strong>FutureTask 继承了RunnableFuture接口,RunnableFuture接口继承了Runnable接口和Future接口</strong></p><p><strong>所以FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果。</strong>(目前我觉得是两个都是必须的,又作为runnable,又作为返回结果,都是必须的)</p><p>当作为Runnable时,有三种状态</p><ul><li>未启动 FutureTask.run()方法还没有执行之前.</li><li>已启动 FutureTask.run()方法执行过程中</li><li>已完成 FutureTask.run()方法执行结束后</li></ul><p>FutureTask主要使用get()和cancle()两个方法.</p><p> <img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-20%2022-17-43.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureCallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String para;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String para)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.para=para;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            StringBuffer sb =<span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(para);</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;<span class="comment">// 上述代码实现了Callable接口,它的call()方法会构造我们需要的真实数据并返回,这里用sleep进行模拟.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureMain</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">           <span class="comment">//构造FutureTask</span></span><br><span class="line">            RealData realData =<span class="keyword">new</span> RealData(<span class="string">"a"</span>);</span><br><span class="line">            FutureTask&lt;String&gt; future = <span class="keyword">new</span> FutureTask&lt;String&gt;(realData);<span class="comment">//1111111</span></span><br><span class="line">            ExecutorService es = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 执行FutureTask</span></span><br><span class="line">            es.submit(future);  <span class="comment">//作为执行!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="comment">//写了111那句后,就必须submit  future了.</span></span><br><span class="line">            Thread.sleep(<span class="number">300</span>);<span class="comment">// 模拟做一些额外的事情</span></span><br><span class="line">            System.out.println(future.get());<span class="comment">// 在需要的时候通过get()方法获得需要的数据.,也作为返回!!!!!!!!!!!!!!!!!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//既作为执行,也作为返回.</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程之AQS</title>
      <link href="/2018/01/19/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)%20AQS/"/>
      <url>/2018/01/19/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)%20AQS/</url>
      
        <content type="html"><![CDATA[<h2 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h2><p>队列同步器 AbstractQueuedSynchronizer ，是用来构建锁或者其他同步组件的基础框架，它使用了int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p><p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p><p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解，锁是面向使用者的，它定义了使用者于锁交互的接口，隐藏了实现细节，同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理，线程的排队，等待，唤醒等底层操作，锁与同步器很好的隔离了使用者和实现者所需要关注的领域。</p><a id="more"></a><p>AQS定义了一套多线程访问共享资源的同步器框架。许多同步类的实现都依赖它。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/2017-12-09-1.png" alt=""></p><p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词。</p><h4 id="state的访问方式有三种"><a href="#state的访问方式有三种" class="headerlink" title="state的访问方式有三种:"></a>state的访问方式有三种:</h4><ul><li>getState()</li><li>setState()</li><li>compareAndSetState()</li></ul><p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p><h4 id="自定义同步器时需要重写的方法"><a href="#自定义同步器时需要重写的方法" class="headerlink" title="自定义同步器时需要重写的方法"></a>自定义同步器时需要重写的方法</h4><p><strong>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在底层实现好了。<strong>自定义同步器</strong>实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p><strong>总结一下来说,就是用<code>getState() setState() compareAndSetState()</code> 三个能获得/改变同步状态的方法来重写上面列出的五个常见的方法 就可以实现一个自定义的同步组件(已经有的同步组件就是<code>ReentrantLock ,ReadWritelLock</code>等)</strong></p><p>​     以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>　　再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>　　一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ol><li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><h4 id="Voliatile"><a href="#Voliatile" class="headerlink" title="Voliatile"></a>Voliatile</h4><p>为了保持可见性，prev ，next 这两个Node 类型的节点指针都是volatile 的，waitStatus(每个节点的等待状态也是)， thread(获取同步状态的线程也是) 当然，同步状态status 肯定也是。</p><h3 id="AQS-的实现分析"><a href="#AQS-的实现分析" class="headerlink" title="AQS 的实现分析"></a>AQS 的实现分析</h3><h4 id="Acquire-int"><a href="#Acquire-int" class="headerlink" title="Acquire(int)"></a>Acquire(int)</h4><p>此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">         selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数流程包括：</p><p>1 tryAcquire() 尝试直接去获取资源，如果成功则直接返回。</p><p>2 addWaiter() 将该线程加入等待队列的尾部，并标记为独占模式。</p><p>3 acquireQueued() 使线程在等待队列中获取资源，一直获取到资源后才返回，如果在整个等待过程中被中断过，则返回true，否则返回false。</p><p>4 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</p><p><strong>如果直接获取到同步状态或者在队列中获取到就算获取到了同步状态</strong></p><h4 id="tryAcquire-int"><a href="#tryAcquire-int" class="headerlink" title="tryAcquire(int)"></a>tryAcquire(int)</h4><p>此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p><h4 id="addWaiter-Node"><a href="#addWaiter-Node" class="headerlink" title="addWaiter(Node)"></a>addWaiter(Node)</h4><p>此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试快速方式直接放到队尾。</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上一步失败则通过enq入队。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node结点是对每一个访问同步代码的线程的封装，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。变量waitStatus则表示当前被封装成Node结点的等待状态，共有4种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE。</p><ul><li>CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</li><li>SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。</li><li>CONDITION：值为-2，与Condition相关，该标识的结点处于<strong>等待队列</strong>中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li><li>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</li><li>0状态：值为0，代表初始化状态。</li></ul><p>AQS在判断状态时，通过用waitStatus&gt;0表示取消状态，而waitStatus&lt;0表示有效状态。</p><h4 id="enq-Node"><a href="#enq-Node" class="headerlink" title="enq(Node)"></a>enq(Node)</h4><p>此方法用于将node 加入队尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//CAS"自旋"，直到成功加入队尾</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//正常流程，放入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node,int)"></a>acquireQueued(Node,int)</h4><p>OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：<strong>进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了</strong>。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：<strong>在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回</strong>。</p><p><strong>节点进入同步队列后，就进入了一个自旋的状态，每个节点（每个线程）都在自省的观察，当条件满足（这里的条件就是前驱是头节点且拿到了同步状态，见下面感叹号标识的那一行，），获取到了同步状态，就可以从这个自旋状态中退出。否则依然保留在这个自旋状态中（并阻塞这个节点表示的线程，也就是说，每个节点都会自旋，但是只有发现自己的前驱是头节点且获取同步状态后才会从自旋状态出退出，通过LockSupport.unpark()这个方法来唤醒阻塞的节点。其他前驱不是头结点的仍然一直阻塞在自旋状态中，并且，先知道自己的前驱是头结点，才会尝试获取同步状态）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//标记等待过程中是否被中断过</span></span><br><span class="line">        <span class="comment">//又是一个“自旋”！</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//拿到前驱</span></span><br><span class="line">            <span class="comment">//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。</span></span><br><span class="line"> &lt;!!!!!!!!!&gt;  <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);<span class="comment">//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;<span class="comment">//返回等待过程中是否被中断过</span></span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="comment">//如果自己可以休息了，就进入waiting状态，直到被unpark()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;<span class="comment">//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>结点进入队尾后，检查状态，找到安全休息点；</li><li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</li><li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</li></ol><h4 id="重入锁的实现原理"><a href="#重入锁的实现原理" class="headerlink" title="重入锁的实现原理"></a>重入锁的实现原理</h4><p>重入锁的非公平方法增加了再次获取同步状态的逻辑，非重入锁只要status==1 表示获取锁，重入锁通过判断当前线程是否为获取锁的线程来决定获取操作能否成功。如果获取锁的线程再次请求，则将同步状态值进行增加并返回ture, 表示获取同步状态成功。</p><p>如果是公平锁，还应该在判断条件那加上hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true,则表示有线程比当前线程更早的请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p><h4 id="读写锁的实现原理"><a href="#读写锁的实现原理" class="headerlink" title="读写锁的实现原理"></a>读写锁的实现原理</h4><p>读写锁同样依赖AQS, 读写锁将变量分成了两个部分，高16位表示读，低16位表示写，读写锁通过位运算快速的确定读和写各自的状态，</p><p>写锁是一个支持重进入的排它锁，如果当前线程已经获取了写锁，则增加写状态，如果当前线程在获取写锁时，读锁已经被获取或者改线程不是已经获取写锁的线程，则当前线程进入等待状态。</p><p>写锁也有可能锁降级，锁降级指的是把持住写锁，再获取到读锁，随后释放写锁的过程。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁的升级与对比</title>
      <link href="/2018/01/19/%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E4%B8%8E%E5%AF%B9%E6%AF%94/"/>
      <url>/2018/01/19/%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E4%B8%8E%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h1 id="锁的升级与对比"><a href="#锁的升级与对比" class="headerlink" title="锁的升级与对比"></a>锁的升级与对比</h1><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗,引入了“偏向锁”和“轻量级锁”,在Java SE 1.6中,<strong>锁一共有4种状态,级别从低到高依次是:无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>,这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级,意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略,目的是为了提高获得锁和释放锁的效率。</p><a id="more"></a><h3 id="Java对象头-在内存中的存放，和Class文件的布局没什么关系"><a href="#Java对象头-在内存中的存放，和Class文件的布局没什么关系" class="headerlink" title="Java对象头(在内存中的存放，和Class文件的布局没什么关系)"></a>Java对象头(在内存中的存放，和Class文件的布局没什么关系)</h3><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。<br>HotSpot虚拟机的对象头(Object Header)包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂 不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。</p><p><strong>锁存在Java对象头里</strong>。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象的hashCode或锁信息等</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>存储到对象类型数据的指针</td></tr><tr><td>32/64bit</td><td>Array length</td><td>数组的长度（如果当前对象是数组）</td></tr></tbody></table><p>Java对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下：</p><table><thead><tr><th></th><th>25 bit</th><th>4bit</th><th>1bit是否是偏向锁</th><th>2bit锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象的hashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr></tbody></table><p>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/2017-12-09-lock.png" width="400px"></p><ul><li>偏向锁，轻量级锁都是乐观锁，重量级锁是悲观锁</li></ul><p>首先，应该知道三种锁偏向锁，轻量级锁，重量级锁的应用场景</p><ul><li>偏向锁主要用于只有一个线程进入临界区的情况。</li><li>轻量级锁主要用于两个线程竞争程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁。</li><li>重量级锁就是用于竞争十分强烈的情况下。</li></ul><h3 id="偏向锁（锁标志位01）"><a href="#偏向锁（锁标志位01）" class="headerlink" title="偏向锁（锁标志位01）"></a>偏向锁（锁标志位01）</h3><p>当Thread#1进入临界区时，JVM会将lockObject的对象头Mark Word的锁标志位设为“01”，同时会用CAS操作把Thread#1的线程ID记录到lockObject的对象头Mark Word中，此时进入偏向模式。所谓“偏向”，指的是这个锁会偏向于Thread#1，若接下来没有其他线程进入临界区，则Thread#1再出入临界区无需再执行任何同步操作。也就是说，若只有Thread#1会进入临界区，实际上只有Thread#1初次进入临界区时需要执行CAS操作，以后再出入临界区都不会有同步操作带来的开销。</p><p>(也就是在锁住的对象的对象头上记录下线程的ID，这样下次该线程再次出入该锁住对象管理的临界区，只需要验证一下对象头上的线程ID即可)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。</span><br><span class="line"></span><br><span class="line">一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。</span><br><span class="line"></span><br><span class="line">    轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</span><br></pre></td></tr></table></figure><p>​      HotSpot的作者经过研究发现,大多数情况下,锁不仅不存在多线程竞争,而且总是由同一线程多次获得,<em>为了让线程获得锁的代价更低而引入了偏向锁</em>。当一个线程访问同步块并获取锁时,会在对象头和栈帧中的锁记录里存储锁偏向的线程ID,以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁,只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功,表示线程已经获得了锁。如果测试失败,则需要再测试一下Mark Word中偏向锁的标识是否设置成1(表示当前是偏向锁):如果没有设置,则使用CAS竞争锁;如果设置了,则尝试使用CAS将对象头的偏向锁指向当前线程。</p><p>​    也就是说，大多数情况下的锁都要通过CAS竞争来获取，<em>偏向锁的目的就是为了消除CAS竞争的开销。直接在对象头标记，下次获取锁时直接看标记就好了，不用再CAS修改获取了,所以直接说省去了CAS 竞争锁的开销</em>。原先的CAS修改需要先看锁是不是在，compare后发现不在，然后再修改锁的值，变成有锁。现在偏向锁直接去掉了CAS修改步骤，只需要CAS替换Mark Word就好了。 </p><h5 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h5><p><strong>偏向锁使用了一种等到竞争出现才释放锁的机制,所以当其他线程尝试竞争偏向锁时,持有偏向锁的线程才会释放锁。</strong>偏向锁的撤销,需要等待全局安全点(在这个时间点上没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程,然后检查持有偏向锁的线程是否活着,如果线程不处于活动状态,则将对象头设置成无锁状态;如果线程仍然活着,拥有偏向锁的栈会被执行,遍历偏向对象的锁记录,栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程,要么恢复到无锁或者标记对象不适合作为偏向锁,最后唤醒暂停的线程。图中的线程1演示了偏向锁初始化的流程,线程2演示了偏向锁撤销的流程。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/2017-12-09-lock2.png" width="500px"></p><h3 id="轻量级锁（锁标志位00）"><a href="#轻量级锁（锁标志位00）" class="headerlink" title="轻量级锁（锁标志位00）"></a>轻量级锁（锁标志位00）</h3><p>在代码进入同步块的时候，如果此同步对象没有被锁定,(锁标志位为01状态)虚拟机首先将当在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，这个空间用于当前线程去 存储LockObject(锁住对象)目前的Mark Word的拷贝。（官方称为Displaced Mark Word）。</p><p>然后虚拟机将使用CAS操作尝试将对象的Mark Word 更新为指向Lock Record 的指针，如果这个更新操作成功了，就代表这个线程拥有了该对象的锁。并且对象Mark Word 的锁标志位也将转变为00. 即表示此对象处于轻量级锁定状态，</p><p>如图所示：</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/llll.jpg" alt=""></p><p>如果这个更新操作失败了，虚拟机先去检查Mark word是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明这个锁对象已经被其他线程抢占了。如果有两个以上线程争用同一个锁，那么轻量级锁就不再有效，要膨胀为重量级锁。</p><p>通过上面的描述可知，轻量级锁是用CAS进行加锁的，其实，解锁也是使用CAS操作的。如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word 和线程中复制的 Displaced Mark Word 替换回来。替换成功的话整个同步过程就完成了，替换失败的话，说明有其他线程尝试获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</p><p>轻量级锁使用CAS操作避免了使用互斥量的开销，所以可以在一定程度上提升性能。</p><blockquote><p><a href="https://blog.csdn.net/choukekai/article/details/63688332" target="_blank" rel="noopener">https://blog.csdn.net/choukekai/article/details/63688332</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步,异步,阻塞,非阻塞</title>
      <link href="/2018/01/19/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
      <url>/2018/01/19/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
      
        <content type="html"><![CDATA[<p>所谓同步异步关心的是<strong>消息通信机制</strong>，所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p><p>而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>而阻塞和非阻塞关注的是程序在等待调用结果（消息返回值）时的状态.</p><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。我们可以用打电话和发短信来很好的比喻同步与异步操作。</p><p>在设计到 IO 处理时通常都会遇到一个是同步还是异步的处理方式的选择问题。因为同步与异步的 I/O 处理方式对调用者的影响很大，在数据库产品中都会遇到这个问题。因为 I/O 操作通常是一个非常耗时的操作，在一个任务序列中 I/O 通常都是性能瓶颈。但是同步与异步的处理方式对程序的可靠性影响非常大，<strong>同步能够保证程序的可靠性，而异步可以提升程序的性能</strong>，必须在可靠性和性能之间做个平衡，没有完美的解决办法。</p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞与非阻塞主要是从 CPU 的消耗上来说的，阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作。虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的 CPU 使用时间能不能补偿系统的切换成本需要好好评估。</p><h3 id="两种的方式的组合"><a href="#两种的方式的组合" class="headerlink" title="两种的方式的组合"></a>两种的方式的组合</h3><p>组合的方式可以由四种，分别是：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞，这四种方式都对 I/O 性能有影响。下面给出分析，并有一些常用的设计用例参考。</p><h5 id="四种组合方式"><a href="#四种组合方式" class="headerlink" title="四种组合方式"></a>四种组合方式</h5><table><thead><tr><th><strong>组合方式</strong></th><th><strong>性能分析</strong></th></tr></thead><tbody><tr><td>同步阻塞</td><td>最常用的一种用法，使用也是最简单的，但是 I/O 性能一般很差，CPU 大部分在空闲状态。</td></tr><tr><td>同步非阻塞</td><td>提升 I/O 性能的常用手段，就是将 I/O 的阻塞改成非阻塞方式，尤其在网络 I/O 是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。这种方式通常能提升 I/O 性能，但是会增加 CPU 消耗，要考虑增加的 I/O 性能能不能补偿 CPU 的消耗，也就是系统的瓶颈是在 I/O 还是在 CPU 上。</td></tr><tr><td>异步阻塞</td><td>这种方式在分布式数据库中经常用到，例如在往一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，而还有两至三份是备份记录会写到其它机器上，这些备份记录通常都是采用异步阻塞的方式写 I/O。异步阻塞对网络 I/O 能够提升效率，尤其像上面这种同时写多份相同数据的情况。</td></tr><tr><td>异步非阻塞</td><td>这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I/O 组合方式。如 Cassandra 的 Gossip 通信机制就是采用异步非阻塞的方式。它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大，但是却非常频繁。这种网络 I/O 用这个方式性能能达到最高。</td></tr></tbody></table><p>对unix来讲：阻塞式I/O(默认)，非阻塞式I/O(nonblock)，I/O复用(select/poll/epoll)都属于同步I/O，因为它们在数据由内核空间复制回进程缓冲区时都是阻塞的(不能干别的事)。只有异步I/O模型(AIO)是符合异步I/O操作的含义的，即在1数据准备完成、2由内核空间拷贝回缓冲区后 通知进程，在等待通知的这段时间里可以干别的事。<strong>在IO中，根据第二阶段是否能够返回来判断是同步还是异步，根据第一阶段是否能干其他事来判断是否阻塞非阻塞</strong></p><p>虽然异步和非阻塞能够提升 I/O 的性能，但是也会带来一些额外的性能成本，例如会增加线程数量从而增加 CPU 的消耗，同时也会导致程序设计的复杂度上升。如果设计的不合理的话反而会导致性能下降。在实际设计时要根据应用场景综合评估一下。</p><blockquote><p><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">https://www.zhihu.com/question/19732473</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程之CAS</title>
      <link href="/2018/01/19/CAS/"/>
      <url>/2018/01/19/CAS/</url>
      
        <content type="html"><![CDATA[<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>独占锁是一种悲观锁，Synchronized就是一种悲观锁。会导致其他有需要锁的线程被挂起，等待持有锁的线程释放锁。更加有效的就是乐观锁。每次不加锁而是假设没有冲突去完成某项操作，如果因为冲突失败就进行重试，直到成功为止。乐观锁用到的机制就是CAS compare and swap</p><p>CAS的算法过程是这样, 它包含三个参数V, A, B.  V表示内存值, A表示旧的预期的值, B表示要修改的新值. 仅当V值等于A值时,才会将V值设置为B, 如果V值和A值不同, 说明已经有其他线程做了更新,则当前线程什么都不做.当且仅当预期值A和内存值V相等时，将内存值修改为B并返回true，否则什么都不干并返回false。</p><a id="more"></a><p><strong>简单的说,CAS需要额外给出一个期望值,也就是你认为这个变量现在应该是什么样子,如果变量不是你想象的那样,说明它已经被别人修改过了.</strong></p><p>CAS中的比较和替换是一组原子操作，不会被外部打断，属于硬件级别的操作，效率要比加锁操作高。</p><p>所以就可以利用CPU的CAS指令，借助JNI来完成Java的非阻塞算法，其他原子操作都是利用类似的特性完成的。</p><h3 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h3><p>CAS中的比较和替换是一组原子操作，不会被外部打断，先根据paramLong/paramLong1获取到内存当中当前的内存值V，若有其他线程修改，则内存立马知道（设置可见），所以A的值就变了，就不能变成B了，要通过循环重新取内存中获取。 在将内存值V和原值A作比较，要是相等就修改为要修改的值B，属于硬件级别的操作，效率比加锁操作高</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p><strong>ABA问题</strong>。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p><p><strong>循环时间长开销大</strong>。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p><p><strong>3. 只能保证一个共享变量的原子操作</strong>。当对一个共享变量执行操作时，我们可以使用<strong>循环CAS的方式来保证原子操作</strong>，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了<strong>AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</strong></p><blockquote><p> <a href="http://www.jianshu.com/p/fb6e91b013cc" target="_blank" rel="noopener">http://www.jianshu.com/p/fb6e91b013cc</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发包之其他并发工具类</title>
      <link href="/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E5%85%B6%E4%BB%96%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E5%85%B6%E4%BB%96%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="控制并发线程数的Semaphone"><a href="#控制并发线程数的Semaphone" class="headerlink" title="控制并发线程数的Semaphone"></a>控制并发线程数的Semaphone</h3><p>Semaphore(信号量)是用来控制同时访问特定资源的线程数量,它通过协调各个线程,以<br>保证合理的使用公共资源。</p><a id="more"></a><p>Semaphore中管理着一组虚拟的许可,许可的初始数量可以通过构造函数来指定,在执行操作时可以首先获得许可(只要还有剩余的许可),并在使用后释放许可,如果没有许可,acquire将阻塞直到有许可,release将返回一个许可给信号量.</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>Semaphore可以用于做流量控制,特别是公用资源有限的应用场景,比如数据库连接。假<br>如有一个需求,要读取几万个文件的数据,因为都是IO密集型任务,我们可以启动几十个线程<br>并发地读取,但是如果读到内存后,还需要存储到数据库中,而数据库的连接数只有10个,这<br>时我们必须控制只有10个线程同时获取数据库连接保存数据,否则会报错无法获取数据库连接。这个时候,就可以使用Semaphore来做流量控制,如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">SemaphoneTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorServicethreadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphone s =<span class="keyword">new</span> Semaphone(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;THREAD_COUNT;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println(<span class="string">"save data"</span>);</span><br><span class="line">                        s.release;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中,虽然有30个线程在执行,但是只允许10个并发执行。Semaphore的构造方法Semaphore(int permits)接受一个整型的数字,表示可用的许可证数量。Semaphore(10)表示允许10个线程获取许可证,也就是最大并发数是10。Semaphore的用法也很简单,首先线程使用Semaphore的acquire()方法获取一个许可证,使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>intavailablePermits():返回此信号量中当前可用的许可证数。</li><li>intgetQueueLength():返回正在等待获取许可证的线程数。</li><li>booleanhasQueuedThreads():是否有线程正在等待获取许可证。</li><li>void reducePermits(int reduction):减少reduction个许可证,是个protected方法。</li><li>Collection getQueuedThreads():返回所有等待获取许可证的线程集合,是个protected方法。</li></ul><h3 id="线程间交换数据的Exchanger"><a href="#线程间交换数据的Exchanger" class="headerlink" title="线程间交换数据的Exchanger"></a>线程间交换数据的Exchanger</h3><p>Exchanger(交换者)是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交<br>换。它提供一个同步点,在这个同步点,两个线程可以交换彼此的数据。这两个线程通过<br>exchange方法交换数据,如果第一个线程先执行exchange()方法,它会一直等待第二个线程也执行exchange方法,当两个线程都到达同步点时,这两个线程就可以交换数据,将本线程生产出来的数据传递给对方。</p><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>Exchanger可以用于遗传算法,遗传算法里需要选出两个人作为交配对象,这时候会交换两人的数据,并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作,比如我们需<br>要将纸制银行流水通过人工的方式录入成电子银行流水,为了避免错误,采用AB岗两人进行<br>录入,录入到Excel之后,系统需要加载这两个Excel,并对两个Excel数据进行校对,看看是否<br>录入一致,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">ExchangerTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt;exgr = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorServicethreadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String A =<span class="string">"bank A"</span> <span class="comment">//A录入数据</span></span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String B =<span class="string">"bank B"</span> <span class="comment">//B录入数据</span></span><br><span class="line">                    Stirng A = exgr.exchange(B);</span><br><span class="line">                    System.out.println(<span class="string">"AB是否一致"</span>+A.equals(B)</span><br><span class="line">                    +<span class="string">"A录得是"</span>+A+<span class="string">"B录得是"</span>+B)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个线程有一个没有执行exchange()方法,则会一直等待,如果担心有特殊情况发<br>生,避免一直等待,可以使用exchange(V x,longtimeout,TimeUnit unit)设置最大等待时长。</p><blockquote><p>参考文献:Java并发编程的艺术</p></blockquote><h2 id="ThreadLocal-的使用"><a href="#ThreadLocal-的使用" class="headerlink" title="ThreadLocal 的使用"></a>ThreadLocal 的使用</h2><p>ThreadLocal，即一个以ThreadLocal 对象为键，任意对象为值的存储结构，这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p><p>可以通过set()方法设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; t1 =<span class="keyword">new</span> ThreadLocal&lt;&gt;();<span class="comment">//声明一个ＴｈｒｅａｄＬｏｃａl变量．</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        Date date =<span class="keyword">new</span> Date();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(t1.get()==<span class="keyword">null</span>)</span><br><span class="line">            &#123;<span class="comment">//设置值</span></span><br><span class="line">                t1.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="comment">//取值</span></span><br><span class="line">                Date t=  t1.get().parse(<span class="string">"2015-03-29 19:29:"</span>+i%<span class="number">60</span>);</span><br><span class="line">                System.out.println(i+<span class="string">" : "</span>+t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发包之并发容器(二)</title>
      <link href="/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%BA%8C/"/>
      <url>/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><h3 id="ConcurrentLinkedQueue-1"><a href="#ConcurrentLinkedQueue-1" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>如果要实现一个线程安全的队列有两种方式:一种是使用阻塞算法,另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁(入队和出队用同一把锁)或两个锁(入队和出队用不同的锁)等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。下面主要讨论使用非阻塞的方式来实现线程安全队列。</p><p>ConcurrentLinkedQueue 是一个基于链接节点的无界线程安全队列，采用先进先出的规则对节点进行排序，采用了CAS算法进行实现。</p><p>ConcurrentLinkedQueue由head节点和tail节点组成,每个节点(Node)由节点元素(item)和指向下一个节点(next)的引用组成,节点与节点之间就是通过这个next关联起来,从而组成一张链表结构的队列。默认情况下head节点存储的元素为空,tail节点等于head节点。</p><a id="more"></a><p>作为一个链表,自然需要定义有关链表内的节点,在ConcurrentLinkedQueue中,定义的节点Node核心如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> E item;</span><br><span class="line">  <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">&#125;<span class="comment">// item 表示目标元素,next表示当前node的下一个元素</span></span><br></pre></td></tr></table></figure><p>对Node进行操作时,使用了CAS操作.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp,E val)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 设置当前Node的item值.</span></span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>,itemOffset,cmp,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNSAFE.putOrderedObject(<span class="keyword">this</span>,nextOffset,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//设置next字段</span></span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>,nextOffset,cmp,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentLinkedQueue内部实现十分复杂,它允许在运行时链表处于多个不同的状态.以tail为例,一般来说,我们总是期望tail为链表的末尾,但是实际上,tail的更新并不是及时的,可能会产生拖延现象,</p><blockquote><p>详见并发编程的艺术p163</p></blockquote><h2 id="不变模式下的CopyOnWriteArrayList"><a href="#不变模式下的CopyOnWriteArrayList" class="headerlink" title="不变模式下的CopyOnWriteArrayList"></a>不变模式下的CopyOnWriteArrayList</h2><p>很多应用场景中,读操作远远大于写操作,由于读操作根本不会修改原有的数据,因此每次读取都加锁是一种很大的浪费,应该允许多个线程同时访问List的内部数据,.</p><p>为了将读取性能发挥到极致,JDK中提供了CopyOnWriteArrayList类,对它来说,读取完全不用加锁,写入操作也不会阻塞读取操作,只有写入和写入之间需要同步等待.</p><p>CopyOnWrite就是在写入操作时,进行一次自我复制,当这个List需要修改时,并不修改原有的内容,而对原有数据进行一次复制,将修改的内容写入副本中,写完之后,再将修改完的副本替换原来的数据.,这样就保证写操作不会影响读了.</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列与普通队列的区别在于，当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来，如从队列中移除一个或者多个元素，或者完全清空队列，下图展示了如何通过阻塞队列来合作：<br><img src="http://blog-1252095801.cosgz.myqcloud.com/2017-11-08.png" alt=""></p><p>阻塞队列常用作数据共享通道.BlockingQueue是一个接口,</p><p>主要的实现有ArrayBlockingQueue和LinkedBlockingQueue,</p><p>阻塞队列之所以适合作为数据共享的通道,关键在于blocking上.</p><p>当服务线程处理完成队列中所有的消息后,如何知道下一条消息何时到来.</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>使用通知模式实现,JDK源码中ArrayBlockingQueue使用了*<em>Condition</em> 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity,<span class="keyword">boolean</span> faie)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">  notEmpty = lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  checkNotFull(e);</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock =<span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lockInterruptibly();<span class="comment">// 优先考虑中断的lock.lock();</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(count==items.length)</span><br><span class="line">    &#123;</span><br><span class="line">      notFull.await();</span><br><span class="line">    &#125;</span><br><span class="line">    insert(e);</span><br><span class="line">  &#125;<span class="keyword">finally</span></span><br><span class="line">  &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    item[putIndex]=x;</span><br><span class="line">  putIndex =inc(putindex);</span><br><span class="line">  ++count;</span><br><span class="line">  notEmpty.singal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock();</span><br><span class="line">lock.lockInterruptibly();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">while</span>(count==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> extract();</span><br><span class="line">&#125;<span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">extract</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">final</span>  Object[] items =<span class="keyword">this</span>.items;</span><br><span class="line">  E x =<span class="keyword">this</span>.&lt;E&gt;cast(items[takeIndex]);</span><br><span class="line">  items[takeIndex]=<span class="keyword">null</span>;</span><br><span class="line">  takeIndex= inc(takeIndex);</span><br><span class="line">  --count;</span><br><span class="line">  notFull.singal();</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发包之并发容器(一)</title>
      <link href="/2018/01/19/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B8%80/"/>
      <url>/2018/01/19/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="无锁的线程安全整数-AtomicInteger"><a href="#无锁的线程安全整数-AtomicInteger" class="headerlink" title="无锁的线程安全整数 AtomicInteger"></a>无锁的线程安全整数 AtomicInteger</h2><p>为了能够受益于CAS等CPU指令,JDK并发包中有一个Atomic包,里面实现了一些直接使用CAS操作的线程安全的类型</p><p>下面是AtomicInteger的一些常用方法,对应其他原子类,操作是类似的.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-18%2021-36-35.png" alt=""></p><p>内部实现上来说,AtomicInteger中保存一个核心字段</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; <span class="comment">//代表atomicInteger的当前实际取值.</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset; <span class="comment">//保存value字段在AtomicInteger对向中的偏移量.</span></span><br></pre></td></tr></table></figure><p>一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger i =<span class="keyword">new</span> AtomicInteger(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">1000</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                i.incrementAndGet();</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                System.out.println(i +<span class="string">" "</span>+Thread.currentThread().getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread[] ts =<span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            ts[k]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            ts[k].start();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for(int k=0;k&lt;10;k++)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            ts[k].join();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AtomicReference-无锁的对象引用"><a href="#AtomicReference-无锁的对象引用" class="headerlink" title="AtomicReference 无锁的对象引用"></a>AtomicReference 无锁的对象引用</h2><p>AtomicReference 和AtomicInteger 非常类似,不同之处在于AtomicInteger是对整数的封装,而AtomicReference对应普通的对象引用.它可以保证用户在修改对象引用时的线程安全性.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个Person对象，它们的id分别是101和102。</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">101</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">102</span>);</span><br><span class="line">        <span class="comment">// 新建AtomicReference对象，初始化它的值为p1对象</span></span><br><span class="line">        AtomicReference&lt;Person&gt; ar = <span class="keyword">new</span> AtomicReference&lt;&gt;(p1);</span><br><span class="line">        <span class="comment">// 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。</span></span><br><span class="line">        ar.compareAndSet(p1, p2);</span><br><span class="line">        Person p3 = ar.get();</span><br><span class="line">        System.out.println(<span class="string">"p3 is "</span>+p3);</span><br><span class="line">        System.out.println(<span class="string">"p3.equals(p1)="</span>+p3.equals(p1));</span><br><span class="line">        System.out.println(<span class="string">"p3.equals(p2)="</span>+p3.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> id;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"id:"</span>+id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="AtomicIntegerArray-无锁的数组"><a href="#AtomicIntegerArray-无锁的数组" class="headerlink" title="AtomicIntegerArray 无锁的数组"></a>AtomicIntegerArray 无锁的数组</h2><p>除基本数据类型外,JDK还准备了数组等复合结构,</p><p>AtomicIntegerArray 本质是对int[] 类型的封装,使用UNSAFE类通过CAS的方式控制int[] 在多线程下的安全性.有如下常用API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//获得数组第i个下标的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;<span class="comment">//获得数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> newValue)</span><span class="comment">//将第i个下标的值设置为newValue,返回旧值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> expect,<span class="keyword">int</span> update)</span><span class="comment">//进行CAS操作,如果第i个下标的元素等于expect,则设置为update,设置成功返回true.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> delta)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicIntegerArray array =<span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">1000</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                array.getAndIncrement(k%array.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread ts[] =<span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            ts[k]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            ts[k].start();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for(int k=0;k&lt;10;k++)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            ts[k].join();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>); <span class="comment">//不让主线程sleep的话,可能输出的时候,其他线程还没有运行结束.这也是前面加join的意思.</span></span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AtomicIntegerFieldUpdater-让类中某变量也可以原子操作"><a href="#AtomicIntegerFieldUpdater-让类中某变量也可以原子操作" class="headerlink" title="AtomicIntegerFieldUpdater 让类中某变量也可以原子操作"></a>AtomicIntegerFieldUpdater 让类中某变量也可以原子操作</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发包之线程池</title>
      <link href="/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>Java中的线程池是运用场景最多的并发框架,几乎所有需要异步或并发执行任务的程序<br>都可以使用线程池。</p><p>使用线程池的好处。<br>第一:降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>第二:提高响应速度。当任务到达时,任务可以不需要等到线程创建就能立即执行。<br>第三:提高线程的可管理性。线程是稀缺资源,如果无限制地创建,不仅会消耗系统资源,<br>还会降低系统的稳定性,使用线程池可以进行统一分配、调优和监控。</p><a id="more"></a><h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3><p>线程池的处理流程</p><p>1)线程池判断核心线程池里的线程是否都在执行任务。如果不是,则创建一个新的工作<br>线程来执行任务。如果核心线程池里的线程都在执行任务,则进入下个流程。<br>2)线程池判断工作队列是否已经满。如果工作队列没有满,则将新提交的任务存储在这<br>个工作队列里。如果工作队列满了,则进入下个流程。<br>3)线程池判断线程池的线程是否都处于工作状态。如果没有,则创建一个新的工作线程<br>来执行任务。如果已经满了,则交给饱和策略来处理这个任务。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-19%2020-32-11.png" width="95%"></p><p>ThreadPoolExecutor执行Executor方法分下面4种情况</p><p>1)如果当前运行的线程少于corePoolSize,则创建新线程来执行任务(注意,执行这一步骤<br>需要获取全局锁)。<br>2)如果运行的线程等于或多于corePoolSize,则将任务加入BlockingQueue。<br>3)如果无法将任务加入BlockingQueue(队列已满),则创建新的线程来处理任务(注意,执行这一步骤需要获取全局锁)。<br>4)如果创建新线程将使当前运行的线程超出maximumPoolSize,任务将被拒绝,并调用<br>RejectedExecutionHandler.rejectedExecution()方法。</p><p>ThreadPoolExecutor采取上述步骤的总体设计思路,是为了在执行execute()方法时,尽可能<br>地避免获取全局锁(那将会是一个严重的可伸缩瓶颈)。在ThreadPoolExecutor完成预热之后(当前运行的线程数大于等于corePoolSize),几乎所有的execute()方法调用都是执行步骤2,而步骤2不需要获取全局锁。</p><p><strong>工作线程</strong> 线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。</p><h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><h4 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h4><p>ArrayListBlockingQueue: 一个由数组结构组成的有界阻塞队列</p><p>LinkedBlockingQueue: 一个由链表结构组成的无界阻塞队列</p><p>PriorityBlockingQueue: 一个支持优先级排序的无界阻塞队列</p><p>DelayQueue: 一个使用优先级队列实现的无界阻塞队列</p><p>SynchronousQueue 一个不存储元素的阻塞队列</p><p>LinkedtransferQueue 一个由链表结构组成的无界阻塞队列</p><p>LinkedBlockingDeque 一个由链表结构组成的双向阻塞对列</p><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><p>通过ThreadPoolExecutor 来创建一个线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corepoolsize,maxiumPoolsize,keepalivetime,millseconds,runnabelTaskQueue,handler);</span><br></pre></td></tr></table></figure><p><strong>一个线程池要实现ExecutorService接口,ExecutorService 继承自Executor.</strong></p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-16%2022-40-03.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h4 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h4><p>两个方法向线程池提交任务.分别为execute()和submit()</p><p>execute()方法用于提交不需要返回值的任务,所以无法判断任务是否被线程池执行成功.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">threadpool.execute(<span class="keyword">new</span> Runnable()</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                       </span>&#123;</span><br><span class="line">                           <span class="comment">//TODO</span></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br></pre></td></tr></table></figure><p>submit方法用于提交需要返回值的任务,线程池会返回一个future类型的对象,通过这个future对象可以判断任务是否执行成功,并且可以通过future的get()方法来获取值,get方法会阻塞当前线程直到任务完成,而使用get(long timeout, TimeUnit unit) 方法则会阻塞当前线程一段时间后立即返回,这时候可能任务还没执行完</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future  =executor.submit(harReturnValuetask);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Object s= future.get();</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程,然后逐个调用线程的interrupt方法来中断线程,所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别,shutdownNow首先将线程池的状态设置成STOP,然后尝试停止所有的正在执行或暂停任务的线程,并返回等待执行任务的列表,而shutdown只是将线程池的状态设置成SHUTDOWN状态,然后中断所有没有正在执行任务的线程。<br>只要调用了这两个关闭方法中的任意一个,isShutdown方法就会返回true。当所有的任务<br>都已关闭后,才表示线程池关闭成功,这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池,应该由提交到线程池的任务特性决定,通常调用shutdown方法来关闭线程池,如果任务不一定要执行完,则可以调用shutdownNow方法。</p><p>也就是或,shutdown 不会关闭还在运行的线程,shutdownnow会尝试中断还在运行的线程.</p><h3 id="核心线程池的内部实现"><a href="#核心线程池的内部实现" class="headerlink" title="核心线程池的内部实现"></a>核心线程池的内部实现</h3><p>对于核心的几个线程池,无论是newFixedThreadPool()方法,newSingleThreadExecutor()还是newCachedThreadPool()方法,虽然看起来创建的线程有着完全不同的特点,但是内部实现均使用了ThreadPoolExecutor实现</p><p>都是return了一个 new ThreadPoolExecutor().核心的线程池都是ThreadPoolExecutor类的封装.</p><p>通过ThreadPoolExecutor来创建一个线程池(自定义线程池)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,</span><br><span class="line">                       milliseconds,runnableTaskQueue,handler,unit);</span><br></pre></td></tr></table></figure><p>1)corePoolSize(线程池的基本大小)</p><p>2)runnableTaskQueue(任务队列):用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue 是一个基于数组结构的有界阻塞队列，此队列按照FIFO原则对元素进行排序。</span><br><span class="line">--------</span><br><span class="line">LinkedBlockingQueue 是一个基于链表结构的阻塞队列，此队列按照FIFO排列元素，吞吐量通常高于ArrayBlockingQueue, 静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</span><br><span class="line">---------</span><br><span class="line">SynchronousQueue 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue, 静态工厂方法Executors.newCachedThreadPool 使用了这个队列。</span><br><span class="line">---------</span><br><span class="line">PriorityBlockingQueue一个具有优先级的无界阻塞队列。</span><br></pre></td></tr></table></figure><p>3)maximumPoolSize(线程池最大数量):线程池允许创建的最大线程数。</p><p>4)ThreadFactory:线程工厂,用于创建线程.一般用默认的即可.</p><p>5)RejectedExecutionHandler(饱和策略):当队列和线程池都满了,说明线程池处于饱和状态,那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy,表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。<br>·AbortPolicy:直接抛出异常。<br>·CallerRunsPolicy:只用调用者所在线程来运行任务。<br>·DiscardOldestPolicy:丢弃队列里最近的一个任务,并执行当前任务。<br>·DiscardPolicy:不处理,丢弃掉。</p><p>6) keepAliveTime(线程活动保持时间):线程池的工作线程空闲后,保持存活的时间。</p><p>7) unit  keepAlivetime的单位.其中,Queue 是指提交但是未执行的任务队列,是一个<strong>BlockingQueue</strong>接口的对象,仅用于存放Runnable对象.</p><h4 id="几种阻塞队列"><a href="#几种阻塞队列" class="headerlink" title="几种阻塞队列:"></a>几种阻塞队列:</h4><ul><li>直接提交的队列:由SynchronousQueue对象提供,是一个特殊的blockingqueue.它没有容量,每一个插入操作都要等待一个相应的删除操作,反之,每一个删除操作都要等待对应的插入操作.如果使用此队列,提交的任务不会被真实的保存,而总是将新任务提交给线程执行,若没有空闲线程,则尝试新的进程,如果进程数量已经达到最大值,则执行拒绝策略.</li><li>有界的任务队列 : ArrayBlockingQueue 实现.它的构造函数中必须带有一个容量参数,表示该队列的最大容量.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br></pre></td></tr></table></figure><p>若有新任务,且实际线程小于corePoolSize,优先创建新的线程,若大于corePoolSize,将新任务加入等待队列,若队列满,则无法加入,在总线程不大于maximumPoolsize的基础上,创建新的线程,若大于maximumPoolSize,执行拒绝策略.</p><ul><li>优先任务队列:带有执行优先级的队列,通过PriorityBlockingQueue实现,可控制任务的执行先后顺序,是一个特殊的无界队列,</li></ul><hr><p><font color="00ffff">newFixedThreadPool 返回了一个corePoolSize和maximumPoolSize大小一样的,并且使用了LinkedBlockingQueue任务队列的线程池,</font></p><p>newSingleThreadExecutor()返回了一个单线程的线程池.</p><p>newCachedThreadPool()返回corePoolSize为0, maximumPoolSize无穷大的线程池, 并使用SynchronousQueue队列.<font color="00ffff"></font></p><h4 id="几种拒绝策略"><a href="#几种拒绝策略" class="headerlink" title="几种拒绝策略"></a>几种拒绝策略</h4><p>拒绝策略是系统超负荷运行时的补充措施,同时,等待队列中也已经满了,塞不下新任务了.JDK提供四种拒绝策略</p><ul><li>AbortPolicy 直接抛出异常,阻止系统正常工作</li><li>CallerRunsPolicy 只要线程池未关闭,该策略直接在调用者线程中,运行当前被丢弃的任务,所以这种策略不会真的丢弃任务,但是任务提交线程的性能极有可能急剧下降.</li><li>DiscardOledestPolicy 丢弃最老的一个请求,也就是即将被执行的一个任务,并尝试再次提交当前任务.</li><li>DiscardPolicy 默默丢弃无法处理的任务,不予以任何处理.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个线程池</span></span><br><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">5</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">10</span>),Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">                        System.out.println(r.toString()+<span class="string">"is discard"</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><h3 id="自定义线程创建-ThreadFactory"><a href="#自定义线程创建-ThreadFactory" class="headerlink" title="自定义线程创建 ThreadFactory"></a>自定义线程创建 ThreadFactory</h3><p>线程池中的线程从哪里来,答案就是ThreadFactory</p><p>ThreadFactory是一个接口,它只有一个方法,用来创建线程,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br></pre></td></tr></table></figure><p>当线程池需要新建线程时,就会调用这个方法</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发包之LockSupport</title>
      <link href="/2018/01/19/LockSupport/"/>
      <url>/2018/01/19/LockSupport/</url>
      
        <content type="html"><![CDATA[<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>LockSupport 是一个非常方便实用的线程阻塞工具,它可以在线程内任意位置让线程阻塞,</p><p>LockSupport 的静态方法park()可以阻塞当前线程,类似的还有parkNanos(),parkUntil()等方法,它们实现了一个限时的等待.</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object u=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t1 =<span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t2 =<span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="title">ChangeObjectThread</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setName(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(u)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"in "</span>+getName());</span><br><span class="line">                LockSupport.park(); <span class="comment">//让当前线程阻塞</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(<span class="string">"123"</span>);</span><br><span class="line">        LockSupport.unpark(t1); <span class="comment">//唤醒t1线程</span></span><br><span class="line">        LockSupport.unpark(t2);<span class="comment">// 唤醒t2线程.</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in t1</span><br><span class="line"><span class="number">123</span></span><br><span class="line">in t2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发包之CyclicBarrier</title>
      <link href="/2018/01/19/CyclicBarrier/"/>
      <url>/2018/01/19/CyclicBarrier/</url>
      
        <content type="html"><![CDATA[<h3 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h3><p>CyclicBarrier的字面意思是可循环使用(Cyclic)的屏障(Barrier)。它要做的事情是,让一组线程到达一个屏障(也可以叫同步点)时被阻塞,直到最后一个线程到达屏障时,屏障才会开门,所有被屏障拦截的线程<strong>才会继续运行</strong>。它的功能比CountDownLatch 更加复杂且强大</p><p>CyclicBarrier 可以理解为循环栅栏,栅栏就是一种障碍物,这里就是用来阻止线程继续执行要求线程在栅栏处等待, Cyclic意为循环,也就是说这个计数器可以重复使用,比如,我们将技术器设置为10,那么凑齐第一批10个线程后,计数器就会归0,然后接着凑齐下一批10个线程,这就是循环栅栏的内在含义.</p><a id="more"></a><p>比countDownLatch 略微强大一些,CyclicBarrier可以接收一个参数作为barrierAction, barrierAction 就是当计数器一次计数完成后系统会执行的动作,所以有如下的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> number,Runnable barrierAction)</span></span></span><br></pre></td></tr></table></figure><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties),其参数表示屏障拦截的线程数量,每个线程调用await方法告诉CyclicBarrier我已经到达了屏障,然后当前线程被阻塞。当都到达await()的时候,屏障<strong>自动打开</strong>,示例代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c =<span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;c.await();&#125; </span><br><span class="line">                <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">                System.out.print(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">        System.out.print(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为主线程,子线程的调度是由CPU决定的,两个线程都有可能先执行,所以会产生两种输出</p><p>1  2   或者  2   1 </p><p>如果把<code>new CyclicBarrier(2)</code>改成<code>new CyclicBarrier(3)</code> 则主线程和子线程都会永远等待,因为没有第三个线程执行await方法,即没有第三个线程到达屏障,所以之前到达的两个线程都不会继续运行.</p><p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties,Runnable barrierAction),用于在线程到达屏障时,优先执行barrierAction,方便处理更复杂的业务场景.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String soldier;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclic;</span><br><span class="line"></span><br><span class="line">        Soldier(CyclicBarrier cyclic, String soldiername)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclic=cyclic;</span><br><span class="line">            <span class="keyword">this</span>.soldier =soldiername;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 每一个都要等待,直到所有的都完成.</span></span><br><span class="line">                cyclic.await();</span><br><span class="line">                dowork();</span><br><span class="line">                cyclic.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">dowork</span><span class="params">()</span> <span class="comment">//模拟做任务</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(Math.abs(<span class="keyword">new</span> Random().nextInt()%<span class="number">10000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println( soldier+<span class="string">"任务完成"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BarrierRun</span><span class="params">(<span class="keyword">boolean</span> flag,<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.flag=flag;</span><br><span class="line">            <span class="keyword">this</span>.N =N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(N+<span class="string">"任务完成"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(N+<span class="string">"集合完毕"</span>);</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">10</span>;</span><br><span class="line">        Thread[] threads =<span class="keyword">new</span> Thread[N];</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier =<span class="keyword">new</span> CyclicBarrier(N,<span class="keyword">new</span> BarrierRun(flag,N));<span class="comment">// 创建了一个屏障</span></span><br><span class="line">        System.out.println(<span class="string">"集合队伍"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(i+<span class="string">"报道"</span>);</span><br><span class="line">            threads[i]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Soldier(cyclicBarrier,<span class="string">" "</span>+i));<span class="comment">//每一个线程都传进去屏障.</span></span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-16%2021-56-33.png" alt=""></p><h4 id="CyclicBarrier的应用场景"><a href="#CyclicBarrier的应用场景" class="headerlink" title="CyclicBarrier的应用场景"></a>CyclicBarrier的应用场景</h4><p>CyclicBarrier可以用于多线程计算数据,最后合并计算结果的场景。例如,用一个Excel保存了用户所有银行流水,每个Sheet保存一个账户近一年的每笔银行流水,现在需要统计用户的日均银行流水,先用多线程处理每个sheet里的银行流水,都执行完之后,得到每个sheet的日均银行流水,最后,再用barrierAction用这些线程的计算结果,计算出整个Excel 的日均银行流水.</p><h4 id="CyclicBarrier-实现"><a href="#CyclicBarrier-实现" class="headerlink" title="CyclicBarrier 实现"></a>CyclicBarrier 实现</h4><p>CyclicBarrier实现主要基于ReentrantLock</p><h4 id="CyclicBarrier和CountDownLatch-的区别"><a href="#CyclicBarrier和CountDownLatch-的区别" class="headerlink" title="CyclicBarrier和CountDownLatch 的区别"></a>CyclicBarrier和CountDownLatch 的区别</h4><p>Countdownlatch 是在多个线程都进行了latch.countDown后才会触发事件，唤醒await在latch上的线程，而执行countDown的线程，执行完countDown后会继续自己的工作。</p><p>CyclicBarrier是一个栅栏，用于同步所有调用await方法的线程，并且等所有线程都到了await方法时，这些线程才一起返回继续各自的工作。</p><p>CountDownLatch简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用countDown()方法发出通知后，当前线程才可以继续执行。cyclicBarrier是所有线程都进行等待，直到所有线程都准备好进入await()方法之后，所有线程同时开始执行.</p><p>CountDownLatch的计数器只能使用一次,而CyclicBarrier的计数器可以用<strong>reset()</strong>方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如,如果计算发生错误,可以重置计数器,并让线程重新执行一次。<br>CyclicBarrier还提供其他有用的方法,比如<code>getNumberWaiting</code>方法可以获得<code>CyclicBarrier</code>阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。</p><p>还有很重要的一个区别是 闭锁用于等待事件,而栅栏常用语等待其他线程.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发包之CountDownLatch</title>
      <link href="/2018/01/19/CountDownLatch/"/>
      <url>/2018/01/19/CountDownLatch/</url>
      
        <content type="html"><![CDATA[<h3 id="等待多线程完成的CountDownLatch-门闩"><a href="#等待多线程完成的CountDownLatch-门闩" class="headerlink" title="等待多线程完成的CountDownLatch(门闩)"></a>等待多线程完成的CountDownLatch(门闩)</h3><p>CountDownLatch 可以让某一个线程直到倒计时结束,才开始执行.</p><p>countdownLatch通过一个计数器进行实现，计数器的初始值为线程的数量，每当一个线程完成了自己的任务后，计数器的值就会减一，当计数器值达到0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的进程就可以恢复任务执行。</p><a id="more"></a><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。<br>假如有这样一个需求:我们需要解析一个Excel里多个sheet的数据,此时可以考虑使用多<br>线程,每个线程解析一个sheet里的数据,等到所有的sheet都解析完之后,程序需要提示解析完<br>成。在这个需求中,要实现主线程等待所有线程完成sheet的解析操作,最简单的做法是使用<br>join()方法,代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinCountDownlatch</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread parser1  = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"1 finish"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread parser2 =<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"2 finish"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        parser1.start();</span><br><span class="line">        parser2.start();</span><br><span class="line">        parser1.join();</span><br><span class="line">        parser2.join();</span><br><span class="line">        System.out.println(<span class="string">"all finished!"</span>);_</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>join用于让当前线程执行线程等待join线程执行结束,其原理是不停的检查join线程是否存活,如果join线程存活则当前线程永远等待. 直到join线程中止后,线程的this.notifyAll()方法会被调用.</p><p>并发包的CountDownLatch 也可以实现join的功能,并且比join的功能更多.</p><p>CountDownLatch 的构造函数接收一个int类型的参数作为计数器,想等待N个点完成,就传入N.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinCountDownlatch</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CountDownLatch c =<span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        c.await(); <span class="comment">//主线程执行这条语句,所以主线程阻塞掉.</span></span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用CountDownLatch的countDown方法时,N就会减1,CountDownLatch 的await方法 会阻塞当前线程,直到N变为0</p><p>countDown可以用在任何地方,所以这里的N个点,可以是N个线程,也可以是一个线程里的N个执行步骤,用在多个线程中时,只需把这个CountDownLatch 的引用传递到线程里即可.</p><p>CountDownLatch的await 函数也有带指定之间的形式避免无限等待.</p><p>与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用<strong>CountDownLatch.await()</strong>方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p><p><em>在主线程的代码中执行await操作就是主线程进行等待，在工作线程上执行就是工作线程执行</em></p><p>其他N 个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过 <strong>CountDownLatch.countDown()</strong>方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调 用了这个方法，count的值等于0，然后主线程就能通过await()方法，恢复执行自己的任务。</p><p>另一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表示有10个线程完成任务,等待在CountDownLatch上的线程才能继续执行.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end =<span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatchDemo demo =<span class="keyword">new</span> CountDownLatchDemo();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)*<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"check comlete"</span>);</span><br><span class="line">            end.countDown();<span class="comment">//通知 CountDownLatch, 一个线程已经完成了任务.</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            executorService.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待检查</span></span><br><span class="line">        end.await();<span class="comment">//要求主线程等待所有10个检查任务全部完成后,主线程才能继续执行.</span></span><br><span class="line">        System.out.println(<span class="string">"Fire!"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发包之读写锁</title>
      <link href="/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/"/>
      <url>/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="并发包之读写锁"><a href="#并发包之读写锁" class="headerlink" title="并发包之读写锁"></a>并发包之读写锁</h2><p>之前的锁基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在<strong>写线程访问时，所有的读线程和其他写线程均被阻塞</strong>，读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排它锁有了很大的提升。</p><p>没有读写锁的时候，要完成读写功能就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行<em>通知</em>后，所有等待的读操作才能继续进行,这样的目的是不会出现脏读。改用读写锁实现上述功能，只需要在读操作时获取读锁，写操作时获取写锁即可。当写锁被获取到后，后续的读写操作都会被阻塞，写锁释放以后，读写操作继续执行，相对于等待通知机制，更加简单明了。</p><a id="more"></a><p>在读大于写的情况下，读写锁能够提供比排他锁更好的并发性和吞吐量。并发包中读写锁的实现是ReentrantReadWriteLock,支持公平性选择，重入，锁降级（遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">读写锁的例子</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> ReentrantReadWriteLock readWriteLock =<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">static</span> Lock read = readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">static</span> Lock write =readWriteLock.writeLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">get</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        read.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            read.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">set</span><span class="params">(String key, String value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        write.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span>  map.put(key,value);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            write.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        write.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            write.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁，读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的</p><p>一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。</p><p>读写锁比互斥锁允许对于共享数据更大程度的并发，每次只能有一个写线程，但是同时可以有多个线程并发地读数据，ReadWriteLock适用于读多写少的并发情况。</p><p>ReadWriteLock是一个接口，主要有两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function">Lock <span class="title">readLock</span><span class="params">()</span>；<span class="comment">//返回读锁</span></span></span><br><span class="line"><span class="function">  Lock <span class="title">writeLock</span><span class="params">()</span></span>;<span class="comment">//返回写锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">   sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">   writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认构造方法时非公平模式，创建的Sync是NonfairSync对象，然后初始化读锁和写锁。</p><p>Sync 继承了AbstractQueuedSynchronizer,而Sync 是一个抽象类，NonfairSync 和FairSync 继承了Sync, 并重写了其中的抽象方法。</p><h4 id="Sync-分析"><a href="#Sync-分析" class="headerlink" title="Sync 分析"></a>Sync 分析</h4><p>Sync中提供了很多方法，但是有两个方法是抽象的，子类必须实现。下面以FairSync为例，分析一下这两个抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926L</span>;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>writerShouldBlock和readerShouldBlock方法都表示当有别的线程也在尝试获取锁时，是否应该阻塞。<br>对于公平模式，hasQueuedPredecessors()方法表示前面是否有等待线程。一旦前面有等待线程，那么为了遵循公平，当前线程也就应该被挂起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">815965037L</span>;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">             * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">             * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">             * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">             * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">             * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，非公平模式下，writerShouldBlock直接返回false，说明不需要阻塞；而readShouldBlock调用了apparentFirstQueuedIsExcluisve()方法。该方法在当前线程是写锁占用的线程时，返回true；否则返回false。也就说明，如果当前有一个写线程正在写，那么该读线程应该阻塞。<br>继承AQS的类都需要使用state变量代表某种资源，ReentrantReadWriteLock中的state代表了读锁的数量和写锁的持有与否，整个结构如下： </p><p><img src="http://two-1252095801.cosgz.myqcloud.com/389B233C-8C3B-49B7-9918-64DE71DA611C.png?sign=uuW44T9QExZU41kS7+TYZsgYqRVhPTEyNTIwOTU4MDEmaz1BS0lEZUVqQVZmZXF1bmN4SFdTS1hLN29ObHgwczlLSzRvTW0mZT0xNTIzNzc4NjY1JnQ9MTUyMTE4NjY2NSZyPTE4NTExMTc0MDYmZj0vMzg5QjIzM0MtOEMzQi00OUI3LTk5MTgtNjRERTcxREE2MTFDLnBuZyZiPXR3bw==" alt=""></p><p>可以看到state的高16位代表读锁的个数；低16位代表写锁的状态。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发包之重入锁</title>
      <link href="/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E9%87%8D%E5%85%A5%E9%94%81/"/>
      <url>/2018/01/19/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E9%87%8D%E5%85%A5%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="并发包之重入锁-synchronized的功能扩展"><a href="#并发包之重入锁-synchronized的功能扩展" class="headerlink" title="并发包之重入锁(synchronized的功能扩展)"></a>并发包之重入锁(synchronized的功能扩展)</h2><p>重入锁ReentrantLock，就是支持重进入的锁，它表示一个该锁能够支持一个线程对资源的重复加锁，除此之外，该锁还支持取锁时的公平和非公平性选择。Synchronized关键字隐式的支持可重入，比如一个Synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次获得该锁。不会因为获取了锁，下次获取锁的时候就把自己阻塞。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reentertLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//显式的声明一个重入锁.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i= <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">        &#123;<span class="comment">//显式加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">//显式解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        reentertLock r1 =<span class="keyword">new</span> reentertLock();</span><br><span class="line">        Thread t1 =<span class="keyword">new</span> Thread(r1);</span><br><span class="line">        Thread t2 =<span class="keyword">new</span> Thread(r1);</span><br><span class="line">      <span class="comment">// 线程t1 t2 都执行相同的run函数.</span></span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="锁申请等待限时"><a href="#锁申请等待限时" class="headerlink" title="锁申请等待限时"></a>锁申请等待限时</h4><p>使用tryLock()方法进行一次限时的等待.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限时等待锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock =<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;   <span class="comment">//try 接收两个参数,时长和单位.</span></span><br><span class="line">            <span class="keyword">if</span>(lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS))</span><br><span class="line">            &#123;Thread.sleep(<span class="number">3000</span>);&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;System.out.println(<span class="string">"get lock failed"</span>);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;e.printStackTrace();&#125;</span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.isHeldByCurrentThread())</span><br><span class="line">            &#123;lock.unlock();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TimeClock m1 =<span class="keyword">new</span> TimeClock();</span><br><span class="line">        Thread t1 =<span class="keyword">new</span> Thread(m1);</span><br><span class="line">        Thread t2 =<span class="keyword">new</span> Thread(m1);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>当使用Synchronized时,产生的锁是非公平的,而重入锁允许对其公平性进行设置 它有一个如下的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fair_lock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock =<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"获得锁"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        fair_lock f1 =<span class="keyword">new</span> fair_lock();</span><br><span class="line">        Thread t1 =<span class="keyword">new</span> Thread(f1,<span class="string">"t1"</span>);</span><br><span class="line">        Thread t2 =<span class="keyword">new</span> Thread(f1,<span class="string">"t2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重入锁的重要方法"><a href="#重入锁的重要方法" class="headerlink" title="重入锁的重要方法"></a>重入锁的重要方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock():获得锁,如果锁已经被占用,则等待</span><br><span class="line">lockInterruptibly():获得锁,但优先相应中断.</span><br><span class="line">tryLock(); 尝试获得锁,如果成功,则返回<span class="keyword">true</span>,失败返回<span class="keyword">false</span>,该方法不等待,立即返回</span><br><span class="line">tryLock(Long time ,TimeUnit unit);给定时间内尝试获得锁</span><br><span class="line">unlock()释放锁.</span><br></pre></td></tr></table></figure><h2 id="Condition条件-重入锁的好搭档"><a href="#Condition条件-重入锁的好搭档" class="headerlink" title="Condition条件( 重入锁的好搭档)"></a>Condition条件( 重入锁的好搭档)</h2><p>Condition 对象和wait()和notify()的作用是大致相同的,但是wait()和notify()是和Synchronized关键字合作使用的,而condition 是和重入锁相关联的</p><p>通过Lock接口的Condition new Condition()方法就可以生成一个与当前重入锁绑定的Condition 实例,</p><p>通过condition 对象,我们就可以让线程在合适的时间等待,或者在合适的时刻得到通知,继续执行</p><p>Condition 接口的基本方法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">await</span><span class="params">()</span></span>;</span><br><span class="line">使当前线程等待,同时释放当前锁,当其他线程中使用signal()或者signalAll()方法时,线程会重新获得锁并继续执行,或者当线程中断时,也能跳出等待.</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">和await()方法基本相同,但是不会在等待过程中相应中断</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time,TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">用于唤醒一个等待中的线程.</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">唤醒所有等待中的线程.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Condition_example</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock =<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">//通过lock 生成condition 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Condition  condition =lock.newCondition();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">          <span class="comment">//线程在condition对象上等待.</span></span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"Thread is  going on"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Condition_example conditionExample =<span class="keyword">new</span> Condition_example();</span><br><span class="line">        Thread  t1 =<span class="keyword">new</span> Thread(conditionExample);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">      <span class="comment">//主线程发出通知,告知等待在Condition上的线程现在可以继续执行了.</span></span><br><span class="line">        condition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和wait和notify方法一样,当线程使用condition.await()时,要求线程持有相关的重入锁.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程之通知等待机制</title>
      <link href="/2018/01/19/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/01/19/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>一个线程修改了一个对象的值，另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，最终执行又是另一个线程，前者是生产者，后者是消费者。Java如何实现？</p><p>一种办法是让消费者线程不断的循环检查变量是否符合预期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(value!=desire)</span><br><span class="line">&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">doSomething();</span><br><span class="line">存在的问题：难以确保及时性，难以降低开销。</span><br></pre></td></tr></table></figure><p>使用内置的等待/通知机制解决问题</p><a id="more"></a><p>等待/通知的相关方法任意Java对象都具备，因为方法定义在Java.lang.Object上。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/171113.png" alt=""></p><p>等待通知机制，指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()方法或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作，上述两个线程通过对象O完成交互，而对象上的wait()和notify/notifyAll()的关系就像开关信息一样，用来等待方和通知方之间的交互工作。</p><p>调用wait() notify() notifyAll() 时注意的细节</p><ul><li>调用wait()方法后会释放对象的锁。</li></ul><ul><li>使用wait() notify() notifyAll() 时需要先对调用对象加锁。</li><li>调用wait() 后，线程状态由running变为waiting.并将当前线程放置到对象的等待队列。</li><li>notify() notifyAll()方法调用后，等待线程依旧不会从wait返回，需要调用notify()或 notifyAll()的线程释放锁以后，等待线程才有机会从wait返回。</li><li>接上一条，从wait方法返回的前提是获得了调用对象的锁（也就是调用notify()释放锁，调用wait()的重新获得锁，才有可能返回）。</li><li>notify()方法将等待队列中一个等待线程从等待队列移到同步队列中。而notifyall方法则将等待队列中所有线程移到同步队列，被移动的线程从waiting变为blocked</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程基础总结</title>
      <link href="/2018/01/19/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
      <url>/2018/01/19/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="如何创建并运行Java线程"><a href="#如何创建并运行Java线程" class="headerlink" title="如何创建并运行Java线程"></a>如何创建并运行Java线程</h2><p>Java线程类也是一个Object类，它的实例都继承自Java.lang.Thread 或者其子类。可以用如下方式在Java中创建一个线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">thread.start();<span class="comment">// 执行该线程</span></span><br></pre></td></tr></table></figure></p><p>编写线程运行的代码分为两种方式，一种是创建Thread子类的一个实例并且重写run()方法，第二种是创建类的时候实现Runnable 接口。</p><a id="more"></a><ol><li>创建子类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Thread子类的一个实例并重写run方法，run方法会在调用start()方法之后被执行。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"running"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread t1= <span class="keyword">new</span> MyThread();</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>一旦线程启动后start()方法就会立即返回，而不会等待到run()方法执行完毕后才返回，就好像run()方法是在另外一个CPU上执行一样，当run方法执行后，将会打印出字符running。</p><ol start="2"><li>实现runnable接口</li></ol><p>runnable的中文意思即为任务，顾名思义，通过实现runnable接口，我们定义了一个子任务，然后将子任务交给Thread去执行。这种方式必须将runnable作为Thread类的参数。</p><p>新建一个实现了Java.lang.Runnable接口的类的实例，实例中的方法可以被线程调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"running"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使线程可以执行run()方法，需要在Thread类的构造函数中传入MyRunnable 的实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread thread =<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">thread.start();<span class="comment">// 当线程运行时，会调用实现了Runnable 接口的run方法。</span></span><br></pre></td></tr></table></figure><p>Thread  类中有方法 getName 来得到当前线程的名字</p><p>但是实现runnable接口的子类并不是Thread的子类。所以没有getName方法。</p><p>通用做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name =  Thread.currentThread().getName();</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><em>1 因为线程操作的不确定性，所以主线程有可能最先执行完，那么此时其他线程不会受到任何影响，并不会随着主线程的结束而结束。 但是主线程一般还是最后完成，因为执行各种关闭动作。</em></p><p><em>2 一个Java程序启动至少会启动两个线程，每当使用Java命令执行一个类时，都会启动一个jvm，每一个jvm实际都是在OS中启动了一个线程，再加上垃圾收集线程，所以Java程序运行时，至少会启动两个线程，一个是主线程，一个是垃圾收集线程。</em></p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ul><li><p>创建（new）状态: 准备好了一个多线程的对象</p></li><li><p>就绪（runnable）状态: 调用了<code>start()</code>方法, 等待CPU进行调度</p></li><li><p>运行（running）状态: 执行<code>run()</code>方法</p></li><li><p>阻塞（blocked）状态: 暂时停止执行, 可能将资源交给其它线程使用</p></li><li><p>终止（dead）状态: 线程销毁</p><p>创建一个进程后，并不会立即进入就绪状态，因为线程的运行需要一些条件（比如内存资源等）只有线程运行的条件都满足了，才进入就绪状态。进入就绪状态也不代表获得了CPU的执行时间，因此只有等到获得了CPU的执行时间，线程才真正的进入运行状态。</p></li></ul><h2 id="线程类中的方法"><a href="#线程类中的方法" class="headerlink" title="线程类中的方法"></a><em>线程类中的方法</em></h2><p><img src="http://blog-1252095801.cosgz.myqcloud.com/1731516027150_.pic_hd.jpg" width="50%"></p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><h5 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread()"></a>currentThread()</h5><p>方法返回代码段正在被哪个线程调用的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[] args）</span><br><span class="line">    &#123; System.out.println(Thread.currentThread.getName());&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sleep-方法-线程的休眠"><a href="#sleep-方法-线程的休眠" class="headerlink" title="sleep() 方法 线程的休眠"></a>sleep() 方法 线程的休眠</h5><p>sleep()方法作用实在指定的毫秒数内让当前正在执行的线程休眠，这个正在执行的线程就是this.currentThread()返回的线程。</p><p>sleep 相当于让线程睡眠，交出CPU，让CPU执行其他任务，但是<em>sleep()方法不会释放锁，如果当前线程持有某个对象的锁，即使调用sleep，其他线程也无法访问这个对象</em></p><p>如果调用了sleep方法，必须捕获InterruptedException 异常或者向上抛出。当线程睡眠时间满后，不一样会立即得到执行，因此此时可能CPU正在执行其他任务。所以相当于让线程<strong>阻塞</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sleep(<span class="keyword">long</span> millis) <span class="comment">//毫秒</span></span><br><span class="line">sleep(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanoseconds) <span class="comment">//毫秒 纳秒</span></span><br></pre></td></tr></table></figure><h5 id="yield-方法-线程的礼让"><a href="#yield-方法-线程的礼让" class="headerlink" title="yield()方法 线程的礼让"></a>yield()方法 线程的礼让</h5><p>调用yield会让当前线程交出CPU权限，让CPU执行其他的线程，跟sleep一样，也不释放锁，但是yield不能控制具体的交出CPU的时间，另外，yield只能让相同优先级的线程获取CPU执行时间的机会。调用yield不会让线程阻塞，只会重新回到就绪状态。</p><h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p><strong>start()方法</strong> start用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。</p><p><strong>run()方法</strong> run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。</p><p><strong>getId()方法</strong>获取线程的唯一标识</p><p><strong>isAlive()方法</strong> 判断当前线程是否处在活动状态。</p><p><strong>join()方法</strong> 很多情况下，主线程创建并启动了线程，如果子线程要进行大量的耗时运算，主线程往往早于子线程结束前结束，这时，如果主线程想等待子线程执行完成后再结束，就是对子线程用join方法，让他进行强制执行，作用就是等待线程对象销毁。用法为对象.join()，然后这个对象就先执行，执行完后再执行其他进程。</p><p>在线程操作中，可以使用join方法让一个线程强制执行，线程强制执行期间，其他线程无法运行，必须等待此线程完成以后才可以继续执行。</p><p>join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程，比如在线程b中调用了a的join方法，直到线程a执行完毕后，才会继续执行线程b.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(Thread.currentThread.getName()+i)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      Mythread mt = <span class="keyword">new</span> Mythread();</span><br><span class="line">        Thread t =<span class="keyword">new</span> Thread(t);</span><br><span class="line">      t.start();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t.join();   <span class="comment">// exception</span></span><br><span class="line">            &#125;</span><br><span class="line">          System.out.println(main运行 +i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">结果：</span><br><span class="line">main <span class="number">0</span></span><br><span class="line">main <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">main <span class="number">9</span></span><br><span class="line">main <span class="number">10</span></span><br><span class="line">线程 <span class="number">0</span></span><br><span class="line">线程 <span class="number">1</span></span><br><span class="line">线程 <span class="number">2</span></span><br><span class="line">...</span><br><span class="line">线程 <span class="number">50</span></span><br><span class="line">main <span class="number">11</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="Object类方法"><a href="#Object类方法" class="headerlink" title="Object类方法"></a>Object类方法</h3><p><strong>wait()方法</strong>导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在<strong>同步方法</strong>中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。</p><p><strong>notify()方法</strong> 选择一个在该对象上调用wait方法的线程，解除其等待状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。</p><p><strong>任何对象都可以调用这两个方法,当在一个对象实例上调用wait()方法后,当前线程就会在这个对象上等待,比如,在线程A中,调用了obj.wait()方法,那么线程A就会停止继续运行,而转为等待状态,等待到何时结束呢,线程A会一直等待到其他线程调用了obj.notify()方法为止</strong></p><p>object.wait()方法并不是随时可以调用的,它必须包含在对应的Synchronized语句中,wait和notify都需要先获得目标对象的一个监视器.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-15%2022-30-20.png" width="40%"></p><p><strong>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</strong></p><p>答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 wait()会释放锁,sleep不释放任何资源</p><h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><p>三种方式。</p><ul><li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li><li>使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样，都是作废过期的方法，使用他们可能产生不可预料的结果。</li><li>使用interrupt方法中断线程，但这个不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止。</li></ul><h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>线程中断不会使线程立即退出,而是给线程发送一个通知,告知目标线程,有人希望你退出,至于目标线程接到通知后如何处理,则完全由目标线程自行决定.</p><p>当一个线程运行时，另外一个线程可以直接通过interrupt()方法中断其运行状态。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础</title>
      <link href="/2018/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步和异步通常用来形容一次方法调用,同步方法调用一旦开始,调用者必须等到方法调用返回后,才能继续后续的行为,异步方法更像是一个消息传递,,一旦开始,方法调用就会立即返回,调用者就可以继续后面的工作,而异步方法通常在另外一个线程中真实的执行,整个过程,不会阻碍调用者的工作.</p><a id="more"></a><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞和非阻塞通常用来形容多线程间的相互关系,比如一个线程占用了临界区资源,那么其他所有需要这个资源的线程都必须啊在这个临界区中进行等待,等待会导致线程挂起,这种情况就是阻塞.</p><h2 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h2><h4 id="并行工作者"><a href="#并行工作者" class="headerlink" title="并行工作者"></a>并行工作者</h4><p>传入的作业被分配到不同的工作者上。<br><img src="http://blog-1252095801.cosgz.myqcloud.com/2017-10-20.png" alt="1"><br>并行工作者模型中，委派者将传入的作业分配给不同的工作者，每个工作者完成任务，工作者们并行运行在不同的线程上，甚至可能不同的ＣＰＵ上。</p><h4 id="流水线模式"><a href="#流水线模式" class="headerlink" title="流水线模式"></a>流水线模式</h4><p><img src="http://blog-1252095801.cosgz.myqcloud.com/2017-10-21-1.png" alt="1"><br>每个工作者只负责作业中的部分工作，当完成了自己的这部分工作时工作者会将作业转发给下一个工作者，每个工作者在自己的线程中运行，并且不会和其他工作者共享状态。<br>采用流水线并发模型的系统有时候也被称为反应器系统或者事件驱动系统。</p><h2 id="竞态条件与临界区"><a href="#竞态条件与临界区" class="headerlink" title="竞态条件与临界区"></a>竞态条件与临界区</h2><p>在同一个程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。</p><p>当两个线程竞争同一资源时，如果在资源的访问顺序敏感，就称存在竞态关系，导致竞态条件发生的代码区就成为临界区。</p><h2 id="线程安全与共享资源"><a href="#线程安全与共享资源" class="headerlink" title="线程安全与共享资源"></a>线程安全与共享资源</h2><p>允许被多个线程同时执行的代码也被叫做线程安全的代码，线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。</p><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>局部变量存储在线程自己的栈中，所以局部变量永远不会被多个线程共享。所以基础类型的局部变量是线程安全的。</p><h5 id="局部的对象引用"><a href="#局部的对象引用" class="headerlink" title="局部的对象引用"></a>局部的对象引用</h5><p>对象的局部引用和基础类型的局部变量不太一样，尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈中。对象都存储在共享堆中。如果在某个方法中创建的对象不会逃逸出（<em>注：即该对象不会被其它方法获得，也不会被非局部变量引用到</em>）该方法，那么它就是线程安全的。实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。</p><h5 id="对象成员"><a href="#对象成员" class="headerlink" title="对象成员"></a>对象成员</h5><p>对象成员存储在堆上，如果两个线程同时更新同一个对象的同一个成员，那么代码就不是线程安全的。</p><h4 id="线程控制逃逸规则"><a href="#线程控制逃逸规则" class="headerlink" title="线程控制逃逸规则"></a>线程控制逃逸规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程控制逃逸规则可以帮助你判断代码中对某些资源的访问是否是线程安全的。</span></span><br><span class="line"><span class="comment">//如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。</span></span><br><span class="line"><span class="comment">//资源可以是对象，数组，文件，数据库连接，套接字等等。Java中你无需主动销毁对象，所以“销毁”指不再有引用指向对象。</span></span><br></pre></td></tr></table></figure><h2 id="线程安全及不可变性"><a href="#线程安全及不可变性" class="headerlink" title="线程安全及不可变性"></a>线程安全及不可变性</h2><p>多个线程同时访问一个资源，并且一个或多个进行了写操作，才会产生竞态条件，多个资源同时读时不会产生竞态条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">通过创建不可变的共享对象来保证对象在线程间共享时不会被修改</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmitableValue</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ImmitableValue</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value =value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//请注意ImmutableValue类的成员变量value是通过构造函数赋值的，并且在类中没有set方法。这意味着一旦ImmutableValue实例被创建，value变量就不能再被修改，这就是不可变性。但你可以通过getValue()方法读取这个变量的值。</span></span><br></pre></td></tr></table></figure><h5 id="引用不是线程安全的"><a href="#引用不是线程安全的" class="headerlink" title="引用不是线程安全的"></a>引用不是线程安全的</h5><p>即使一个对象是线程安全的不可变对象，指向这个对象的引用也可能不是线程安全的。</p><h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h2><p>意思是不管怎么重排序，程序的执行结果不能被改变，编译器，runtime,和处理器都必须遵守as if serial 语义。</p><h2 id="volatile-写-读的内存语义"><a href="#volatile-写-读的内存语义" class="headerlink" title="volatile 写 读的内存语义"></a>volatile 写 读的内存语义</h2><p>写的内存语义是：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存中。</p><p>读的内存语义是：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p><h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><p>锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送信息。</p><p>当线程释放锁后时，JMM会把该线程对应的本地内存中共享变量刷新到主内存中。</p><p>当线程获取锁后，JMM会把该线程对应的本地内存设置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</p><h2 id="何时释放锁"><a href="#何时释放锁" class="headerlink" title="何时释放锁"></a>何时释放锁</h2><p>在以下情况下，持有锁的线程会释放锁：</p><p>\1. 执行完同步代码块。</p><p>\2. 在执行同步代码块的过程中，遇到异常而导致线程终止。</p><p>\3. 在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放锁，进行对象的等待池。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9. Palindrome Number</title>
      <link href="/2018/01/19/leetcode9/"/>
      <url>/2018/01/19/leetcode9/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Determine whether an integer is a palindrome. Do this without extra space.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>不使用额外空间判断一个数是否是回文数<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, k = x;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x=-x;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k==res)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>可以直接算出反过来的数,然后与原数对比,就可以判断了.</p><p>这里主要说明直接算相反数的方法 ,x是原数,res 是最后算出来的相反数.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    res = res*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">    x = x/<span class="number">10</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 远程操作</title>
      <link href="/2018/01/13/Git-%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/01/13/Git-%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Git 远程操作</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/06/git_remote.html</a></p></blockquote><ul><li>git clone</li><li>git remote</li><li>git fetch</li><li>git pull</li><li>git push</li></ul><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-13%2015-07-23.png" alt=""></p><a id="more"></a><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>从远程主机克隆一个版本库,使用git clone 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone http://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure><p>若想改变本地库的名字,加第二个参数为名字</p><p><code>git clone</code>支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等.</p><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>为了便于管理,每个远程主机都必须指定一个主机名,git remote用于管理主机名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 列出所有远程主机</span><br><span class="line"><span class="meta">$</span> git remote</span><br><span class="line">origin  # 表示当前只有一台远程主机</span><br><span class="line"><span class="meta">#</span> 加 -v 选项,查看远程主机网址</span><br><span class="line">origingit@github.com:brett427/LeetCode-Solution.git (fetch)</span><br><span class="line">origingit@github.com:brett427/LeetCode-Solution.git (push)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git remote add &lt;主机名&gt; &lt;网址&gt; # 添加远程主机</span><br></pre></td></tr></table></figure><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>一旦远程主机的版本库有了更新,需要将这些更新取回本地,使用git fetch 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git fetch &lt;远程主机名&gt;</span><br></pre></td></tr></table></figure><p><code>git fetch</code>命令通常用来查看其他人的进程</p><p><code>git branch</code>命令的<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -r</span><br><span class="line">origin/master</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p>上面命令表示，本地主机的当前分支是<code>master</code>，远程分支是<code>origin/master</code>。</p><p>取回远程主机的更新以后，可以在它的基础上，使用<code>git checkout</code>命令创建一个新的分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout -b newBrach origin/master</span><br></pre></td></tr></table></figure><p>上面命令表示，在<code>origin/master</code>的基础上，创建一个新分支。</p><p>此外，也可以使用<code>git merge</code>命令或者<code>git rebase</code>命令，在本地分支上合并远程分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git merge origin/master</span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line"><span class="meta">$</span> git rebase origin/master</span><br></pre></td></tr></table></figure><p>上面命令表示在当前分支上，合并<code>origin/master</code>。</p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>如果合并需要采用rebase模式，可以使用<code>--rebase</code>选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><code>git push</code>命令用于将本地分支的更新，推送到远程主机。它的格式与<code>git pull</code>命令相仿。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Ubuntu 任务栏图标变成问号</title>
      <link href="/2018/01/13/%E8%A7%A3%E5%86%B3Ubuntu%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
      <url>/2018/01/13/%E8%A7%A3%E5%86%B3Ubuntu%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Pycham 升级后,任务栏的图标就变成了问号,强迫症看着实在很难受,好在最后把问题解决了</p><p>在/usr/share/applications 存有图标文件,把对应图标文件的路径改对即可</p><p>原先,我总是自己创建一个pycharm.desktop的文件,其实是不用的,因为里面本来就有.</p><a id="more"></a><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-13%2016-26-41.png" alt=""></p><p>使用gedit 打开 jetbrains-pycharm.desktop 修改对象的执行文件路径和图标路径即可.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Type=Application</span><br><span class="line">Name=PyCharm</span><br><span class="line">Icon=/home/brett/download/pycharm-2017.3.2/bin/pycharm.png</span><br><span class="line">Exec="/home/brett/download/pycharm-2017.3.2/bin/pycharm.sh" %f</span><br><span class="line">Comment=The Drive to Develop</span><br><span class="line">Categories=Development;IDE;</span><br><span class="line">Terminal=false</span><br><span class="line">StartupWMClass=jetbrains-pycharm</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> QA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 持久化</title>
      <link href="/2018/01/12/RDB%20%E5%92%8CAOF/"/>
      <url>/2018/01/12/RDB%20%E5%92%8CAOF/</url>
      
        <content type="html"><![CDATA[<h3 id="RDB-和AOF"><a href="#RDB-和AOF" class="headerlink" title="RDB 和AOF"></a>RDB 和AOF</h3><blockquote><p><a href="http://redisdoc.com/topic/persistence.html" target="_blank" rel="noopener">http://redisdoc.com/topic/persistence.html</a></p></blockquote><p>Redis 提供了多种不同级别的持久化方式：</p><ul><li><p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照。</p></li><li><p>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</p></li><li><p>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</p></li><li><p>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</p><p>​</p><a id="more"></a></li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB持久化</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</li><li>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。</li><li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 <code>fork</code> 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。</li><li>每次保存 RDB 的时候，Redis 都要 <code>fork()</code> 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， <code>fork()</code>可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 <code>fork()</code> ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 <code>fsync</code> 策略，比如无 <code>fsync</code> ，每秒钟一次 <code>fsync</code> ，或者每次执行写入命令时 <code>fsync</code> 。 AOF 的默认策略为每秒钟 <code>fsync</code> 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ <code>fsync</code> 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li><li>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 <code>seek</code> ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， <code>redis-check-aof</code> 工具也可以轻易地修复这种问题。</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li><li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 <a href="http://doc.redisfans.com/server/flushall.html#flushall" target="_blank" rel="noopener"><em>FLUSHALL</em></a> 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 <a href="http://doc.redisfans.com/server/flushall.html#flushall" target="_blank" rel="noopener"><em>FLUSHALL</em></a> 命令， 并重启 Redis ， 就可以将数据集恢复到 <a href="http://doc.redisfans.com/server/flushall.html#flushall" target="_blank" rel="noopener"><em>FLUSHALL</em></a> 执行之前的状态。</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li><li>根据所使用的 <code>fsync</code> 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 <code>fsync</code> 的性能依然非常高， 而关闭 <code>fsync</code> 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li><li>AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 <a href="http://doc.redisfans.com/list/brpoplpush.html#brpoplpush" target="_blank" rel="noopener"><em>BRPOPLPUSH</em></a> 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis复制与内存</title>
      <link href="/2018/01/12/Redis%20%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98/"/>
      <url>/2018/01/12/Redis%20%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-复制"><a href="#Redis-复制" class="headerlink" title="Redis 复制"></a>Redis 复制</h2><p>在分布式系统中为了解决单点问题， 通常会把数据复制多个副本部署到其他机器， 满足故障恢复和负载均衡等需求。 Redis也是如此， 它提供了复制功能， 实现了相同数据的多个Redis副本。 复制功能是高可用Redis的基础。</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li><p>Redis 使用异步复制。 从 Redis 2.8 开始， 从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。</p></li><li><p>一个主服务器可以有多个从服务器。</p></li><li><p>不仅主服务器可以有从服务器， 从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个图状结构。</p></li><li><p><strong>复制功能不会阻塞主服务器</strong>： 即使有一个或多个从服务器正在进行初次同步， 主服务器也可以继续处理命令请求。</p></li><li><p>复制功能也不会阻塞从服务器： 只要在 <code>redis.conf</code> 文件中进行了相应的设置， 即使从服务器正在进行初次同步， 服务器也可以使用旧版本的数据集来处理命令查询。不过， 在从服务器删除旧版本数据集并载入新版本数据集的那段时间内， 连接请求会被阻塞。</p><p>还可以配置从服务器， 让它在与主服务器之间的连接断开时， 向客户端发送一个错误。</p></li><li><p>复制功能可以单纯地用于数据冗余（data redundancy）， 也可以通过让多个从服务器处理只读命令请求来提升扩展性（scalability）： 比如说， 繁重的 <a href="http://doc.redisfans.com/key/sort.html#sort" target="_blank" rel="noopener"><em>SORT</em></a> 命令可以交给附属节点去运行。</p></li><li><p>可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可。</p></li></ul><p>Redis 使用复制功能非常容易,只需要在从数据库的配置文件中加入<code>slaveof 主库地址 主库端口</code>即可,主库无需进行任何配置.</p><p>默认情况下,从数据库是只读的.</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h5><p>当一个从数据库启动后,会向主数据库发送SYNC命令,同时主数据库收到SYNC命令后会开始在后台保存快照(即RDB持久化的过程)并在保存快照期间将收到的命令缓存起来,当快照完成后,Redis 会将快照文件和所有缓存的命令一起发给从数据库.从数据库收到后,会载入快照文件并执行收到的缓存命令,以上过程成为复制初始化.复制初始化结束后,主数据库每当收到写命令时就会将命令同步给从数据库.从而保障主从数据库数据库一致.</p><p>当主从数据库连接断开重连后,2.6之前的版本会进行复制初始化这样效率就很低,所以2.8后的版本支持了有条件的增量数据传输.从库重新连接上主库后,只需要将断线期间执行的命令传送给从库,大大提高了复制的可用性.</p><ul><li>执行slaveof后从节点保存主节点信息</li><li>从节点（ slave） 内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的主节点后， 会尝试与该节点建立网络连接。</li><li>从节点发送ping命令</li><li>主节点进行权限验证</li><li>同步数据集</li><li>命令持续复制</li></ul><p>无论是初次连接还是重新连接， 当建立一个从服务器时， 从服务器都将向主服务器发送一个 <a href="http://doc.redisfans.com/server/sync.html#sync" target="_blank" rel="noopener"><em>SYNC</em></a> 命令。</p><p>接到 <a href="http://doc.redisfans.com/server/sync.html#sync" target="_blank" rel="noopener"><em>SYNC</em></a> 命令的主服务器将开始执行 <a href="http://doc.redisfans.com/server/bgsave.html#bgsave" target="_blank" rel="noopener"><em>BGSAVE</em></a> ， 并在保存操作执行期间， 将所有新执行的写入命令都保存到一个缓冲区里面。</p><p>当 <a href="http://doc.redisfans.com/server/bgsave.html#bgsave" target="_blank" rel="noopener"><em>BGSAVE</em></a> 执行完毕后， 主服务器将执行保存操作所得的 <code>.rdb</code> 文件发送给从服务器， 从服务器接收这个 <code>.rdb</code> 文件， 并将文件中的数据载入到内存中。</p><p>之后主服务器会以 Redis 命令协议的格式， 将写命令缓冲区中积累的所有内容都发送给从服务器。</p><p>即使有多个从服务器同时向主服务器发送 <a href="http://doc.redisfans.com/server/sync.html#sync" target="_blank" rel="noopener"><em>SYNC</em></a> ， 主服务器也只需执行一次 <a href="http://doc.redisfans.com/server/bgsave.html#bgsave" target="_blank" rel="noopener"><em>BGSAVE</em></a> 命令， 就可以处理所有这些从服务器的同步请求。</p><p>Redis 采用了乐观复制的复制策略,允许一定时间内主从数据库的内容是不同的,但是两者的数据会最终同步.</p><h4 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h4><p>从 Redis 2.8 开始， 在网络连接短暂性失效之后， 主从服务器可以尝试继续执行原有的复制进程（process）， 而不一定要执行完整重同步操作。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-28%2019-26-30.png" alt=""></p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-28%2019-26-39.png" alt=""></p><h4 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h4><ul><li>一主一从</li><li>一主多从</li><li>树状主从</li></ul><h2 id="Redis-内存"><a href="#Redis-内存" class="headerlink" title="Redis 内存"></a>Redis 内存</h2><p>Redis所有的数据都存在内存中， 当前内存虽然越来越便宜， 但跟廉价的硬盘相比成本还是比较昂贵， 因此如何高效利用Redis内存变得非常重要。 高效利用Redis内存首先需要理解Redis内存消耗在哪里， 如何管理内存， 最后才能考虑如何优化内存。</p><h4 id="内存消耗划分"><a href="#内存消耗划分" class="headerlink" title="内存消耗划分"></a>内存消耗划分</h4><p>Redis进程内消耗主要包括： 自身内存+对象内存+缓冲内存+内存碎片。</p><p>对象内存是Redis内存占用最大的一块， 存储着用户所有的数据。 Redis所有的数据都采用key-value数据类型， 每次创建键值对时， 至少创建两个类型对象： key对象和value对象。 对象内存消耗可以简单理解为sizeof（ keys）+sizeof（ values） 。 键对象都是字符串。 value对象更复杂些， 主要包含5种基本数据类型： 字符串、 列表、 哈希、 集合、 有序集合。 其他数据类型都是建立在这5种数据结构之上实现的。</p><p>缓冲内存主要包括： 客户端缓冲、 复制积压缓冲区、 AOF缓冲区。</p><p>客户端缓冲指的是所有接入到Redis服务器TCP连接的输入输出缓冲。输入缓冲无法控制， 最大空间为1G。复制积压缓冲区： Redis在2.8版本之后提供了一个可重用的固定大小缓冲区用于实现部分复制功能， 根据repl-backlog-size参数控制， 默认1MB。 对于复制积压缓冲区整个主节点只有一个， 所有的从节点共享此缓冲区。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis哨兵与集群</title>
      <link href="/2018/01/12/%E5%93%A8%E5%85%B5%E4%B8%8E%E9%9B%86%E7%BE%A4/"/>
      <url>/2018/01/12/%E5%93%A8%E5%85%B5%E4%B8%8E%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>Redis的主从复制模式下， 一旦主节点由于故障不能提供服务， 需要人工将从节点晋升为主节点， 同时还要通知应用方更新主节点地址， 对于很多应用场景这种故障处理的方式是无法接受的。 Redis从2.8开始正式提供了Redis Sentinel（ 哨兵） 架构来解决这个问题， </p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Redis Sentinel是Redis的高可用实现方案， 在实际的生产环境中， 对提高整个系统的高可用性是非常有帮助的。</p><p>哨兵的功能包括两个,一是监控主数据库和从数据库是否正常运行,二是主数据库出现故障时自动将从数据库转换为主数据库.</p><h5 id="主从复制的问题"><a href="#主从复制的问题" class="headerlink" title="主从复制的问题"></a>主从复制的问题</h5><p>Redis的主从复制模式可以将主节点的数据改变同步给从节点， 这样从节点就可以起到两个作用： 第一， 作为主节点的一个备份， 一旦主节点出了故障不可达的情况， 从节点可以作为后备“顶”上来， 并且保证数据尽量不丢失（ 主从复制是最终一致性） 。 第二， 从节点可以扩展主节点的读能力， 一旦主节点不能支撑住大并发量的读操作， 从节点可以在一定程度上帮助主节点分担读压力。</p><p>但是主从复制也带来了以下问题</p><ul><li>一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址， 还需要命令其他从节点去复制新的主节点， 整个过程都需要人工干预。(高可用问题)</li><li>主节点的写能力受到单机的限制。(分布式问题)</li><li>主节点的存储能力受到单机的限制。(分布式问题)</li></ul><h5 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h5><p>Redis主从复制模式下的主节点出现故障后， 故障转移过程如下所示。</p><p>1）主节点发生故障后，客户端连接主节点失败，两个从节点与主节点连接失败造成复制中断。</p><p>2）如果主节点无法正常启动， 需要选出一个从节点（slave-1),对其执行slaveof no one命令使其成为新的主节点。</p><p>3)原来的从节点（ slave-1） 成为新的主节点后， 更新应用方的主节点信息， 重新启动应用方。</p><p>4)客户端命令另一个从节点（ slave-2） 去复制新的主节点（ new-master）</p><p>5)待原来的主节点恢复后， 让它去复制新的主节点。</p><p>上述处理过程就可以认为整个服务或者架构的设计不是高可用的， 因为整个故障转移的过程需要人介入.</p><h5 id="Redis-哨兵的高可用性"><a href="#Redis-哨兵的高可用性" class="headerlink" title="Redis 哨兵的高可用性"></a>Redis 哨兵的高可用性</h5><p>当主节点出现故障时， Redis Sentinel能自动完成故障发现和故障转移，并通知应用方， 从而实现真正的高可用。</p><p>Redis Sentinel是一个分布式架构， 其中包含若干个Sentinel节点和Redis数据节点， 每个Sentinel节点会对数据节点和其余Sentinel节点进行监控， 当它发现节点不可达时， 会对节点做下线标识。 如果被标识的是主节点， 它还会和其他Sentinel节点进行“协商”， 当大多数Sentinel节点都认为主节点不可达时， 它们会选举出一个Sentinel节点来完成自动故障转移的工作， 同时会将这个变化实时通知给Redis应用方。 整个过程完全是自动的， 不需要人工来介入， 所以这套方案很有效地解决了Redis的高可用问题。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效地解决了Redis分布式方面的需求。 当遇到单机内存、 并发、 流量等瓶颈时， 可以采用Cluster架构方案达到负载均衡的目的。</p><h3 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h3><h5 id="数据分布理论"><a href="#数据分布理论" class="headerlink" title="数据分布理论"></a>数据分布理论</h5><p>分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的问题， 即把数据集划分到多个节点上， 每个节点负责整体数据的一个子集。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/1AF80826-FF01-413A-97AE-D1A995A1CB8D.png" width="40%"></p><p>常见的数据分区规则主要有哈希分区和顺序分区两种。Redis Cluster采用哈希分区规则.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/2FCF5E61-5B5F-4BC2-93C2-2735A519F8FF.png"></p><p>常见哈希规则主要有</p><ul><li>节点取余分区</li></ul><p>使用特定的数据， 如Redis的键或用户ID， 再根据节点数量N使用公式：hash（ key） %N计算出哈希值， 用来决定数据映射到哪一个节点上。突出优点是简单性， 常用于数据库的分库分表规则。</p><ul><li>一致性哈希分区</li></ul><p>一致性哈希分区（ Distributed Hash Table） 实现思路是为系统中每个节点分配一个token， 范围一般在0~<code>2^32</code>， 这些token构成一个哈希环。 数据读写执行节点查找操作时， 先根据key计算hash值， 然后顺时针找到第一个大于等于该哈希值的token节点。 </p><ul><li>虚拟槽分区</li></ul><p>虚拟槽分区巧妙地使用了哈希空间， 使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中， 整数定义为槽（ slot） 。 这个范围一般远远大于节点数， 比如Redis Cluster槽范围是0~16383。 槽是集群内数据管理和迁移的基本单位。 采用大范围槽的主要目的是为了方便数据拆分和集群扩展。 每个节点会负责一定数量的槽， 如下图所示。当前集群有5个节点， 每个节点平均大约负责3276个槽。 由于采用高质量的哈希算法， 每个槽所映射的数据通常比较均匀， 将数据平均划分到5个节点进行数据分区。 Redis Cluster就是采用虚拟槽分区， 下面就介绍Redis数据分区方法。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/F464CD1E-5B6C-49CB-9224-1B059B8D3D08.png" width="40%"></p><p>Redis Cluser采用虚拟槽分区， 所有的键根据哈希函数映射到0~16383整数槽内， 计算公式： <code>slot=CRC16 (key) &amp;16383</code>。 每一个节点负责维护一部分槽以及槽所映射的键值数据.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网时代的消息中间件</title>
      <link href="/2018/01/11/Java%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2018/01/11/Java%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><h4 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h4><p>JMS 是Java Message Service  的缩写，它是Java EE 中的一个关于消息的规范。而Hornetq,ActiceMq 等产品都是对这个规范的实现。如果是企业内部或者一些小型的系统，直接使用JMS 的实现产品是一个经济的选择，而在大型系统中有一些场景不适合使用JMS。</p><p>在大型互联网中，采用消息中间件可以进行应用之间的解耦以及操作的异步。这是消息中间件的两个最基本的特点，也正是我们需要的。在此基础上，更多考虑的是消息的顺序保证，扩展性，可靠性，业务操作与消息发送一致性。以及多集群订阅等方面的问题。</p><h4 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h4><p>非底层操作系统软件,非业务应用软件,不是直接给最终用户使用的,不能直接给客户带来价值的软件都统称为中间件</p><a id="more"></a><h4 id="如何解决消息发送一致性"><a href="#如何解决消息发送一致性" class="headerlink" title="如何解决消息发送一致性"></a>如何解决消息发送一致性</h4><p>首先 ，消息发送一致性是指产生消息的业务动作与消息发送的一致，也就是说，如果业务操作成功了，那么由这个操作产生的消息一定要发送出去。否则就丢失消息了，另一方面，如果这个业务行为没有发生或者失败，那么久不应该把消息发送出去。</p><h5 id="JMS-是否有方案？"><a href="#JMS-是否有方案？" class="headerlink" title="JMS 是否有方案？"></a>JMS 是否有方案？</h5><p>主要是用XA开头的接口来实现，XA系列的接口支持了分布式事务的支持，（即发送消息和业务操作用事务包住）</p><p>但是此做法有相应的问题：</p><ul><li>引入了分布式事务，这会带来一些开销并增加复杂性</li><li>对于业务操作有限制，要求业务操作的资源必须支持XA协议，才能够与发送消息一起来做分布式事务。这会成为一个限制，因为并不是所有需要与发送消息一起做成分布式事务的业务操作都支持XA协议。</li></ul><p><strong>XA是一个分布式事务协议，由Tuxedo提出。XA中大致分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。</strong></p><p><img src="http://four-1252095801.cosbj.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8A%E5%8D%889.44.40.png" alt=""></p><p>总的来说，XA协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。但是，XA也有致命的缺点，那就是性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景。XA目前在商业数据库支持的比较理想，在mysql数据库中支持的不太理想，mysql的XA实现，没有记录prepare阶段日志，主备切换回导致主库与备库数据不一致。许多nosql也没有支持XA，这让XA的应用场景变得非常狭隘。</p><h5 id="另外的方案"><a href="#另外的方案" class="headerlink" title="另外的方案"></a>另外的方案</h5><p><img src="http://four-1252095801.cosbj.myqcloud.com/51534902495_.pic.jpg" alt=""></p><p>1 业务处理应用首先把消息发送给消息中间件，标记消息的状态为待处理。</p><p>2 消息中间件收到消息后，把消息存储在消息存储中，并不投递该消息。</p><p>3 消息中间件返回消息处理的结果（仅是入库的结果），结果是成功或者失败。</p><p>4 业务方收到消息中间件返回的结果并进行处理。</p><ul><li>如果收到的结果是失败 那么就放弃业务处理，结束。</li><li>如果收到的结果是成功，则进行业务自身的操作。</li></ul><p>5 业务操作完成，把业务操作的结果发送给消息中间件。</p><p>6 消息中间件收到业务操作结果，根据结果进行处理。</p><ul><li>如果业务失败，则删除消息存储中的消息，结束。</li><li>如果业务成功，则更新消息存储中的消息状态为可发送，并且进行调度，进行消息的投递。</li></ul><h4 id="消息队列模型"><a href="#消息队列模型" class="headerlink" title="消息队列模型"></a>消息队列模型</h4><h5 id="Queue-模型"><a href="#Queue-模型" class="headerlink" title="Queue 模型"></a>Queue 模型</h5><p>多个消费者，消费的消息是不同的，多个消费者的消费消息和是全部消息。</p><h5 id="Topic-模型"><a href="#Topic-模型" class="headerlink" title="Topic 模型"></a>Topic 模型</h5><p>所有消费者是可以收到所有的消费消息的</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 迭代器,生成器,装饰器,可变参数总结</title>
      <link href="/2018/01/10/Python-%E8%BF%AD%E4%BB%A3%E5%99%A8,%E7%94%9F%E6%88%90%E5%99%A8,%E8%A3%85%E9%A5%B0%E5%99%A8,%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"/>
      <url>/2018/01/10/Python-%E8%BF%AD%E4%BB%A3%E5%99%A8,%E7%94%9F%E6%88%90%E5%99%A8,%E8%A3%85%E9%A5%B0%E5%99%A8,%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="函数中的可变参数列表"><a href="#函数中的可变参数列表" class="headerlink" title="函数中的可变参数列表"></a>函数中的可变参数列表</h3><p>当函数调用可变个数的参数时,这些可变参数被包装进一个元组,在可变参数前,可以有0到多个普通的参数,多个参数用*作为前缀.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_multiple_items</span><span class="params">(file, separator, *args)</span>:</span></span><br><span class="line">    file.write(separator.join(args))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concat</span><span class="params">(*args, sep=<span class="string">"/"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sep.join(args)</span><br><span class="line"></span><br><span class="line">concat(<span class="string">"earth"</span>, <span class="string">"mars"</span>, <span class="string">"venus"</span>)</span><br><span class="line"><span class="string">'earth/mars/venus'</span></span><br><span class="line">concat(<span class="string">"earth"</span>, <span class="string">"mars"</span>, <span class="string">"venus"</span>, sep=<span class="string">"."</span>)</span><br><span class="line"><span class="string">'earth.mars.venus'</span></span><br></pre></td></tr></table></figure><p>相反的情况</p><a id="more"></a><p>要传递的参数已经是一个列表,但是调用的函数却接手分开一个个的参数值,这时候就要把已有的列表拆开,,可以在调用函数时加一个<code>*</code>操作符来自动把参数列表拆开</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(range(<span class="number">3</span>, <span class="number">6</span>))</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">args = [<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">list(range(*args)) <span class="comment"># 和第一行的效果相同</span></span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>以同样的方式,可以用**操作符拆关键字参数为字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">parrot</span><span class="params">(voltage, state=<span class="string">'a stiff'</span>, action=<span class="string">'voom'</span>)</span>:</span></span><br><span class="line">     print(<span class="string">"-- This parrot wouldn't"</span>, action, end=<span class="string">' '</span>)</span><br><span class="line">     print(<span class="string">"if you put"</span>, voltage, <span class="string">"volts through it."</span>, end=<span class="string">' '</span>)</span><br><span class="line">     print(<span class="string">"E's"</span>, state, <span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">"voltage"</span>: <span class="string">"four million"</span>, <span class="string">"state"</span>: <span class="string">"bleedin' demised"</span>, <span class="string">"action"</span>: <span class="string">"VOOM"</span>&#125;</span><br><span class="line">parrot(**d)</span><br><span class="line">--This parrot wouldn<span class="string">'t VOOM if you put four million volts through it. E'</span>s bleedin<span class="string">' demised !</span></span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>大部分容器对象都可以用for循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    print(element)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">    print(element)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> &#123;<span class="string">'one'</span>:<span class="number">1</span>, <span class="string">'two'</span>:<span class="number">2</span>&#125;:</span><br><span class="line">    print(key)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">"123"</span>:</span><br><span class="line">    print(char)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">"myfile.txt"</span>):</span><br><span class="line">    print(line, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>这种形式的访问清晰、简洁、方便。迭代器的用法在 Python 中普遍而且统一。在后台， for语句在容器对象中调用 iter() 。该函数返回一个定义了 <code>__next__()</code>方法的迭代器对象，它在容器中逐一访问元素。没有后续的元素时， <code>__next__()</code> 抛出一个 <code>StopIteration</code> 异常通知 <code>for</code>语句循环结束。你可以是用内建的 <code>next()</code>函数调用 <code>__next__()</code> 方法；以下是其工作原理的示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'abc'</span></span><br><span class="line">it = iter(s)</span><br><span class="line">it</span><br><span class="line">&lt;iterator object at <span class="number">0x00A1DB50</span>&gt;</span><br><span class="line">next(it)</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line">next(it)</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line">next(it)</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line">next(it)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in ?</span><br><span class="line">    next(it)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>了解了迭代器协议的后台机制,就可以给自己的类添加迭代器行为,定义一个<code>__iter__()</code>方法,使其返回一个带有<code>__next__()</code>方法的对象,如果这个类已经定义了<code>__next__()</code>,那么<code>__iter__()</code>只需要返回self.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reverse</span>:</span></span><br><span class="line">    <span class="string">"""Iterator for looping over a sequence backwards."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = len(data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">      <span class="comment"># __next__()自定义迭代方法.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.index = self.index - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.data[self.index]</span><br></pre></td></tr></table></figure><p>测试上面的类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rev = Reverse(<span class="string">'spam'</span>)</span><br><span class="line">iter(rev)</span><br><span class="line">&lt;__main__.Reverse object at <span class="number">0x00A1DB50</span>&gt;</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> rev:</span><br><span class="line">     print(char)</span><br><span class="line"></span><br><span class="line">m</span><br><span class="line">a</span><br><span class="line">p</span><br><span class="line">s</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><p>创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator.</p><p>第二种:如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator.</p><p>在执行过程中，遇到<code>yield</code>就中断，下次又继续执行。</p><p>生成器Generator是创建迭代器简单而强大的工具,需要返回数据的时候使用yield语句,每次next()被调用时,生成器回复它脱离的位置.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(data)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">yield</span> data[index]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> reverse(<span class="string">'golf'</span>):</span><br><span class="line">  print(char)</span><br><span class="line">f</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">g</span><br></pre></td></tr></table></figure><p>前一节中描述了基于类的迭代器，它能作的每一件事生成器也能作到。因为自动创建了 <a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><strong>iter</strong>()</a> 和 <a href="https://docs.python.org/3/reference/expressions.html#generator.__next__" target="_blank" rel="noopener"><strong>next</strong>()</a> 方法，生成器显得如此简洁。</p><h3 id="args-和-kw"><a href="#args-和-kw" class="headerlink" title="*args 和 ** kw"></a>*args 和 ** kw</h3><p>补充 *args 代表多个参数,但是没有key值,**kw代表有多个参数的key值.</p><h5 id="args"><a href="#args" class="headerlink" title="*args"></a>*args</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(f1, *args)</span>:</span>  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"arg:"</span>, f1  </span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> args:  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"another arg:"</span>, value  </span><br><span class="line">fun(<span class="number">1</span>, <span class="string">"two"</span>, <span class="number">3</span>) <span class="comment"># *args可以当作可容纳多个变量组成的list</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arg: <span class="number">1</span>  </span><br><span class="line">another arg: two  </span><br><span class="line">another arg: <span class="number">3</span></span><br></pre></td></tr></table></figure><h5 id="kw"><a href="#kw" class="headerlink" title="**kw"></a>**kw</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> a1 <span class="keyword">in</span> args:</span><br><span class="line">        print(a1)</span><br><span class="line">    <span class="keyword">for</span> k1 <span class="keyword">in</span> kwargs:</span><br><span class="line">        print(k1,kwargs[k1])</span><br><span class="line">fun(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,d=<span class="number">1</span>,ff=<span class="number">2</span>,v=<span class="number">34</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">ff <span class="number">2</span></span><br><span class="line">d <span class="number">1</span></span><br><span class="line">v <span class="number">34</span></span><br></pre></td></tr></table></figure><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"2018"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = now</span><br><span class="line">&gt;&gt;&gt;f()</span><br><span class="line"><span class="number">2018</span></span><br></pre></td></tr></table></figure><p>函数对象有一个<code>__name__</code>属性,可以拿到函数的名字</p><p>假设我们要增强<code>now()</code>函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p><p>本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        func(*args, **kw)</span><br><span class="line">        print(<span class="string">"after"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'i am bar'</span>)</span><br><span class="line"></span><br><span class="line">bar = use_logging(bar)</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p><strong>函数use_logging就是装饰器,wrapper是组装的最终函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call bar():</span><br><span class="line">i am bar</span><br><span class="line">after</span><br></pre></td></tr></table></figure><p>@符号是装饰器的语法糖,在定义函数的时候使用,避免再一次赋值操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        func(*args, **kw)</span><br><span class="line">        print(<span class="string">"after"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'i am foo'</span>)</span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'i am bar'</span>)</span><br></pre></td></tr></table></figure><h5 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h5><p>装饰器语法允许在调用时,提供其他参数,可以在装饰器的外面再封装一层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaoceng_fengzhuang</span><span class="params">(参数)</span>  </span></span><br><span class="line"><span class="function">  <span class="title">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">          print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">          <span class="comment">#里面写参数的处理</span></span><br><span class="line">          func(*args, **kw)</span><br><span class="line">          print(<span class="string">"after"</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">  <span class="keyword">return</span> use_logging</span><br></pre></td></tr></table></figure><h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><p>使用类装饰器还可以依靠内部的<code>__call__</code>方法,当使用@形式将装饰器附加到函数上时,就会调用此方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(Object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">    self.func =func</span><br><span class="line">  <span class="comment"># 装饰器方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'before'</span>)</span><br><span class="line">    self.func()</span><br><span class="line">    print(<span class="string">'after'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'bar'</span>)</span><br><span class="line">bar()</span><br><span class="line"><span class="comment"># 输出 before /bar   /after</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2018/01/09/Git/"/>
      <url>/2018/01/09/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="基础原理"><a href="#基础原理" class="headerlink" title="基础原理"></a>基础原理</h3><p>Git 是一个分布式版本管理系统,可以在任何时间点,把文档的状态作为更新记录保存起来,因此可以把编辑过的文档复原到以前状态,也可以显示编辑前后的内容差异.</p><p>版本库(Repository)是记录文件或目录状态的地方,存储着内容修改的历史记录,在版本库的管理下,把文件和目录修改的历史记录放在对应的目录下.</p><a id="more"></a><h4 id="远程版本库和本地版本库"><a href="#远程版本库和本地版本库" class="headerlink" title="远程版本库和本地版本库"></a>远程版本库和本地版本库</h4><p>git分远程版本库和本地版本库,远程版本库配有专门的服务器,为了多人共享而建立的数据库,本地版本库是为了方便用户个人使用,在自己机器上配置的版本库.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-09%2018-54-33.png" alt=""></p><p>两种创建版本库方法:</p><ul><li>创建全新的版本库</li><li>复制远程版本库</li></ul><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>若要把文件或目录的添加和变更保存到版本库,就需要进行提交</p><p>执行提交后,版本库中就会生成上次提交的状态与当前状态的差异记录 (也称为revision)</p><p>如果,提交是按时间顺序保存到版本库中的,凭借该提交和最新的文件状态,就可以直到过去的修改记录以及内容.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-09%2019-02-33.png" alt=""></p><p>系统会给出一个40位的名字来指定这次提交,这样就可以在数据库中找到对应的提交</p><blockquote><p>不同类别的修改 (如：Bug修复和功能添加) 要尽量分开提交，以方便以后从历史记录里查找特定的修改内容。</p></blockquote><h4 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h4><p>git管理下,实际操作的目录被成为工作区.</p><p>在版本库和工作区之间有暂存区,索引是为了向版本库提交作准备的区域</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-09%2019-06-39.png" alt=""></p><p>Git在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库。因此，要提交文件，首先需要把文件加入到索引区域中。</p><h3 id="使用基础"><a href="#使用基础" class="headerlink" title="使用基础"></a>使用基础</h3><p>安装后,输入用户名和电邮,这些信息将作为提交者信息显示在更新历史中.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config --global user.name "brett427"</span><br><span class="line"><span class="meta">$</span> git config --global user.email "wangkangning1@foxmail.com"</span><br></pre></td></tr></table></figure><h4 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a>新建数据库</h4><p>首先在任意一个地方创建tutorial目录。然后使用init命令把该tutorial目录移动到本地Git数据库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h4 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h4><p>确定工作树和索引的状态<code>git status</code></p><p>文件加到索引,使用<code>git add</code></p><p>提交文件 <code>git commit -m &quot;&quot;</code></p><p>查看提交记录 <code>git log--pretty=oneline</code> </p><p>####　PUSH到远程客户端</p><p>为了将本地数据库的修改记录共享到远程数据库，必须上传本地数据库中存储的修改记录。为此，需要在Git执行推送(Push)操作。执行Push之后，本地的修改记录会被上传到远程数据库。所以远程数据库的修改记录就会和本地数据库的修改记录保持同步。</p><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>3628</code>，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。 版本回退,就使用 <code>git reset</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">或者直接指定版本号</span><br><span class="line">git reset --hard 42342342</span><br></pre></td></tr></table></figure><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD改变了指向</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog 记录每一次命令!!!!!!</span><br></pre></td></tr></table></figure><p><em>当不知道reset号的时候,可以用reflog去找</em></p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-09%2019-45-55.png" alt=""></p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff    #是工作区(work dict)和暂存区(stage)的比较</span><br><span class="line">git diff --cached    #是暂存区(stage)和分支(master)的比较</span><br></pre></td></tr></table></figure><h4 id="丢弃修改"><a href="#丢弃修改" class="headerlink" title="丢弃修改"></a>丢弃修改</h4><h5 id="丢弃工作区的修改"><a href="#丢弃工作区的修改" class="headerlink" title="丢弃工作区的修改"></a>丢弃工作区的修改</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --&lt;filename&gt;   # 丢弃工作区的修改</span><br></pre></td></tr></table></figure><p>就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><h5 id="丢弃暂存区的修改"><a href="#丢弃暂存区的修改" class="headerlink" title="丢弃暂存区的修改"></a>丢弃暂存区的修改</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>使用git  reset HEAD <code>&lt;filename&gt;</code>,就回到了上面选择丢弃工作区的修改的状态.</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm 并且  git commit</span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>在版本回退中,每次提交,git都会把他们串成一条时间线,上面所有的操作,只有一条时间线,也就是主分支,即master分支,<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-09%2020-22-44.png" alt=""></p><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长：</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-09%2020-26-57.png" alt=""></p><p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><p><strong>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</strong></p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-09%2020-28-33.png" alt=""></p><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-09%2020-29-53.png" alt=""></p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支.</p><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>创建dev分支,然后切换到dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">Switched to a new branch 'dev'</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于git branch dev.  git checkout dev</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch   # 查看当前分支 ,当前分支前面会标星号</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master# 切换为master 分支</span><br></pre></td></tr></table></figure><p>把dev分支合并到Master上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p><code>git merge</code>命令用于合并指定分支到当前分支。</p><p>删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>查看远程库信息，使用<code>git remote -v</code>；</p><h5 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h5><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git push origin dev</span><br></pre></td></tr></table></figure><p>多人协作时,大家都往Master和dev分支上推送自己的修改,</p><p>多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin branch-name</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin branch-name</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。</p><ul><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li><li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li></ul><p>(origin 指远程版本库)</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绝对路径和相对路径</title>
      <link href="/2018/01/07/%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
      <url>/2018/01/07/%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>相对路径就是相对于当前文件的路径。网页中一般表示路径使用这个方法.</p><p>绝对路径就是你的主页上的文件或目录在硬盘上真正的路径。绝对路径就是你的主页上的文件或目录在硬盘上真正的路径，比如，你的Perl 程序是存放在 c:/bin 下的，那么 c:/bin就是bin目录的绝对路径</p><p>在网络中,以http开头的链接都是绝对路径,绝对路径就是你的主页上的文件或目录在硬盘上真正的路径.</p><a id="more"></a><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>以下为建立路径所使用的几个特殊符号，及其所代表的意义。</p><p><code>./</code>：代表目前所在的目录。</p><p><code>../</code>：代表上一层目录。</p><p><strong><code>/</code>：代表根目录。</strong></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>根目录下有wkn文件夹和Image/Image.jpg，wkn下有Page1.html文件和wkn2文件夹。wkn2下有Page2.html和Image2.jpg图片文件。</p><ul><li>文件在当前目录</li></ul><p>page2.html 访问Image2.jpg </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">”./Image2.jpg”</span>&gt;</span>或者<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">”Image2.jpg”</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>文件在上一层目录</li></ul><p>page1 访问Image 下的image.jpg</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">”../Image/Image.jpg”</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>文件在下一层目录</li></ul><p>Page1.html访问wkn2文件夹下的Image2.jpg</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">”./Site2/Image.jpg”</span>&gt;</span>或者<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">”Site2/Image.jpg”</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>根目录表示法,任何页面访问Image下的Image.jpg图片</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">”/Image/Image.jpg”</span>&gt;</span></span><br></pre></td></tr></table></figure><p>尽量使用相对路径</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL的锁</title>
      <link href="/2018/01/04/MYSQL%E7%9A%84%E9%94%81/"/>
      <url>/2018/01/04/MYSQL%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql-锁详解"><a href="#Mysql-锁详解" class="headerlink" title="Mysql 锁详解"></a>Mysql 锁详解</h2><p>Mysql存在多种数据存储引擎，每种存储引擎所针对的应用场景特点都不太一样，为了满足各自特定应用场景的需求，每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别。MySQL各存储引擎使用了三种类型（级别）的锁定机制：表级锁定，行级锁定和页级锁定。</p><ul><li>表级锁定（table-level）</li></ul><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。最大特点是实现逻辑简单，系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。但是并发度大打折扣。<br>使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。</p><ul><li>行级锁定（row-level）</li></ul><p>行级锁定最大特点是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。<br>使用行级锁定的主要是InnoDB存储引擎。</p><ul><li>页级锁定（page-level）</li></ul><p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是<strong>锁定颗粒度介于行级锁定与表级锁之间</strong>，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。<br>在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。<br>使用页级锁定的主要是BerkeleyDB存储引擎。</p><h3 id="Myisam表级锁定"><a href="#Myisam表级锁定" class="headerlink" title="Myisam表级锁定"></a>Myisam表级锁定</h3><h5 id="MySQL-表级锁的两种锁模式"><a href="#MySQL-表级锁的两种锁模式" class="headerlink" title="MySQL 表级锁的两种锁模式"></a>MySQL 表级锁的两种锁模式</h5><p>表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）</p><p>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；<br>对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；</p><h5 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h5><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p><h5 id="并发锁"><a href="#并发锁" class="headerlink" title="并发锁"></a>并发锁</h5><p>在一定条件下，MyISAM也支持查询和操作的并发进行。</p><p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。</p><ul><li>当concurrent_insert设置为0时，不允许并发插入。</li><li>当concurrent_insert设置为1时，如果MyISAM允许在一个读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。</li><li>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾插入记录，都允许在表尾并发插入记录。</li></ul><p>可以利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入锁争用。例如，将concurrent_insert系统变量为2，总是允许并发插入；同时，通过定期在系统空闲时段执行OPTIONMIZE TABLE语句来整理空间碎片，收到因删除记录而产生的中间空洞。</p><h5 id="锁调度"><a href="#锁调度" class="headerlink" title="锁调度"></a>锁调度</h5><p>前面讲过，MyISAM存储引擎的读和写锁是互斥，读操作是串行的。那么，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，<strong>即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！这是因为MySQL认为写请求一般比读请求重要</strong>。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！可以通过一些设置来调节MyISAM的调度行为。</p><hr><h3 id="InnoDB行级锁定"><a href="#InnoDB行级锁定" class="headerlink" title="InnoDB行级锁定"></a>InnoDB行级锁定</h3><p>InnoDB与MYISAM最大的不同有两点，一时支持事务，二是采用了行级锁。</p><h4 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h4><ul><li><strong>更新丢失</strong>（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题</li><li><strong>脏读</strong>（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。</li><li><strong>不可重复读</strong>（Non-Repeatable Reads）：在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。</li><li><strong>幻读</strong>（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><table><thead><tr><th>隔离级别/读数据一致性及允许的并发副作用</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（Read uncommitted）</td><td>最低级别，只能保证不读取物理上损坏的数据</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读已提交（Read committed）</td><td>语句级</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（Repeatable read）</td><td>事务级</td><td>否</td><td>否</td><td>是</td></tr><tr><td>可序列化（Serializable）</td><td>最高级别，事务级</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h4 id="InnoDB行锁"><a href="#InnoDB行锁" class="headerlink" title="InnoDB行锁"></a>InnoDB行锁</h4><p>行级锁定不是MySQL自己实现的锁定方式，而是由其他存储引擎自己所实现的，如广为大家所知的InnoDB存储引擎，以及MySQL的分布式存储引擎NDBCluster等都是实现了行级锁定。主要分析一下InnoDB的锁定特性。</p><h5 id="InnoDB锁定模式及实现机制"><a href="#InnoDB锁定模式及实现机制" class="headerlink" title="InnoDB锁定模式及实现机制"></a>InnoDB锁定模式及实现机制</h5><ul><li>共享锁【S锁】 </li></ul><p>又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。</p><p>用法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure><p>在查询语句后面增加<code>LOCK IN SHARE MODE</code>，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p><ul><li>排他锁【X锁】</li></ul><p>又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p><p>用法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...FOR <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>在查询语句后面增加<code>FOR UPDATE</code>，Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。</p><ul><li>意向锁</li></ul><p>意向锁是<strong>表级锁</strong>，其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型。在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。**</p><p>InnoDB中的两个表锁：</p><p>意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁</p><p>意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。</p><p><strong>意向锁是InnoDB自动加的，不需要用户干预。</strong></p><p>对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的Select语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。</p><p>共享锁：<code>SELECT ... LOCK IN SHARE MODE;</code></p><p>排他锁：<code>SELECT ... FOR UPDATE;</code></p><h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><p>InnoDB行锁是<strong>通过给索引上的索引项加锁来实现的</strong>，<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁</strong><br>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。下面通过一些实际例子来加以说明。<br>（1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。<br>（2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。<br>（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。<br>（4）即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p><p>举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p><p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p><p>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。</p><p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p><p>还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可扩展的MYSQL</title>
      <link href="/2018/01/03/%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84MYSQL/"/>
      <url>/2018/01/03/%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84MYSQL/</url>
      
        <content type="html"><![CDATA[<h2 id="可扩展的MYSQL"><a href="#可扩展的MYSQL" class="headerlink" title="可扩展的MYSQL"></a>可扩展的MYSQL</h2><p>容量是一个和可拓展性相关的概念,系统容量表示在一定时间内能够完成的工作量,容量必须是可以有效利用的,系统的最大吞吐量不等同于容量。从较高层次来看，可拓展性就是能够通过增加资源来提升容量的能力。</p><p>可拓展性的定义: 可拓展性是当增加资源以处理负载和增加容量时系统能够获得的投资产出率.</p><a id="more"></a><h3 id="扩展MySQL"><a href="#扩展MySQL" class="headerlink" title="扩展MySQL"></a>扩展MySQL</h3><p>如果将应用所有的数据简单的放到单个MySQL服务器实例上,则无法很好的扩展,迟早会遇到性能瓶颈.传统的解决方法是购买更多强悍的机器,也就是常说的”垂直扩展”或者”向上扩展”,另外一个与之相反的方法是将任务分配到多台计算机上,通常称为”水平扩展”或者”向外扩展”,另外,大部分应用还会有一些很少或者从来不需要的数据,这些数据可以被清理或者归档,将这个方案称为”向内扩展”.</p><p>通常在无法满足增加的负载时会考虑可扩展性,具体表现为工作负载从CPU密集型变成IO密集型,并发查询的竞争,以及不断增大的延迟.</p><h4 id="规划可扩展性"><a href="#规划可扩展性" class="headerlink" title="规划可扩展性"></a>规划可扩展性</h4><p>人们都长只有在无法满足增加的负载时才会考虑到可扩展性，具体表现为工作负载从CPU密集型变成IO密集型，并发查询的竞争，以及不断增加的延迟。</p><h4 id="向上扩展"><a href="#向上扩展" class="headerlink" title="向上扩展"></a>向上扩展</h4><p>向上扩展意味着购买更多的硬件,对许多应用来说这是唯一需要做的事情，这种策略有很多好处，比如更容易维护和开发，能显著节约开销</p><p>向上扩展的策略可能能够持续一段时间,实际上很多应用是达不到天花板的,但是如果应用十分庞大,向上扩展可能就没有办法了,</p><h4 id="向外扩展（垂直拆分和水平拆分）"><a href="#向外扩展（垂直拆分和水平拆分）" class="headerlink" title="向外扩展（垂直拆分和水平拆分）"></a>向外扩展（垂直拆分和水平拆分）</h4><p><strong>垂直拆分就是根据业务拆到不同的库中，水平拆分可以分到不同的库中，也可以分到不同的表中。</strong></p><p><strong>可以把向外扩展策略划分为三个部分,复制,拆分,以及数据分片。</strong></p><p>最简单最常见的向外扩展的方法是通过复制将数据分发到多个服务器上,然后将备库用于读查询,这种技术对于以读为主的应用很有效,但是缺点也很明显,例如重复缓存,</p><p>另外一个比较常见的向外扩展方法是将工作负载分布到多个节点,具体如果分布工作负载是一个复杂的话题, 在MySQL架构中,一个节点就是一个功能部件,如果没有规划冗余和高可用性,那么一个节点可能就是一个服务器,如果设计的是能够故障转移的冗余系统,那么一个节点可能是1)一个主主复制的双机结构,2)一个主库和多个备库3)一个主动服务器,并使用分布式复制块设备作为备用服务器4)一个基于存储区域网络的集群</p><p>大多数情况下,一个节点内的所有服务器应该拥有相同的数据,</p><h5 id="按功能拆分"><a href="#按功能拆分" class="headerlink" title="按功能拆分"></a>按功能拆分</h5><p>按功能拆分,或者按职责拆,意味着不同的节点执行不同的任务,例如一个网站,各个部分无需共享数据,那么可以按照网站的功能区域进行划分,</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-03%2020-18-51.png" alt=""></p><p>如果应用很大,每个功能区域还可以拥有其专用的web服务器.但是一旦采用了按功能划分,以后就不好进行更具扩展性的设计了.</p><p>另一个可能的按功能划分方法是对单个服务器的数据进行划分，并确保划分的表集合之间不会执行关联操作。</p><p>归根结底，还是不能通过功能划分来无限地进行拓展，因为如果一个功能区域被捆绑到单个Mysql 节点，就只能进行垂直扩展。</p><h5 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h5><p>在目前扩展大型MySQL应用的方案中,<strong>数据分片是最通用,最成功的方法,</strong>它把数据分割成一小片,或者说一块,然后存储到不同的节点中,</p><p>数据分片在和某些类型的按功能划分联合使用时非常有用,大多数分片系统也有一些全局的数据不会被分片.全局数据一般存储在单个节点上. 事实上,大部分应用只会对需要的数据做分片,—通常是那些会增长的非常庞大的数据,</p><p>大型应用可能有多个逻辑数据集，并且处理方式也可以各不相同，可以将他们存储到不同的服务器组上，但这并不是必需的。还可以以多种方式对数据进行分片，这取决于如何使用他们。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-03%2020-34-25.png" alt=""></p><p>采用分片的应用常会有一个数据库访问抽象层，用以降低应用和分片数据存储之间通信的复杂度，但无法完全隐藏分片，因为相比数据存储，应用通常更了解跟查询相关的一些信息。</p><ul><li>选择分区键</li></ul><p>数据分片最大的挑战是查找和获取数据，如何查询数据取决于如何进行分片，有很多方法，其中有一些方法会比另外一些更好。我们的目标是对那些最重要并且频繁查询的数据减少分片。这其中最重要的是如何为数据选择一个或者多个分区键，分区键决定了每一行分配到哪一个分片中，如果知道一个对象的分区键，就可以回答如下两个问题：应该在哪里存储数据，应该从哪里取得希望取得的数据。一个好的分区键常常是数据库中一个非常重要的实体的主键，这些键决定了分片单元，选择分区键的时候，尽可能选择那些能够避免跨分片查询的，但同时也要让分片足够小，以免过大的数据片导致问题。</p><h4 id="通过多实例扩展"><a href="#通过多实例扩展" class="headerlink" title="通过多实例扩展"></a>通过多实例扩展</h4><p>不要在一个性能很强的服务器上只运行一个服务器实例,我们还有别的选择,可以让数据分片足够小,以使每台机器上都能放置多个分片,每台服务器上运行多个实例,然后划分服务器的硬件资源,将其分配给每个实例.</p><h4 id="通过集群扩展"><a href="#通过集群扩展" class="headerlink" title="通过集群扩展"></a>通过集群扩展</h4><p>理想的扩展方案是单一逻辑数据库能够存储尽可能多的数据,处理尽可能多的查询,并且如期望的那样增长,随着云计算的流行,自动扩展-根据负载或者数据大小动态地在集群中增加/移除服务器越来越多.</p><h4 id="向内扩展"><a href="#向内扩展" class="headerlink" title="向内扩展"></a>向内扩展</h4><p>处理不断增加的数据和负载最简单的方法是对不再需要的数据进行归档和清理,这种操作可能带来显著的成效,具体取决于工作负载和数据特性,这种做法并不用来代替其他策略,但是可以作为争取时间的短期策略,也可以作为处理大数据量的长期计划之一.</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>首先,集群和分布式的区别</p><p>分布式：一个业务分拆多个子业务，部署在不同的服务器上<br>集群：同一个业务，部署在多个服务器上</p><p>负载均衡的思路很简单,在一个服务器集群中尽可能的平均负载量,通常的做法是在服务器前端设置一个负载均衡器(一般是专门的硬件设备),然后负载均衡器将请求的连接路由到最空闲的可用服务器,下图是一个大型网站的负载均衡设置,其中一个负载均衡器用于http流量,另一个用于MySQL访问</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-03%2020-54-11.png" alt=""></p><p> 负载均衡的主要目的有可扩展性,高效性,可用性,透明性,一致性.</p><p>在与MySQL相关的领域中,负载均衡通常与数据分片及复制紧密相关.可以把负载均衡和高可用性结合在一起,部署到应用的任一层次上.</p><h4 id="应用与MySQL直接相连"><a href="#应用与MySQL直接相连" class="headerlink" title="应用与MySQL直接相连"></a>应用与MySQL直接相连</h4><h5 id="复制上的读写分离"><a href="#复制上的读写分离" class="headerlink" title="复制上的读写分离"></a>复制上的读写分离</h5><p>MySQL复制产生了多个数据副本,由于备库复制是异步的,因此难点在于如何处理备库上的脏数据,<strong>应该将备库用作只读的,</strong>而主库可以同时处理读和写查询.</p><p>比较常见的读写分离方法如下：</p><ul><li>基于查询分离：最简单的分离方法是将所有不能容忍脏数据的读和写查询分配到主库服务器上，其他的读查询分配到备库或被动服务器上，</li><li>基于脏数据分离，这是对基于查询分离方法的小改进，需要做一些额外的工作，让应用检查复制延迟，以确定备库数据是否太旧，许多报表类应用都使用这个策略，只需要晚上加载的数据复制到备库疾苦，它们并不关心是不是100%跟上了主库。</li><li>基于会话分离 判断用户自己是否修改了数据，用户不需要看到其他用户的最新数据，但是需要看到自己的更新，可以在会话层设置一个标记位，表明做了更新，就将该用户的查询在一段时间内总是指向主库，这是十分推荐的策略，因为它是在简单和有效性之间的一种很好的妥协。</li></ul><p>大多数读写分离解决方案都需要监控复制延迟来决策读查询的分配，不管是通过复制或负载均衡器，或是一个中间系统。</p><h4 id="引入中间件"><a href="#引入中间件" class="headerlink" title="引入中间件"></a>引入中间件</h4><p>许多负载均衡方案都会引入一个中间件,作为网络通信的代理,它一边接受所有的通信请求,另一边将这些请求派发到指定的服务器上,然后把执行结果发送回请求的机器上.中间件可以是硬件设备或是软件,</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-03%2021-27-51.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL复制</title>
      <link href="/2018/01/03/MYSQL%E5%A4%8D%E5%88%B6/"/>
      <url>/2018/01/03/MYSQL%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Mysql内建的复制功能是构建基于MySQL的大规模高性能应用的基础,使用所谓水平拓展的架构,可以通过为服务器配置一个或者多个备库的方式来进行数据同步,</p><h4 id="复制概述"><a href="#复制概述" class="headerlink" title="复制概述"></a>复制概述</h4><p>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步,一台主库的数据可以同步到多台备库中,备库本身也可以被配置为另外一台服务器的主库,主库与备库之间可以有多种不同的组合方式</p><a id="more"></a><p>MySQL支持两种复制方式,<strong>基于行的复制和基于语句的复制</strong>,两种方式都是通过在主库上记录二进制日志,在备库重放日志的方式来实现异步的数据复制,也就意味者,同一时间点,备库的数据可能与主库存在不一致,并且无法保证主备之间的延迟,一些打的语句可能导致备库产生几秒,甚至几个小时的延迟.</p><p>复制通常不会增加主库的开销,主要是启用二进制日志带来的开销.通过复制可以将读操作指向备库来获得更好的读拓展,但对于写操作,除非设计得当,否则不适合通过复制来拓展写操作.当使用一主库多备库的架构时,可能会造成一些浪费,因为本质上会复制大量不必要的数据.</p><p>通过复制可以将读操作指向备库来获得更好的读拓展，但是对于写操作，除非设计得当，否则并不适合通过复制来拓展写操作，在一主多从多备库的架构中，写操作会被执行多次，这时候整个系统的性能取决于写入最慢的那部分。</p><h5 id="复制的用途"><a href="#复制的用途" class="headerlink" title="复制的用途"></a>复制的用途</h5><p>主要有,</p><ul><li>数据分布(在不同的地理位置分布数据备份)</li><li>负载均衡(通过复制将多个读操作分布到多个服务器上,实现对读密集型应用的优化) </li><li>备份</li><li>高可用性和故障切换，(复制能够帮助应用程序避免MYSQL单点失败。一个包含复制的设计良好的故障切换系统能够显著地缩短宕机时间，)</li><li>MySQL升级测试</li></ul><h5 id="复制如何工作"><a href="#复制如何工作" class="headerlink" title="复制如何工作"></a>复制如何工作</h5><p>三步,第一步,在主库上把数据更改记录到二进制日志中,第二步备库将主库上的日志复制到自己的中继日志中,第三步,备库读取中继日志中的事件,将其重放到备库数据中.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-02%2021-11-41.png" alt=""></p><p>第一步是在主库上记录二进制日志，在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MYSQL 会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志，在记录二进制日志后，主库会告诉存储引擎可以提交事务了。</p><p>下一步，备库将主库的二进制日志复制到其本地的中继日志中，首先，备库会启动一个工作线程，称为IO线程，IO线程会跟主库建立一个普通的客户端连接，然后在主库上启动一个特殊的二进制转储线程，这个二进制转储线程会读取主库上二进制日志中的事件，它不会对事件进行轮询。如果该线程追赶上了主库，它将进入睡眠状态，直到主库发送信号量通知其有新的事件产生时才会被唤醒，备库IO线程会将接收到的事件记录到中继日志中。</p><p>备库的SQL 线程执行最后一步，该线程从中继日志中读取事件并在备库执行，从而实现备库数据的更新。当SQL线程追赶上IO线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低。</p><h4 id="配置复制"><a href="#配置复制" class="headerlink" title="配置复制"></a>配置复制</h4><p>三步,在每台服务器上创建复制账号,配置主库和备库,通知备库连接到主库并从主库辅助数据.</p><h4 id="复制的原理"><a href="#复制的原理" class="headerlink" title="复制的原理"></a>复制的原理</h4><p>MySQL5.0之前的版本只<strong>支持基于语句的复制</strong>,在基于语句的复制模式下,主库会记录那些造成数据更改的查询,当备库读取并重放这些事件时,实际上只是把主库上执行过的SQL重新执行了一遍,好处是实现相当简单，另一个好处是二进制日志里的事件更加紧凑。</p><p>MySQL5.1开始支持基于行的复制,这种方式会将实际数据记录在二进制日志中,最大的好处就是可以正确的复制每一行.</p><p>MySQL可以在两种模式下动态切换,默认情况下,使用的是基于语句的复制方式,但是如果发现有语句无法被正确的复制,就会切换到基于行的复制模式.</p><h4 id="发送复制事件到其他备库"><a href="#发送复制事件到其他备库" class="headerlink" title="发送复制事件到其他备库"></a>发送复制事件到其他备库</h4><p>log_slave_updates 选项可以让备库变成其他服务器的主库，在设置该选项后，MYSQL 会将其执行过的事件记录到它自己的二进制日志中。这样，它的备库就可以从其日志中检索并执行事件。</p><h4 id="复制拓扑"><a href="#复制拓扑" class="headerlink" title="复制拓扑"></a>复制拓扑</h4><p>可以在任意个主库和备库之间建立复制,只有一个限制,<strong>每一个备库只能有一个主库.</strong></p><p>下面是一些基本原则： </p><p>一个MYSQL 备库实例只能有一个主库。</p><p>每个备库必须有一个唯一的服务器ID</p><p>一个主库可以由多个备库</p><h5 id="一主库多个备库"><a href="#一主库多个备库" class="headerlink" title="一主库多个备库"></a>一主库多个备库</h5><p>备库之间没有交互,它们仅仅是连接到同一个主库上,在有少量写和大量读时,这种配置非常有用,可以把读分摊到多个备库上,直到备库给主库造成了太大的负担.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-02%2021-33-47.png" alt=""></p><p>用途:</p><ul><li>为不同的角色使用不同的备库,(例如添加不同的索引或使用不同的存储引擎)</li><li>把一台备库当待用的主库,除了复制没有其他数据传输</li><li>将一台备库放到远程数据中心,用作灾难恢复</li><li>延迟一个或者多个备库,以备灾难恢复</li><li>实用其中一个备库,作为备份,培训,开发或者测试使用服务器</li></ul><h5 id="主动-主动模式下的主-主复制"><a href="#主动-主动模式下的主-主复制" class="headerlink" title="主动-主动模式下的主-主复制"></a>主动-主动模式下的主-主复制</h5><p>两台服务器,每一个都被配置成对方的主库和备库,换句话说,他们是一对主库. 通常用于特殊的目的,,一种可能的应用场景是两个出于不同地理位置的办公室,并且都需要一份可写的数据拷贝.这种情况下导致的问题会非常多,两个服务器都可以写</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-02%2021-45-53.png" alt=""></p><h5 id="主动-被动模式下的主-主复制"><a href="#主动-被动模式下的主-主复制" class="headerlink" title="主动-被动模式下的主-主复制"></a>主动-被动模式下的主-主复制</h5><p>构建容错性和高可用性系统的强大方式,和上面的主要区别在于其中的一台服务器是只读的被动服务器.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-02%2021-47-07.png" alt=""></p><p>这种方式使得反复切换主动和被动服务器非常方便,因为服务器的配置是对称的,这使得故障恢复和故障转移很容易,可以在不关闭服务器的情况下执行维护,优化表,升级操作系统或其他任务.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-02%2021-49-41.png" alt=""></p><h5 id="拥有备库的主-主结构"><a href="#拥有备库的主-主结构" class="headerlink" title="拥有备库的主-主结构"></a>拥有备库的主-主结构</h5><p>为每一个主库增加一个备库</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-02%2021-52-13.png" alt=""></p><p>优点是增加了冗余,对于不同地理位置的复制拓扑,能够消除站点单点失效的问题,</p><h5 id="环形复制-尽量避免"><a href="#环形复制-尽量避免" class="headerlink" title="环形复制(尽量避免)"></a>环形复制(尽量避免)</h5><h5 id="主库-分发主库和备库"><a href="#主库-分发主库和备库" class="headerlink" title="主库,分发主库和备库"></a>主库,分发主库和备库</h5><p>备库足够多时,会给主库造成很大的负载,每个备库会在主库上创建一个线程,并执行binlog dump命令, 该命令会读取二进制日志文件中的数据并将其发送给备库,每个备库都会重复这样的工作,他们不会共享binlog dump的资源</p><p>因此,如果需要多个备库,一个好的方法是从主库移除负载并使用分发主库,分发主库事实上也是一个备库,它的唯一目的是提取和提供主库的二进制文件,多个备库连接到分发主库,使原来的主库拜托了负担,为了避免在分发主库上做实际的查询,可以将它的表修改为blackhole引擎</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-03%2019-22-09.png" alt=""></p><h5 id="树型或金字塔型"><a href="#树型或金字塔型" class="headerlink" title="树型或金字塔型"></a>树型或金字塔型</h5><p>如果正在将主库复制到大量的备库中,不管是把数据分发到不同的地方,还是提供更高的读性能,使用金字塔结构都能够更好的管理.这种设计减轻了主库的负担.</p><h3 id="复制与容量规划"><a href="#复制与容量规划" class="headerlink" title="复制与容量规划"></a>复制与容量规划</h3><p>写操作通常是复制的瓶颈，并且很难使用复制来拓展写操作，当计划为系统增加复制容量时，需要确保进行了正确的计算，否则很容易犯一些复制相关的错误。</p><p>糟糕的服务容量比例的根本原因是不能像分发读操作那样把写操作等同地分发到更多服务器上，也就是说，复制只能拓展读操作，无法拓展写操作。对数据进行分区是唯一可以拓展写入的方法。</p><blockquote><p>高性能MySQL</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进制与位运算</title>
      <link href="/2018/01/03/%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2018/01/03/%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="进制与位运算"><a href="#进制与位运算" class="headerlink" title="进制与位运算"></a>进制与位运算</h2><p>进制也就是进位制，是人们规定的一种进位方法。</p><h5 id="进制的前缀"><a href="#进制的前缀" class="headerlink" title="进制的前缀"></a>进制的前缀</h5><p>0b开头表示二进制</p><p>0开头表示八进制</p><p>0x开头表示十六进制</p><a id="more"></a><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="1-amp"><a href="#1-amp" class="headerlink" title="1.  &amp;"></a>1.  &amp;</h4><p>如果两个相应的二进制位都为1,则该位的结果值为1,否则为0</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-03%2018-27-53.png" alt=""></p><h4 id="2"><a href="#2" class="headerlink" title="2.  |"></a>2.  |</h4><p>两个相应的二进制位只要有一个是1,则结果就是1,否则是0.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-03%2018-29-59.png" alt=""></p><h4 id="3-lt-lt-向左位移"><a href="#3-lt-lt-向左位移" class="headerlink" title="3.  &lt;&lt; 向左位移"></a>3.  &lt;&lt; 向左位移</h4><p>向左移一位,右边自动补零 ,结果变成当前值的两倍</p><h4 id="4-向右位移"><a href="#4-向右位移" class="headerlink" title="4.   向右位移"></a>4.   向右位移</h4><p>向右移一位,有符号数左边补符号位, 无符号数直接补0, 结果变为原来的二分之一.</p><h4 id="5-异或"><a href="#5-异或" class="headerlink" title="5.   ^ 异或"></a>5.   ^ 异或</h4><p>两个相同的数会变成0,反之是1.</p><h4 id="6"><a href="#6" class="headerlink" title="6 .  ~"></a>6 .  ~</h4><p>在加法中用到, ~y = -y - 1 比如 ~11 = -11-1 = -12</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136. Single Number</title>
      <link href="/2018/01/02/leetcode136/"/>
      <url>/2018/01/02/leetcode136/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given an array of integers, every element appears <em>twice</em> except for one. Find that single one.</p><p><strong>Note:</strong><br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>短小精悍的一道题,给定一个数组,每个元素都出现了两次,但是有一个只出现了一次,求出是哪一个元素？线性复杂度,常数空间.</p><a id="more"></a><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len =nums.size();</span><br><span class="line">        <span class="keyword">int</span> result =nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result =result^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>使用位运算, XOR异或.</p><p>XOR will return 1 only on two different bits. So if two numbers are the same, XOR will return 0. Finally only one number left.<br>A ^ A = 0 and A ^ B ^ A = B.</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36. Valid Sudoku</title>
      <link href="/2018/01/02/leetcode36/"/>
      <url>/2018/01/02/leetcode36/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx" target="_blank" rel="noopener">Sudoku Puzzles - The Rules</a>.</p><p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>&#39;.&#39;</code>.</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p><p>A partially filled sudoku which is valid.</p><p><strong>Note:</strong><br>A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一个二维数组代表数独,判断是否满足数独的定义,数独需要满足的规则有每一行1-9不能重复,每一列1-9不能重复,每一个块(一共3*3=9块)1-9不能重复. 点代表未知的任意数,</p><a id="more"></a><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = board.size();</span><br><span class="line">        <span class="keyword">int</span> used1[<span class="number">9</span>][<span class="number">9</span>]=&#123;<span class="number">0</span>&#125;,used2[<span class="number">9</span>][<span class="number">9</span>]=&#123;<span class="number">0</span>&#125;,used3[<span class="number">9</span>][<span class="number">9</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!=<span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j]-<span class="string">'0'</span>- <span class="number">1</span>; <span class="comment">//当前遍历到的数字.</span></span><br><span class="line">                    <span class="keyword">int</span> k = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>; <span class="comment">//当前属于的区块,这里除3再乘3和原来不相等,因为除三只保留整数位.</span></span><br><span class="line">                    <span class="keyword">if</span>(used1[i][num]||used2[j][num]||used3[k][num])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    used1[i][num]=<span class="number">1</span>;</span><br><span class="line">                    used2[j][num]=<span class="number">1</span>;</span><br><span class="line">                    used3[k][num]=<span class="number">1</span>;    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>使用哈希表,used1 表示判断每行,used2表示判断没列,used3表示判断每个块.</p><p>从上到下,从左到右,对每一个数进行遍历,i,j,k 分别代表当前遍历到的块走到了哪一个行,列,块.</p><p>有了就在对应的used标记为1,若有重复标记的1 .直接return false.</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2017/12/30/SpringMVC-(%E4%B8%80)/"/>
      <url>/2017/12/30/SpringMVC-(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p>Spring MVC框架围绕DispatcherServlet这个核心展开,DispatcherServlet是Spring MVC最重要的Servlet,它负责截获请求并将其分派给相应的处理器处理.</p><p>Spring MVC 框架包括注解驱动控制器,请求及相应的信息处理, 视图解析,本地化解析,上传文件解析,异常处理,及表单标签绑定等内容</p><a id="more"></a><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-29%2020-58-28.png" alt=""></p><p>Spring如何将上下文的Spring MVC 组件装配到DispatcherServlet中,查看DispatcherServlet的initStrategies()方法的代码,</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-29%2021-17-08.png" alt=""></p><p>(<em>ApplicationContext是Spring的核心，Context我们通常解释为上下文环境，我想用“容器”来表述它更容易理解一些，ApplicationContext则是“应用的容器”了；在Web应用中，我们会用到WebApplicationContext，WebApplicationContext继承自ApplicationContext；WebApplicationContext的初始化方式和BeanFactory.ApplicationContext有所区别,因为WebApplicationContext需要ServletContext实例,也就是说它必须拥有Web容器的前提下才能完成启动的工作.</em>)</p><p>initStrategies()方法将在WebApplicationContext初始化后自动执行,此时Spring上下文中的Bean已经初始化完毕,该方法的工作原理是通过反射查找并装配Spring容器中用户显式自定义的组件Bean,找不到,就装配默认的组件实例.</p><h5 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h5><p>不但支持标准URL,还支持Ant风格的和带占位符{XXX}的URL</p><p>ANT通配符有三种：</p><table><thead><tr><th>通配符</th><th>说明</th></tr></thead><tbody><tr><td>?</td><td>匹配任何单字符</td></tr><tr><td>*</td><td>匹配0或者任意数量的字符</td></tr><tr><td>**</td><td>匹配0或者更多的目录</td></tr></tbody></table><p>例子：</p><table><thead><tr><th>URL路径</th><th>说明</th></tr></thead><tbody><tr><td>/app/*.x</td><td>匹配(Matches)所有在app路径下的.x文件</td></tr><tr><td>/app/p?ttern</td><td>匹配(Matches) /app/pattern 和 /app/pXttern,但是不包括/app/pttern</td></tr><tr><td>/**/example</td><td>匹配(Matches) /app/example, /app/foo/example, 和 /example</td></tr><tr><td>/app/*<em>/dir/file.</em></td><td>匹配(Matches) /app/dir/file.jsp, /app/foo/dir/file.html,/app/foo/bar/dir/file.pdf, 和 /app/dir/file.java</td></tr><tr><td>/*<em>/</em>.jsp</td><td>匹配(Matches)任何的.jsp 文件</td></tr></tbody></table><h5 id="Spring-MVC的配置"><a href="#Spring-MVC的配置" class="headerlink" title="Spring MVC的配置"></a>Spring MVC的配置</h5><p>配置视图解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="请求处理方法签名详解"><a href="#请求处理方法签名详解" class="headerlink" title="请求处理方法签名详解"></a>请求处理方法签名详解</h4><p>@RequestParam绑定请求参数值</p><p>@CookieValue绑定请求中的Cookie值</p><p>@RequestHeader 绑定请求报文头的属性值</p><p>使用Servlet API作为入参 如HttpServletRequest request</p><h4 id="使用HttpMessageConverter-lt-T-gt"><a href="#使用HttpMessageConverter-lt-T-gt" class="headerlink" title="使用HttpMessageConverter&lt;T&gt;"></a>使用HttpMessageConverter<code>&lt;T&gt;</code></h4><p><code>HttpMessageConverter&lt;T&gt;</code>是Spring的一个重要接口,负责将请求信息转换为一个对象(类型为T),将对象(类型为T)输出为相应信息.</p><p>Spring 为<code>HttpMessageConverter&lt;T&gt;</code>提供了多个实现类,这些类组成了一个功能强大,用途广泛的信息转换家族.Spring中已经默认装配了以下的HttpMessageConverter,<code>StringHttpMessageConverter</code> <code>ByteHttpMessageConverter</code> <code>SourceHttpMessageConverter</code> <code>XmlAwareFormHttpMessageConverter</code>,如果要装配其他的HttpMessageConverter,则应该自行定义一个RequestMappingHandlerAdapter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverters"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>/&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如何使用<code>HttpMessageConvert&lt;T&gt;</code>将请求信息转换并绑定到处理方法的入参,可以使用@RequestBody和@ReponseBody对处理方法进行标注,</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-29%2022-21-28.png" alt=""></p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-29%2022-23-07.png" alt=""></p><hr><p><code>&lt;mvc:annotation-driven&gt;</code>会自动注册<code>RequestMappingHandlerMapping</code>与<code>RequestMappingHandlerAdapter</code>两个bean</p><p><code>&lt;mvc:default-servlet-handler/&gt;</code>使用默认的Servlet来相应静态文件</p><hr><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><h4 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h4><p>spring在核心模型中添加了一个通用的类型转换模块,类型转换模块位于org.springframework.core.convert包中,spring希望用这个类型转换体系替换Java标准中的PropertyEditor.</p><p>ConversionService是spring类型转换体系的核心接口,位于org.springframework.core.convert包中.也是该包唯一一个接口.</p><p>可以利用<code>org.springframework.context.support.ConversionServiceFactoryBean</code>在spring的上下文中定义一个ConversionService. spring将自动识别上下文的ConversionService ,并在Bean属性配置及SpringMVC处理方法入参绑定等场合使用它进行数据转换.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过ConversionServiceFactoryBean的converters属性注册自定义的类型转换器,代码如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> =<span class="string">"com.sysu.MyConverter"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当实现一个自定义的转换器时,需要实现Converter接口,这个接口仅有一个接口方法,它的接口定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">&#125;<span class="comment">//负责将S类型的对象转换为T类型的对象,</span></span><br></pre></td></tr></table></figure><h4 id="在SpringMVC中使用ConversionService例子"><a href="#在SpringMVC中使用ConversionService例子" class="headerlink" title="在SpringMVC中使用ConversionService例子"></a>在SpringMVC中使用ConversionService例子</h4><p>将一个请求参数字符串直接转换为User对象,</p><p>先定义一个自定义转换器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToUserConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>,<span class="title">User</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">convert</span><span class="params">(String source)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    User user= <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">//&lt;将字符串转为对象的代码&gt;</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写好转换器后,将其声明在spring上下文中,</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:</span> <span class="attr">annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">names</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">com.sysu.converters.StringToUserConverter</span>&gt;</span> //上面那个</span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在装配好StringToUserConverters后,就可以在任何控制器的处理方法中使用这个转换器了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/path"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hand</span><span class="params">(@RequestParam(<span class="string">"user"</span>)</span> User user)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问<code>localhost:8080/path?user=tom:1234:tomon</code>时就会自动使用控制器转换了.</p><h3 id="视图和视图解析器"><a href="#视图和视图解析器" class="headerlink" title="视图和视图解析器"></a>视图和视图解析器</h3><p>SpringMVC借助视图解析器(ViewResolver)得到最终的视图对象(View),这可以是常见的jsp视图,也可能是基于FreeMarker,Velocity 模板技术的视图,还可能是PDF,Execl,XML.JSON等各种形式的视图.</p><p>不同的视图实现技术对应不同的View实现类,这些视图实现类都位于org.springframework.web.servlet.view包中,</p><p>SpringMVC为逻辑视图名的解析提供了不同的策略,可以在Spring web上下文中配置一种或者多种解析策略,并指定先后顺序,每种解析策略对应一个具体的视图解析器实现类. 所以视图解析器都实现了ViewResolver接口,该接口只有一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">resolverViewName</span><span class="params">(String viewName,Locale locale)</span></span></span><br></pre></td></tr></table></figure><p>JSP是最常见的视图技术,配置JSP视图解析如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><p>在web.xml的dispatcherServlet中,设置<code>&lt;urlpattern&gt;/&lt;urlpattern&gt;</code>,所有请求都被SpringMVC的dispatcherServlet截获.</p><h5 id="采用-lt-mvc-default-servlet-handler-gt"><a href="#采用-lt-mvc-default-servlet-handler-gt" class="headerlink" title="采用&lt;mvc:default-servlet-handler/&gt;"></a>采用<code>&lt;mvc:default-servlet-handler/&gt;</code></h5><p>配置上面的语句后,spring会在上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler,它充当检察员的责任,对进入dispatcherservlet的url进行检查,如果发现是静态资源的请求,就将该请求转由web应用服务器默认的servlet处理.</p><h5 id="采用-lt-mvc-resources-gt"><a href="#采用-lt-mvc-resources-gt" class="headerlink" title="采用&lt;mvc:resources/&gt;"></a>采用<code>&lt;mvc:resources/&gt;</code></h5><p>配置后,springMVC自己处理静态资源,并添加一些有用的附加功能.</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC相关配置</title>
      <link href="/2017/12/30/SpringMVC%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/12/30/SpringMVC%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p>Spring MVC框架围绕DispatcherServlet这个核心展开,DispatcherServlet是Spring MVC最重要的Servlet,它负责截获请求并将其分派给相应的处理器处理.</p><p>Spring MVC 框架包括注解驱动控制器,请求及相应的信息处理, 视图解析,本地化解析,上传文件解析,异常处理,及表单标签绑定等内容</p><a id="more"></a><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-29%2020-58-28.png" alt=""></p><p>Spring如何将上下文的Spring MVC 组件装配到DispatcherServlet中,查看DispatcherServlet的initStrategies()方法的代码,</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-29%2021-17-08.png" alt=""></p><p>(<em>ApplicationContext是Spring的核心，Context我们通常解释为上下文环境，我想用“容器”来表述它更容易理解一些，ApplicationContext则是“应用的容器”了；在Web应用中，我们会用到WebApplicationContext，WebApplicationContext继承自ApplicationContext；WebApplicationContext的初始化方式和BeanFactory.ApplicationContext有所区别,因为WebApplicationContext需要ServletContext实例,也就是说它必须拥有Web容器的前提下才能完成启动的工作.</em>)</p><p>initStrategies()方法将在WebApplicationContext初始化后自动执行,此时Spring上下文中的Bean已经初始化完毕,该方法的工作原理是通过反射查找并装配Spring容器中用户显式自定义的组件Bean,找不到,就装配默认的组件实例.</p><h5 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h5><p>不但支持标准URL,还支持Ant风格的和带占位符{XXX}的URL</p><p>ANT通配符有三种：</p><table><thead><tr><th>通配符</th><th>说明</th></tr></thead><tbody><tr><td>?</td><td>匹配任何单字符</td></tr><tr><td>*</td><td>匹配0或者任意数量的字符</td></tr><tr><td>**</td><td>匹配0或者更多的目录</td></tr></tbody></table><p>例子：</p><table><thead><tr><th>URL路径</th><th>说明</th></tr></thead><tbody><tr><td>/app/*.x</td><td>匹配(Matches)所有在app路径下的.x文件</td></tr><tr><td>/app/p?ttern</td><td>匹配(Matches) /app/pattern 和 /app/pXttern,但是不包括/app/pttern</td></tr><tr><td>/**/example</td><td>匹配(Matches) /app/example, /app/foo/example, 和 /example</td></tr><tr><td>/app/*<em>/dir/file.</em></td><td>匹配(Matches) /app/dir/file.jsp, /app/foo/dir/file.html,/app/foo/bar/dir/file.pdf, 和 /app/dir/file.java</td></tr><tr><td>/*<em>/</em>.jsp</td><td>匹配(Matches)任何的.jsp 文件</td></tr></tbody></table><h5 id="Spring-MVC的配置"><a href="#Spring-MVC的配置" class="headerlink" title="Spring MVC的配置"></a>Spring MVC的配置</h5><p>配置视图解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="请求处理方法签名详解"><a href="#请求处理方法签名详解" class="headerlink" title="请求处理方法签名详解"></a>请求处理方法签名详解</h4><p>@RequestParam绑定请求参数值</p><p>@CookieValue绑定请求中的Cookie值</p><p>@RequestHeader 绑定请求报文头的属性值</p><p>使用Servlet API作为入参 如HttpServletRequest request</p><h4 id="使用HttpMessageConverter-lt-T-gt"><a href="#使用HttpMessageConverter-lt-T-gt" class="headerlink" title="使用HttpMessageConverter&lt;T&gt;"></a>使用HttpMessageConverter<code>&lt;T&gt;</code></h4><p><code>HttpMessageConverter&lt;T&gt;</code>是Spring的一个重要接口,负责将请求信息转换为一个对象(类型为T),将对象(类型为T)输出为相应信息.</p><p>Spring 为<code>HttpMessageConverter&lt;T&gt;</code>提供了多个实现类,这些类组成了一个功能强大,用途广泛的信息转换家族.Spring中已经默认装配了以下的HttpMessageConverter,<code>StringHttpMessageConverter</code> <code>ByteHttpMessageConverter</code> <code>SourceHttpMessageConverter</code> <code>XmlAwareFormHttpMessageConverter</code>,如果要装配其他的HttpMessageConverter,则应该自行定义一个RequestMappingHandlerAdapter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverters"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>/&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如何使用<code>HttpMessageConvert&lt;T&gt;</code>将请求信息转换并绑定到处理方法的入参,可以使用@RequestBody和@ReponseBody对处理方法进行标注,</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-29%2022-21-28.png" alt=""></p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-29%2022-23-07.png" alt=""></p><hr><p><code>&lt;mvc:annotation-driven&gt;</code>会自动注册<code>RequestMappingHandlerMapping</code>与<code>RequestMappingHandlerAdapter</code>两个bean</p><p><code>&lt;mvc:default-servlet-handler/&gt;</code>使用默认的Servlet来相应静态文件</p><hr><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><h4 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h4><p>spring在核心模型中添加了一个通用的类型转换模块,类型转换模块位于org.springframework.core.convert包中,spring希望用这个类型转换体系替换Java标准中的PropertyEditor.</p><p>ConversionService是spring类型转换体系的核心接口,位于org.springframework.core.convert包中.也是该包唯一一个接口.</p><p>可以利用<code>org.springframework.context.support.ConversionServiceFactoryBean</code>在spring的上下文中定义一个ConversionService. spring将自动识别上下文的ConversionService ,并在Bean属性配置及SpringMVC处理方法入参绑定等场合使用它进行数据转换.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过ConversionServiceFactoryBean的converters属性注册自定义的类型转换器,代码如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> =<span class="string">"com.sysu.MyConverter"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当实现一个自定义的转换器时,需要实现Converter接口,这个接口仅有一个接口方法,它的接口定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">&#125;<span class="comment">//负责将S类型的对象转换为T类型的对象,</span></span><br></pre></td></tr></table></figure><h4 id="在SpringMVC中使用ConversionService例子"><a href="#在SpringMVC中使用ConversionService例子" class="headerlink" title="在SpringMVC中使用ConversionService例子"></a>在SpringMVC中使用ConversionService例子</h4><p>将一个请求参数字符串直接转换为User对象,</p><p>先定义一个自定义转换器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToUserConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>,<span class="title">User</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">convert</span><span class="params">(String source)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    User user= <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">//&lt;将字符串转为对象的代码&gt;</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写好转换器后,将其声明在spring上下文中,</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:</span> <span class="attr">annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">names</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">com.sysu.converters.StringToUserConverter</span>&gt;</span> //上面那个</span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在装配好StringToUserConverters后,就可以在任何控制器的处理方法中使用这个转换器了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/path"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hand</span><span class="params">(@RequestParam(<span class="string">"user"</span>)</span> User user)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问<code>localhost:8080/path?user=tom:1234:tomon</code>时就会自动使用控制器转换了.</p><h3 id="视图和视图解析器"><a href="#视图和视图解析器" class="headerlink" title="视图和视图解析器"></a>视图和视图解析器</h3><p>SpringMVC借助视图解析器(ViewResolver)得到最终的视图对象(View),这可以是常见的jsp视图,也可能是基于FreeMarker,Velocity 模板技术的视图,还可能是PDF,Execl,XML.JSON等各种形式的视图.</p><p>不同的视图实现技术对应不同的View实现类,这些视图实现类都位于org.springframework.web.servlet.view包中,</p><p>SpringMVC为逻辑视图名的解析提供了不同的策略,可以在Spring web上下文中配置一种或者多种解析策略,并指定先后顺序,每种解析策略对应一个具体的视图解析器实现类. 所以视图解析器都实现了ViewResolver接口,该接口只有一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">resolverViewName</span><span class="params">(String viewName,Locale locale)</span></span></span><br></pre></td></tr></table></figure><p>JSP是最常见的视图技术,配置JSP视图解析如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><p>在web.xml的dispatcherServlet中,设置<code>&lt;urlpattern&gt;/&lt;urlpattern&gt;</code>,所有请求都被SpringMVC的dispatcherServlet截获.</p><h5 id="采用-lt-mvc-default-servlet-handler-gt"><a href="#采用-lt-mvc-default-servlet-handler-gt" class="headerlink" title="采用&lt;mvc:default-servlet-handler/&gt;"></a>采用<code>&lt;mvc:default-servlet-handler/&gt;</code></h5><p>配置上面的语句后,spring会在上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler,它充当检察员的责任,对进入dispatcherservlet的url进行检查,如果发现是静态资源的请求,就将该请求转由web应用服务器默认的servlet处理.</p><h5 id="采用-lt-mvc-resources-gt"><a href="#采用-lt-mvc-resources-gt" class="headerlink" title="采用&lt;mvc:resources/&gt;"></a>采用<code>&lt;mvc:resources/&gt;</code></h5><p>配置后,springMVC自己处理静态资源,并添加一些有用的附加功能.</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cache 策略</title>
      <link href="/2017/12/29/Spring%E7%BC%93%E5%AD%98/"/>
      <url>/2017/12/29/Spring%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cache-策略"><a href="#Spring-Cache-策略" class="headerlink" title="Spring Cache 策略"></a>Spring Cache 策略</h1><p>不同层级对应的缓存要求和缓存策略,</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-29%2015-31-41.png" alt=""></p><h4 id="自定义缓存实现"><a href="#自定义缓存实现" class="headerlink" title="自定义缓存实现"></a>自定义缓存实现</h4><a id="more"></a><p>场景: 用户查询是一个十分常见的动作,为了提高页面相应速度,将用户的userid作为key,返回的用户信息作为value,而当以相同的userid查询用户时,程序直接从缓存中获取结果并返回,否则更新缓存.</p><p>首先定义一个User实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String userid;</span><br><span class="line">  <span class="keyword">private</span> String userName;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="comment">//省略get,set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java对象的缓存和序列化息息相关,一般情况下,需要被缓存的实体类需要实现Serializable ,只有实现了Serializable接口的类,JVM才会对其对象进行序列化. 对于redis,EhCache 等缓存套件来说,被缓存的对象应该是可以序列化的,否则在网络传输,硬盘传输时都会抛出序列化异常</p><p>接着定义一个缓存管理器,管理器负责实现缓存逻辑,支持对象的增加,修改和删除,并支持值对象的泛型.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cacheManager</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String,T&gt; cache =<span class="keyword">new</span> ConcurrentHashMap&lt;String, T&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrUpdateCache</span><span class="params">(String key,T value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cache.put(key,cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictCache</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="comment">//  根据key删除缓存中的一条记录</span></span><br><span class="line">    <span class="keyword">if</span>(cache.containsKey(key))</span><br><span class="line">    &#123;</span><br><span class="line">      cache.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="comment">// 清空缓存中的记录</span></span><br><span class="line">    cache.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了实体类和一个缓存管理器,还需要一个提供用户查询的服务类,此服务类使用缓存管理器来支持用户查询.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Userservice</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CacheManager&lt;User&gt; cacheManager;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cacheManager =<span class="keyword">new</span> CacheManager&lt;User&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUserByID</span><span class="params">(String userid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//首先查询缓存</span></span><br><span class="line">      User result = cacheManager.getValue(userid);</span><br><span class="line">      <span class="keyword">if</span>(result!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果在缓存中,直接返回缓存结果</span></span><br><span class="line">          System.out.plintln(<span class="string">"get from cache"</span>+userid);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      result = getFromDB(userId);</span><br><span class="line">      <span class="keyword">if</span>(result!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cacheManager.addOrUpdateCache(userid,result);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cacheManager.evictCache();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> User <span class="title">getFromDB</span><span class="params">(String userid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"querying db"</span> +userid);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(userid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一种自定义缓存的方法,但是缓存代码和业务代码高度耦合,如果要新增功能,代码将进一步复杂化.</p><p>下面使用spring cache来实现上面的例子. 因为Spring已经提供了默认的缓存管理器,所以不用自己实现缓存模拟器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">UserService</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//使用一个名为users的缓存.</span></span><br><span class="line">    <span class="meta">@Cacheable</span>(cacheNames=<span class="string">"users"</span>)</span><br><span class="line">  <span class="function">Public User <span class="title">getUserById</span><span class="params">(String userId)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//直接实现业务</span></span><br><span class="line">      System.out.println(<span class="string">"query"</span> +userid);</span><br><span class="line">      <span class="keyword">return</span> getFromDB(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Cacheable(cacheNames=&quot;users&quot;)</code>注解标注的方法被调用的时候,会先从users缓存中查询匹配的缓存对象,如果存在就直接返回,不存在就查询数据库,并将返回值放入缓存中,对应缓存的key为userId的值,value就是userId所对应的User对象,缓存名称要在spring配置文件中定义.</p><p>在spring配置文件中配置支持基于注解的缓存</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-29%2019-39-02.png" alt=""></p><p>Spring 通过<code>&lt;cache: annotation-driven/&gt;</code> 即可启动基于注解的缓存驱动,配置项默认使用了定义为cacheManager的缓存管理器,SimpleCacheManager是这个缓存管理器的默认实现,相当于前面自己实现的缓存管理器,可以看到,除了默认的default缓存外,还有一个名为users的缓存.</p><p>上面就是使用自定义cache和使用spring cache的过程.</p><h2 id="详细介绍Spring-Cache"><a href="#详细介绍Spring-Cache" class="headerlink" title="详细介绍Spring Cache"></a>详细介绍Spring Cache</h2><h4 id="缓存注解"><a href="#缓存注解" class="headerlink" title="缓存注解"></a>缓存注解</h4><p>首先,只有使用public定义的方法才可以被缓存,注解定义了哪些方法的返回值会被缓存或者从缓存中移除.</p><h5 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h5><p>@Cacheable是最重要的注解,它制定了注解方法的返回值是可以被缓存的,缓存名必须提供,一般使用cacheNames或者Value属性来定义名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(cacheNames=<span class="string">"users"</span>) 或<span class="meta">@Cacheable</span>(value=<span class="string">"users"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(cacheNames=<span class="string">"users"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(String id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.get(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子以id为键值(key)将用户(value)缓存至users缓存段中,此外还可以自定义键</p><p>Spring cache中的值是返回值,键有以下情况</p><ul><li>如果方法没有入参,则使用SimpleKey.Empty 作为key</li><li>如果只有一个入参,则使用该入参作为key</li><li>如果有多个入参,则返回包含所有入参的一个SimpleKey</li></ul><p>也可以用SPEL自定义键值</p><h5 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h5><p>和@Cacheable注解效果几乎一样,当需要保证方法被调用，又希望结果被缓存, 可以使用@CachePut </p><h5 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h5><p>@CacheEvict注解是@Cacheable注解的反向操作,负责从给定的缓存中移除一个值.</p><h4 id="缓存管理器"><a href="#缓存管理器" class="headerlink" title="缓存管理器"></a>缓存管理器</h4><p>CacheManager是SPI(服务程序提供接口)提供了访问缓存名称和缓存对象的方法,同时也提供了管理缓存,操作缓存,和移除缓存的方法</p><h3 id="Spring-EhCache"><a href="#Spring-EhCache" class="headerlink" title="Spring + EhCache"></a>Spring + EhCache</h3><p>1 .pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ehcache 相关依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2 .添加ehcache配置文件ehcache-setting.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定一个文件目录，当EhCache把数据写到硬盘上时，将把数据写到这个文件目录下 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"java.io.tmpdir"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设定缓存的默认数据过期策略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">"10000"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">"false"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">"10"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">"20"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"cacheTest"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">"10"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3 .spring 配置文件application.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:cache</span>=<span class="string">"http://www.springframework.org/schema/cache"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/cache </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/cache/spring-cache-3.1.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描注解的bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.sysu.service"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache:annotation-driven</span> <span class="attr">cache-manager</span>=<span class="string">"cacheManager"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheCacheManager"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"ehcache"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ehcache"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheManagerFactoryBean"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:ehcache-setting.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>EhCacheTestService接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sysu.service;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EhCacheTestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserid</span><span class="params">(String param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5 .EhCacheTestService接口的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sysu.service.impl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> com.sysu.service.EhCacheTestService;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EhCacheTestServiceImpl</span> <span class="keyword">implements</span> <span class="title">EhCacheTestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Cacheable</span>(value=<span class="string">"cacheTest"</span>,key=<span class="string">"#param"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTimestamp</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        Long timestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> timestamp.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring整合ORM</title>
      <link href="/2017/12/29/Spring%E6%95%B4%E5%90%88ORM/"/>
      <url>/2017/12/29/Spring%E6%95%B4%E5%90%88ORM/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-整合ORM框架"><a href="#Spring-整合ORM框架" class="headerlink" title="Spring 整合ORM框架"></a>Spring 整合ORM框架</h1><p>使用mybatis提供的ORM机制,对业务逻辑实现人员来说,面对的是纯粹的Java对象,</p><p><code>&lt;context: property-placeholder location=&quot;classpath: jbdc.properties&quot;/&gt;</code>导入properties文件.</p><h4 id="配置SqlMapClient"><a href="#配置SqlMapClient" class="headerlink" title="配置SqlMapClient"></a>配置SqlMapClient</h4><p>每个mybatis的应用程序都以一个SQLSessionFactory对象的实例为核心,SQLSessionFactory的对象实例可以通过SqlSesssionFactoryBuilder对象来获得,SQLSessionFactoryBuilder可以从XML配置文件或者Configuration类的实例中构建SqlSessionFactory对象.</p><a id="more"></a><p>MySQL拥有多个SQL映射文件,并通过一个配置文件对这些SQL映射文件进行装配,同时在该文件中定义一些控制属性的信息,</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!--sesstings提供mybatis运行时的行为属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useGeneratedKeys"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="在Spring中配置Mybatis"><a href="#在Spring中配置Mybatis" class="headerlink" title="在Spring中配置Mybatis"></a>在Spring中配置Mybatis</h5><p>可以使用mybatis提供的mybatis-spring整合包实现Spring和Mybatis的整合,从功能上说,mbatis-spring完全符合Spring的风格,要在Spring中整合Mybatis,必须把mybatis-spring构件添加到pom.xml中.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.sysu.dao"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.sysu.service"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:</span> <span class="attr">property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath: jbdc.properties"</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;dataSource.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;dataSource.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;dataSource.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idleConnectionTestPeriod"</span> <span class="attr">value</span>=<span class="string">"60"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapper/*.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"org.Sysu.bean"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 扫描mybatis核心配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis-spring提供了一个sqlsessionFactoryBean,以便通过Spring风格创建mybatis的SqlsessionFactory,像上面配置文件的最后一个bean.mapperLoactions 属性快速扫描sql映射文件.</p><h5 id="使用映射接口"><a href="#使用映射接口" class="headerlink" title="使用映射接口"></a>使用映射接口</h5><p>mybatis提供了一种可将sql映射文件中的映射项通过名称匹配接口进行调用的方法,接口名称和映射命名空间相同,接口方法和映射元素的id相同.</p><p>定义好DAO接口后,如何通过该接口进行数据访问呢,mybatis-spring提供了转换器MapperScannerConfigurer,将映射接口直接变为spring容器中的bean,</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"org.Sysu.Dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务管理</title>
      <link href="/2017/12/28/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2017/12/28/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Spring提供了灵活方便的事务管理功能,这些功能都是基于底层数据库本身的事务处理机制工作的.</p><p>Spring为事务管理提供了一致的编程模板,在高层次建立了统一的事务抽象,也就说不管hibernate,mybatis,JPA,spring都可以让用户用统一的编程模型进行事务管理.</p><p>Spring将事务管理委托给底层具体的持久化实现框架来完成,因此,Spring为不同的持久化框架提供了PlatformTransactionManager 接口的实现类,</p><a id="more"></a><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-28%2021-19-29.png" alt=""></p><p>这些事务管理器都是对特定事务实现框架的代理,这样就可以通过Spring所提交的高级抽象对不同种类的事务实现使用相同的方式进行管理,而不关心具体的实现.</p><p>要实现事务管理,首先要在Spring中配置好相应的事务管理器,为事务管理器指定数据资源及一些其他事务管理控制属性.下图是mybatis的配置</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-28%2021-26-10.png" alt=""></p><h4 id="使用注解配置声明式事务"><a href="#使用注解配置声明式事务" class="headerlink" title="使用注解配置声明式事务"></a>使用注解配置声明式事务</h4><p>Spring的声明式事务是通过SpringAOP实现的,通过事务的声明性信息,Spring负责将事务管理增强逻辑动态织入业务方法的相应连接点中,这些逻辑包括获取线程绑定资源,开始事务,提交/回滚事务,进行异常转换和处理工作.</p><p>Spring提供了基于注解的事务配置,即通过@Transactional对需要事务增强的Bean接口,实现类,或方法进行标注,在容器中配置基于注解的事务增强驱动,即可启用基于注解的声明式事务,</p><h5 id="使用-Transactional注解"><a href="#使用-Transactional注解" class="headerlink" title="使用@Transactional注解"></a>使用@Transactional注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForumService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addtopic</span><span class="params">(Topic topic)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        topicDao.addTopic(topic);</span><br><span class="line">      postDao.addPost(topic.getPost());</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Forum <span class="title">getForum</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> forumDao.getForum(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为注解本身具有一组普适性的默认事务属性,所以往往只需要在需要事务管理的业务类中添加一个@transactional注解,就完成了业务类事务属性的配置.</p><p>然后还需要在spring配置文件中通过一行小小的配置”通知”Spring容器对标注@Transactional注解的bean加工处理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:</span> <span class="attr">annotation-driven</span> <span class="attr">transaction-manager</span> =<span class="string">"数据源事务管理器的id"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="两种事务管理方式"><a href="#两种事务管理方式" class="headerlink" title="两种事务管理方式"></a>两种事务管理方式</h4><p>Spring 支持编程式事务管理和声明式事务管理两种方式</p><p>编程式事务管理使用TransactionTemplate（推荐使用）或者直接使用底层的PlatformTransactionManager。</p><p>声明式事务管理是建立在AOP基础上的，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明，便可以将事务规则应用到业务逻辑中。</p><p>声明式事务也有两种常用的方法，一种是基于tx和aop命名空间的xml配置文件，另一种就是基于@Transactional注解。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring对DAO的支持</title>
      <link href="/2017/12/28/Spring%E5%AF%B9DAO%E7%9A%84%E6%94%AF%E6%8C%81/"/>
      <url>/2017/12/28/Spring%E5%AF%B9DAO%E7%9A%84%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<p>Spring对多个持久化技术提供了集成支持,包括hibernate,mybatis,JPA,JDO, Spring面向DAO制定了一个通用的异常体系,屏蔽具体持久化技术的异常,使业务层和具体的持久化技术实现解耦.</p><p>DAO即Data Access Object ,是用于访问数据的对象,DAO不仅屏蔽了数据存储的最终介质的不同,也屏蔽了具体的实现技术的不同.</p><a id="more"></a><h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p>数据源表示可用于应用程序的数据。 更具体而言，数据源表示您希望在应用程序中使用的数据。 数据源可从数据库（包括本地数据库文件）、服务以及对象中获得。</p><p>不管采用何种持久化技术,都必须拥有数据连接,在spring中,数据连接是通过数据源获得的,在以往的应用中,数据源一般是由应用服务器提供的,在spring中,不但可以通过JNDI获取应用服务器的数据源,也可以直接在Spring容器中配置数据源,,还可以通过代码的方式创建一个数据源,以便进行无容器依赖的单元测试.</p><h5 id="配置一个数据源"><a href="#配置一个数据源" class="headerlink" title="配置一个数据源"></a>配置一个数据源</h5><p>两个数据源实现类包，一个Apache的DBCP,一个是c3p0</p><p>c3p0是一个开放源码的JDBC数据源实现项目,实现了JDBC3和JDBC2拓展规范说明的Connection和Statement池.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;dataSource.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;dataSource.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;dataSource.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 每60秒检查所有连接池中的空闲连接。Default: 0 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idleConnectionTestPeriod"</span> <span class="attr">value</span>=<span class="string">"60"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 初始化时获取三个连接，取值应在minPoolSize与maxPoolSize之间。Default: 3 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"5"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdleTime"</span> <span class="attr">value</span>=<span class="string">"60"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 连接池中保留的最大连接数。Default: 15 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 连接池中保留的最小连接数。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span> <span class="attr">value</span>=<span class="string">"5"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements</span></span><br><span class="line"><span class="comment">属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。</span></span><br><span class="line"><span class="comment">如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。Default: 0  --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatementsPerConnection"</span> <span class="attr">value</span>=<span class="string">"3"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 定义所有连接测试都执行的测试语句。在使用连接测试的情况下这个显著提高测试速度。注意：</span></span><br><span class="line"><span class="comment">测试的表必须在初始数据源的时候就存在。Default: null --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"preferredTestQuery"</span> <span class="attr">value</span>=<span class="string">"select 1"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 定义在从数据库获取新连接失败后重复尝试的次数。Default: 30--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireRetryAttempts"</span> <span class="attr">value</span>=<span class="string">"3"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 两次连接中间隔时间，单位毫秒。Default: 1000 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireRetryDelay"</span> <span class="attr">value</span>=<span class="string">"1000"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 当连接池用完时客户端调用getConnection()后等待获取新连接的时间，超时后将抛出</span></span><br><span class="line"><span class="comment">SQLException,如设为0则无限期等待。单位毫秒。Default: 0 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span> <span class="attr">value</span>=<span class="string">"30000"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="使用属性文件"><a href="#使用属性文件" class="headerlink" title="使用属性文件"></a>使用属性文件</h5><p>数据源的配置信息可能经常改动,所以一般将数据源的配置信息独立出来到一个属性文件中,通过</p><p><code>&lt;context:property-placeholder&gt;</code>引入属性文件,以${xxx}的方式引用属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"/WEB-INF/jdbc.properties"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;dataSource.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;dataSource.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;dataSource.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataSource.url = jdbc:mysql://localhost:3309/sample</span><br><span class="line">dataSource.username=root</span><br><span class="line">dataSource.password=123</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringAOP</title>
      <link href="/2017/12/27/SpringAOP/"/>
      <url>/2017/12/27/SpringAOP/</url>
      
        <content type="html"><![CDATA[<h5 id="Filter（过滤器）与Interceptor（拦截器）和Spring-AOP的区别？"><a href="#Filter（过滤器）与Interceptor（拦截器）和Spring-AOP的区别？" class="headerlink" title="Filter（过滤器）与Interceptor（拦截器）和Spring AOP的区别？"></a>Filter（过滤器）与Interceptor（拦截器）和Spring AOP的区别？</h5><p>Filter过滤器：拦截web访问url地址。</p><p>Interceptor拦截器：拦截以 .action结尾的url，拦截Action的访问。</p><p>Spring AOP拦截器：只能拦截Spring管理Bean的访问（业务层Service）</p><a id="more"></a><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP即面向切面编程,希望将分散在各个业务逻辑代码中的相同代码通过横向切割的方法抽取大一个独立的模块中,给业务逻辑类一个清新的世界.</p><h3 id="AOP-术语"><a href="#AOP-术语" class="headerlink" title="AOP 术语"></a>AOP 术语</h3><ul><li>连接点</li></ul><p>一个类或者一段程序拥有一些具有边界性质的特定点,这些代码中的特定点就成为连接点,spring仅支持方法的连接点,即仅能在方法调用前,方法调用后,方法抛出异常时这些程序执行点织入增强.</p><ul><li>切点</li></ul><p>每个程序类都有多个连接点,AOP通过切点来定位特定的连接点,类比数据库.连接点相当于数据库中的记录,而切点相当于查询条件,一个切点可以匹配多个连接点.</p><ul><li>增强</li></ul><p>增强是织入目标连接点上的一段程序代码</p><ul><li>目标对象</li></ul><p>增强逻辑的织入目标类</p><ul><li>引介</li></ul><p>引介是一种特殊的增强,它为类增加一些属性和方法</p><ul><li>织入</li></ul><p>织入是将增强添加到目标类的具体连接点上的过程</p><ul><li>代理</li></ul><p>一个类被AOP织入增强后,就产生了一个结果类,它是融合了原类和增强逻辑的代理类.</p><ul><li>切面</li></ul><p>切面由切点和增强组成,既包括横切逻辑的定义,也包括连接点的定义.</p><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>​     JDK的动态代理主要涉及java.lang.reflect包中的两个类,<code>Proxy</code> 和<code>InvocationHandler</code>,其中InvocationHandler是一个接口,可以通过该接口定义横切逻辑,并通过反射机制调用目标类的代码,动态的将横切罗杰和业务逻辑编织在一起.</p><p>​    而Proxy利用InvocationHandler 动态创建一个符合某一接口的实例,生成目标类的代理对象.</p><h4 id="spring对AOP的支持"><a href="#spring对AOP的支持" class="headerlink" title="spring对AOP的支持"></a>spring对AOP的支持</h4><p>springAOP包括了基于XML配置的AOP和基于@AspectJ注解的AOP,两种方法在配置切面时的表现方式不同,但是底层都采用了动态代理技术</p><h5 id="了解注解"><a href="#了解注解" class="headerlink" title="了解注解"></a>了解注解</h5><p>注解是代码的附属信息,遵循一个基本原则,注解不能直接干扰程序代码的运行,无论增加还是删除注解,代码都可以正常运行,Java语言解释器会忽略这些注解,而由第三方工具对注解进行处理,第三方工具可以利用代码中的注解间接控制程序代码的运行,他们通过Java反射机制读取注解的信息,并根据这些信息更改目标程序的逻辑,</p><h4 id="使用-AspectJ"><a href="#使用-AspectJ" class="headerlink" title="使用@AspectJ"></a>使用@AspectJ</h4><p>使用前的准备: spring在处理@AspectJ注解表达式时,需要将spring的asm模块添加到类路径中,asm是轻量级的字节码处理框架,因为Java的反射机制无法获取入参名,spring就利用asm处理@AspectJ中所描述的方法入参名.  spring采用AspectJ提供的@AspectJ注解类库及相应的解析类库,需要在pom.xml文件中添加aspectj.weaver和aspectj.tools类包的依赖.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--使用AspectJ方式注解需要相应的包--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeWaiter</span> <span class="keyword">implements</span> <span class="title">Waiter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetTo</span><span class="params">(String clientName)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"greet"</span>+clientName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serveTo</span><span class="params">(String clientName)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"serve"</span>+clientName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面用@AspectJ定义一个切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 通过该注解把PreGreetingAspect标识为一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreGreetingAspect</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* greeTo(..))"</span>) <span class="comment">//定义切点以及增强类型</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeGreeting</span><span class="params">()</span>   <span class="comment">//增强的横切逻辑</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"How are you"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@before表示是前置增强,成员值是一个@AspectJ切点表达式,意思是在目标类的greetTo方法上织入增强,greetTo()方法可以带任意的入参和任意的返回值.最后,beforeGreeting是增强使用的横切逻辑,该横切逻辑在目标方法调用前调用.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-27%2021-52-58.png" alt=""></p><h5 id="配置AspectJ切面"><a href="#配置AspectJ切面" class="headerlink" title="配置AspectJ切面"></a>配置AspectJ切面</h5><p>使用基于schema的aop命名空间进行配置</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-27%2021-56-31.png" alt=""></p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-27%2021-57-00.png" alt=""></p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-27%2021-58-01.png" alt=""></p><p><strong>切面类必须还要在spring中注册</strong></p><h3 id="AspectJ语法基础"><a href="#AspectJ语法基础" class="headerlink" title="@AspectJ语法基础"></a>@AspectJ语法基础</h3><p>AspectJ切点表达式由关键字和操作参数组成,如切点表达式<code>execution(* greeTo(..))</code> <code>execution</code> 为关键字,</p><p><code>* greeTo(..)</code> 为操作参数,execution代表目标类执行某一方法,而 <code>* greeTo(..)</code>描述目标方法的匹配模式串,二者联合起来来表示目标类greetTo()方法的连接点.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-28%2016-32-12.png" alt=""></p><p>切面表达式分成三种,第一种就是指示器,描述通过什么样方式匹配对应的类的方法</p><p>第二种就是通配符,第三种就是运算符,描述多个不同的匹配条件之间的逻辑</p><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><ul><li><code>*</code>匹配任意数量的字符</li><li><code>+</code>匹配指定的类及其子类</li><li><code>..</code>匹配任意数的子包或参数</li></ul><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><ul><li><code>&amp;&amp;</code> and 运算符</li><li><code>||</code> or运算符</li><li><code>!</code> 非运算符</li></ul><h5 id="designators-指示器"><a href="#designators-指示器" class="headerlink" title="designators 指示器"></a>designators 指示器</h5><p>匹配方法: execution </p><p>匹配注解: @target @args @within @annotation</p><p>匹配包/类型: within()</p><p>匹配对象: this()  bean() target()</p><p>匹配参数  args()</p><p>主要是execution匹配</p><p>语法如下:(模式指的是都可以用前面的通配符进行匹配)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="tag">&lt;<span class="name">修饰符模式(public等)</span>&gt;</span>  <span class="tag">&lt;<span class="name">返回类型模式</span>&gt;</span> <span class="tag">&lt;<span class="name">方法名模式</span>&gt;</span>(<span class="tag">&lt;<span class="name">参数模式</span>&gt;</span>) <span class="tag">&lt;<span class="name">异常模式</span>&gt;</span>)</span><br></pre></td></tr></table></figure><ul><li>通过方法签名定义切点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> * *(..)) 匹配所有目标类的<span class="keyword">public</span>方法,第一个*代表返回类型,第二个*代表方法名.</span><br><span class="line">execution(* *To(..)) 匹配目标类中所有以To为后缀的方法</span><br></pre></td></tr></table></figure><ul><li>通过类定义切点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.sysu.Waiter.*(..)匹配com.sysu.Waiter接口中的所有方法,第一个*表示任意返回类型)</span><br><span class="line">execution(* com.sysu.Waiter+.*(..)) 匹配waiter接口及其实现类的所有方法</span><br></pre></td></tr></table></figure><ul><li>通过类包定义切点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.sysu.* (..))匹配com.sysu包下所有类的所有方法</span><br><span class="line">execution(* com.sysu..*(..))匹配com.sysu 包,子孙包下所有类的所有方法</span><br><span class="line">execution(* com..*.*Dao.find*(..))匹配包前缀名为com的任何包下类名后缀为Dao的方法.方法名以find前缀</span><br></pre></td></tr></table></figure><ul><li>通过方法入参定义切点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execution(* joke(String,<span class="keyword">int</span>)) 匹配joke(String,<span class="keyword">int</span>)方法</span><br><span class="line">execution(* joke(String,* ))匹配joke方法,且第一个参数是String类型</span><br><span class="line">execution(* joke(String,..)) 第二个参数可以有无限类型.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的配置</title>
      <link href="/2017/12/26/Spring%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/12/26/Spring%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>要使spring容器成功启动,需要具备下面三个条件,spring框架的类包都已经放到应用程序的类路径下,应用程序为spring提供了完整的Bean配置信息,Bean的类都已经放到应用程序的类路径下.</p><p>spring容器和Bean的使用流程图如下:</p><a id="more"></a><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-26%2021-37-34.png" alt=""></p><h4 id="基于XML的配置"><a href="#基于XML的配置" class="headerlink" title="基于XML的配置"></a>基于XML的配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>XML Schema 描述 XML 文档的结构。首先在上面的配置文件中</p><p><code>xmlns=&quot;http://www.springframework.org/schema/beans&quot;</code>规定了默认的命名空间,用于spring bean 的定义</p><p><code>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</code> 是标准命名空间,用于为每个文档中的命名空间指定相应的Schema 样式文件,是W3C 定义的标准命名空间</p><p><code>xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</code>这种都属于自定义的命名空间,比如tx就表示spring配置事务的命名空间.</p><p>命名空间的定义分为两个步骤.</p><ul><li>第一步指定命名空间的名称,</li><li>第二步指定命名空间的schema文档格式文件的位置,用空格或者回车换行就进行分割.</li></ul><p>在第一步中,需要指定命名空间的缩略名和全名比如</p><p><code>xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</code> tx为命名空间的别名,一般使用简记的形式,而<code>http://www.springframework.org/schema/tx</code>为空间的全限定名,习惯上用文档发布机构的官方网站和相关网站目录作为全限定名</p><p>如果命名空间的别名为空,则表示该命名空间为文档默认命名空间,文档中无命名空间前缀的都属于默认命名空间.如<code>&lt;beans&gt;</code></p><p>第二步中,为每个命名空间指定了对应的schema文档格式的定义文件,定义的语法如下:</p><p><code>&lt;命名空间1&gt; &lt;1的schema文件&gt;  命名空间2&gt; &lt;2的schema文件&gt;</code></p><p>命名空间使用全限定名,每个组织机构在发布schema文件后,都会为该schema文件提供一个引用的URL地址,一般使用这个URL地址指定命名空间对应的schema文件.</p><h4 id="装配一个Bean"><a href="#装配一个Bean" class="headerlink" title="装配一个Bean"></a>装配一个Bean</h4><p>在spring容器的配置文件中定义一个简要bean的配置片段</p><p><code>&lt;bean id=&quot;Foo&quot; class=&quot;com.smart.Foo&quot;&gt;</code></p><p>一般情况,springIoC容器中的一个Bean对应配置文件中的一个<code>&lt;bean&gt;</code>,通过容器的getBean()即可获取相应的bean.</p><h4 id="整合多个配置文件"><a href="#整合多个配置文件" class="headerlink" title="整合多个配置文件"></a>整合多个配置文件</h4><p>spring允许使用import将多个配置文件引入到一个文件中,进行配置文件的集成.(p命名空间是一种简化的配置方式,)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:com/sysu/beans1.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b1"</span> <span class="attr">class</span>=<span class="string">"com.Boss"</span> <span class="attr">p:name</span>=<span class="string">"John"</span> <span class="attr">p:car-ref</span>=<span class="string">"car1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b2"</span> <span class="attr">class</span>=<span class="string">"com.Boss"</span> <span class="attr">p:name</span>=<span class="string">"John"</span> <span class="attr">p:car-ref</span>=<span class="string">"car2"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>p:name =&quot;john&quot;</code> 就是property name的值为john .p:属性-ref=”其他bean的id” 是引用bean.</p><h4 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h4><h5 id="使用注解定义Bean"><a href="#使用注解定义Bean" class="headerlink" title="使用注解定义Bean"></a>使用注解定义Bean</h5><p>前面说,spring容器成功启动的三个要件是bean定义信息,bean实现类,及spring本身,如果用XML方式,那么定义信息和实现类就是分离的,基于注解则是一个更好的方法.</p><p>例如在Dao上使用@Component注解,就可以被spring容器识别,并转换为容器管理的Bean.</p><ul><li>@Repository 用于对DAO实现类进行标注</li><li>@Service 用于对Service实现类进行标注</li><li>@Controller 用于对Controller实现类进行标注</li></ul><h5 id="扫描注解定义的Bean"><a href="#扫描注解定义的Bean" class="headerlink" title="扫描注解定义的Bean"></a>扫描注解定义的Bean</h5><p>spring 提供了一个context命名空间,提供了通过扫描类包以应用注解定义Bean的方式,</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&gt;                           </span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;context:component-scan base-package="</span><span class="attr">com.smart.anno</span>"/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>声明context命名空间后,就可以通过context命名空间的Component-scan 的base-package属性指定一个需要扫描的基类包,spring会扫描这个基类包的所有类,并从类的注解信息中获取Bean的定义信息.</p><h4 id="自动装配Bean"><a href="#自动装配Bean" class="headerlink" title="自动装配Bean"></a>自动装配Bean</h4><p>spring使用@Autowired注解实现Bean的依赖注入,@Autowired默认<strong>按类型匹配</strong>的方式在容器中查找匹配的Bean,当且仅有一个匹配的Bean的时候,Spring将其注入@Autowired标注的变量中.</p><p>如果希望spring即使找不到对应的Bean也不要报出异常,可以用<code>@Autowired(required=false)进行标注</code></p><p>如果在容器中有一个以上匹配的Bean时,可以通过@Qualifier注解限定Bean的名称例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">LoginService</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">  <span class="meta">@Qualifier</span>(<span class="string">"userdao"</span>)</span><br><span class="line">  <span class="keyword">private</span> UserDap userdao;</span><br><span class="line">  <span class="comment">//注入名为userdao,类型为UserDao的Bean.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在类方法上标注@Autowired,也更加推荐这样写.</p><h5 id="对集合类进行标注"><a href="#对集合类进行标注" class="headerlink" title="对集合类进行标注"></a>对集合类进行标注</h5><p>spring如果发现变量是一个Lis和一个Map集合类,它会将容器中匹配集合元素类型的所有Bean都注入进来,</p><h5 id="延迟依赖注入"><a href="#延迟依赖注入" class="headerlink" title="延迟依赖注入"></a>延迟依赖注入</h5><p>在spring容器启动的时候,对于在Bean上标注@Lazy及@Autowired注解的属性,不会立即注入属性值,而会延迟到调用此属性的时候才会注入属性值.</p><h3 id="Spring-的配置方法"><a href="#Spring-的配置方法" class="headerlink" title="Spring 的配置方法"></a>Spring 的配置方法</h3><p>Spring的配置方法有三种，分别是基于XML的配置，基于注解的配置和基于Java Config 的配置。</p><p>基于XML注入有getter/setter注入和构造器注入。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式(生成器模式)</title>
      <link href="/2017/12/26/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/12/26/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式——建造者模式"><a href="#设计模式——建造者模式" class="headerlink" title="设计模式——建造者模式"></a>设计模式——建造者模式</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>建造者模式使用多个简单的对象一步一步构建成一个复杂的对象,属于创建型模式.</p><p>主要目的是为了将一个复杂对象的构建和它的表示分离,使得同样的构建过程可以创建不同的表示,</p><h3 id="针对的问题"><a href="#针对的问题" class="headerlink" title="针对的问题"></a>针对的问题</h3><p><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>如何解决：</strong>将变与不变分离开。</p><p><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系</p><p><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、Java 中的 StringBuilder。</p><p><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p><p><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><a id="more"></a><h3 id="涉及角色"><a href="#涉及角色" class="headerlink" title="涉及角色"></a>涉及角色</h3><ul><li><strong>产品类：</strong>一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有比较多的代码量。在本类图中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与它的不同实现组成，也可以是由多个抽象类与他们的实现组成。</li><li><strong>抽象建造者：</strong>引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个是用来返回产品。</li><li><strong>建造者：</strong>实现抽象类的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品。</li><li><strong>导演类：</strong>负责调用适当的建造者来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。一般来说，导演类被用来封装程序中易变的部分。</li></ul><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-26%2020-29-55.png" alt=""></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Class Product</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String type;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"名称:"</span>+name);</span><br><span class="line">    System.out.println(<span class="string">"型号"</span>+type);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setPart1</span><span class="params">(String arg1)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setPart2</span><span class="params">(String arg2)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span></span><br><span class="line"><span class="class"></span>&#123;<span class="comment">// 建造者的目的就是建造零件</span></span><br><span class="line">  <span class="keyword">private</span> Product product =<span class="keyword">new</span> Product();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Porduct <span class="title">getProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart1</span><span class="params">(String arg1)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">    product.setName(arg1);    </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart2</span><span class="params">(String arg2)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">    product.setType(arg2);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span></span></span><br><span class="line"><span class="class"></span>&#123; <span class="comment">//从建造者中取出零件,进行组件的组装.</span></span><br><span class="line">    <span class="keyword">private</span> Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getAProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        builder.setPart1(<span class="string">"宝马"</span>);</span><br><span class="line">      builder.setPart2(<span class="string">"C1"</span>);</span><br><span class="line">      <span class="keyword">return</span> builder.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">getBProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        builder.setPart1(<span class="string">"奔驰"</span>);</span><br><span class="line">      builder.setPart2(<span class="string">"E2"</span>);</span><br><span class="line">      <span class="keyword">return</span> builder.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Director director = <span class="keyword">new</span> Director();  </span><br><span class="line">        Product product1 = director.getAProduct();  </span><br><span class="line">        product1.showProduct();  </span><br><span class="line">        Product product2 = director.getBProduct();  </span><br><span class="line">        product2.showProduct();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与工厂模式相比，建造者模式一般用来创建<strong>更为复杂的对象</strong>，因为对象的创建过程更为复杂，因此<em>将对象的创建过程独立出来组成一个新的类——导演类</em>。也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。<strong>(建造者类中的建造者相当于工厂中的工厂,在建造者类中对部件进行建造,,导演类是多出来的,用来封装组件创建成整体的过程)</strong></p><p>建造者模式与工厂模式类似，他们都是建造者模式，适用的场景也很相似。一般来说，如果产品的建造<strong>很复杂</strong>，那么请用工厂模式；如果产品的建造<strong>更复杂</strong>，那么请用建造者模式。</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>115. Distinct Subsequences</title>
      <link href="/2017/12/25/leetcode115/"/>
      <url>/2017/12/25/leetcode115/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ol><li><p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>S</strong> which equals <strong>T</strong>.</p><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p><p>Here is an example:<br><strong>S</strong> = <code>&quot;rabbbit&quot;</code>, <strong>T</strong> = <code>&quot;rabbit&quot;</code></p><p>Return <code>3</code>.</p></li></ol><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>给定两个字符串S,T, 找出S中有多少个不同的子串T, 子串是可以删除任意数量的字符(可以是0个),但是不能改变字符的顺序.<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(T.length() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(S.length() + <span class="number">1</span>, <span class="number">0</span>));  </span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S.length() + <span class="number">1</span>; ++i)   </span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; T.length() + <span class="number">1</span>; ++i)   </span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; T.length() + <span class="number">1</span>; ++i) &#123;  </span><br><span class="line">           <span class="keyword">if</span> (S[j - <span class="number">1</span>] == T[i - <span class="number">1</span>])  </span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>]+dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">                    dp[i][j]=dp[i][j<span class="number">-1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> dp[T.length()][S.length()];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>啊,感觉好难.</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-25%2020-23-48.png" alt=""></p><p><strong><code>dp[i][j]</code>是比S, T字符串长度都长1二维数组,<code>dp[i][j]</code> 中 i,j 表示的都是长度,不是字符串的index.</strong></p><p>比如, <code>dp[2][3]</code>表示T中的ra和S中的rab的匹配情况。</p><p>(1)显然，至少有<code>dp[i][j]</code> = <code>dp[i][j - 1]</code>. </p><p>比如, 因为T 中的”ra” 匹配S中的 “ra”， 所以<code>dp[2][2]</code> = 1 。 显然T 中的”ra” 也匹配S中的 “rab”，所以<code>s[2][3]</code> 至少可以等于<code>dp[2][2]</code>。(也就是说,S多了一个字符,dp肯定更大了)</p><p>(2) 如果T[i-1] == S[j-1]， 那么</p><p><code>dp[i][j] = dp[i-1][j-1]+dp[i][j - 1];</code></p><p>前者是截止到当前字母的前一个字母一共有多少个匹配的，那当前字母相等自然这些会继续匹配；后者是截止到当前字母有多少个匹配的，那当前字母可以替换它们，于是就把二者相加即可。</p><p>比如, T中的”rab”和S中的”rab”显然匹配，</p><p>根据(1)， T中的”rab”显然匹配S中的“rabb”，所以<code>dp[3][4]</code> = <code>dp[3][3]</code> = 1， </p><p>根据(2),   T中的”rab”中的b等于S中的”rab1b2”中的b2, 所以要把T中的”rab”和S中的”rab1”的匹配个数累加到当前的<code>dp[3][4]</code>中。 所以<code>dp[3][4]</code> += <code>dp[2][3]</code> = 2; 就是去掉S中的这个,有多少个可以匹配和加上S中的这个的匹配个数.</p><p>(3) 初始情况是<br>dp[0][0] = 1; // T和S都是空串.<br>dp[0][1 … S.length() ] = 1; // T是空串，S只有一种子序列匹配。<br>dp[1 … T.length() ][0] = 0; // S是空串，T不是空串，S没有子序列匹配。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91. Decode Ways</title>
      <link href="/2017/12/24/leetcode91/"/>
      <url>/2017/12/24/leetcode91/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ol><li><p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;A&apos; -&gt; 1</span><br><span class="line">&apos;B&apos; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&apos;Z&apos; -&gt; 26</span><br></pre></td></tr></table></figure><p>Given an encoded message containing digits, determine the total number of ways to decode it.</p><p>For example,<br>Given encoded message <code>&quot;12&quot;</code>, it could be decoded as <code>&quot;AB&quot;</code> (1 2) or <code>&quot;L&quot;</code> (12).</p><p>The number of ways decoding <code>&quot;12&quot;</code> is 2.</p></li></ol><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>用数字表示字母,给定一个数字字符串,计算有多少种字符的表示方式.<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a == <span class="string">'1'</span>||(a == <span class="string">'2'</span> &amp;&amp; b &lt;=<span class="string">'6'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a != <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,fn_1 = <span class="number">1</span>,fn_2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = fn_1;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s[i])&amp;&amp;isValid(s[i<span class="number">-1</span>],s[i]))  </span><br><span class="line">              res+=fn_1+fn_2;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!isValid(s[i])&amp;&amp;isValid(s[i<span class="number">-1</span>],s[i])) </span><br><span class="line">              res+=fn_2;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(isValid(s[i])&amp;&amp;!isValid(s[i<span class="number">-1</span>],s[i])) </span><br><span class="line">              res+=fn_1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!isValid(s[i])&amp;&amp;!isValid(s[i<span class="number">-1</span>],s[i]))  </span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            fn_1 = res;</span><br><span class="line">            fn_2 = temp;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn_1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>(类比爬梯子问题,是和前面两个状态有关!!!!!!)</p><p>使用动态规划,当前的dp和前两个状态有关,且有两个限制条件,第一个条件是当前遍历的字符是否为0,第二个是当前的和前一个的是否可以组成合法字符,然后四种情况分类.</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级特性(二)</title>
      <link href="/2017/12/22/MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7(%E4%BA%8C)/"/>
      <url>/2017/12/22/MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h3 id="字符集和校对"><a href="#字符集和校对" class="headerlink" title="字符集和校对"></a>字符集和校对</h3><p>字符集是指一种从二进制编码到某类字符符号的映射,校对是指一组用于某个字符集的排序规则.</p><h4 id="MySQL如何使用字符集"><a href="#MySQL如何使用字符集" class="headerlink" title="MySQL如何使用字符集"></a>MySQL如何使用字符集</h4><p>每种字符集都可能有多种校对规则,并且都有一个默认的校对规则,每个校对规则都是针对某个特定的字符集的,和其他的字符集没有关系,校对规则和字符集总是一起使用的,所以也将这样的一个组合统称为一个字符集.</p><h5 id="创建对象时的默认设置"><a href="#创建对象时的默认设置" class="headerlink" title="创建对象时的默认设置"></a>创建对象时的默认设置</h5><a id="more"></a><p>MySQL服务器有默认字符集,每个数据库也有默认值,每个表也有默认值,这是一个逐层继承的默认设置,最终最靠底层的默认设置将影响创建的这个对象</p><ul><li>创建数据库的时候,将根据服务器上的character_set_server 设置来设定该数据库的默认字符集</li><li>创建表的时候,将根据数据库的字符集来设置指定这个表的字符集设置</li><li>创建列的时候,将根据表的设置指定列的字符集设置</li></ul><p>最终起作用的还是最靠近底层的设置.</p><h5 id="服务器与客户端通信时的设置"><a href="#服务器与客户端通信时的设置" class="headerlink" title="服务器与客户端通信时的设置"></a>服务器与客户端通信时的设置</h5><p>当服务器和客户端通信的时候,它们可能使用不同的字符集,这时,服务器端将进行必要的翻译转换工作.</p><ul><li>服务器端总是假设客户端是按照character_set_client 设置的字符来传输数据和SQL语句的</li><li>当服务器收到客户端的SQL语句时,先将其转换为字符集character_set_connection .它还使用这个设置来决定如何将数据转换成字符串</li><li>当服务器端返回数据或者错误信息给客户端时,会将其转换为character_set_result.</li></ul><p><img src="http://one-1252095801.cosgz.myqcloud.com/71D1750C-741C-4C16-81BA-8286E25B1E09.png" alt=""></p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>通过数值比较,范围过滤等就可以完成绝大多数查询,但是如果希望通过关键字的匹配来进行查询过滤,那么就需要基于相似度的查询,而不是原来的精确数值比较,全文索引就是为这种场景设计的.</p><p>全文索引有自己独特的语法,没有索引也可以工作,如果有索引效率会更高,用于全文搜索的索引有着独特的结构,帮助这类查询找到匹配某些关键字的记录</p><p>全文索引可以支持各种字符内容的搜索,也支持自然语言搜索和布尔搜索.</p><h3 id="分布式-XA-事务"><a href="#分布式-XA-事务" class="headerlink" title="分布式(XA)事务"></a>分布式(XA)事务</h3><p>存储引擎的事务特性能够保证在存储引擎级别实现ACID,而分布式事务则让存储引擎级别的ACID 可以扩展到数据库层面,甚至可以扩展到多个数据库之间,</p><p>分布式事务中需要有一个事务协调器来保证所有的事务参与者都完成了准备工作,如果协调器收到所有的参与者都准备好的消息,就会告诉所有的事务可以提交了,这是第二阶段,MySQL在这个分布式事务过程中扮演一个参与者的角色,而不是协调者.</p><p>MySQL有两种XA 事务,一方面,MySQL可以参与到外部的分布式事务中,另一方面,还可以通过分布式事务来协调存储引擎和二进制日志.</p><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>很多数据库产品都可以缓存查询的执行计划, 对于相同类型的SQL就可以跳过SQL解析和执行计划生成阶段,MySQL在某些场景下页可以实现,但是MySQL还有另一种不同的缓存类型 缓存完整的SELECT 查询结果,也就是查询缓存.</p><p>MySQL查询缓存 保存查询返回的完整结果,当查询命中该缓存,MySQL会立刻返回结果,跳过了解析,优化,和执行阶段.</p><p>查询缓存系统会跟踪查询中涉及的每个表,如果这些表发生变化,那么和这个表相关的所有缓存数据都将失效,虽然看起来这样实现效率很低,但是这种实现代价小,</p><p>查询缓存对应用程序是完全透明的,应用程序无需关心MySQL是通过查询缓存返回的结果还是实际执行返回的结果,</p><p>随着现在通用服务器越来越强大,查询缓存被发现是一个影响服务器扩展性的因素,它可能成为整个服务器的资源竞争点,在多核服务器上还可能导致服务器僵死,所以很多时候应该默认关闭查询缓存</p><h5 id="MySQL如何判断缓存命中"><a href="#MySQL如何判断缓存命中" class="headerlink" title="MySQL如何判断缓存命中"></a>MySQL如何判断缓存命中</h5><p>MySQL判断缓存命中的方法很简单,缓存存放在一个引用表中,通过一个哈希值引用,哈希值包括了查询本身,当前要查询的数据库,客户端协议的版本等一些其他可能会影响返回结果的信息.当判断缓存是否命中时,MySQL不会解析,正则化或者参数化查询语句,而是直接使用SQL语句和客户端发送过来的原始信息,任何字符的不同都会导致缓存不命中.</p><p>如果希望有更高的缓存效率,可以选择memcached等.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级特性(一)</title>
      <link href="/2017/12/21/MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7(%E4%B8%80)/"/>
      <url>/2017/12/21/MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p><p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。</p><p>视图本身是一个虚拟表,不存放任何数据,在使用sql语句访问视图的时候,它返回的数据是MySQL从其他表中生成的,视图和表是在同一个命名空间,MySQL在很多地方对于视图和表是同样对待的,视图和表也有不同,比如不能对视图创建触发器,也不能用DROP TABLE 命令删除视图</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建一个视图</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> OCeania <span class="keyword">As</span> <span class="keyword">SELECT</span> * <span class="keyword">from</span> Country <span class="keyword">where</span> continent=<span class="string">"OCea"</span></span><br></pre></td></tr></table></figure><p>实现视图最简单的方法就是将select语句的结果存放到临时表中,当需要访问视图的时候, 直接访问这个临时表就可以了.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询</span><br><span class="line"><span class="keyword">select</span> code ,<span class="keyword">name</span> <span class="keyword">from</span> OCeania <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">"Australia"</span></span><br></pre></td></tr></table></figure><p>可更新视图指的是可以通过更新这个视图来更新视图涉及的相关表,只要指定了合适的条件,就可以更新,删除 甚至向视图中写入数据</p><p>在某些情况下,视图还可以提升性能</p><p>MySQL的视图还不支持物化视图,也就是将视图结果数据存放在一个可以查看的表中.</p><p>MySQL也不支持在视图中创建索引</p><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>InnoDB是MySQL目前唯一支持外键的内置存储引擎</p><p>使用外键是有成本的,比如外键通常要求每次在修改数据时都要在另外一张表中多执行一个查找操作,虽然InnoDB强制外键使用索引,但是还是无法消除这种约束检查的开销,如果外键列的选择性很低,则会导致一个非常大且选择性很低的索引</p><p>不过,在某些场景下,外键还是会提升一些性能的.如果要确保两个相关表始终有一致的数据,那么使用外键比在应用程序中检查一致性的性能要高的多,外键在相关数据的删除和更新上,也比在应用中维护要更高效</p><p>外键约束使得查询需要访问额外的表,也就意味着额外的锁,如果向子表中写入一条记录,外键约束会让InnoDB检查对应的父表的记录,也就需要对父表对应记录进行加锁,这会导致额外的锁等待,甚至会导致死锁,因为没有直接访问,所以难以排查</p><p>有时.,可以用触发器来代替外键,对于相关数据的同时更新,外键好,但是如果外键只是作为数值约束,那么触发器或者显示限制取值会更好</p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是种特殊的存储过程,它的执行不是由程序调用,也不需要手动操作,它是由事件来触发的,就像按钮的click事件,网页的load事件等,触发器的事件是由对表进行增删改操作所触发的,当对一个数据库或表进行增删改(insert delete update)时就会激活触发器.</p><p>常见的触发器有两种after(for) instead of </p><p>after(for) 表示执行代码后,执行触发器</p><p>instead of 表示执行代码前,用已经写好的触发器代替你的操作</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器的名字   <span class="keyword">on</span> 操作表</span><br><span class="line"><span class="keyword">for</span>|<span class="keyword">after</span>         instead <span class="keyword">of</span></span><br><span class="line"><span class="keyword">update</span>|<span class="keyword">insert</span>|<span class="keyword">delete</span>   <span class="keyword">as</span>     <span class="keyword">SQL</span>语句</span><br></pre></td></tr></table></figure><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>删除谁就让谁的账户加上10元</p><p>create trigger tr_dalete on bank  instead of　　delete　　as</p><p>update bank balance=balance+10 where cid=(select cid from deleted)</p><p>生成这个触发器之后，当用户输入delete语句后，对应的那个id不但没有被删除掉，而且他的账户增加了10元 </p><p>如：delete from bank where cid=’0002’,执行完这句话后，编号为0002的账户会增加10元.</p><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>在操作mysql的时候我们知道MySQL检索操作返回一组称为结果集的行。这组返回的行都是与 SQL语句相匹配的行（零行或多行）。使用简单的 SELECT语句，例如，没有办法得到第一行、下一行或前 10行，也不存在每次一行地处理所有行的简单方法（相对于成批地处理它们）。有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。游标（ cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条 SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p><p>注意：只能用于存储过程。不像多数 DBMS，MySQL 游标只能用于存储过程（和函数）。</p><p>MySQL在服务器端提供只读的,单向的游标,而且只能在存储过程(<strong>存储在服务器中的一套SQL语句。一旦它被存储了，客户端不需要再重新发布单独的语句，而是可以引用存储程序来替代</strong>)或者更底层的客户端API,因为MySQL游标中指向的对象都是存储在临时表中而不是实际查询到的数据,所以MySQL游标总是只读的,它可以逐行指向查询结果,然后让程序做进一步的处理,在一个存储过程中,可以有多个游标,也可以在循环中嵌套的使用游标</p><p>当打开一个游标的时候,需要执行整个查询.</p><h3 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h3><p>MySQL支持服务器端的绑定变量,这大大提高了客户端和服务器端数据传输的效率,</p><p>当创建一个绑定变量SQL时,客户端向服务器发送了一个SQL语句的原型,服务器端收到这个SQL语句框架后,解析并存储这个SQL语句的部分执行计划,返回给客户端一个SQL语句处理句柄,以后每次执行此类查询,客户端都指定使用这个句柄</p><h3 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h3><p>MySQL支持用户自定义函数,存储过程只能用SQL来编写,而UDF(用户自定义函数)没有这个限制,你可以使用支持C语句调用约定的任何编程语言来实现</p><p>UDF必须事先编译好并动态链接到服务器上.这种平台相关性使得UDF在很多方面都很强大,UDF速度非常块,而且可以访问大量操作系统的功能,还可以使用库函数,使用SQL实现的存储函数在实现一些简单操作上很有优势,但是如果操作涉及到网络交互,就只能使用UDF了,同样,如果需要一个MySQL不支持的统计聚合函数,而且无法使用SQL编写的存储函数来实现的话,通常使用UDF很容易实现</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>76. Minimum Window Substring</title>
      <link href="/2017/12/20/leetcode76/"/>
      <url>/2017/12/20/leetcode76/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p>For example,<br><strong>S</strong> = <code>&quot;ADOBECODEBANC&quot;</code><br><strong>T</strong> = <code>&quot;ABC&quot;</code></p><p>Minimum window is <code>&quot;BANC&quot;</code>.</p><p><strong>Note:</strong><br>If there is no such window in S that covers all characters in T, return the empty string <code>&quot;&quot;</code>.</p><p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>找出包含第二个字符的最短子串<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> || t.length() &gt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; freq(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) &#123;</span><br><span class="line">            freq[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, h = <span class="number">0</span>, counter = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq[s[h++]]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (counter == t.length()) &#123;</span><br><span class="line">                <span class="comment">// [l, h)</span></span><br><span class="line">                <span class="keyword">if</span> (h - l &lt; minLen) &#123;</span><br><span class="line">                    res = s.substr(l, h - l);</span><br><span class="line">                    minLen = res.length();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++freq[s[l++]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    counter--;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>求子串的问题一般都是哈希表和two piont 相结合.</p><p>先把t字符串读到哈希表中.</p><p>本题主要分两个阶段,刚开始初始左右指针都在s的起点处, 先不断的移动右指针,直到包含了所有的T字符,(用counter代表一共S中有了多少T里的字符,当counter等于T.size的时候,代表此时,左指针和右指针围住的子串符合题意了,这时进入第二个阶段,不断的移动左指针,去除掉一些左边不必要的指针,freq是每个字符在T中需要的个数,所以在第二个阶段,就是如果freq[s[l++]]++后,大于0,说明左指针和右指针已经围不住包含T的子串了,此时count–. count–后,会跳出第二个while循环,又会重新去移动右边的指针.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">下面是用哈希表写 ,主要看上面那个解法把</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tot =t.size(); </span><br><span class="line">        <span class="keyword">int</span> ret = s.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>, ansHead = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.find(s[i])-&gt;second&gt;<span class="number">0</span>)   tot--;</span><br><span class="line">            mp.find(s[i])-&gt;second--; <span class="comment">//尾坐标右移,直接就加入了.</span></span><br><span class="line">            <span class="keyword">while</span>(tot==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ret &gt; i - head + <span class="number">1</span>) &#123; ret = i - head + <span class="number">1</span>; ansHead = head;&#125;</span><br><span class="line">                    <span class="comment">// move s[head]</span></span><br><span class="line">                <span class="keyword">if</span> (mp.find(s[ head ])-&gt;second == <span class="number">0</span>) tot ++;</span><br><span class="line">                mp.find(s[ head ])-&gt;second++;</span><br><span class="line">                head ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; s.size()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> s.substr(ansHead, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux硬链接与软链接</title>
      <link href="/2017/12/20/Linux%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5/"/>
      <url>/2017/12/20/Linux%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>现代操作系统为解决信息能独立于进程之外被长期存储引入了文件，文件作为进程创建信息的逻辑单元可被多个进程并发使用。在 UNIX 系统中，操作系统为磁盘上的文本与图像、鼠标与键盘等输入设备及网络交互等 I/O 操作设计了一组通用 API，使他们被处理时均可统一使用字节流方式。换言之，UNIX 系统中除进程之外的一切皆是文件，而 Linux 保持了这一特性。为了便于文件的管理，Linux 还引入了目录（有时亦被称为文件夹）这一概念。目录使文件可被分类管理，且目录的引入使 Linux 的文件系统形成一个层级结构的目录树。</p><a id="more"></a><h4 id="硬链接和软链接的连续与区别"><a href="#硬链接和软链接的连续与区别" class="headerlink" title="硬链接和软链接的连续与区别"></a>硬链接和软链接的连续与区别</h4><p>我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。下图展示了程序通过文件名获取文件内容的过程。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-20%2009-27-57.png" alt=""></p><p>在 Linux 系统中查看 inode 号可使用命令 stat 或 ls -i.  使用命令 mv 移动并重命名文件 glibc.tar.xz，其结果不影响文件的用户数据及 inode 号，文件移动前后 inode 号均为：2485677。</p><p>为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名,他们有共同的 inode。硬链接可由命令 link 或 ln 创建。如下是对文件 oldfile 创建硬链接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">link oldfile newfile </span><br><span class="line">ln oldfile newfile</span><br></pre></td></tr></table></figure><p>由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：</p><ul><li>文件有相同的 inode 及 data block；</li><li>只能对已存在的文件进行创建；</li><li>不能交叉文件系统进行硬链接的创建；</li><li>不能对目录进行创建，只可对文件创建；</li><li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。(删除的时候删的都是名字,都删完没有连接的时候再进行回收)</li></ul><h5 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h5><p>软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块（见下图）。因此软链接的创建与使用没有类似硬链接的诸多限制：</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-20%2009-33-37.png" alt=""></p><ul><li>软链接有自己的文件属性及权限等；</li><li>可对不存在的文件或目录创建软链接；</li><li>软链接可交叉文件系统；</li><li>软链接可对文件或目录创建；</li><li>创建软链接时，链接计数 i_nlink 不会增加；</li><li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s 源文件 目标文件       (-s : 进行软链结symbolic link)</span><br></pre></td></tr></table></figure><h4 id="链接相关命令"><a href="#链接相关命令" class="headerlink" title="链接相关命令"></a>链接相关命令</h4><p>命令 ls 或 stat 可帮助我们区分软链接与其他文件并查看文件 inode 号，但较好的方式还是使用 find 命令，其不仅可查找某文件的软链接，还可以用于查找相同 inode 的所有硬链接。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux管道,grep命令</title>
      <link href="/2017/12/19/Linux%E7%AE%A1%E9%81%93,grep%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/12/19/Linux%E7%AE%A1%E9%81%93,grep%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="查看程序路径"><a href="#查看程序路径" class="headerlink" title="查看程序路径"></a>查看程序路径</h3><p>查看程序的 binary 文件所在路径:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ which command</span><br></pre></td></tr></table></figure><p>eg: 查找 make 程序安装路径:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ which make</span><br><span class="line">/opt/app/openav/soft/bin/make install</span><br></pre></td></tr></table></figure><p>查看程序的搜索路径:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whereis command</span><br></pre></td></tr></table></figure><p>当系统中安装了同一软件的多个版本时，不确定使用的是哪个版本时，这个命令就能派上用场。</p><a id="more"></a><h3 id="linux-管道"><a href="#linux-管道" class="headerlink" title="linux 管道"></a>linux 管道</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">利用Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。下面来看看管道是如何在构造一条Linux命令中得到应用的。</span><br><span class="line"></span><br><span class="line">1.利用一个管道</span><br><span class="line"># rpm -qa|grep licq</span><br><span class="line"></span><br><span class="line">这条命令使用一个管道符“|”建立了一个管道。管道将rpm -qa命令的输出（包括系统中所有安装的RPM包）作为grep命令的输入，从而列出带有licq字符的RPM包来。</span><br><span class="line">4.利用多个管道</span><br><span class="line"></span><br><span class="line"># cat /etc/passwd | grep /bin/bash | wc -l</span><br><span class="line"></span><br><span class="line">这条命令使用了两个管道，利用第一个管道将cat命令（显示passwd文件的内容）的输出送给grep命令，grep命令找出含有“/bin /bash”的所有行；第二个管道将grep的输出送给wc命令，wc命令统计出输入中的行数。这个命令的功能在于找出系统中有多少个用户使用bash。</span><br></pre></td></tr></table></figure><h3 id="linux-grep命令"><a href="#linux-grep命令" class="headerlink" title="linux grep命令"></a>linux grep命令</h3><p><strong>1.作用</strong><br>Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p><p><strong>2.格式</strong><br>grep [options]</p><p><strong>3.主要参数</strong><br>[options]主要参数：<br>－c：只输出匹配行的计数。<br>－I：不区分大 小写(只适用于单字符)。<br>－h：查询多文件时不显示文件名。<br>－l：查询多文件时只输出包含匹配字符的文件名。<br>－n：显示匹配行及 行号。<br>－s：不显示不存在或无匹配文本的错误信息。<br>－v：显示不包含匹配文本的所有行。<br>pattern正则表达式主要参数：<br>\： 忽略正则表达式中特殊字符的原有含义。<br>^：匹配正则表达式的开始行。<br>$: 匹配正则表达式的结束行。<br>\&lt;：从匹配正则表达 式的行开始。<br>>：到匹配正则表达式的行结束。<br>[ ]：单个字符，如[A]即A符合要求 。<br>[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。<br>。：所有的单个字符。<br>* ：有字符，长度可以为0。</p><p><strong>4.grep命令使用简单实例</strong></p><p>$ grep .-.v</p><p>匹配有-v的行</p><p>$ grep ‘test’ d<em><br>显示所有以d开头的文件中包含 test的行。<br>$ grep ‘test’ aa bb cc<br>显示在aa，bb，cc文件中匹配test的行。<br>$ grep ‘[a-z]{5}’ aa<br>显示所有包含每个字符串至少有5个连续小写字符的字符串的行。<br>$ grep ‘w(es)t.</em>\1′ aa<br>如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.<em>)，这些字符后面紧跟着 另外一个es(\1)，找到就显示该行。如果用egrep或grep -E，就不用”\”号进行转义，直接写成’w(es)t.</em>\1′就可以了。</p><blockquote><p>参考文献(<a href="http://www.cnblogs.com/end/archive/2012/02/21/2360965.html" target="_blank" rel="noopener">http://www.cnblogs.com/end/archive/2012/02/21/2360965.html</a>)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>79. Word Search</title>
      <link href="/2017/12/19/leetcode72/"/>
      <url>/2017/12/19/leetcode72/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to convert <em>word1</em> to <em>word2</em>. (each operation is counted as 1 step.)</p><p>You have the following 3 operations permitted on a word:</p><p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>给定两个单词,求两个变成相同的最少步骤.</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = word1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = word2.size();</span><br><span class="line">        <span class="keyword">int</span> dp[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] =i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];<span class="comment">// 十分容易搞错下标</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] =min(dp[i<span class="number">-1</span>][j],min(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = dp[len1][len2];</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果要计算单词”INTENTION”和单词”EXECUTION”之间的编辑距离，那么该怎么计算呢？</p><p>首先，把这个问题简单化。把上面两个单词简化为长度为1的两个单词I和E。</p><p>如果要“I”变化为”E”，可以把”I”替换为”E”<br>如果要“I”变化为空串” “，可以把”I”删除，从而形成””<br>如果要空串“ ”变化为”E”，可以把”E”插入，从而形成E</p><p>上面三种变化分别表示替换，删除，插入这三种基本操作。</p><p>接下来，定义一个表达式D(i,j)。它表示从第1个字单词的第0位至第i位形成的子串和第2个单词的第0位至第j位形成的子串的编辑距离。</p><p>显然，可以计算出动态规划的初始表达式，如下:</p><p>D(i,0) = i</p><p>D(0,j) = j</p><p>然后，考虑动态规划的状态转移方程式，如下:</p><p>​                                   D(i-1, j) + 1<br>D(i,j)=min                  ( D(i, j-1) + 1 )<br>​                                   D(i-1, j-1) +2( if  X(i) != Y(j) ) ; D(i-1,j-1) ( if  X(i) == Y(j) )</p><p>上面的状态转移方程的含义是，D(i,j)的值，要么是D(i-1, j)的操作完成之后删除一个字符(第1个单词的第i个字符)，要么是D(i, j-1)的操作完成之后增加一个字符(第2个单词的第j个字符)，要么是D(i-1, j-1)的操作完成自后替换一个字符(如果第1个单词的第i个字符和第2个单词的第j个字符不等)(<strong>意思是已经知道<code>dp[i-1][j]</code>,现在求<code>dp[i][j]</code>要么把多出来的i 删除,要么补一个j</strong>)，或者是D(i-1, j-1)的操作完成自后什么也不做(如果第1个单词的第i个字符和第2个单词的第j个字符相等)。</p><p>接着便是定义了,这里定义<code>dp[i][j]</code> 为第一个单词 从0到i-1 和第二个单词从0到j-1 的编辑距离.</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/www.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>67. Add Binary</title>
      <link href="/2017/12/18/leetcode67/"/>
      <url>/2017/12/18/leetcode67/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ol><li><p>Given two binary strings, return their sum (also a binary string).</p><p>For example,<br>a = <code>&quot;11&quot;</code><br>b = <code>&quot;1&quot;</code><br>Return <code>&quot;100&quot;</code>.</p></li></ol><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>二进制加法<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sizea = a.size();</span><br><span class="line">        <span class="keyword">int</span> sizeb = b.size();</span><br><span class="line">        <span class="keyword">if</span>(sizea &lt; sizeb)</span><br><span class="line">            <span class="keyword">return</span> addBinary(b, a);</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">zeros</span><span class="params">(sizea-sizeb, <span class="string">'0'</span>)</span></span>;</span><br><span class="line">        b = zeros + b;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sizea<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (a[i]-<span class="string">'0'</span>) + (b[i] - <span class="string">'0'</span>) + carry;</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i] = <span class="string">'1'</span>;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i] = <span class="string">'0'</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="comment">//sum == 3 (1+1+1)</span></span><br><span class="line">                a[i] = <span class="string">'1'</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)</span><br><span class="line">            a = <span class="string">"1"</span> + a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先补齐0,然后相加.</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>43. Multiply Strings</title>
      <link href="/2017/12/18/leetcode43/"/>
      <url>/2017/12/18/leetcode43/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>.</p><p><strong>Note:</strong></p><ol><li>The length of both <code>num1</code> and <code>num2</code> is &lt; 110.</li><li>Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.</li><li>Both <code>num1</code> and <code>num2</code> does not contain any leading zero.</li><li>You <strong>must not use any built-in BigInteger library</strong> or <strong>convert the inputs to integer</strong> directly.</li></ol><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>长字符串相乘.<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = num1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = num2.size();</span><br><span class="line">        <span class="keyword">if</span>(len1==<span class="number">0</span>||len2==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">if</span>(num1==<span class="string">"0"</span>||num2==<span class="string">"0"</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(len1+len2,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                v[i+j] =v[i+j] +(num1[len1-i<span class="number">-1</span>]-<span class="string">'0'</span>) * (num2[len2-j<span class="number">-1</span>]-<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 不管进位的把数存到相应的位置.</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = v[i] + carry;</span><br><span class="line">            v[i] = num % <span class="number">10</span>;</span><br><span class="line">            carry = num / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 处理进位,因为vector足够大,所以最前面的进位也可以直接取,不用特殊处理</span></span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span>  slen =v.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(v[slen]==<span class="number">0</span>) slen--;</span><br><span class="line">      <span class="comment">// 去掉最前面多余的0</span></span><br><span class="line">        <span class="keyword">for</span>( ; slen &gt;= <span class="number">0</span>; slen--)</span><br><span class="line">            s += v[slen] + <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>简单来说,</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/webwxgetmsgimg.jpeg" alt=""></p><p>假设两个整数的长度分别为了l1和l2，则其最后结果长度为l1+l2（最后有进位）或者l1+l2-1（最后没有有进位）。</p><p>因此，可以先用长度为l1+l2的数组记录结果，最后再转成字符串。</p><p>进行乘法的时候，先把各个位的相乘结果对应累加起来，即第1个整数的第i位（低位到高位）和第2个整数的第j位（低位到高位）相乘的结果应该存放在数组的i+j位。</p><p>其次,首先不管进位,直接把得到的值存在相应的位置上,就像</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/webwxgetmsgimg%20%281%29.jpeg" height="30%" width="50%"></p><p>然后再一次性处理进位.</p><p>接着把前面多余的零去掉,然后加到字符串中即可.</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查询性能优化</title>
      <link href="/2017/12/17/%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2017/12/17/%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h1><p>建立索引对高性能来说,必不可少,但这些还不够,还需要合理的设计查询,如果查询写的很糟糕,即使数据库表结构再合理,索引再合适,也无法实现高性能</p><h3 id="为什么查询会慢"><a href="#为什么查询会慢" class="headerlink" title="为什么查询会慢"></a>为什么查询会慢</h3><p>真正重要的是相应时间，如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间，如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数。要么让子任务运行的更快。</p><p>通常来说,查询的生命周期可以按照顺序来看,从客户端,到服务器,然后在服务器上进行解析,生成执行计划,执行,并返回结果给客户端,其中,执行可以认为是整个生命周期中最重要的阶段,这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理,包括排序,分组</p><a id="more"></a><h3 id="慢查询基础-优化数据访问"><a href="#慢查询基础-优化数据访问" class="headerlink" title="慢查询基础:优化数据访问"></a>慢查询基础:优化数据访问</h3><p>查询性能低下最基本的原因是访问的数据太多,某些查询可能不可避免的需要筛选大量数据,但这并不常见,大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化</p><h5 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h5><p>有些查询会请求超过实际需要的数据,然后这些多余的数据会被应用程序丢弃,这会给MySQL服务器带来额外的负担,并增加网络开销,同时也会消耗应用服务器的cpu和内存资源</p><h5 id="MYSQL是否在扫描额外的记录"><a href="#MYSQL是否在扫描额外的记录" class="headerlink" title="MYSQL是否在扫描额外的记录"></a>MYSQL是否在扫描额外的记录</h5><p>在确定查询只返回需要的数据后,接下来应该看看查询为了返回结果是否扫描了过多的数据,对于MySQL,三个简单的衡量开销的指标1相应时间,2扫描的行数,3返回的行数</p><h3 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h3><h5 id="一个复杂查询还是多个简单查询"><a href="#一个复杂查询还是多个简单查询" class="headerlink" title="一个复杂查询还是多个简单查询"></a>一个复杂查询还是多个简单查询</h5><p>是否需要将一个复杂的查询分成多个简单的查询,</p><p>MySQL从设计上让连接和断开连接都很轻量级,在返回一个小的查询结果方面很高效,有时候,将一个大查询分解成多个小查询是很有必要的.</p><h5 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h5><p>有时候对于一个大查询我们需要分而治之,将大查询切分成小查询,每个查询功能完全一样,只完成一部分,每次只返回一小部分查询结果</p><p>删除旧数据就是一个很好的例子,定期的清除大量数据时,如果用一个大的语句一次性完成的话,可能需要一次锁住很多数据,占满整个事务日志,耗尽系统资源,阻塞很多小的但是重要的操作,将一个大的delete语句切分成很多小的,可以尽可能小的印象MySQL性能,还可以减少MySQL复制的延迟.</p><h5 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h5><p>很多高性能的应用都会对关联查询进行分解,简单的,可以对每一个表进行一次单表查询,然后将结果在应用程序中进行关联. 这样做的好处有 <strong>让缓存的效率更高,执行单个查询减少对锁的竞争,在应用层关联,可以更容易对数据库进行拆分,更容易做到高性能和可拓展,查询本身的效率也会有所提升,较少冗余记录的查询</strong></p><h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><p>当向MySQL发送一个请求的时候,MySQL到底做了什么.</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-17%2019-42-49.png" alt=""></p><p>1 客户端发送一条查询给服务器</p><p>2 服务器先检查缓存,如果命中了缓存,则立刻返回存储在缓存中的结果,否则进入下一阶段</p><p>3 服务器端进行sql解析,预处理,再由优化器生成对应的执行计划</p><p>4 MySQL根据优化器生成的执行计划,调用存储引擎的API来执行查询</p><p>5 将结果返回客户端</p><h5 id="MySQL客户端-服务器通信协议"><a href="#MySQL客户端-服务器通信协议" class="headerlink" title="MySQL客户端/服务器通信协议"></a>MySQL客户端/服务器通信协议</h5><p>MySQL客户端和服务器之间的通信协议是<strong>半双工</strong>的,这意味着,在任何一个时刻,要么由客户端向服务端发送数据,要么反过来,这两个动作不能同时发生.</p><p>这种协议让MySQL简单快速,但是也在很多地方限制了MySQL,比如无法进行流量控制.</p><h5 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h5><p>对于一个MySQL连接,任何时刻都有一个状态,该状态表示了MySQL正在做什么,可以使用<code>show full processlist</code> ,常见的状态有</p><ul><li>sleep 线程正在等待客户端发送新的请求</li><li>query 线程正在执行查询或者正在将结果发送给客户端</li><li>locked 在MySQL服务器层,表示正在等待表锁</li><li>analyzing and statistics 线程正在收集存储引擎的统计信息,并生成查询的执行计划</li><li>copying to tmp table 正在执行查询,并将结果复制到一个临时表中</li><li>sorting result 对结果集进行排序</li><li>sending data  线程多个状态之间传送数据</li></ul><h5 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h5><p>在解析一个查询语句前,如果查询缓存是打开的,那么MySQL会优先检查这个查询是否命中查询缓存中的数据,这个检查通过一个对大小写敏感的哈希查找实现的.一个字节不同都不会匹配结果</p><p>命中缓存后还要检查用户权限,如果权限没问题,直接返回缓存中的数据</p><h5 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h5><p>查询的声明周期的下一步是将一个sql转化成一个执行计划,MySQL再按照这个执行计划和存储引擎进行交互,包括多个子阶段,解析sql,预处理,优化SQL执行计划,这个过程中有任何错误都会终止查询.</p><ul><li>语法解析器和预处理</li></ul><p>首先通过关键字将SQL进行解析,生成解析树, 预处理器根据一些SQL规则进一步检查结息树是否合法,下一步会进行验证权限,权限验证通常很快</p><ul><li>查询优化器</li></ul><p>现在的语法树已经合法,将由优化器转化成执行计划,一条查询可以有很多种执行方式,最后都返回相同的结果,优化器的作用就是找出这里面最好的执行计划</p><p>MySQL使用基于成本的优化器,将尝试预测一个查询使用某种执行计划的成本,并选择其中成本最小的一个</p><h5 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h5><p>在解析和优化阶段,MySQL将生成对应的执行计划,MySQL的查询执行引擎则根据这个执行计划来完成整个查询.</p><p>查询执行阶段,只是简单的根据执行计划给出的指令逐步执行,在根据计划逐步执行的过程中,大量操作需要调用存储引擎实现的接口完成,</p><p>存储引擎接口有很丰富的功能,但是底层接口只有几十个,这些接口像搭积木一样能够完成查询的大部分操作.</p><h5 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h5><p>查询执行的最后一步是将结果返回给客户端.即使查询不需要返回结果给客户端,MySQL仍然会返回这个查询的一些信息,如该查询影响的行数.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建高性能的索引</title>
      <link href="/2017/12/17/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
      <url>/2017/12/17/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="创建高性能的索引"><a href="#创建高性能的索引" class="headerlink" title="创建高性能的索引"></a>创建高性能的索引</h1><p>在数据之外,数据库系统还维护着特定结构,这些数据结构以某种方式引用指向数据,这样就可以在这些数据结构上实现高级查找算法,这种数据结构,就是索引.</p><p>索引在MySQL中也叫做键,是存储引擎用于快速找到记录的一种数据结构,这是索引的基本功能</p><p>索引对于良好的性能十分关键,尤其是当表中的数据量越来越大时,索引对性能的影响越来越大.</p><p>索引优化是对查询性能优化最有效的手段了,索引能够轻易将查询性能提高好几个数量级.</p><h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><p>在MySQL中,现在索引中找到对应值,然后根据匹配的索引记录找到对应的数据行</p><p>索引可以包含一个或者多个列的值,如果索引包含多个列,列的顺序也十分重要,因为MySQL只能高效的使用索引的最左前缀列.</p><a id="more"></a><h4 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h4><p>索引有很多类型,可以在不同的场景提供更好的性能,在MySQL中,索引是<strong>存储引擎层</strong>而不是在服务层实现的,不同存储引擎的索引的工作方式也不一样,也不是所有的存储引擎都支持所有类型的索引,即使多个存储因剧情支持同一种类型的索引,其底层的实现也可能不同.</p><h5 id="B-tree-索引"><a href="#B-tree-索引" class="headerlink" title="Ｂ-tree 索引"></a>Ｂ-tree 索引</h5><p>默认的索引类型，很多存储引擎使用Ｂ+树来存储数据</p><p>存储引擎以不同的方式使用Ｂ-tree索引，性能也各有不同，各有优劣，例如MyISAM 使用前缀压缩技术使索引更小,但InnoDB则按照原数据格式进行存储,再如MYISAM索引通过数据的物理位置引用被索引的行,而InnoDB则根据主键引用被索引的行.</p><p>B-Tree 通常意味着所有的值按顺序存储,并且每一个叶子页到根的距离相同,</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-17%2010-49-24.png" alt=""></p><p>B-Tree索引能够加快访问数据的速度,因为存储引擎不需要进行全表扫描来获取需要的数据,取而代之的是从索引的根节点开始进行搜索,根节点的槽中存放了指向子节点的指针,存储引擎根据这些指针向下层查找,通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点,这些指针实际定义了子节点页中值的上限和下限,<strong>叶子节点比较特殊,他们的指针指向的是被索引的数据,而不是其他的节点页,</strong></p><font color="red"> B-Tree 对索引列是顺序组织存储的,索引适合查找范围数据*(虽然实际存储顺序不是顺序的,但是索引的底层实现可以看成是顺序的,所以用b_tree索引就可以顺序的找了)</font><p><strong>可以使用B-Tree 索引的查询类型有</strong></p><ul><li>全值匹配,即对索引中的所有列进行匹配</li><li>匹配最左前缀, 即只使用索引的第一列</li><li>匹配列前缀 即只匹配某一列的值的开头部分</li><li>匹配范围值</li><li>精确匹配某一列并范围匹配另外一列</li></ul><p>因为索引数的节点是有序的,所以除了按值查找外,索引还可以用于查询中的Orderby 操作</p><p><strong>B-Tree 索引的限制</strong></p><ul><li>如果不是按照索引的最左列开始查找,则无法使用索引</li><li>不能跳过索引中的列,也就是姓 ,名,生日的三行索引,这种索引不能找姓为XX 生日为XX的人,因为没有指定名.</li><li>如果查询中有某个列的范围查找</li></ul><p>有些限制不是B_tree本身导致的,而是MYSQL优化器和存储引擎使用索引的方式导致的.</p><h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><p>哈希索引基于哈希表实现,只有精确匹配索引所有列的查询才有效,对于每一行数据,存储引擎会对所有的索引列计算一个哈希码, 哈希码是一个较小的值,并且不同键值的行计算出来的哈希码也不一样,哈希索引将所有的哈希码存储在索引中,同时在哈希表中保存指向每个数据行的指针.</p><p>如果多个列的哈希值一样,索引会以链表的方式存放多个记录指针到同一个哈希条目中.</p><p>因为索引自身只需存储对应的哈希值,所以索引的结构十分紧凑,也让哈希索引查找的速度十分快。</p><p>哈希索引的限制在于</p><ul><li><strong>哈希索引只包含哈希值和行指针,而不存储字段值</strong>,所以不能使用索引中的值来避免读取行.</li><li>哈希索引数据不是按照索引值顺序存储的,所以也就无法用于排序</li><li>哈希索引也不支持部分索引列匹配查找</li><li>哈希索引只支持等值比较查询</li><li>访问哈希索引的数据非常快,除非有很多哈希冲突</li></ul><p>所以,一旦适合哈希索引的话,带来的性能提升会十分的明显</p><p><em>InnoDB 引擎有”自适应哈希索引,当InnoDB注意到某些索引值被使用的十分频繁时,会在内存中基于B-tree 索引之上再创建一个哈希索引,这样也让B-tree索引有了哈希索引的一些优点.,比如快速的查找.这是一个完全自动,内部的行为,用户无法控制或者配置,,用户可以关闭此功能”</em></p><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p>最常见的B-Tree 索引，按照顺序存储数据，所以MYSQL 可以用来做ORDER BY 和GROUP BY 操作，因为数据是有序的，所以Btree 也就会将相关的列值都存储在一起，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。</p><ul><li>索引大大减少了服务器需要扫描的数据量</li><li>索引可以帮助服务器避免排序和临时表</li><li>索引可以将随机IO变为顺序IO</li></ul><h2 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h2><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p><p><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/8.png" alt="img"></p><p>图8</p><p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p><p><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/9.png" alt="img"></p><p>图9</p><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h2 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h2><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/10.png" alt="img"></p><p>图10</p><p>图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：</p><p><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/11.png" alt="img"></p><p>图11</p><p>这里以英文字符的ASCII码作为比较准则。<strong>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</strong></p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>索引分为聚簇索引和非聚簇索引。</p><p>根据数据库的功能，有三种索引，分别是唯一索引，主键索引 和聚集索引。</p><p>唯一索引是不允许其中任何两行具有相同索引值的索引，当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。</p><p>主键索引 主键索引和唯一索引的特定类型，该索引要求主键中的每个值都唯一。</p><p>聚集索引 即聚簇索引。</p><h3 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>独立的列指的是索引列不能是表达式的一部分,也不能是函数的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select actor_id from actor where actor_id +1 =5</span><br></pre></td></tr></table></figure><p>上面的查询就不能使用索引,因为MySQL无法解析这个方程式,索引应该简化where条件</p><p>始终将索引列单独放在比较符号的一侧</p><h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>通常可以索引开始的部分字符,这样可以大大的节约索引的空间,从而提高索引效率,但是这样也会降低索引的选择性.</p><p>对于BLOB,TEXT 或者更长的VARCHAR类型的列,<strong>必须使用前缀索引</strong>,因为MySQL不允许索引这些列的完整长度。</p><h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>将where条件的所有列都建立索引这种话是非常错误的,在多个列上单独建立独立的单列索引大部分情况下并不会提高MySQL的查询性能</p><h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><p>正确的顺序依赖于使用该索引的查询,并且同时需要考虑如何更好的满足排序和分组的需要,在一个多行的B-tree索引中,索引列的顺序意味着索引首先按照最左列进行排序,其次是第二列.</p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引不是一种单独的索引类型,而是一种数据存储方式,具体的细节依赖于其实现方式,但是InnoDB的聚簇索引实际上在同一个结构中保存了BTree索引和数据行</p><p>术语聚簇表示数据行和相邻的键值紧凑的存储在一起，因为无法同时把数据行存放在两个不同的地方，所以一个表只能由一个聚簇索引。</p><p>聚簇索引也称为聚集索引，聚类索引，簇集索引，聚簇索引确定表中数据的物理顺序。聚簇索引类似于电话簿，后者按姓氏排列数据。由于聚簇索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚簇索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。汉语字典也是聚簇索引的典型应用，在汉语字典里，索引项是字母+声调，字典正文也是按照先字母再声调的顺序排列。</p><p><strong>聚集索引是根据数据行的键值在表中排序存储数据行。索引定义中包含聚集索引列。每个表只能有一个聚集索引。只有当表包含聚集索引时，表中的数据行才按排序顺序存储。如果表具有聚集索引，则该表称为聚集表。集索引决定了表数据的存储顺序,如果表没有聚集索引，则其数据行存储在一个称为堆的无序结构中。</strong></p><p>也就是说,聚簇索引会按照主键值重新在磁盘中对数据进行排序,这样磁盘中的物理数据也是有序的了.</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-17%2015-33-47.png" alt=""></p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-17%2015-38-55.png" alt=""></p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>设计优秀的索引应该考虑到整个查询，而不单单是where条件部分。MYSQL可以使用索引来直接获取列的数据，这样就不再需要读取数据行。</p><p>如果一个索引包含(或者说覆盖)所有需要查询的字段的值,我们就成为覆盖索引</p><p>不是所有类型的索引都可以成为覆盖索引,覆盖索引必须要存储索引列的值,而哈希索引,空间索引,和全文索引等都不存储索引列的值,索引MySQL只能使用Btree索引做覆盖索引.</p><h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><p>MySQL有两种方式可以生成有序的结果,通过排序操作,或者按索引顺序扫描,如果EXPLAIN出来的type 列的值为index,则说明MySQL使用了索引扫描来做排序.</p><h4 id="压缩-前缀压缩-索引"><a href="#压缩-前缀压缩-索引" class="headerlink" title="压缩(前缀压缩)索引"></a>压缩(前缀压缩)索引</h4><p>MyISAM 使用前缀压缩来减少索引的大小,从而让更多的索引可以放入内存中,这在某些情况下能极大的提高性能,默认只压缩字符串,但是通过参数设置也可以对整数做压缩。</p><p>MYISAM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。例如，索引块中的第一个值是“perform”，第二个值是“performance”，那么第二个值的前缀压缩后存储的是类似“7,ance”这样的形式，MYISAM对行指针也采用类似的前缀压缩方式。</p><p>压缩块使用更少的空间，代价是某些操作可能更慢，因为每个值的压缩前缀都依赖前面的值，所以MYISAM查找时无法在索引块使用二分查找而只能从头开始扫描，</p><h4 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h4><p>MYSQL允许在相同列上创建多个索引,无论有意还是无意的,MySQL需要单独维护重复的索引,并且优化器在优化查询的时候也需要逐个的进行考虑,这会影响性能</p><p>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引,应该避免这样创建重复索引,发现也应该立即移除.</p><p>冗余索引与重复索引有一些不同，如果创建了索引(A,B)，再创建索引(A)就是冗余索引，因为这是前一个索引的前缀索引。</p><h4 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h4><p>索引可以让查询锁定更少的行，如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，</p><p>InnoDB只有在访问行的时候才会对其加锁,而索引能够减少InnoDB访问的行数,从而减少锁的数量</p><blockquote><p>&lt;高性能MySQL&gt;</p><p>blog.csdn.net/a724888/article/details/68936953</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 优化指南</title>
      <link href="/2017/12/14/Mysql-%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/"/>
      <url>/2017/12/14/Mysql-%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><h4 id="SQL优化的一般步骤"><a href="#SQL优化的一般步骤" class="headerlink" title="SQL优化的一般步骤"></a>SQL优化的一般步骤</h4><h5 id="通过-show-status-和应用特点了解各种-SQL-的执行频率"><a href="#通过-show-status-和应用特点了解各种-SQL-的执行频率" class="headerlink" title="通过 show status 和应用特点了解各种 SQL 的执行频率"></a>通过 show status 和应用特点了解各种 SQL 的执行频率</h5><p>通过show status可以提供服务器状态信息,show status可以根据需要显式session级别的统计结果和global 级别的统计结果.</p><a id="more"></a><h5 id="定位执行效率较低的SQL语句"><a href="#定位执行效率较低的SQL语句" class="headerlink" title="定位执行效率较低的SQL语句"></a>定位执行效率较低的SQL语句</h5><p>可以通过以下两种方式定位执行效率地的sql语句,</p><ul><li>通过慢查询日志定位那些优化效率较低的sql语句…但是慢查询日志在查询结束后才记录,所以在应用反应执行效率出现问题的时候查询慢查询日志并不能定位问题.</li><li>使用show processlist 命令查看当前MYSQL在运行的线程,包括线程的状态,是否锁表等等,可以实时查看SQL执行情况</li></ul><h5 id="通过explain-分析低效SQL的执行计划"><a href="#通过explain-分析低效SQL的执行计划" class="headerlink" title="通过explain 分析低效SQL的执行计划:"></a>通过explain 分析低效SQL的执行计划:</h5><p>通过以上步骤查询到效率低的 SQL 后,我们可以通过 explain 或者 desc 获取MySQL 如何执行 SELECT 语句的信息,包括 select 语句执行过程表如何连接和连接的次序。explain 可以知道什么时候必须为表加入索引以得到一个使用索引来寻找记录的更快的 SELECT。</p><h5 id="确定问题-采取相应的优化措施"><a href="#确定问题-采取相应的优化措施" class="headerlink" title="确定问题,采取相应的优化措施"></a>确定问题,采取相应的优化措施</h5><p>通过以上步骤查询到效率低的 SQL 后,我们可以通过 explain 或者 desc 获取MySQL 如何执行 SELECT 语句的信息,包括 select 语句执行过程表如何连接和连接的次序。</p><h4 id="索引问题"><a href="#索引问题" class="headerlink" title="索引问题"></a>索引问题</h4><h5 id="索引的存储分类"><a href="#索引的存储分类" class="headerlink" title="索引的存储分类"></a>索引的存储分类</h5><p>myisam 表的数据文件和索引文件是自动分开的,innoDB的数据和索引是存储在同一个表空间里面的,但是可以有多个文件组成.</p><p>索引的语法:</p><p>创建索引: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE  [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING index_type] </span><br><span class="line">ON tbl_name (index_col_name,...)</span><br><span class="line">index_col_name的格式:  col_name [(length)][ASC | DESC]</span><br></pre></td></tr></table></figure><p>索引的存储类型目前只有两种(btree和hash) ,具体和表的模式有关.</p><p>myisam -&gt;btree </p><p>innoDB -&gt;btree</p><p>memory/heap -&gt; hash btree</p><h5 id="mysql-如何使用索引"><a href="#mysql-如何使用索引" class="headerlink" title="mysql 如何使用索引"></a>mysql 如何使用索引</h5><p>索引用于快速找出在某个列中有某一特定值的行,对相关列使用索引是提高select操作性能的最佳途径.</p><p>下列情况中,MySQL不会使用已有的索引</p><p>1 如果MySQL估计使用索引比全表扫描更慢,则不会使用索引.</p><p>2 如果使用 heap 表并且 where 条件中不用=索引列,其他&gt; 、&lt;、 &gt;=、 &lt;=均不使用索引</p><p>3 如果不是索引列的第一部分</p><p>4 如果like 是以% 开始</p><p>5 对 where 后边条件为字符串的一定要加引号,字符串如果为数字 mysql 会自动转为字符串,但是不使用        索引。</p><h5 id="查看索引使用情况"><a href="#查看索引使用情况" class="headerlink" title="查看索引使用情况"></a>查看索引使用情况</h5><p>如果索引正在工作,Handler_read_key 的值将很高,这个值代表了一个行被索引值读的次数,很低的值表明增加索引得到的性能改善不高,因为索引并不经常使用 。<br>Handler_read_rnd_next 的值高则意味着查询运行低效,并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果你正进行大量的表扫描,该值较高。通常说明表索引不正确或写入的查询没有利用索引。</p><h3 id="两个简单实用优化方法"><a href="#两个简单实用优化方法" class="headerlink" title="两个简单实用优化方法"></a>两个简单实用优化方法</h3><h5 id="定期分析表"><a href="#定期分析表" class="headerlink" title="定期分析表"></a>定期分析表</h5><p>ANALYZE TABLE</p><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><p>本语句用于分析和存储表的关键字分布。在分析期间,使用一个读取锁定对表进行锁定。这对于 MyISAM, BDB 和 InnoDB 表有作用。对于 MyISAM 表,本语句与使用 myisamchk -a 相当。</p><p>CHECK TABLE</p><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br></pre></td></tr></table></figure><p>检查一个或多个表是否有错误。CHECK TABLE 对 MyISAM 和 InnoDB 表有作用。对于MyISAM 表,关键字统计数据被更新。CHECK TABLE 也可以检查视图是否有错误,比如在视图定义中被引用的表已不存在。</p><p>CHECKSUM TABLE</p><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHECKSUM TABLE tbl_name [, tbl_name] ... [ QUICK | EXTENDED ]</span><br></pre></td></tr></table></figure><p>报告一个表校验和。</p><h5 id="优化表"><a href="#优化表" class="headerlink" title="优化表"></a>优化表</h5><p>OPTIMIZE TABLE</p><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><p>如果已经删除了表的一大部分,或者如果您已经对含有可变长度行的表(含有VARCHAR, BLOB 或 TEXT 列的表)进行了很多更改,则应使用 OPTIMIZE TABLE。被删除的记录被保持在链接清单中,后续的 INSERT 操作会重新使用旧的记录位置。您可以使用 OPTIMIZE TABLE 来重新利用未使用的空间,并整理数据文件的碎片。OPTIMIZE TABLE 只对 MyISAM, BDB 和 InnoDB 表起作用。</p><h3 id="常用SQL优化"><a href="#常用SQL优化" class="headerlink" title="常用SQL优化"></a>常用SQL优化</h3><h5 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h5><p>1因为 Innodb 类型的表是按照主键的顺序保存的,所以将导入的数据按照主键的顺序排列,可以有效的提高导入数据的效率。如果 Innodb 表没有主键,那么系统会默认创建一个内部列作为主键,所以如果可以给表创建一个主键,将可以利用这个优势提高导入数据的效率。</p><p>2在导入数据前执行 SET UNIQUE_CHECKS=0,关闭唯一性校验,在导入结束后执行 SET UNIQUE_CHECKS=1,恢复唯一性校验,可以提高导入的效率。</p><p>3 如果应用使用自动提交的方式,建议在导入前执行 SET AUTOCOMMIT=0,关闭自动提交,导入结束后再执行 SET AUTOCOMMIT=1,打开自动提交,也可以提高导入的效率。</p><h5 id="insert优化"><a href="#insert优化" class="headerlink" title="insert优化"></a>insert优化</h5><p>1如果你同时从同一客户插入很多行,使用多个值表的 INSERT 语句。这比使用分开INSERT 语句快。</p><p>2如果你从不同客户插入很多行,能通过使用 INSERT DELAYED 语句得到更高的速度。Delayed 的含义是让 insert 语句马上执行,其实数据都被放在内存的队列中,并没有真正写入磁盘;这比每条语句分别插入要快的多;</p><p>3将索引文件和数据文件分在不同的磁盘上存放(利用建表中的选项);</p><p>4 如果进行批量插入,可以增加 bulk_insert_buffer_size 变量值的方法来提高速度,但是,这只能对 myisam 表使用;</p><p>5 当从一个文本文件装载一个表时,使用 LOAD DATA INFILE。这通常比使用很多INSERT 语句快 20 倍;</p><p>6 根据应用情况使用 replace 语句代替 insert;</p><p>7 根据应用情况使用 ignore 关键字忽略重复记录。</p><h5 id="group-by-优化"><a href="#group-by-优化" class="headerlink" title="group by 优化"></a>group by 优化</h5><p>默认情况下group by 会先进行排序, 如果查询包括 GROUP BY 但你想要避免排序结果的消耗,你可以指定 ORDER BY NULL 禁止排序。</p><h5 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h5><p>在某些情况中,MySQL 可以使用一个索引来满足 ORDER BY 子句,而不需要额外的排序 。where 条件和 order by 使用相同的索引,并且 order by 的顺序和索引顺序相同 ,并且 order by 的字段都是升序或者都是降序。</p><h5 id="join-优化"><a href="#join-优化" class="headerlink" title="join 优化"></a>join 优化</h5><p>子查询可以被更有效率的连接(JOIN)替代。</p><p>连接(JOIN).. 之所以更有效率一些,是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><h5 id="or-优化"><a href="#or-优化" class="headerlink" title="or 优化"></a>or 优化</h5><p>对于 or 子句,如果要利用索引,则 or 之间的每个条件列都必须用到索引;如果没有索引,则应该考虑增加索引。</p><h5 id="查询优先还是更新优先"><a href="#查询优先还是更新优先" class="headerlink" title="查询优先还是更新优先"></a>查询优先还是更新优先</h5><p>MySQL 还允许改变语句调度的优先级,它可以使来自多个客户端的查询更好地协作,这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。</p><h5 id="其他优化措施"><a href="#其他优化措施" class="headerlink" title="其他优化措施"></a>其他优化措施</h5><p>1 使用持久的连接数据库以避免连接开销。</p><p>2 经常检查所有查询确实使用了必要的索引。</p><p>3 避免在频繁更新的表上执行复杂的 SELECT 查询,以避免与锁定表有关的由于读、写冲突发生的问题。</p><p>4 对于没有删除的行操作的 MyISAM 表,插入操作和查询操作可以并行进行,因为没有删除操作的表查询期间不会阻塞插入操作.对于确实需要执行删除操作的表,尽量在空闲时间进行批量删除操作,避免阻塞其他操作。</p><p>5.充分利用列有默认值的事实。只有当插入的值不同于默认值时,才明确地插入值。这减少 MySQL 需要做的语法分析从而提高插入速度。</p><p>6.对经常访问的可以重构的数据使用内存表,可以显著提高访问的效率。</p><p>7.通过复制可以提高某些操作的性能。可以在复制服务器中分布客户的检索以均分负载。为了防止备份期间对应用的影响,可以在复制服务器上执行备份操作.</p><p>8,表的字段尽量不使用自增长变量,在高并发情况下该字段的自增可能对效率有比较大的影响,推荐通过应用来实现字段的自增长。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 序列化与反序列化</title>
      <link href="/2017/12/12/Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2017/12/12/Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-序列化与反序列化"><a href="#Java-序列化与反序列化" class="headerlink" title="Java 序列化与反序列化"></a>Java 序列化与反序列化</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>Java序列化</strong>是指把Java对象转换为字节序列的过程；而<strong>Java反序列化</strong>是指把字节序列恢复为Java对象的过程。</p><h3 id="序列化的原因"><a href="#序列化的原因" class="headerlink" title="序列化的原因"></a>序列化的原因</h3><p>两个进程远程通信时,可以相互发送各种类型的数据,包括文本,图片,音频,视频,这些数据都会以二进制序列的形式在网络上传送.,那么当两个Java进程通信时,如何实现进程间的对象传送呢?答案就是序列化与反序列化. 换句话说，一方面，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。</p><a id="more"></a><h3 id="序列化的好处"><a href="#序列化的好处" class="headerlink" title="序列化的好处"></a>序列化的好处</h3><p>好处一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上，好处二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p><code>java.io.ObjectOutputStream：表示对象输出流</code></p><p>它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p><p><code>java.io.ObjectInputStream：表示对象输入流</code></p><p>它的readObject()方法从输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回。</p><p><strong>只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常。</strong></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Java序列化序列化对象的信息包括：类元数据描述、类的属性、父类信息以及属性域的值。Java将这些信息分成3部分：序列化头信息、类的描述部分以及属性域的值部分。</p><p>java序列化算法的基本步骤：<br>a)输出序列化的头部信息，包括标识序列化协议的幻数以及协议的版本；<br>b)按照由子类到父类的顺序，递归的输出类的描述信息，直到不再有父类为止；类描述信息按照类元数据，类属性信息的顺序写入序列化流中；<br>c)按照由父类到子类的顺序，递归的输出对象域的实际数据值；而对象的属性信息是按照基本数据类型到java对象类型的顺序写入序列化流中；其中java对象类型的属性会从步骤a)重新开始递归的输出，直到不再存在java对象类型的属性。 </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49. Group Anagrams</title>
      <link href="/2017/12/11/leetcode49/"/>
      <url>/2017/12/11/leetcode49/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given an array of strings, group anagrams together.</p><p>For example, given: <code>[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code>,<br>Return:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>找出字符相同的所有字符串,归为一组.<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = strs.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; maps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s =strs[i];</span><br><span class="line">            sort(s.begin(),s.end());</span><br><span class="line">            maps[s].push_back(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt;::iterator iter = maps.begin(); iter != maps.end(); iter++)</span><br><span class="line">            res.push_back(iter-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>穷举会超时,所以这道题要使用哈希表,每个字符串的每个单词进行排序,排序完成后放到相应的map中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java 版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] ca = s.toCharArray();</span><br><span class="line">            Arrays.sort(ca);</span><br><span class="line">            String keyStr = String.valueOf(ca);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(keyStr)) map.put(keyStr, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            map.get(keyStr).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32. Longest Valid Parentheses</title>
      <link href="/2017/12/11/leetcode32/"/>
      <url>/2017/12/11/leetcode32/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</p><p>For <code>&quot;(()&quot;</code>, the longest valid parentheses substring is <code>&quot;()&quot;</code>, which has length = 2.</p><p>Another example is <code>&quot;)()())&quot;</code>, where the longest valid parentheses substring is <code>&quot;()()&quot;</code>, which has length = 4.</p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>找到可以匹配的最长的括号串.<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len =s.size();</span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>) st.push(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(st.size()==<span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    last = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    st.pop();</span><br><span class="line">                    <span class="keyword">if</span>(st.size()==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res =max(res,i-last);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        res=max(res,i-st.top());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>栈中保存的不是字符（而是字符（所在的下标。<br>如果遇到字符（，无条件压入栈中；<br>如果遇到字符），并且栈为空，说明这是一个无法匹配的字符），用变量last记录下标。last存放的其实是最后一个无法匹配的字符）。<br>如果遇到字符），并且栈不为空，我们可以消除一对括号（栈顶元素出栈）。</p><ul><li>如果栈为空，用当前元素下标i 减去 last计算有效长度；</li><li>如果栈不为空，用当前元素下标i 减去 栈顶元素下标计算有效长度；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22. Generate Parentheses</title>
      <link href="/2017/12/10/leetcode22/"/>
      <url>/2017/12/10/leetcode22/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given <em>n</em> = 3, a solution set is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一个数,输出所有的能匹配的结果.</p><a id="more"></a><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;  </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;     </span><br><span class="line">        DFS(s,n,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> zuo,<span class="keyword">int</span> you)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(you&lt;zuo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(you==<span class="number">0</span> &amp;&amp; zuo==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(zuo&gt;<span class="number">0</span>)   DFS(s+<span class="string">'('</span>,zuo<span class="number">-1</span>,you);  <span class="comment">//!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">        <span class="keyword">if</span>(you&gt;<span class="number">0</span>)   DFS(s+<span class="string">')'</span>,zuo,you<span class="number">-1</span>);  <span class="comment">// !!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>自己写的解法,首先看到求所有可能的值,想到用深度优先算法,</p><p>设置zuo ,you 两个指针,初始值为n,也就是有多少个,每次用一个就减一次.</p><p><strong>和以往的DFS不同的地方在于DFS递归是有条件的递归,也就是个数是有限的,</strong></p><p>感叹号的地方,不是每一次都要进行递归,而是满足条件才进行递归,</p><p>(和死胡同的区别,DFS中最开始两个if语句表示进入到这个胡同中,判断是不是符合的解,</p><p>这里感叹号的if表示的是没有这个胡同,但是程序不知道,你要告诉程序没有这个胡同)</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 命令基础</title>
      <link href="/2017/12/09/Redis(Remote%20Dictionary%20Server)/"/>
      <url>/2017/12/09/Redis(Remote%20Dictionary%20Server)/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-Remote-Dictionary-Server"><a href="#Redis-Remote-Dictionary-Server" class="headerlink" title="Redis(Remote Dictionary Server)"></a>Redis(Remote Dictionary Server)</h1><p>redis 的可执行文件有</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis 服务器</span><br><span class="line">redis-cli redis 命令行客户端</span><br><span class="line">redis-benchmark redis 性能测试工具</span><br><span class="line">redis-check-aof  aof文件修复工具</span><br><span class="line">redis-check-dump rdb 文件检查工具</span><br><span class="line">启动redis 即运行redis-server.</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h4><h5 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h5><p>直接运行 redis-server 即可启动redis. redis 服务器默认使用6379端口。</p><p>通过 –port 参数可以自定义端口号。</p><h5 id="初始化脚本启动redis"><a href="#初始化脚本启动redis" class="headerlink" title="初始化脚本启动redis"></a>初始化脚本启动redis</h5><p>停止redis</p><p>强行终止redis 进程可能导致数据丢失</p><p>应该使用命令 redis-cli SHUTDOWN。当 redis 收到shutdown 命令后，会先断开所有客户端连接，然后根据配置执行持久化。最后完成退出。</p><h4 id="redis-命令行客户端"><a href="#redis-命令行客户端" class="headerlink" title="redis 命令行客户端"></a>redis 命令行客户端</h4><h5 id="发送命令"><a href="#发送命令" class="headerlink" title="发送命令"></a>发送命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line">不带参数的执行</span><br><span class="line">redis-cli 会进入交互模式，可以自由输入命令</span><br></pre></td></tr></table></figure><h4 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h4><p>一个redis实例提供了多个用来存储数据的字典，客户端可以指定讲数据存储在哪个字典中，每一个字典相当于一个独立的数据库。</p><p>每个数据库对外都是以一个从0开始的递增数字命名，redis 默认支持16个数据库。客户端与redis 建立连接后会自动选择0号数据库，不过随时可以使用select 命令更换数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> select 1</span><br><span class="line">OK</span><br><span class="line">redis[1] &gt; GET foo</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>redis 不支持自定义数据库的名字，每个数据库都以编号命名，开发者自己记录每个数据库里有哪些数据，多个数据库之间也不是完全隔离的。不同的应用应该使用不同的redis 实例存储数据。一个空的redis 实例占用1 MB 左右。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>1 获得符合规则的键名列表    KEYS pattern </p><p>pattern 支持glob 风格通配符。比如 KEYS *  获得所有的键。</p><p>2.判断键的存在性 EXISTS key 存在返回1 否则 0</p><p>3.删除键 DEL key</p><p>4 TYPE key 获得键值的数据类型</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>可以存储任何形式字符串，包括了二进制数据。可以用其存储用户的邮箱，JSON化的对象甚至一张图片。</p><p>1 赋值与取值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br><span class="line">GET key</span><br></pre></td></tr></table></figure><p>2 递增数字 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br></pre></td></tr></table></figure><p>当存储的字符串是整数形式时，INCR 使当前 <strong>键值</strong>  递增，并返回增加后的值。</p><p>3 增加指定的整数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INCRBY key increment</span><br><span class="line"><span class="meta">redis&gt;</span> INCRBY bar 2</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">redis&gt;</span> INCRBY bar 3</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><p>4减少指定的整数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECR key</span><br></pre></td></tr></table></figure><p>5 增加指定浮点数 INCRBYFLOAT key increment</p><p>6 向尾部追加值  append key value   append的作用时向键值的末尾追加value，如果键不存在就将该键的值设置为value。</p><p>7 获取字符串长度 STRLEN key（返回键值的长度）</p><p>8 同时获得/设置多个键值 MGET key1 key2/MSET key1 v1 key2 v2</p><h4 id="散列类型"><a href="#散列类型" class="headerlink" title="散列类型"></a>散列类型</h4><p>散列类型的键值也是一种字典结构。其中存储了字段和字段值的映射。 但是字段值只能是字符串。不支持其它数据类型。散列类型适合存储对象，使用对象类别和ID构成键名，使用字段表示对象的属性，而字段值则存储属性值。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/101601.png" alt="12"></p><p>1 赋值与取值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value</span><br><span class="line">HGET key field</span><br><span class="line"><span class="meta">redis&gt;</span> HSET car price 400</span><br><span class="line">(integer)1</span><br><span class="line"><span class="meta">redis&gt;</span>HSET car name BMW</span><br><span class="line">(integer)1</span><br><span class="line"><span class="meta">redis&gt;</span>HGET car name</span><br><span class="line">"BMW"</span><br></pre></td></tr></table></figure><p>HSET 不区分插入和更新操作，所以不用事先对存在性进行判断。插入时，返回 1 更新时，返回0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// HMSET 设置多个值</span><br><span class="line"><span class="meta">redis&gt;</span>HMSET key field1 value1 field2 value2</span><br><span class="line">//HMGET 获取多个值</span><br><span class="line"><span class="meta">redis&gt;</span>HMGET car price name</span><br><span class="line">1) "500"</span><br><span class="line">2) "BMW"</span><br></pre></td></tr></table></figure><p>2 判断字段是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field //存在返回 1 否则返回0 键不存在也返回0</span><br></pre></td></tr></table></figure><p>3 字段不存在时赋值 （存在时不执行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key field value</span><br></pre></td></tr></table></figure><p>4 增加数字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment//字段值增加指定整数</span><br></pre></td></tr></table></figure><p>5 删除字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field</span><br></pre></td></tr></table></figure><p>6 只获取字段名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br></pre></td></tr></table></figure><p>7 只获取字段值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HVALS key</span><br></pre></td></tr></table></figure><p>8 获取字段数量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN key</span><br></pre></td></tr></table></figure><p>9 获取所有field</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br></pre></td></tr></table></figure><p>10 获取所有value</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hvals key</span><br></pre></td></tr></table></figure><h4 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h4><p>列表类型可以存储一个有序的字符串列表，常用操作时向列表两端添加元素，或者获得列表的某一个片段。</p><p>列表类型内部使用双向链表实现，</p><p>1.向列表两端添加元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key value//向列表左边添加元素，返回值表示添加元素后元素的长度。</span><br><span class="line">RPUSH key value// 向右边添加元素。两个命令都支持添加多个命令。</span><br></pre></td></tr></table></figure><p>2.向列表两端弹出元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPOP key//返回被移除的元素值。</span><br><span class="line">RPOP key</span><br></pre></td></tr></table></figure><p>3.获取列表中元素个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key //复杂度o(1) 会直接读取现成的值。</span><br></pre></td></tr></table></figure><p>4 获取列表片段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop//start 和 stop都是索引。从0开始</span><br></pre></td></tr></table></figure><p>5 删除列表中指定的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LREM key count value// 删除前count个值为value的元素。</span><br><span class="line"><span class="meta">count&gt;</span>0 从左边开始删除前count个值为value的元素。</span><br><span class="line">count&lt;0 从右边开始删除。</span><br><span class="line">count=0 删除所有值为value的元素。</span><br></pre></td></tr></table></figure><p>6.获得/设置指定索引的元素值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index</span><br><span class="line">LSET key index value</span><br></pre></td></tr></table></figure><p>如果要将列表类型当数组用，LINDEX命令不可少，LINDEX命令用来返回指定索引的元素。</p><p>7 只保留列表指定片段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTRIM key start end</span><br></pre></td></tr></table></figure><p>8 向列表插入元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key BEFORE|AFTER pivot value</span><br></pre></td></tr></table></figure><p>首先会在列表中从左到右查找值为pivot的元素，然后根据BEFORE|BEFER 来决定将 value 插前面还是后面。</p><p>9 将元素从一个列表移到另一个列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOPLPUSH source destination</span><br></pre></td></tr></table></figure><p><strong>10. 阻塞式弹出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blpop key timeout</span><br><span class="line">brpop key timeout</span><br></pre></td></tr></table></figure><h4 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h4><p>集合中每个元素时不同的，且没有顺序。一个集合类型键可以存储之多2^32-1个字符串。集合类型在redis内部时使用值为空的散列表实现的。</p><p>1.增加/删除元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SADD key member</span><br><span class="line"><span class="meta">redis&gt;</span> SADD letters a</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">redis&gt;</span> SADD letters a b c</span><br><span class="line">(integer) 2</span><br><span class="line">SREM key member 删除元素</span><br></pre></td></tr></table></figure><p>SADD 命令用来向集合中增加一个或多个元素，键不存在则会自动创建。</p><p>2 获得集合中所有的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><p>3 判断元素是否在集合中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><p>4 集合间运算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key1 key2 差集/SINTER key1 key2 交集运算/SUNION key1 key2并集运算</span><br></pre></td></tr></table></figure><p>5 获得集合中元素个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></table></figure><p>6 进行集合运算并将结构存储</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE destination key</span><br><span class="line">SINTERSTORE destination key</span><br><span class="line">SUNIONSTORE destination key 结果存储在destination 中</span><br></pre></td></tr></table></figure><p>7 随机获得集合中一个元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key</span><br></pre></td></tr></table></figure><p>8 从集合中弹出一个元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP key</span><br></pre></td></tr></table></figure><h4 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h4><p>在集合类型的基础上为集合中的每个元素关联了一个分数，虽然集合中每个元素时不同的，但是他们的分数可以相同。</p><p>1 增加元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score member</span><br></pre></td></tr></table></figure><p>ZADD 命令向有序集合中加入一个元素和该元素的分数，返回新加入到集合的元素个数。</p><p>2 获得元素的分数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></table></figure><p>3 获得排名在某个范围的元素列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop// start stop 都是索引</span><br></pre></td></tr></table></figure><p>zrange 命令会按照元素分数从小到大的顺序返回索引从start到stop之间的所有的元素</p><p>4 获得指定分数范围的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max</span><br></pre></td></tr></table></figure><p>5 增加某个元素的分数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure><p>6 获得集合中元素的数量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></table></figure><p>7 获得指定分数范围内的元素个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure><p>8删除一个或者多个元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>redis 中的事务是一组命令的集合，事务同命令一样都是redis 的最小执行单位。</p><p>先用MULTI命令告诉redis 下面所有都是一个事务，EXEC命令告诉redis 结束了。</p><h4 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h4><p>有些时候需要知道一条命令的返回值，再根据返回值进行下一步操作，Watch指令可以监控一个或者多个键，一旦其中有一个键被修改或者删除，之后的事务就不会执行，监控一直持续到EXEC命令。</p><p>###　生存时间</p><p>在redis 中可以使用EXPIRE 命令设置一个键的生存时间，到时间后redis 会自动删除它。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE key seconds//单位时秒</span><br><span class="line">TTL key // 返回剩余的时间</span><br><span class="line">PRESIST key // 将键设置成永久的</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>#####　有序集合的集合操作</p><p>集合类型提供了强大的集合操作命令，但是如果需要排序就要用到有序集合类型。</p><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p>sort 命令可以对列表类型，集合类型和有序集合类型键进行排序，</p><h5 id="sort-指令的by-参数"><a href="#sort-指令的by-参数" class="headerlink" title="sort 指令的by 参数"></a>sort 指令的by 参数</h5><p>by 参数的语法为by 参考键　参考键可以时字符串类型键或者时散列类型键的某个字段（表示为键名－&gt; 字段名）若提供了by参数，sort命令将不再依据元素自身的值进行排序，而是对每个元素使用元素的值替换掉参考键的第一个*并取出其值。然后对该值进行排序。</p><h5 id="get参数"><a href="#get参数" class="headerlink" title="get参数"></a>get参数</h5><p>get参数不影响排序，它的作用是使sort命令的返回结果不再时元素自身的值，而是get参数中指定的键值。也是用×作为占位符。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17. Letter Combinations of a Phone Number</title>
      <link href="/2017/12/09/leetcode17/"/>
      <url>/2017/12/09/leetcode17/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a digit string, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:Digit string &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure><p><strong>Note:</strong><br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>像图中一样，给定一个数字字符串，输出所有可能的英文字符串。</p><a id="more"></a><h4 id="答案1"><a href="#答案1" class="headerlink" title="答案1"></a>答案1</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> len =digits.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res.push_back(<span class="string">""</span>);</span><br><span class="line">        <span class="built_in">string</span> s[<span class="number">10</span>] =&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">      <span class="comment">//先声明一个string 类型的数组。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temps;</span><br><span class="line">            <span class="built_in">string</span> chars = s[digits[i]-<span class="string">'0'</span>];</span><br><span class="line">          <span class="comment">//chars是当前数字对应的字符串。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;chars.size();c++)</span><br><span class="line">            &#123;<span class="comment">//chars中每个字符进行遍历。</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;res.size();j++)</span><br><span class="line">                  <span class="comment">// res里是前面已经存进去的所有字符串，现在要和chars中的每个字符进行交叉组合。</span></span><br><span class="line">                    temps.push_back(res[j]+chars[c]);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 组合完成后，把新的res(temps)赋值给老的res.</span></span><br><span class="line">            res =temps;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代的思想，数字字符串每多一个字符，就是把前面已经存进去的所有字符串和这个新增加数字字符串进行穷举组合。得到最终的res.</p><h3 id="答案2"><a href="#答案2" class="headerlink" title="答案2"></a>答案2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> len =digits.size();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// res.push_back("");</span></span><br><span class="line">        <span class="built_in">string</span> ss = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> s[<span class="number">10</span>] =&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        DFS(<span class="number">0</span>,digits,ss, s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//index 记录digits到第几位，ss是DFS中拼装的字符串，s[10]是定义的String数组。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> index, <span class="built_in">string</span> digits, <span class="built_in">string</span> ss ,<span class="built_in">string</span> s[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==digits.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s[digits[index] - <span class="string">'0'</span>].size(); i++)</span><br><span class="line">           &#123;</span><br><span class="line">              <span class="comment">//DFS中ss+s[digits[index] - '0'][i] 加号后面的部分就相当于push_back().</span></span><br><span class="line">                DFS(index + <span class="number">1</span>, digits, ss+s[digits[index] - <span class="string">'0'</span>][i], s);</span><br><span class="line">              <span class="comment">//这里，DFS中ss+s[digits[index] - '0'][i]不同的i值实际隐藏了pop_back的动作。</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>深度优先遍历，字符串的深度优先遍历更为简单，不用像vector一样push_back pop_back，可以直接在string后面加上某个字符，就相当于push_back了，下一次直接加上不同的字符就好。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>两种方法，可以迭代，可以递归。</p><p>一般这种需要遍历所有情况的问题一看就是要用DFS进行遍历。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6. ZigZag Conversion</title>
      <link href="/2017/12/08/leetcode6/"/>
      <url>/2017/12/08/leetcode6/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>And then read line by line: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure><p>Write the code that will take a string and make this conversion given a number of rows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string text, int nRows);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert(&quot;PAYPALISHIRING&quot;, 3)</span><br></pre></td></tr></table></figure><p> should return </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>以齿轮性输出字符串。</p><p>例如：</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/17-12-08-1.png" alt=""></p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>||s.size()&lt;=numRows)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len =s.size();</span><br><span class="line">        <span class="keyword">int</span> row =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> groupnumber = <span class="number">2</span>*numRows<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;numRows;row++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(row==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i=i+groupnumber)</span><br><span class="line">                &#123;</span><br><span class="line">                    res = res+s[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(row==numRows<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=numRows<span class="number">-1</span>;i&lt;len;i=i+groupnumber)</span><br><span class="line">                &#123;</span><br><span class="line">                    res =res+s[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i=i+groupnumber)</span><br><span class="line">                &#123;   </span><br><span class="line">                    <span class="keyword">if</span>(i+row&lt;len) res = res+s[i+row]; <span class="comment">// 注释1</span></span><br><span class="line">                    <span class="keyword">if</span>(i+groupnumber-row&lt;len) res = res+s[i+groupnumber-row];     </span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先要求z子型输出，其实可以把拐弯的地放都看成直的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A       B      Y            A   A   A</span><br><span class="line">B     A D    T R            A A A A A</span><br><span class="line">C   A   R   R  Y   ======&gt;  A A A A A      看成这种形状比较方便，也好写代码。 </span><br><span class="line">D A     T  F   Q            A A A A A </span><br><span class="line">E       Y      Y            A   A   A</span><br></pre></td></tr></table></figure><p>一行一行的输出，首先根据行数可以计算出一个group的个数，比如上面的图中一个PAYP就是一个group，然后就是以一个group为一个循环。首先判断，字符串长度没有行数长时，就可以直接输出。</p><p>接着是for循环，分为三部分，第一行，最后一行，中间行，分别进行输出。</p><p>需要特别注意的是注释1的地方，注释1上面的for循环只确保了i&lt;len，并没有确保i+row&lt;len 所以加一个if判断，否则会输出乱码。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. Longest Palindromic Substring</title>
      <link href="/2017/12/07/leetcode5/"/>
      <url>/2017/12/07/leetcode5/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line"></span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>找出最长的回文字符串</p><h4 id="答案（神坑。。）"><a href="#答案（神坑。。）" class="headerlink" title="答案（神坑。。）"></a>答案（神坑。。）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(s[j]==s[k]&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;k&lt;s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k-j<span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="comment">// 给出中间数，向两边扩展，找到最长的不等边界。</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">int</span> leng =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxlen =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = extend(s,i,i); <span class="comment">//aba型的最大值 </span></span><br><span class="line">            <span class="keyword">int</span> len2 = extend(s,i,i+<span class="number">1</span>);<span class="comment">//abba型的最大值</span></span><br><span class="line">            <span class="keyword">int</span> leng = max(len1,len2);<span class="comment">// 相比较的最大值。</span></span><br><span class="line">            <span class="keyword">if</span>(leng&gt;maxlen)</span><br><span class="line">            &#123;</span><br><span class="line">                maxlen =leng;</span><br><span class="line">                start = i-(maxlen<span class="number">-1</span>)/<span class="number">2</span>; </span><br><span class="line">                end = start+leng<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start,maxlen);<span class="comment">//神坑在此，Java中subString的参数是左坐标，右坐标的下一位，然而c++中的substr第一个参数为开始，第二个参数是截取的个数。。。简直rlg。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>直接从中间开始寻找，直至找到最远的边缘。<br>回数的中间可能是一个单值，如aba中的b；也可能是双值，如abba中的bb。<br>我们可以对当前下标上的单值双值都进行尝试。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link href="/2017/12/07/leetcode3/"/>
      <url>/2017/12/07/leetcode3/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Examples:</strong></p><p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p><p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code> is a <em>subsequence</em> and not a substring.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>找出最长的连续的没有重复元素的子字符串。</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len  =s.size();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxres =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; charset;</span><br><span class="line">        charset.insert(s[left]);</span><br><span class="line">        <span class="keyword">while</span>(right&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(charset.count(s[right])!= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                charset.erase(s[left]);   </span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;  </span><br><span class="line">                charset.insert(s[right]);</span><br><span class="line">                right++;</span><br><span class="line">                res = right -left;</span><br><span class="line">                maxres =max(maxres,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxres;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>此问题是求最长的连续子字符串，可以使用滑动窗口算法求解。</p><p>维护左右两个指针，设下标left和right，[left, right ) 表示一个窗口，不断的滑动窗口。</p><p>不断的滑动右边的窗口：</p><p>当s[right] 和窗口内的字符有重复时，则不断的滑动左边的窗口，直到把重复的字符滑出维护的窗口，这种情况下，窗口的值是越来越小的。</p><p>当s[right]和窗口内的字符没有重复时，则不断的滑动右边的窗口，</p><p>当右边的窗口到达字符串的最后时，就是循环结束的时候了。</p><h5 id="判断存在"><a href="#判断存在" class="headerlink" title="判断存在"></a>判断存在</h5><p>c++中判断存在用 <code>charset.count(number)!=0</code>来判断在charset这个set中，number不存在。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Beautiful Soup</title>
      <link href="/2017/12/05/Beautiful%20Soup/"/>
      <url>/2017/12/05/Beautiful%20Soup/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="noopener">Beautiful Soup</a> 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">'html.parser'</span>) <span class="comment"># 构造对象</span></span><br><span class="line">print(soup.prettify())  <span class="comment"># 以标准的缩进格式进行结构输出。</span></span><br></pre></td></tr></table></figure><h5 id="简单浏览结构化数据的方法"><a href="#简单浏览结构化数据的方法" class="headerlink" title="简单浏览结构化数据的方法"></a>简单浏览结构化数据的方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">soup.title</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br><span class="line">soup.title.name</span><br><span class="line"><span class="comment"># u'title'</span></span><br><span class="line">soup.title.string</span><br><span class="line"><span class="comment"># u'The Dormouse's story'</span></span><br><span class="line">soup.title.parent.name</span><br><span class="line"><span class="comment"># u'head'</span></span><br><span class="line">soup.p</span><br><span class="line"><span class="comment"># &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line">soup.p[<span class="string">'class'</span>]</span><br><span class="line"><span class="comment"># u'title'</span></span><br><span class="line">soup.a</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span></span><br><span class="line">soup.find_all(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br><span class="line">soup.find(id=<span class="string">"link3"</span>)</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>从文档中找到所有<code>&lt;a&gt;</code>标签的链接:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(<span class="string">'a'</span>):</span><br><span class="line">    print(link.get(<span class="string">'href'</span>))</span><br><span class="line">    <span class="comment"># http://example.com/elsie</span></span><br><span class="line">    <span class="comment"># http://example.com/lacie</span></span><br><span class="line">    <span class="comment"># http://example.com/tillie</span></span><br></pre></td></tr></table></figure><p>获取所有文字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.get_text())</span><br></pre></td></tr></table></figure><h3 id="安装解析器"><a href="#安装解析器" class="headerlink" title="安装解析器"></a>安装解析器</h3><p>可以选择安装第三方HTML解析器lxml </p><h3 id="传入文件"><a href="#传入文件" class="headerlink" title="传入文件"></a>传入文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(open(<span class="string">"index.html"</span>))</span><br><span class="line">soup = BeautifulSoup(<span class="string">"&lt;html&gt;data&lt;/html&gt;"</span>)</span><br></pre></td></tr></table></figure><h3 id="对象种类"><a href="#对象种类" class="headerlink" title="对象种类"></a>对象种类</h3><p>Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: <code>Tag</code> , <code>NavigableString</code> , <code>BeautifulSoup</code> , <code>Comment</code> .</p><h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tag 对象与XML或HTML原生文档中的tag相同:</span></span><br><span class="line">soup = BeautifulSoup(<span class="string">'&lt;b class="boldest"&gt;Extremely bold&lt;/b&gt;'</span>,<span class="string">'lxml'</span>) <span class="comment"># 第二个参数传解析器</span></span><br><span class="line">tag = soup.b</span><br><span class="line">type(tag) <span class="comment">#  &lt;class 'bs4.element.Tag'&gt;</span></span><br><span class="line">print(tag) <span class="comment">#&lt;b class="boldest"&gt;Extremely bold&lt;/b&gt;</span></span><br></pre></td></tr></table></figure><h5 id="tag的属性-name-和attributes"><a href="#tag的属性-name-和attributes" class="headerlink" title="tag的属性 name 和attributes"></a>tag的属性 name 和attributes</h5><p>每个tag都有自己的名字,通过 <code>.name</code> 来获取:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tag.name <span class="comment"># u'b'</span></span><br><span class="line">tag.attrs <span class="comment"># &#123;u'class': u'boldest'&#125;</span></span><br><span class="line">tag.contents 属性可以将tag的子节点以列表的方式输出:</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一个tag可能有很多个属性(attributes). tag &lt;b class="boldest"&gt; 有一个 “class” 的属性,值为 “boldest” . tag的属性的操作方法与字典相同:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用字典方式取具体属性</span></span><br><span class="line">tag[<span class="string">'class'</span>]  <span class="comment"># u'boldest'</span></span><br></pre></td></tr></table></figure><h4 id="NavigableString（获取标签内部的内容）"><a href="#NavigableString（获取标签内部的内容）" class="headerlink" title="NavigableString（获取标签内部的内容）"></a>NavigableString（获取标签内部的内容）</h4><p>字符串常被包含在tag内.Beautiful Soup用 <code>NavigableString</code> 类来包装tag中的字符串:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag.string</span><br><span class="line"><span class="comment"># u'Extremely bold'</span></span><br><span class="line">type(tag.string)</span><br><span class="line"><span class="comment"># &lt;class 'bs4.element.NavigableString'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><p><code>BeautifulSoup</code> 对象表示的是一个文档的全部内容.大部分时候,可以把它当作 <code>Tag</code> 对象，是一个特殊的 Tag，我们可以分别获取它的类型，名称，以及属性来感受一下</p><h4 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h4><p>注释对象</p><h3 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h3><p>直接子节点（要点：.contents  .children  属性）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tag 的 .content 属性可以将tag的子节点以列表的方式输出</span><br><span class="line">tag.children 它返回的不是一个 list，不过我们可以通过遍历获取所有子节点。</span><br></pre></td></tr></table></figure><p>所有子孙节点    (.descendants)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contents 和 .children 属性仅包含tag的直接子节点，.descendants 属性可以对所有tag的子孙节点进行递归循环，和 children类似，我们也需要遍历获取其中的内容。</span><br></pre></td></tr></table></figure><p>节点内容 (.string)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> soup.head.string</span><br><span class="line"><span class="comment">#The Dormouse's story</span></span><br></pre></td></tr></table></figure><p>多个内容  （.strings  .stripped_strings 属性）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.strings获取多个内容，不过需要遍历获取，</span><br><span class="line">.stripped_strings 输出的字符串中可能包含了很多空格或空行,使用 .stripped_strings 可以去除多余空白内容</span><br><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> soup.strings:</span><br><span class="line">    print(repr(string))</span><br><span class="line">    <span class="comment"># u"The Dormouse's story"</span></span><br><span class="line">    <span class="comment"># u'\n\n'</span></span><br><span class="line">    <span class="comment"># u"The Dormouse's story"</span></span><br></pre></td></tr></table></figure><p>父节点   （ .parent 属性）</p><p>全部父节点     (.parents 属性)</p><p>兄弟节点 (.next_sibling  .previous_sibling 属性)</p><p>全部兄弟节点   (.next_siblings  .previous_siblings 属性)</p><p>前后节点  (.next_element  .previous_element 属性)</p><h3 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h3><p>####1）find_all( name , attrs , recursive , text , **kwargs )</p><p><code>find_all()</code> 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件</p><h3 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h3><p>写 CSS 时，标签名不加任何修饰，类名前加点，id名前加 #，在这里我们也可以利用类似的方法来筛选元素，用到的方法是 <strong>soup.select()，</strong>返回类型是 <strong>list</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Requests 总结</title>
      <link href="/2017/12/05/Requests-%E6%80%BB%E7%BB%93%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/12/05/Requests-%E6%80%BB%E7%BB%93%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="comment"># 导入库</span></span><br><span class="line"><span class="comment"># 尝试获取某个网页</span></span><br><span class="line">r =requests.get(<span class="string">'https://www.baidu.com'</span>)</span><br></pre></td></tr></table></figure><p>r 是一个response对象，从这个对象可以获取想要的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>)</span><br><span class="line">r = requests.put(<span class="string">"http://httpbin.org/put"</span>)</span><br><span class="line">r = requests.delete(<span class="string">"http://httpbin.org/delete"</span>)</span><br><span class="line">r = requests.head(<span class="string">"http://httpbin.org/get"</span>)</span><br><span class="line">r = requests.options(<span class="string">"http://httpbin.org/get"</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p>当传递参数的时候，若手动构建，那么数据会以键/值对的形式置于 URL 中，跟在一个问号的后面。例如， <code>httpbin.org/get?key=val</code>。</p><p> Requests 允许你使用 <code>params</code> 关键字参数，以一个字符串字典来提供这些参数。举例来说，如果你想传递 <code>key1=value1</code> 和 <code>key2=value2</code> 到 <code>httpbin.org/get</code> ，那么你可以使用如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myparam=&#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>,<span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.get(<span class="string">"http://httpbin.org/get"</span>, params=myparam)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将列表作为值传入</span></span><br><span class="line">payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: [<span class="string">'value2'</span>, <span class="string">'value3'</span>]&#125;</span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/get'</span>, params=payload)</span><br><span class="line">print(r.url)</span><br><span class="line"><span class="comment"># http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3</span></span><br></pre></td></tr></table></figure><h5 id="打印URL"><a href="#打印URL" class="headerlink" title="打印URL"></a>打印URL</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(r.url)</span><br></pre></td></tr></table></figure><h3 id="相应内容"><a href="#相应内容" class="headerlink" title="相应内容"></a>相应内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取服务器相应内容</span></span><br><span class="line">r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</span><br><span class="line">r.text</span><br><span class="line"><span class="comment"># Requests 会自动解码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。</span></span><br><span class="line"><span class="comment"># 改变输出编码</span></span><br><span class="line">r.encoding = <span class="string">'ISO-8859-1'</span></span><br></pre></td></tr></table></figure><h5 id="二进制相应内容"><a href="#二进制相应内容" class="headerlink" title="二进制相应内容"></a>二进制相应内容</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非文本请求</span></span><br><span class="line">r.content</span><br><span class="line">Requests 会自动为你解码 gzip 和 deflate 传输编码的响应数据。</span><br><span class="line">例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码：</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">i = Image.open(BytesIO(r.content))</span><br></pre></td></tr></table></figure><h5 id="JSON相应内容"><a href="#JSON相应内容" class="headerlink" title="JSON相应内容"></a>JSON相应内容</h5><p>requests内置JSON解码器，帮助处理JSON数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</span><br><span class="line">r.json()</span><br><span class="line"><span class="comment"># [&#123;u'repository': &#123;u'open_issues': 0, u'url': 'https://github.com/...</span></span><br></pre></td></tr></table></figure><h5 id="原始相应内容"><a href="#原始相应内容" class="headerlink" title="原始相应内容"></a>原始相应内容</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">'https://github.com/timeline.json'</span>, stream=<span class="keyword">True</span>)</span><br><span class="line">r.raw</span><br><span class="line">&lt;requests.packages.urllib3.response.HTTPResponse object at <span class="number">0x101194810</span>&gt;</span><br><span class="line">r.raw.read(<span class="number">10</span>)</span><br><span class="line"><span class="string">'\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03'</span></span><br></pre></td></tr></table></figure><h3 id="定制请求头"><a href="#定制请求头" class="headerlink" title="定制请求头"></a>定制请求头</h3><p>如果你想为请求添加 HTTP 头部，只要简单地传递一个 <code>dict</code> 给 <code>headers</code> 参数就可以了。</p><p>例如，在前一个示例中我们没有指定 content-type:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'https://api.github.com/some/endpoint'</span></span><br><span class="line">headers = &#123;<span class="string">'user-agent'</span>: <span class="string">'my-app/0.0.1'</span>&#125;</span><br><span class="line">r = requests.get(url, headers=headers)</span><br></pre></td></tr></table></figure><h3 id="更加复杂POST请求"><a href="#更加复杂POST请求" class="headerlink" title="更加复杂POST请求"></a>更加复杂POST请求</h3><p>你想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需简单地传递一个字典给 data 参数。你的数据字典在发出请求时会自动编码为表单形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">"http://httpbin.org/post"</span>, data=payload)</span><br><span class="line">print(r.text)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"form"</span>: &#123;</span><br><span class="line">    <span class="string">"key2"</span>: <span class="string">"value2"</span>,</span><br><span class="line">    <span class="string">"key1"</span>: <span class="string">"value1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="POST-Multipart-Encoded-的文件"><a href="#POST-Multipart-Encoded-的文件" class="headerlink" title="POST Multipart-Encoded)的文件"></a>POST Multipart-Encoded)的文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: open(<span class="string">'report.xls'</span>, <span class="string">'rb'</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"files"</span>: &#123;</span><br><span class="line">    <span class="string">"file"</span>: <span class="string">"&lt;censored...binary...data&gt;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###　状态响应码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测相应状态码</span></span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">r.status_code</span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="comment"># 为方便引用，Requests还附带了一个内置的状态码查询对象：</span></span><br><span class="line">r.status_code == requests.codes.ok</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="相应头"><a href="#相应头" class="headerlink" title="相应头"></a>相应头</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我们可以查看以一个 Python 字典形式展示的服务器响应头：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'content-encoding'</span>: <span class="string">'gzip'</span>,</span><br><span class="line">    <span class="string">'transfer-encoding'</span>: <span class="string">'chunked'</span>,</span><br><span class="line">    <span class="string">'connection'</span>: <span class="string">'close'</span>,</span><br><span class="line">    <span class="string">'server'</span>: <span class="string">'nginx/1.0.4'</span>,</span><br><span class="line">    <span class="string">'x-runtime'</span>: <span class="string">'148ms'</span>,</span><br><span class="line">    <span class="string">'etag'</span>: <span class="string">'"e1ca502697e5c9317743dc078f67693f"'</span>,</span><br><span class="line">    <span class="string">'content-type'</span>: <span class="string">'application/json'</span></span><br><span class="line">&#125;</span><br><span class="line">因此，我们可以使用任意大写形式来访问这些响应头字段：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers[<span class="string">'Content-Type'</span>]</span><br><span class="line"><span class="string">'application/json'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers.get(<span class="string">'content-type'</span>)</span><br><span class="line"><span class="string">'application/json'</span></span><br></pre></td></tr></table></figure><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h5 id="访问cookie"><a href="#访问cookie" class="headerlink" title="访问cookie"></a>访问cookie</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果某个响应中包含一些 cookie，你可以快速访问它们：</span></span><br><span class="line">url = <span class="string">'http://example.com/some/cookie/setting/url'</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">r.cookies[<span class="string">'example_cookie_name'</span>]</span><br><span class="line"><span class="string">'example_cookie_value'</span></span><br></pre></td></tr></table></figure><h5 id="发送cookie"><a href="#发送cookie" class="headerlink" title="发送cookie"></a>发送cookie</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要想发送你的cookies到服务器，可以使用 cookies 参数：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/cookies'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cookies = dict(cookies_are=<span class="string">'working'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url, cookies=cookies)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line"><span class="string">'&#123;"cookies": &#123;"cookies_are": "working"&#125;&#125;'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 多线程</title>
      <link href="/2017/12/05/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2017/12/05/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>对于操作系统来说，一个任务就是一个线程。</p><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字，拼写检查等事情，在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程。</p><p>Python 内置多线程的支持，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p><p>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p><a id="more"></a><h4 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h4><p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"thread is runing"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        print(str(i) + <span class="string">'\n'</span>) <span class="comment">#   (1)</span></span><br><span class="line">        </span><br><span class="line">t = threading.Thread(target=loop, name=<span class="string">'LoopThread'</span>)<span class="comment"># target 传入函数名</span></span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">"main thread"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行结果 main thread 可能在 (<span class="number">1</span>)输出的任意位置。</span><br></pre></td></tr></table></figure><h4 id="线程命名"><a href="#线程命名" class="headerlink" title="线程命名"></a>线程命名</h4><p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为<code>Thread-1</code>，<code>Thread-2</code>……</p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p><p>创建一个锁就是通过<code>threading.Lock()</code>来实现</p><p>获取锁就是<code>lock.acquire()</code></p><p>释放锁就是<code>lock.release()</code></p><p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 使用指南</title>
      <link href="/2017/12/04/Mysql-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2017/12/04/Mysql-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="帮助的使用"><a href="#帮助的使用" class="headerlink" title="帮助的使用"></a>帮助的使用</h3><h5 id="按照层次看帮助"><a href="#按照层次看帮助" class="headerlink" title="按照层次看帮助"></a>按照层次看帮助</h5><p>如果不知道帮助提供什么,可以一层一层往下看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySQL&gt; ? content</span><br><span class="line"># 在列出的分类中继续使用 ? (内容) 查看对应的帮助</span><br></pre></td></tr></table></figure><h5 id="快速查阅帮助"><a href="#快速查阅帮助" class="headerlink" title="快速查阅帮助"></a>快速查阅帮助</h5><p>需要快速查阅某项语法时,用关键字进行快速查询. 也是使用 ? </p><a id="more"></a><p>###　表类型（存储引擎）的选择</p><p>mysql的存储引擎包括:MyISAM、 InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、<br>ARCHIVE、CSV、BLACKHOLE、FEDERATED等,其中InnoDB和BDB提供事务安全表,其他存储引<br>擎都是非事务安全表. </p><p><strong>Myisam</strong> mysql默认存储引擎,当create创建新表时,未指定新表存储引擎时,默认使用Myisam.</p><p>每个MyISAM在磁盘上存储成三个文件。文件名都和表名相同,扩展名分别是 .frm(存储表定义)、.MYD (MYData,存储数据)、.MYI (MYIndex,存储索引)。数据文件和索引文件可以放置在不同的目录,平均分布io,获得更快的速度。<em>是在web,数据仓储和其他应用环境下最常用的存储引擎之一</em></p><p><strong>InnoDB</strong> 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比 Myisam的存储引擎,InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。<em>用于事务处理应用程序,具有众多特性,包括ACID 事务支持</em></p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>字符集是一套符号和编码的规则,不论在Oracle 还是MySQL,都存在字符集的选择问题,后期字符集的更换是比较高的操作,页存在风险,所以在应用开始阶段,就按照需求选择合适的字符集,避免后期不必要的调整.</p><h5 id="MySQL支持的字符集"><a href="#MySQL支持的字符集" class="headerlink" title="MySQL支持的字符集"></a>MySQL支持的字符集</h5><p>可以用<code>show character set</code>命令查看所有MySQL支持的字符集,</p><p>MySQL的字符集包括字符集(CHARACTER)和校对规则(COLLATION)两个概念,字符集是用来定义MySQL存储字符串的方式,校对规则是定义了比较字符串的方式,字符集和校对规则是一对多的关系.每个字符集至少一个校对规则,可以用<code>show COLLATION LIKE &#39;utf8%&#39;;</code>命令查看相关字符集的校对规则.</p><h5 id="字符集的设置"><a href="#字符集的设置" class="headerlink" title="字符集的设置"></a>字符集的设置</h5><p>mysql 的字符集和校对规则有 4 个级别的默认设置:服务器级、数据库级、表级和字段级。分别在不同的地方设置,作用也不相同。</p><h3 id="索引的设计与使用"><a href="#索引的设计与使用" class="headerlink" title="索引的设计与使用"></a>索引的设计与使用</h3><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>索引可以理解为就是数据库的目录,目的是为了让数据库更快的找回返回的数据.</p><p>对相关列使用索引是提高SELECT操作性能的最佳途径.存储引擎支持每个表至少16个索引,总索引长度至少256字节,大多数存储引擎有更高的限制.</p><h5 id="设计引擎的原则"><a href="#设计引擎的原则" class="headerlink" title="设计引擎的原则"></a>设计引擎的原则</h5><p>1: 最适合索引的列是出现在where子句中的列,或连接子句中指定的列,而不是出现在select关键字后的选择列表中的列.</p><p>2: 使用唯一索引,考虑某列中值的分布,对于唯一值的列,效果最好,多个重复值的列,效果最差.(例如,年龄的就很容易区分,但是性别的就没什么用)</p><p>3: 使用短索引,如果有一个char(200)列, 如果在前10个或20个字符内,多数值是唯一的,就不要对整个列进行索引.对前10个字符索引能够节省大量索引空间,也可能查询更快</p><p>4: 最左前缀：顾名思义，就是最左优先，比如我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。这样一个多列索引可以起几个索引的作用,因为可以利用索引中最左边的列集来匹配行.</p><p>5: 不要过度索引 索引并不是越多越好,每个额外的索引都要占用额外的磁盘空间,并降低写操作的性能.</p><p>6: 考虑在列上进行的比较类型,索引可用于<code>&lt;</code> <code>&lt;=</code> <code>=</code> <code>&gt;</code> <code>&gt;=</code> <code>between</code> 运算,在模式具有一个直接量前缀时,索引也用于 LIKE 运算。如果只将某个列用于其他类型的运算时(如 STRCMP( )),对其进行索引没有价值。 </p><h5 id="btree索引和hash索引"><a href="#btree索引和hash索引" class="headerlink" title="btree索引和hash索引"></a>btree索引和hash索引</h5><p>hsah索引把数据的索引以hash形式组织起来，因此当查找某一条记录的时候,速度非常快。当时因为是hash结构，每个键只对应一个值，而且是散列的方式分布。所以他并不支持范围查找和排序等功能。</p><p>B+tree是mysql使用最频繁的一个索引数据结构，是Inodb和Myisam存储引擎模式的索引类型。相对Hash索引，B+树在查找单条记录的速度比不上Hash索引，但是因为更适合排序等操作，所以他更受用户的欢迎。毕竟不可能只对数据库进行单条记录的操作.</p><h3 id="锁机制和事务控制"><a href="#锁机制和事务控制" class="headerlink" title="锁机制和事务控制"></a>锁机制和事务控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 加锁</span><br><span class="line">LOCK TABLES</span><br><span class="line">#　解锁</span><br><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure><p>InnoDB提供行级锁,支持共享锁和排他锁两种锁定模式,以及四种不同的隔离级别.</p><h5 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h5><p> 在mysql命令行的默认下，事务都是自动提交的，sql语句提交后马上会执行commit操作。</p><p>事务控制语句:</p><ul><li>start transaction 或 begin ; 显式的开启一个事务</li><li>commit ,提交事务,</li><li>rollback  回滚会结束用户的事务,并撤销正在进行的所有未提交的修改.</li><li>chain 定义事务提交后的操作,会立即启动一个新的事务</li><li>release 定义事务回滚之后的操作,release 会断开和客户端的连接.</li><li>set autocommit =0 禁止自动提交事务 =1 开启自动提交事务</li></ul><p>在事务中可以通过定义savepoint,指定回滚事务的一个部分,但是不能指定提交事务的一个部分。对于复杂的应用,可以定义多个不同的savepoint,满足不同的条件时,回滚不同的 savepoint。需要注意的是, 如果定义了 相同名字的 savepoint ,则后面定义的savepoint会覆盖之前的定义。对于不再需要使用的savepoint,可以通过release savepoint命令删除savepoint,删除后的savepoint,不能再执行rollback to savepoint命令。</p><h3 id="常用SQL技巧"><a href="#常用SQL技巧" class="headerlink" title="常用SQL技巧"></a>常用SQL技巧</h3><h5 id="检索包含最大-最小值的行-使用max-min-函数-找不到返回NULL"><a href="#检索包含最大-最小值的行-使用max-min-函数-找不到返回NULL" class="headerlink" title="检索包含最大/最小值的行(使用max min 函数 找不到返回NULL)"></a>检索包含最大/最小值的行(使用max min 函数 找不到返回NULL)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select Student_name ,MIN(test_score),MAX(test_score) from Student group by student_name;</span><br></pre></td></tr></table></figure><h5 id="提取随机行"><a href="#提取随机行" class="headerlink" title="提取随机行"></a>提取随机行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 随机顺序检索数据行</span><br><span class="line">select * from name order by rand();</span><br></pre></td></tr></table></figure><p>order by rand() 和limit 结合可以从一组列中选择随机样本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from table1,table2 where a=b and c&lt;d order by rand() limit 1000;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>189. Rotate Array</title>
      <link href="/2017/12/04/leetcode189/"/>
      <url>/2017/12/04/leetcode189/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Rotate an array of <em>n</em> elements to the right by <em>k</em> steps.</p><p>For example, with <em>n</em> = 7 and <em>k</em> = 3, the array <code>[1,2,3,4,5,6,7]</code> is rotated to <code>[5,6,7,1,2,3,4]</code>.</p><p><strong>Note:</strong><br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p><p><a href="https://leetcode.com/problems/rotate-array/description/#" target="_blank" rel="noopener">[show hint]</a></p><p>Related problem: <a href="https://leetcode.com/problems/reverse-words-in-a-string-ii/" target="_blank" rel="noopener">Reverse Words in a String II</a></p><p><strong>Credits:</strong><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Freezen" target="_blank" rel="noopener">@Freezen</a> for adding this problem and creating all test cases.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>旋转数组</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len =nums.size();</span><br><span class="line">        k = k%len;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">        reverse(nums,k,len<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums[left],nums[right]);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>很简单的一道题，但是毕竟第一次见。</p><p>三步反转法来做，时间复杂度是O(n),空间复杂度是O(1)</p><p>一共有3步。假设输入数组的下标是0~ n-1，需要rotate的步数是k.</p><p>step 1 reverse原来的数组</p><p>step 2 reverse 0~ k-1</p><p>step 3 reverse k ~ n-1</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>152. Maximum Product Subarray</title>
      <link href="/2017/12/03/leetcode152/"/>
      <url>/2017/12/03/leetcode152/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p><p>For example, given the array <code>[2,3,-2,4]</code>,<br>the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>给定一个数组，求出最大的乘积值。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>解题思路：乘法与加法最大差别在于，当前元素的符号具有全局性的作用。</p><p>如果当前元素为负，那么连乘到上个元素的最大乘积，再乘以当前元素，就变成负数，甚至可能成为最小乘积。</p><p>同样，连乘到上个元素的最小乘积如为负，再乘以当前元素，就变成正数，甚至可能成为最大乘积。</p><p>也就是说，当前遍历到的数是一个负数，那么乘以前面的最大元素直接就变成最小元素了。</p><p>所以用两个数组 dpmax[] 和dpmin[] 分别记录以i 为最后的乘积的最大值和最小值，然后通过max函数得到最大值。</p><a id="more"></a><p>####　答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len =nums.size();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dpmax(len,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dpmin(len,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> res =nums[<span class="number">0</span>];</span><br><span class="line">        dpmax[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dpmin[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">           dpmax[i] = max(max(dpmax[i<span class="number">-1</span>]*nums[i],dpmin[i<span class="number">-1</span>]*nums[i]),nums[i]);</span><br><span class="line">           dpmin[i] = min(min(dpmax[i<span class="number">-1</span>]*nums[i],dpmin[i<span class="number">-1</span>]*nums[i]),nums[i]);</span><br><span class="line">          <span class="comment">//重点在于上面的状态转移方程，当前的最大值可能是前面的最大值乘以当前的数字</span></span><br><span class="line">          <span class="comment">//也可能是前面的最小值（比如是一个负数）乘以当前的负数，变成最大值。</span></span><br><span class="line">          <span class="comment">//还要和nums[i]比较是有０的情况。</span></span><br><span class="line">          <span class="comment">//同样，当求最小值的时候，当前的最小值可能是前面的最小值（负数）乘当前数，也可能前面的最大值（正数）成为当前数（负数），</span></span><br><span class="line">          <span class="comment">//最后res就等于最大的 dpmax.</span></span><br><span class="line">           res =max(res,dpmax[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的解法空间复杂度为ｏ(n)观察到状态转移方程中当前状态只和前一个状态有关，所以可能进行保存前一个状态就好，这样就降低了空间复杂度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//易错解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len =nums.size();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res =nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dpmax =nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dpmin =nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">           dpmax = max(max(dpmax*nums[i],dpmin*nums[i]),nums[i]);</span><br><span class="line">          <span class="comment">//错误的原因就在于 dpmax在得到后没有进行保存，本来下面的dpmax是前一个数的dpamx,但是经过上面的计算后就有了新的ｄｐｍａｘ,下面计算ｄｐｍｉｎ的时候直接用了新的ｄpmax进行计算，所以错了。</span></span><br><span class="line">           dpmin = min(min(dpmax*nums[i],dpmin*nums[i]),nums[i]);</span><br><span class="line">           res = max(res,dpmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len =nums.size();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res =nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dpmax =nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dpmin =nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> mmax;</span><br><span class="line">        <span class="keyword">int</span> mmin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">           mmax = max(max(dpmax*nums[i],dpmin*nums[i]),nums[i]);</span><br><span class="line">           mmin = min(min(dpmax*nums[i],dpmin*nums[i]),nums[i]);</span><br><span class="line">           dpmax=mmax;</span><br><span class="line">           dpmin=mmin;</span><br><span class="line">           res = max(res,mmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Screen命令的使用</title>
      <link href="/2017/12/03/Screen%20%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/03/Screen%20%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Screen-命令的使用"><a href="#Screen-命令的使用" class="headerlink" title="Screen 命令的使用"></a>Screen 命令的使用</h1><p>GNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。</p><p>GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。</p><p>由于需要在服务器上跑程序，如果出现网断的情况的话，原先的ssh登录服务器的方式就会断开链接，这样是极不方便的，这时就可以使用screen命令，就不会使任务终端了。</p><a id="more"></a><h4 id="screen命令的最常见命令"><a href="#screen命令的最常见命令" class="headerlink" title="screen命令的最常见命令"></a>screen命令的最常见命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">screen -S wkn 创建一个名字为wkn的session</span><br><span class="line">control_A +D 暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。 </span><br><span class="line">screen -ls -&gt; 列出当前所有的session</span><br><span class="line">screen -r 回到yourname这个session。</span><br><span class="line"></span><br><span class="line">screen -X -S [session # you want to kill] quit   杀死某个session.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121&amp;122&amp;123. Best Time to Buy and Sell Stock I II III</title>
      <link href="/2017/12/03/leetcode121&amp;122&amp;123/"/>
      <url>/2017/12/03/leetcode121&amp;122&amp;123/</url>
      
        <content type="html"><![CDATA[<h4 id="121题目"><a href="#121题目" class="headerlink" title="121题目"></a>121题目</h4><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [7, 1, 5, 3, 6, 4]</span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [7, 6, 4, 3, 1]</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="121大意"><a href="#121大意" class="headerlink" title="121大意"></a>121大意</h4><p>给定一个序列，序列的值代表股票的值，求出最大的收益（只能交易一次）。</p><h4 id="121-答案"><a href="#121-答案" class="headerlink" title="121 答案"></a>121 答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len =prices.size();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minindex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;prices[minindex])</span><br><span class="line">            &#123;</span><br><span class="line">                res =max(res,prices[i]-prices[minindex]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                minindex=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="121解析"><a href="#121解析" class="headerlink" title="121解析"></a>121解析</h4><p>此题就是选择买入卖出股票的最大收益，对于第i天卖出的最大收益即为第i天的股市价格减去[0,i-1]天内的最小股市价格，当第i天的股市价格比前面最低股市价格还低，则更新最低股市价格。然后取最大的股市收益，为DP问题。用profit[i]表示第i天的收益，则minBuyPrice = min(minBuyPrice, prices[i]),并且profit[i] = prices[i]-minBuyPrice. 然后取profit中的最大值。</p><p>profit[i]即为dp数组，表示的是以第i天卖出去的最大的收益，所以profit[i] 的值就等于第i天的价格减去前面最低的价格，要是第i的价格比前面所有的都低，则更新最低的价格，并记录当前的节点。</p><h4 id="122题目"><a href="#122题目" class="headerlink" title="122题目"></a>122题目</h4><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><h4 id="122大意"><a href="#122大意" class="headerlink" title="122大意"></a>122大意</h4><p>一个数组仍代表股票序列，这次可以有无数次的交易机会</p><h4 id="122答案"><a href="#122答案" class="headerlink" title="122答案"></a>122答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len =prices.size();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i+<span class="number">1</span>]-prices[i]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res = res + prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="122-解析"><a href="#122-解析" class="headerlink" title="122 解析"></a>122 解析</h4><p>因为有无数次的交易机会，这道题的解法不是动态规划了，而是贪心，遍历数组，只要当前的值比上一个大，就进行一次买入卖出的操作，最后统计整体的收入。</p><h4 id="123-题目"><a href="#123-题目" class="headerlink" title="123 题目"></a>123 题目</h4><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p><p><strong>Note:</strong><br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><h4 id="123-大意"><a href="#123-大意" class="headerlink" title="123 大意"></a>123 大意</h4><p>还是股票数组，这次要求只能交易两次。</p><h4 id="123思路"><a href="#123思路" class="headerlink" title="123思路"></a>123思路</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(prices[i]&gt;=prices[minindex])</span><br><span class="line">  &#123;</span><br><span class="line">    dpzheng[i]=prices[i]-prices[minindex]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    minindex = i;</span><br><span class="line">    dpzheng[i]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxindex=len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(prices[i]&lt;=prices[maxindex])</span><br><span class="line">  &#123;</span><br><span class="line">    dpfan[i]=prices[maxindex]-prices[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    dpfan[i]=<span class="number">0</span>;</span><br><span class="line">    maxindex=i;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的代码是本题的基本思路，可以看成是121题的变形，两次股票交易是可以定义一个交易点，在这个点之前可以进行一次交易，在这个点之后可以进行一次交易。</p><p>定义一个dpzheng[]数组用来存以i为结束的最大收益，从前往后遍历，minindex记录最小值的位置。</p><p>再定义一个dpfan[]数组用来存以i为开始的最大收益，从后往前遍历，若price[i]&lt; price[max],则相减就是获利值，若price[i]&gt;price[max],获利是0，且更新最大值的位置。</p><p>这样求出的dpzheng[] 数组存的都是以i为结束的最大获利，dpfan[i]存的都是以i开始的最大获利值。</p><p>但是这样还不对。</p><h4 id="123-答案"><a href="#123-答案" class="headerlink" title="123 答案"></a>123 答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//zheng数组表示的是以i为结束的dpzheng[]的最大值，</span></span><br><span class="line">      <span class="comment">//fan数组表示的值以i为开始的dpfan[]的最大值。</span></span><br><span class="line">      <span class="comment">//这样求出来的zheng数组和fan数组才是最后能获利的最大值。</span></span><br><span class="line">      <span class="comment">//这样做的原因是假设第一步交易和第二步交易不一定是重合的，</span></span><br><span class="line">      <span class="comment">//也就是说在某个点卖出以后，并不一定马上进行第二步交易，</span></span><br><span class="line">      <span class="comment">//所以需要转换一下，使zheng[] 和fan[]存的都是历史的最大值。</span></span><br><span class="line">      <span class="comment">//这样，遍历zheng[i]+fan[i]才是最大值。</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zheng(len,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fan(len,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> reszheng=<span class="number">0</span>,resfan=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minindex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> zhengmax=<span class="number">0</span>,fanmax=<span class="number">0</span>;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;=prices[minindex])</span><br><span class="line">            &#123;</span><br><span class="line">                reszheng=(prices[i]-prices[minindex]);</span><br><span class="line">                zhengmax =max(zhengmax,reszheng);</span><br><span class="line">                zheng[i]=zhengmax;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                minindex = i;</span><br><span class="line">                reszheng=<span class="number">0</span>;</span><br><span class="line">                zhengmax =max(zhengmax,reszheng);</span><br><span class="line">                zheng[i]=zhengmax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxindex=len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;=prices[maxindex])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//dpfan[i]=prices[maxindex]-prices[i];</span></span><br><span class="line">                resfan=(prices[maxindex]-prices[i]);</span><br><span class="line">                fanmax =max(fanmax,resfan);</span><br><span class="line">                fan[i]=fanmax;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                maxindex=i;</span><br><span class="line">                resfan=<span class="number">0</span>;</span><br><span class="line">                fanmax =max(fanmax,resfan);</span><br><span class="line">                fan[i]=fanmax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=max(res,zheng[i]+fan[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog.csdn.net/u012501459/article/details/<span class="number">46514309</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射技术总结</title>
      <link href="/2017/12/01/%E5%8F%8D%E5%B0%84/"/>
      <url>/2017/12/01/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>现在有一个对象，要通过对象找到一个类的名称，此时就要用到反射机制。</p><p>核心概念<em>一切的操作都将使用Object完成，类，数组的引用都可以使用Object进行接收</em></p><p>通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。<br>程序中一般的对象的类型都是在<em>编译期</em>就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p><p>反射的核心是JVM<em>在运行时</em>才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><a id="more"></a><h3 id="功能（重点：在运行时不是编译时）"><a href="#功能（重点：在运行时不是编译时）" class="headerlink" title="功能（重点：在运行时不是编译时）"></a>功能（重点：在运行时不是编译时）</h3><p>反射主要提供了以下的功能</p><ul><li>1.在运行时判断任意一个对象所属的类；</li><li>2.在运行时构造任意一个类的对象；</li><li>3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li><li>4.在运行时调用任意一个对象的方法</li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,controller之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射（把类写进配置文件中，然后通过运行时读配置文件来动态的加载类）——运行时动态加载需要加载的对象。（运行时传入类名，然后来创建对象，而不是去new 对象）(和基于接口的方法的区别: 当基于接口时,接口中的定义中方法名是固定好的,它无法直接引用到其他的方法,要加载某个对象必须重新去写new的代码,而使用接口,就可以在运行时动态的从配置文件中读取类名,动态的加载需要的类.)</p><p>java的反射机制就是增加程序的灵活性，避免将程序写死到代码里，</p><p>例如： 实例化一个 person()对象， 不使用反射， new person(); 如果想变成 实例化 其他类， 那么必须修改源代码，并重新编译。</p><p> 使用反射： class.forName(“person”).newInstance()； 而且这个类描述可以写到配置文件中，如 .xml, 这样如果想实例化其他类，只要修改配置文件的”类描述”就可以了，<strong>不需要重新修改代码并编译</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反射可以结合Java的字节码，使用ASM和cglib等库，还能动态生成类。</span><br></pre></td></tr></table></figure><h3 id="认识Class类"><a href="#认识Class类" class="headerlink" title="认识Class类"></a>认识Class类</h3><p>Class是一个java类，跟Java API中定义的诸如Thread、Integer类、我们自己定义的类是一样，也继承了Object（Class是Object的直接子类）。总之，必须明确一点，它其实只是个类，只不过名字比较特殊。更进一步说，Class是一个java中的泛型类型。</p><p><strong>Java.lang.Class是一个比较特殊的类</strong>，它<strong>用于封装被装入到JVM中的类（包括类和接口）的信息</strong>。<strong>当一个类或接口被装入的JVM时便会产生一个与之关联的java.lang.Class对象，可以通过这个</strong>Class对象<strong>对被装入类的详细信息进行访问。（</strong>Java中Class对象和类的实例对象是两个不同的概念，不能混淆！)(<font color="red"><strong>每一个类都有一个封装它的java.lang.Class类对象</strong></font>) 基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。 每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p><p><strong>一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象：</strong>事实上，Class对象就是用来创建类的所有的“普通”对象的。  类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译了一个新类，就会产生一个Class对象（恰当地说，是被保存在一个同名的.class文件中）。在运行时，当我们想生成这个类的对象时，运行这个程序的 Java虚拟机（JVM）首先检查这个类的Class对象是否已经加载。如果尚未加载，JVM就会根据类名查找.class文件，并将其载入。  一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有(实例)对象.</p><p>在Java中Object是一切类的父类，那么所有类的对象实际上也都是Java.lang.Class类的实例，所以所有的对象都可以转变为Java.lang.Class类型表示。</p><h4 id="如何取到Class-类对象-三种方法"><a href="#如何取到Class-类对象-三种方法" class="headerlink" title="如何取到Class 类对象 三种方法"></a>如何取到Class 类对象 三种方法</h4><p>1、调用Object类的getClass()方法来得到Class对象，这也是最常见的产生Class对象的方法。例如：<br>​    <code>MyObject x</code>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = x.getClass();</span><br></pre></td></tr></table></figure><p>2、使用Class类的中静态forName()方法获得与字符串对应的Class对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c2=Class.forName(<span class="string">"MyObject"</span>),Employee必须是接口或者类的名字。</span><br></pre></td></tr></table></figure><p>3、获取Class类型对象的第三个方法非常简单。如果T是一个Java类型，那么T.class就代表了匹配的类对象。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class cl1 = Manager.class;</span><br><span class="line">Class cl2 = <span class="keyword">int</span>.class;</span><br><span class="line">Class cl3 = Double[].class;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//综合实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//三种反射方式</span></span><br><span class="line">        <span class="comment">/************************************/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; h2 =Class.forName(<span class="string">"Hello"</span>);</span><br><span class="line">            <span class="comment">//找到了封装的Class类对象.</span></span><br><span class="line">            h2.getConstructors();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*************************************/</span></span><br><span class="line">        Class&lt;?&gt; h = Hello.class;</span><br><span class="line">        <span class="comment">//找到了封装的Class类对象.</span></span><br><span class="line">        h.getConstructors();</span><br><span class="line">        <span class="comment">/*************************************/</span></span><br><span class="line">        Hello hello =<span class="keyword">new</span> Hello();</span><br><span class="line">        Class&lt;?&gt; c = hello.getClass();</span><br><span class="line">        <span class="comment">//找到了封装的Class类对象.</span></span><br><span class="line">        c.getConstructors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h4><p>前面三种方法已经找到了Class类对象,下面就是Class类中的常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入完整包.类名实例化Class对象。!!!!!!!!!!!!!!!!!!!!!! 上面的第一种方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)  <span class="comment">//静态方法</span></span><br><span class="line"><span class="comment">// 得到一个类的对象.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 得到一个类的全部构造方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructors[] <span class="title">getConstructors</span><span class="params">()</span> <span class="keyword">throws</span> SecurityException</span></span><br><span class="line"><span class="function"><span class="comment">//得到本类中单独定义的全部属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Field[] <span class="title">getDeclareFields</span><span class="params">()</span> <span class="keyword">throws</span> SecurityException</span></span><br><span class="line"><span class="function"><span class="comment">//得到本类继承来的全部属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Field[] <span class="title">getFields</span><span class="params">()</span> <span class="keyword">throws</span> SecurityException</span></span><br><span class="line"><span class="function"><span class="comment">//得到一个类中的全部方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method[] <span class="title">getMethods</span><span class="params">()</span> <span class="keyword">throws</span> SecurityException</span></span><br><span class="line"><span class="function"><span class="comment">//返回一个method对象，并设置一个方法中的所有参数类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String methodname, Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function"><span class="comment">//得到一个类中实现的全部接口</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class[] <span class="title">getInterfaces</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//得到一个类完整的包类名称</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回表示数组类型的Class</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class&lt;?&gt; <span class="title">getComponentType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="使用class类"><a href="#使用class类" class="headerlink" title="使用class类"></a>使用class类</h3><p> 要想对JVM中Class类封装的信息进行访问</p><h5 id="通过无参构造实例化对象"><a href="#通过无参构造实例化对象" class="headerlink" title="通过无参构造实例化对象"></a>通过无参构造实例化对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c =String.class;<span class="comment">//也可以用forname得到class对象。</span></span><br><span class="line"><span class="comment">//得到class对象后，通过newInstance实例化对象。</span></span><br><span class="line">Object str =c.newInstance();</span><br></pre></td></tr></table></figure><h5 id="调用有参构造实例化对象"><a href="#调用有参构造实例化对象" class="headerlink" title="调用有参构造实例化对象"></a>调用有参构造实例化对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">操作时需要明确调用的构造函数，并将参数进行传递。</span><br><span class="line"><span class="number">1</span>.通过<span class="class"><span class="keyword">class</span>类的<span class="title">getConstructors</span>()取得本类中的全部构造方法</span></span><br><span class="line"><span class="class">2.向构造方法传递一个对象数组进去，里面包含了构造方法所需的各个参数</span></span><br><span class="line"><span class="class">3.之后通过<span class="title">Constructor</span>实例化对象</span></span><br><span class="line"><span class="class"><span class="title">Class</span>&lt;?&gt; <span class="title">c</span> </span>=<span class="keyword">null</span>;</span><br><span class="line">c =Class.forNAme(<span class="string">"org.sysu.book"</span>);</span><br><span class="line">Constructor&lt;?&gt; cons[] =<span class="keyword">null</span>;</span><br><span class="line">cons=c.getConstructors();</span><br><span class="line">Book book =(Book)cons[<span class="number">0</span>].newInstance(<span class="string">"wkn"</span>,<span class="number">22</span>);</span><br></pre></td></tr></table></figure><h3 id="反射的基本运用"><a href="#反射的基本运用" class="headerlink" title="反射的基本运用"></a>反射的基本运用</h3><p>反射可以用于判断任意对象所属的类，获得Class对象，构造任意一个对象以及调用一个对象。介绍一下基本反射功能的实现.</p><h5 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">Hello hello =<span class="keyword">new</span> Hello();</span><br><span class="line">Class&lt;?&gt; c = hello.getClass();<span class="comment">//找到了封装的Class类对象.</span></span><br><span class="line">System.out.println(c.isInstance(hello));</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><h5 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h5><p>1 使用class对象的newInstance()方法创建class对象对应类的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c =String.class;</span><br><span class="line">Object str =c.newInstance();</span><br></pre></td></tr></table></figure><p>2 先通过class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法创建实例，这种方法可以用指定的构造器构造类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器!!!!</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"wkn"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"> Hello hello =<span class="keyword">new</span> Hello();</span><br><span class="line">        Class&lt;?&gt; c = hello.getClass();<span class="comment">//找到了封装的Class类对象.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//找到有三个参数的构造函数</span></span><br><span class="line">            Constructor c1 =c.getConstructor(String.class,Integer.class,String.class);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Hello hhh = (Hello) c1.newInstance(<span class="string">"123"</span>,<span class="number">1</span>,<span class="string">"123"</span>);<span class="comment">//实例化对象</span></span><br><span class="line">                System.out.println(hhh.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><p>获取某个class对象的方法集合</p><p>1 getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure><p>2 getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure><p>3 getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure><h5 id="获取构造器信息"><a href="#获取构造器信息" class="headerlink" title="获取构造器信息"></a>获取构造器信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br></pre></td></tr></table></figure><h5 id="获取类的成员变量信息"><a href="#获取类的成员变量信息" class="headerlink" title="获取类的成员变量信息"></a>获取类的成员变量信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getFiled: 访问公有的成员变量</span><br><span class="line">getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量</span><br><span class="line">getFileds和getDeclaredFields用法同上（参照Method）</span><br></pre></td></tr></table></figure><font color="red"><strong>但是获取私有属性的时候必须先设置Accessible为true，然后才能获取。</strong></font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hello hello3 =<span class="keyword">new</span> Hello();</span><br><span class="line">Class&lt;?&gt; t3 = hello.getClass();<span class="comment">//找到了封装的Class类对象.</span></span><br><span class="line">Field f = t3.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">f.setAccessible(<span class="keyword">true</span>); <span class="comment">//要先设置这个!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">f.set(hello3,<span class="string">"123"</span>);</span><br><span class="line">System.out.println(hello3.toString());</span><br></pre></td></tr></table></figure><h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><p>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:   <em>调用方法，必须传入对象实例</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">           InvocationTargetException</span></span><br><span class="line"><span class="function"> <span class="comment">//obj是指定哪个对象调用,args是传入的参数.</span></span></span><br></pre></td></tr></table></figure><p>下面是一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例2</span></span><br><span class="line">Hello hello1 =<span class="keyword">new</span> Hello();</span><br><span class="line">Class&lt;?&gt; t = hello.getClass();<span class="comment">//找到了封装的Class类对象.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Method m = t.getMethod(<span class="string">"method1"</span>,String.class);<span class="comment">//method1 是方法的名字</span></span><br><span class="line">  Hello hello2 = (Hello) t.newInstance();<span class="comment">// Hello对象</span></span><br><span class="line">  Object re =   m.invoke(hello2,<span class="string">"sss"</span>); <span class="comment">//反射调用方法</span></span><br><span class="line">  System.out.println(re);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; klass = methodClass.class;</span><br><span class="line">        <span class="comment">//创建methodClass的实例</span></span><br><span class="line">        Object obj = klass.newInstance();</span><br><span class="line">        <span class="comment">//获取methodClass类的add方法</span></span><br><span class="line">        Method method = klass.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">//调用method对应的方法 =&gt; add(1,4)</span></span><br><span class="line">        Object result = method.invoke(obj,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">methodClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> f = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射的应用之注解"><a href="#反射的应用之注解" class="headerlink" title="反射的应用之注解"></a>反射的应用之注解</h3><p>从原理上讲，注解处理器就是通过反射机制获取被检查方法上的注解信息，然后根据注解元素的值进行特定的处理。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap</title>
      <link href="/2017/11/30/ConcurrentHashMap/"/>
      <url>/2017/11/30/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h3 id="ConcurrentHashMap的实现原理与使用"><a href="#ConcurrentHashMap的实现原理与使用" class="headerlink" title="ConcurrentHashMap的实现原理与使用"></a>ConcurrentHashMap的实现原理与使用</h3><p>ConcurrentHashMap是线程安全且高效的HashMap,并发编程中使用HashMap可能导致程序死循环，线程安全的HashTable效率低下，基于上述原因，有了ConcurrentHashMap.</p><p>HashTable容器效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁,假如容器里有多把锁,每一把锁用于锁容器其中一部分数据,那么当多线程访问容器里不同数据段的数据时,线程间就不会存在锁竞争,从而可以有效提高并发访问效率,这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储,然后给每一段数据配一把锁,当一个线程占用锁访问其中一个段数据的时候,其他段的数据也能被其他线程访问。</p><a id="more"></a><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁, 在ConcurrentHashMap里扮演锁的角色; HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。</p><p>segment 本身就相当于一个HashMap对象</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/171207.png" alt=""></p><p>像这样的Segment对象，有2的N次方个，共同保存在一个名为segments的数组中。</p><p>所以可以说，ConcurrentHashMap是一个二级哈希表，在一个总的哈希表下面，有若干个子哈希表。</p><p>Segment的结构和HashMap类似,是一种数组和链表结构。一个Segment里包含一个HashEntry数组,每个HashEntry是一个链表结构的元素,每个Segment守护着一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时,必须首先获得与它对应的Segment锁,如下图所示。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/17113001.png" alt=""></p><p>ConcurrentHashMap的优势就是采用了锁分段技术，每一个Segment就像一个自治区，读写操作高度自治，segement之间互不影响。</p><h4 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h4><p>初始化方法通过initialCapacity，loadFactor和concurrencyLevel等几个参数来初始化Segment数组，段偏移量segmentshift,段掩码segmentMask 和每个Segment里的HashEntry数组。</p><h4 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h4><p>ConcurrentHashMap使用分段锁来保护不同段的数据，在插入和获取的时候，必须先通过散列算法定位到Segment，所以可以直到ConcurrentHashMap会首先使用Wang/Jenkins hash 的变种算法对元素的hashCode进行一次再散列。进行再散列的目的是为了减少散列冲突，使元素可以均匀的分布在不同的Segment中，从而提升容器存储效率。</p><h4 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h4><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><p>get的高效之处在于整个get过程没有加锁，除非读到空值才会加锁重读，ConcurrentHashMap中的get方法里要使用的共享变量都被定义为volatile类型，volatile类型的变量可以在线程间保持可见性。能够同时被多线程读。并且不会读到过期的值，但是只能被单线程写。get操作里只需要读不需要写，所以可以不用加锁。</p><p>get过程为</p><ul><li>为输入的key做哈希运算，得到Hash值。</li><li>通过hash值，定位到对应的Segment对象</li><li>再次通过hash值，定位到Segment当中数组的具体位置。</li></ul><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><p>put要对共享变量进行写入操作，所以为了线程安全，在操作共享变量的时候必须加锁，put方法首先定位到Segment，然后在Segment里进行插入操作，插入操作需要经过两个步骤，第一步需要对Segment里的hashEntry数组进行扩容，第二部需要定位添加元素的位置，然后将其放在HashEntry数组里。</p><p>put 过程为</p><ul><li>为输入的key做hash运算，得到hash值</li><li>通过hash值，定位到Segment对象</li><li>获取可重入锁</li><li>再次通过hash值，定位到Segment中数组的具体位置</li><li>插入或者覆盖HashEntry对象</li><li>释放锁</li></ul><h5 id="size"><a href="#size" class="headerlink" title="size"></a>size</h5><p>要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和，Segment里的全局变量count是一个volatile变量。不能把所有Segment里的count相加得到size,因为可能累加前使用的count发生了变化。</p><p>最安全的做法是统计size时，把所有Segment的put,remove,clean方法全锁住，但是这样十分低效</p><p>ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小,如果统计的过程中,容器的count发生了变化,则再采用加锁的方式来统计所有Segment的大小。那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢?使用modCount变量,在put、remove和clean方法里操作元素前都会将变量modCount进行加1,那么在统计size前后比较modCount是否发生变化,从而得知容器的大小是否发生变化。（乐观锁的思想）</p><p>size方法过程</p><ul><li>遍历所有的Segment</li><li>把Segment的元素数量累加起来</li><li>把Segment的修改次数累加起来</li><li>判断所有Segment的总修改次数是否大于上一次的总修改次数，如果大于，说明统计过程中有修改，重新统计，尝试次数加1，如果不是，说明没有修改，统计结束。</li><li>如果尝试次数超过阀值，则对每一个Segment加锁，再重新统计。</li><li>再次判断所有Segment的总修改次数是否大于上一次的总修改次数，由于已经加锁，次数一定和上次相等。</li><li>释放锁，统计结束。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string stringbuffer stringbuilder 区别</title>
      <link href="/2017/11/29/string-stringbuffer-stringbuilder-%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/11/29/string-stringbuffer-stringbuilder-%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="string-stringbuffer-stringbuilder-区别"><a href="#string-stringbuffer-stringbuilder-区别" class="headerlink" title="string stringbuffer stringbuilder 区别"></a>string stringbuffer stringbuilder 区别</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>String 字符串常量 StringBuffer 字符串变量(线程安全) StringBuilder 字符串变量(非线程安全)</p><h3 id="执行速度"><a href="#执行速度" class="headerlink" title="执行速度"></a>执行速度</h3><p>StringBuilder&gt;StringBuffer&gt;String</p><p>String类型和StringBuffer类型的主要性能区别在于String是不可变的对象，因此每次对String类型进行改变的时候其实等统一生成了一个新的String对象，然后将指针指向新的String对象，所以经常改变内容的字符串最后不要String，因为每次生成对象都会对系统性能产生影响，内存中无引用多了后，还会进行GC，速度就相当慢了。</p><p>StringBuffer结果就不同了，StringBuffer每次都是对对象本身进行操作的，所以一般情况下推荐使用StringBuffer.</p><p>某些特殊情况下，String的字符串拼接被JVM解释成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String S1 = “This is only a” + “ simple” + “ test”;</span><br><span class="line">在JVM中，S1被解释成</span><br><span class="line">String S1 = “This is only a simple test”; <span class="comment">//所以快。</span></span><br><span class="line">StringBuffer Sb = <span class="keyword">new</span> StringBuilder(“This is only a”).append(“ simple”).append(“ test”);</span><br><span class="line">---------------------------------</span><br><span class="line">String str2 = “This is only a”;</span><br><span class="line">String str3 = “ simple”;</span><br><span class="line">String str4 = “ test”;</span><br><span class="line">String str1 = str2 +str3 + str4;</span><br><span class="line"><span class="comment">//这时候JVM会规规矩矩的按照原来的方式去做。</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>StringBuilder：线程非安全的</p><p>StringBuffer：线程安全的</p><p>　　当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的，就是速度的原因。</p><h3 id="StringBuffer常用API"><a href="#StringBuffer常用API" class="headerlink" title="StringBuffer常用API"></a>StringBuffer常用API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span><span class="comment">//</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span>/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">append</span><span class="params">(StringBuffer sb)</span><span class="comment">// append 添加任意类型。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">IndexOf</span><span class="params">(String str)</span><span class="comment">// 查找指定字符串是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">IndexOf</span><span class="params">(String str,<span class="keyword">int</span> fromIndex)</span> <span class="comment">//从指定位置查找字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">indsert</span><span class="params">(<span class="keyword">int</span> offset,String str)</span><span class="comment">//指定位置插入字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">()</span> <span class="comment">//翻转</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,String str)</span><span class="comment">//指定内容替换</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="comment">//长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span><span class="comment">// 删除指定范围字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span><span class="comment">//截取指定范围</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2017/11/27/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/11/27/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式——观察者模式"><a href="#设计模式——观察者模式" class="headerlink" title="设计模式——观察者模式"></a>设计模式——观察者模式</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><h3 id="针对的问题"><a href="#针对的问题" class="headerlink" title="针对的问题"></a>针对的问题</h3><p>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。</p><a id="more"></a><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>解除耦合，让耦合的双方都依赖于抽象，从而使得各自的变换都不会影响另一边的变换。</p><p><strong>缺点</strong>在应用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，而且在Java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。</p><h3 id="涉及角色"><a href="#涉及角色" class="headerlink" title="涉及角色"></a>涉及角色</h3><p><img src="http://blog-1252095801.cosgz.myqcloud.com/171127.png" alt=""></p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li><li>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们可以拿微信公众号来举例，假设微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号，当这个公众号更新时就会通知这些订阅的微信用户。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象观察者Observer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体观察者ConcrereObserver</span></span><br><span class="line">Public <span class="class"><span class="keyword">class</span> <span class="title">weixinuser</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">weixinuser</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    System.out.println(name+message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象被观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">/*增加订阅者*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">  <span class="comment">/*删除订阅者*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">  <span class="comment">/*通知订阅者更新信息*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体被观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">gongzhonghao</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    weixinUserlist.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    weixinUserlist.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Observer o:weixinUserlist)</span><br><span class="line">    &#123;</span><br><span class="line">      observer.update(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Subject gong =<span class="keyword">new</span> gongzhonghao();</span><br><span class="line">      WeixinUser user1=<span class="keyword">new</span> WeixinUser(<span class="string">"A"</span>);</span><br><span class="line">        WeixinUser user2=<span class="keyword">new</span> WeixinUser(<span class="string">"B"</span>);</span><br><span class="line">        WeixinUser user3=<span class="keyword">new</span> WeixinUser(<span class="string">"C"</span>);</span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        gong.attach(user1);</span><br><span class="line">        gong.attach(user2);</span><br><span class="line">        gong.attach(user3);</span><br><span class="line">        <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line">        gong.notify(<span class="string">"更新了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出</span><br><span class="line">A-更新了</span><br><span class="line">B-更新了</span><br><span class="line">C-更新了</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>120. Triangle</title>
      <link href="/2017/11/27/leetcode120/"/>
      <url>/2017/11/27/leetcode120/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the following triangle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>The minimum path sum from top to bottom is <code>11</code> (i.e., 2 + 3 + 5 + 1 = 11).</p><p><strong>Note:</strong><br>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>给定一个三角形，输出从顶到下面最短的路径，求出最短值。<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> results;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(triangle.size(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> hang =triangle.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=hang<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=triangle[i].size()<span class="number">-1</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                 res[j] = min(res[j],res[j+<span class="number">1</span>])+ triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>因为是求最值，所以是典型的动态规划。</p><p>此题要求辅助空间为o(n).若采取从上往下的动态规划策略，需要两维的数组保存值。（再想想怎么感觉一维也行，但是更复杂，因为需要判断是否有左父亲节点和右父亲节点）</p><p>简单的动态规划，假如我们用minimus[i][j]来表示从第i行第j列处的数字开始往下到最后一层的最小路径和，那么有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minimus[i][j]=data[i][j]+min(minimums[i+<span class="number">1</span>][j]+minimums[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>然而上述描述中需要一个O（n^2）的额外空间，接下来我们来解决这个问题。</p><p>由于我们在公式里需要递归求解子问题，那么我们不妨反过来想一下，先求解子问题，然后再解决父问题。即，<strong>从下往上求解最小路径和</strong>。我们可以发现如下规律，当我们求解minimum[i][j]时，我们会用到minimum[i+1][j]和minimum[i+1][j+1]，但是当求解完所有minimum[i]之后minimum[i+1]就没有用处了。既然如此，我们可以复用同一个空间来存储minimum的值。进一步观察发现，存储最后一行的每个数字的最小路径和需要n个空间，因此至少我们需要n个空间，这也是题目里给出O（n）的空间复杂度的原因；之后存储倒数第二行时，我们只需要前面的n-1个空间……以此类推，第一行只需要一个空间来存储最小路径和，这也正是我们要求解的结果。</p><p>观察代码，先对最后一行进行赋值(最后一行的最小值就是三角形最后一行的值，这是动态规划的初始化赋值)</p><p>然后到达上一层后，求出到达倒数第二层中每个点的最小值，进行更新res,然后倒数第三层，以此类推。最后，到达的就是整体的最小值。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap 简单使用记录</title>
      <link href="/2017/11/26/bootstrap%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/11/26/bootstrap%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap 实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jumbotron"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个 Bootstrap 页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>重置窗口大小，查看响应式效果！<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.container &#123;</span><br><span class="line">   padding-right: 15px;</span><br><span class="line">   padding-left: 15px;</span><br><span class="line">   margin-right: auto;</span><br><span class="line">   margin-left: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网格系统"><a href="#网格系统" class="headerlink" title="网格系统"></a>网格系统</h3><p>Bootstrap 包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到 12 列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类。</p><h5 id="基本网格结构"><a href="#基本网格结构" class="headerlink" title="基本网格结构"></a>基本网格结构</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-*-*"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-*-*"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="模态框"><a href="#模态框" class="headerlink" title="模态框"></a>模态框</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap 实例 - 模态框（Modal）插件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span> <span class="attr">style</span>=<span class="string">"text-align: center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>创建模态框（Modal）<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按钮触发模态框(这个按钮相当于触发器) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary btn-lg"</span> <span class="attr">data-toggle</span>=<span class="string">"modal"</span> <span class="attr">data-target</span>=<span class="string">"#myModal"</span>&gt;</span></span><br><span class="line">    开始演示模态框</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 模态框（Modal） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal fade"</span> <span class="attr">id</span>=<span class="string">"myModal"</span> <span class="attr">tabindex</span>=<span class="string">"-1"</span> <span class="attr">role</span>=<span class="string">"dialog"</span> <span class="attr">aria-labelledby</span>=<span class="string">"myModalLabel"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-dialog"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-content"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-header"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"close"</span> <span class="attr">data-dismiss</span>=<span class="string">"modal"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">                    &amp;times;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"modal-title"</span> <span class="attr">id</span>=<span class="string">"myModalLabel"</span>&gt;</span></span><br><span class="line">                    模态框（Modal）标题</span><br><span class="line">                <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-body"</span>&gt;</span></span><br><span class="line">                在这里添加一些文本</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-footer"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">data-dismiss</span>=<span class="string">"modal"</span>&gt;</span>关闭</span><br><span class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span></span><br><span class="line">                    提交更改</span><br><span class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- /.modal-content --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- /.modal --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>data-toggle=&quot;modal&quot; data-target=&quot;#myModal&quot;</code> 的作用分别是以什么条件触发，触发的目标。</p><p><code>tabindex</code>的作用是用户使用tab键会切换目标。</p><p><code>role,aria-labelledby,aria-hidden</code>主要是为了方便盲人所用。</p><ul><li><strong>aria-labelledby=”myModalLabel”</strong>，该属性引用模态框的标题。</li><li>属性 <strong>aria-hidden=”true”</strong> 用于保持模态窗口不可见，直到触发器被触发为止（比如点击在相关的按钮上）。</li></ul><p><code>&amp;times;</code>会被转义成<code>x</code></p><h4 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap 实例 - 标签页（Tab）插件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myTab"</span> <span class="attr">class</span>=<span class="string">"nav nav-tabs"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#home"</span> <span class="attr">data-toggle</span>=<span class="string">"tab"</span>&gt;</span></span><br><span class="line"> 菜鸟教程</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#ios"</span> <span class="attr">data-toggle</span>=<span class="string">"tab"</span>&gt;</span>iOS<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dropdown"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">id</span>=<span class="string">"myTabDrop1"</span> <span class="attr">class</span>=<span class="string">"dropdown-toggle"</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">data-toggle</span>=<span class="string">"dropdown"</span>&gt;</span>Java </span><br><span class="line"><span class="tag">&lt;<span class="name">b</span> <span class="attr">class</span>=<span class="string">"caret"</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"dropdown-menu"</span> <span class="attr">role</span>=<span class="string">"menu"</span> <span class="attr">aria-labelledby</span>=<span class="string">"myTabDrop1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#jmeter"</span> <span class="attr">tabindex</span>=<span class="string">"-1"</span> <span class="attr">data-toggle</span>=<span class="string">"tab"</span>&gt;</span>jmeter<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#ejb"</span> <span class="attr">tabindex</span>=<span class="string">"-1"</span> <span class="attr">data-toggle</span>=<span class="string">"tab"</span>&gt;</span>ejb<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myTabContent"</span> <span class="attr">class</span>=<span class="string">"tab-content"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab-pane fade in active"</span> <span class="attr">id</span>=<span class="string">"home"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>菜鸟教程是一个提供最新的web技术站点，本站免费提供了建站相关的技术文档，帮助广大web技术爱好者快速入门并建立自己的网站。菜鸟先飞早入行——学的不仅是技术，更是梦想。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab-pane fade"</span> <span class="attr">id</span>=<span class="string">"ios"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>iOS 是一个由苹果公司开发和发布的手机操作系统。最初是于 2007 年首次发布 iPhone、iPod Touch 和 Apple </span><br><span class="line">TV。iOS 派生自 OS X，它们共享 Darwin 基础。OS X 操作系统是用在苹果电脑上，iOS 是苹果的移动版本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab-pane fade"</span> <span class="attr">id</span>=<span class="string">"jmeter"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>jMeter 是一款开源的测试软件。它是 100% 纯 Java 应用程序，用于负载和性能测试。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab-pane fade"</span> <span class="attr">id</span>=<span class="string">"ejb"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Enterprise Java Beans（EJB）是一个创建高度可扩展性和强大企业级应用程序的开发架构，部署在兼容应用程序服务器（比如 JBOSS、Web Logic 等）的 J2EE 上。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2017/11/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/11/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://blog.csdn.net/nsw911439370/article/details/50456231" target="_blank" rel="noopener">http://blog.csdn.net/nsw911439370/article/details/50456231</a></p></blockquote><h1 id="设计模式——单例模式"><a href="#设计模式——单例模式" class="headerlink" title="设计模式——单例模式"></a>设计模式——单例模式</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，<em>可以直接访问，不需要实例化该类的对象</em>。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。</li></ul><p>单例类就是实体类，这个类里有自己的构造方法，但是只能有一个实例。单例类提供了一种访问其唯一的对象的方式。</p><a id="more"></a><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><h3 id="关键代码：构造函数是私有的。"><a href="#关键代码：构造函数是私有的。" class="headerlink" title="关键代码：构造函数是私有的。"></a>关键代码：构造函数是私有的。</h3><p><strong>应用实例：</strong> 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p><p><strong>优点：</strong> 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。</p><p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><strong>使用场景：</strong> 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p><p><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p><img src="http://blog-1252095801.cosgz.myqcloud.com/17112602.png" alt=""></p><p>我们将创建一个 <em>SingleObject</em> 类（单例类）。<em>SingleObject</em> 类有它<strong>的私有构造函数和本身的一个静态实例</strong>。</p><p><em>SingleObject</em> 类提供了一个静态方法，供外界获取它的静态实例。<em>SingletonPatternDemo</em>，我们的演示类使用 <em>SingleObject</em> 类来获取 <em>SingleObject</em> 对象。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>&#123;</span><br><span class="line">   <span class="comment">//创建 SingleObject 的一个对象，因为statics修饰，在类被初始化的时候会自动执行new SingleObject()</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line">   <span class="comment">//让构造函数为 private，这样该类就不会被外部实例化！！！！！！！！！！！！！</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">   <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//通过getinstance()获取唯一可用的对象。</span></span><br><span class="line">      SingleObject object = SingleObject.getInstance();</span><br><span class="line">      <span class="comment">//显示消息</span></span><br><span class="line">      object.showMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式的实现方法"><a href="#单例模式的实现方法" class="headerlink" title="单例模式的实现方法"></a>单例模式的实现方法</h3><h3 id="1、懒汉式，线程不安全"><a href="#1、懒汉式，线程不安全" class="headerlink" title="1、懒汉式，线程不安全"></a>1、懒汉式，线程不安全</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>否</p><p><strong>实现难度：</strong>易</p><p><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p><p><strong>代码实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、懒汉式，线程安全"><a href="#2、懒汉式，线程安全" class="headerlink" title="2、懒汉式，线程安全"></a>2、懒汉式，线程安全</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><p><strong>描述：</strong>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br>优点：第一次调用才初始化，避免内存浪费。<br>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p><p><strong>代码实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、饿汉式"><a href="#3、饿汉式" class="headerlink" title="3、饿汉式"></a>3、饿汉式</h3><p><strong>是否 Lazy 初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><p><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。<br>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p><p><strong>代码实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4、双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4、双检锁/双重校验锁（DCL，即 double-checked locking）"></a>4、双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p><strong>JDK 版本：</strong>JDK1.5 起</p><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>较复杂</p><p><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p><p><strong>代码实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>105&amp;106. Construct Binary Tree from Preorder and Inorder Traversal and Inorder and Preorder</title>
      <link href="/2017/11/26/leetcode105&amp;106/"/>
      <url>/2017/11/26/leetcode105&amp;106/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>给定一颗树的前序和中序序列，重建二叉树。返回根结点。</p><a id="more"></a><h5 id="首先，注意，vector-begin-指向第一个数，end-指向的是最后一个数的后一位。"><a href="#首先，注意，vector-begin-指向第一个数，end-指向的是最后一个数的后一位。" class="headerlink" title="首先，注意，vector.begin()指向第一个数，end()指向的是最后一个数的后一位。"></a>首先，注意，vector.begin()指向第一个数，end()指向的是最后一个数的后一位。</h5><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, preorder.begin(), preorder.end(), inorder, inorder.begin(), inorder.end());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator end1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin2,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator end2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin1&gt;=end1|| begin2&gt;=end2)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> value = *begin1;</span><br><span class="line">        TreeNode *pNode =<span class="keyword">new</span> TreeNode(value);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(begin2, end2, value);  </span><br><span class="line">        <span class="keyword">int</span> leftlength =it - begin2;</span><br><span class="line">        pNode-&gt;left = helper(pre,begin1+<span class="number">1</span>,begin1+<span class="number">1</span>+leftlength,in,begin2,it);</span><br><span class="line">        pNode-&gt;right= helper(pre,begin1+<span class="number">1</span>+leftlength,end1,in,it+<span class="number">1</span>,end2);</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用递归，在已知前序和中序时</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/171126.png" alt=""></p><p>先序的第一个数一定是根节点，在中序中找相同的数，就可以把中序序列分为两半，然后记录下在中序的指针，计算左边结点的个数，然后使用递归。</p><h2 id="106-已知中序和后序，还原二叉树"><a href="#106-已知中序和后序，还原二叉树" class="headerlink" title="106 已知中序和后序，还原二叉树"></a>106 已知中序和后序，还原二叉树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(inorder,inorder.begin(),inorder.end(),postorder,postorder.begin(),postorder.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator end1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; post,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin2,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator end2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin1&gt;=end1||begin2&gt;=end2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> value = *(end2<span class="number">-1</span>);</span><br><span class="line">        TreeNode *pnode = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(begin1,end1,value);</span><br><span class="line">        <span class="keyword">int</span> leftlength = it-begin1;</span><br><span class="line">        pnode-&gt;left = helper(in,begin1,it,post,begin2,begin2+leftlength);</span><br><span class="line">        pnode-&gt;right = helper(in,it+<span class="number">1</span>,end1,post,begin2+leftlength,end2<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> pnode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java动态代理</title>
      <link href="/2017/11/24/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2017/11/24/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513926&amp;idx=1&amp;sn=1c43c5557ba18fed34f3d68bfed6b8bd&amp;chksm=80d67b85b7a1f2930ede2803d6b08925474090f4127eefbb267e647dff11793d380e09f222a8#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513926&amp;idx=1&amp;sn=1c43c5557ba18fed34f3d68bfed6b8bd&amp;chksm=80d67b85b7a1f2930ede2803d6b08925474090f4127eefbb267e647dff11793d380e09f222a8#rd</a></p></blockquote><p>在java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个接口和类是实现我们动态代理所必须用到的。</p><ul><li><p>InvocationHandler接口</p><p><strong>（代理的方法调用会被转发到InvocationHandler的invoke()方法）</strong>。</p><p>proxy 动态产生的代理会调用InvocationHandler实现类，所以InvocationHandler 是实际执行者。</p><p>InvocationHandler接口是代理处理程序类的实现接口，该接口作为代理实例的调用处理者的公共父类，每一个代理类的实例都可以提供一个相关的具体调用处理者（InvocationHandler接口的子类）。在该接口中声明了如下方法：public Object invoke(Objectproxy, Method method, Object[] args)：该方法用于处理对代理类实例的方法调用并返回相应的结果，当一个代理实例中的业务方法被调用时将自动调用该方法。</p></li></ul><p>​        动态代理类需要在运行时指定所代理真实主题类的接口，客户端在调用动态代理对象的方法时，调用请求会将请求自动转发给InvocationHandler对象的invoke()方法，由invoke()方法来实现对请求的统一处理。</p><p><strong>每一个动态代理类都必须要实现InvocationHandler这个接口</strong>，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。InvocationHandler这个接口的唯一一个方法 invoke 方法。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">proxy:　指代我们所代理的那个真实对象。</span></span><br><span class="line"><span class="function">method: 指代的是我们所要调用真实对象的某个方法的Method对象。</span></span><br><span class="line"><span class="function">args:　 指代的是调用真实对象某个方法时接受的参数。</span></span><br></pre></td></tr></table></figure><ul><li>Proxy类</li></ul><p><strong>Proxy这个类的作用就是用来动态创建一个代理对象的类</strong>，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法。<strong>这个方法的作用就是得到一个动态的代理对象</strong>，其接收三个参数，我们来看看这三个参数所代表的含义：(<strong>本质还是通过字节码增强技术生成一个适配原来接口的新的代理类</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">loader:　　一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载</span></span><br><span class="line"><span class="function">interfaces:　　一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口<span class="params">(多态)</span>，这样我就能调用这组接口中的方法了</span></span><br><span class="line"><span class="function">h: 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</span></span><br></pre></td></tr></table></figure><h4 id="Proxy-为什么可以动态产生不同接口类型的代理呢？"><a href="#Proxy-为什么可以动态产生不同接口类型的代理呢？" class="headerlink" title="Proxy 为什么可以动态产生不同接口类型的代理呢？"></a>Proxy 为什么可以动态产生不同接口类型的代理呢？</h4><p>因为newProxyInstanse 创建了一个实例，是通过cl这个class文件的构造方法反射生成，cl由getProxyClass0()方法获取。</p><h4 id="为什么代理类的方法会被转发到Invocation的invoke-上"><a href="#为什么代理类的方法会被转发到Invocation的invoke-上" class="headerlink" title="为什么代理类的方法会被转发到Invocation的invoke 上"></a>为什么代理类的方法会被转发到Invocation的invoke 上</h4><p>因为动态创建的代理类在创建的时候关联了InvocationHandler和要实现的接口。要实现的接口和代理类有关，所以就关联上了。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>首先我们定义了一个Subject类型的接口，为其声明了两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I want to rent my house"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello: "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以复用的中间类.告诉代理类加的方法写在什么地方,专门添加日志用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject realSubject;</span><br><span class="line">    <span class="comment">//这里用的是接口,所以可以复用.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoggerHandler</span><span class="params">(Subject realSubject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realSubject = realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//在代理真实对象前我们可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before rent house"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Method:"</span> + method);</span><br><span class="line">        <span class="comment">//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">        method.invoke(realSubject, args);</span><br><span class="line">        <span class="comment">//　　在代理真实对象后我们也可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after rent house"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LoggerHandler 是方法调用的实际处理者，生成代理对象时第三个参数就是填入的实际处理者，然后代理对象的方法调用都会转发到这里。</p><p>client 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//    我们要代理的真实对象</span></span><br><span class="line">        Subject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">       <span class="comment">//    我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的</span></span><br><span class="line">        <span class="comment">//MyProxy是一个可复用的类,位于动态代理类和原始类之间.动态代理类会调用它的方法</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> Loggerhandler(realSubject);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过Proxy类的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数</span></span><br><span class="line"><span class="comment">         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象</span></span><br><span class="line"><span class="comment">         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，</span></span><br><span class="line"><span class="comment">         * 表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了</span></span><br><span class="line"><span class="comment">         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上,</span></span><br><span class="line"><span class="comment">         ！！！！也就是方法调用的实际处理者</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//newProxyInstance()作用得到一个动态代理对象.</span></span><br><span class="line">        Subject proxysubject = (Subject) Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); <span class="comment">//这句话创建了动态代理对象.</span></span><br><span class="line">        <span class="comment">//System.out.println(subject.getClass().getName());</span></span><br><span class="line">        proxysubject.rent();</span><br><span class="line">        System.out.println(<span class="string">"***********"</span>);</span><br><span class="line">        proxysubject.hello(<span class="string">"world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输出</span><br><span class="line">$Proxy0</span><br><span class="line"></span><br><span class="line">before rent house</span><br><span class="line">Method:public abstract void com.xiaoluo.dynamicproxy.Subject.rent()</span><br><span class="line">I want to rent my house</span><br><span class="line">after rent house</span><br><span class="line"></span><br><span class="line">before rent house</span><br><span class="line">Method:public abstract void com.xiaoluo.dynamicproxy.Subject.hello(java.lang.String)</span><br><span class="line">hello: world</span><br><span class="line">after rent house</span><br></pre></td></tr></table></figure><p>我们首先来看看 $Proxy0 这东西，我们看到，这个东西是由 System.out.println(subject.getClass().getName()); 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject</span><br><span class="line">                .getClass().getInterfaces(), handler);</span><br></pre></td></tr></table></figure><p>可能我以为返回的这个代理对象会是Subject类型的对象，或者是InvocationHandler的对象，结果却不是，首先我们解释一下<strong>为什么我们这里可以将其转化为Subject类型的对象？</strong>原因就是在newProxyInstance这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是Subject类型，所以就可以将其转化为Subject类型了。</p><p><strong>同时我们一定要记住，通过 Proxy.newProxyInstance 创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号</strong>。</p><p><code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法简单来说执行了以下操作：</p><ul><li>1、生成一个实现了参数 interfaces 里所有接口且继承了 Proxy 的代理类的字节码，然后用参数里的 classLoader 加载这个代理类。</li><li>2、使用代理类父类的构造函数 Proxy(InvocationHandler h) 来创造一个代理类的实例，将我们自定义的 InvocationHandler 的子类传入。</li><li>3、返回这个代理类实例.</li></ul><p>接着我们来看看这两句 </p><p>subject.rent();<br>subject.hello(“world”);</p><p>这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的invoke方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的invoke方法去执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object object, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//　　在代理真实对象前我们可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before rent house"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"Method:"</span> + method);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//    当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">        method.invoke(subject, args);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//　　在代理真实对象后我们也可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after rent house"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> com.xiaoluo.dynamicproxy.Subject.rent()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> com.xiaoluo.dynamicproxy.Subject.hello(java.lang.String)</span><br></pre></td></tr></table></figure><p>正好就是我们的Subject接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的invoke方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。</p><p>这就是我们的java动态代理机制</p><p>动态代理两类实现</p><p>基于接口的代理和基于继承的代理 JDK代理和Cglib代理</p><h5 id="JDK代理"><a href="#JDK代理" class="headerlink" title="JDK代理"></a>JDK代理</h5><p>1 通过java.lang.reflect.Proxy 动态生成代理类</p><p>2 代理类需要实现InvocationHandler 接口，</p><p>3 只能基于接口进行动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"request"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">动态代理类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//动态代理的实现类还是要引用目标对象</span></span><br><span class="line"><span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JDKProxy</span><span class="params">(RealSubject realsubject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.realSubject =realSubject;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="meta">@OVerride</span></span><br><span class="line">  <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//函数里执行动态代理的逻辑</span></span><br><span class="line">    System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    <span class="comment">//使用反射调用目标对象的方法</span></span><br><span class="line">    Object result =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = method.invoke(realSubject,args); <span class="comment">// 传入对象和参数。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">      System.out.println(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">client</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//传当前的classLoader就行，把接口传进来。handler传进来</span></span><br><span class="line">        Subject subject =Proxy.newProxyInstance(Client.class.getClassLoader(),</span><br><span class="line">                       <span class="keyword">new</span> Class[]&#123;Subject.class&#125;,<span class="keyword">new</span> JDKProxy(<span class="keyword">new</span> RealSubject()));    subject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理时，接口里每增加一个方法，realsubject要实现一遍，关键的是代理类还是要实现一遍，但是动态代理就自己写代码实现了，这样就使代理量减少。</p><h3 id="字节码增强技术"><a href="#字节码增强技术" class="headerlink" title="字节码增强技术"></a>字节码增强技术</h3><p>Java字节码增强指的是<strong>在Java字节码生成之后，对其进行修改</strong>，增强其功能，这种方式相当于对应用程序的二进制文件进行修改。Java字节码增强主要是为了减少冗余代码，提高性能等。</p><p>​    实现字节码增强的主要步骤为：</p><ul><li><p>修改字节码</p><p> 在内存中获取到原来的字节码，然后通过一些工具（如 ASM，Javaasist）来修改它的byte[]数组，得到一个新的byte数组。</p></li><li><p>使修改后的字节码生效</p></li></ul><p>​    有两种方法：</p><p>   1） 自定义ClassLoader来加载修改后的字节码；</p><p>   2）替换掉原来的字节码：在JVM加载用户的Class时，拦截，返回修改后的字节码；或者在运行时，使用Instrumentation.redefineClasses方法来替换掉原来的字节码；</p><h3 id="动态代理与静态代理"><a href="#动态代理与静态代理" class="headerlink" title="动态代理与静态代理"></a>动态代理与静态代理</h3><p>每个代理类只能为一个接口服务，这样程序开发中必然会产生许多的代理类. 所以可以通过一个代理类完成全部的代理功能，那么我们就需要用动态代理.</p><p>一个代理只能代理一种类型，而且是在编译期就已经确定被代理的对象。而动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象</p><p>动态代理可以传入不同的对象实现相同的重复功能(比如前面的加日志操作)</p><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使我们的类职责更加单一，复用性更强.</p><h3 id="Cglib-动态代理技术"><a href="#Cglib-动态代理技术" class="headerlink" title="Cglib 动态代理技术"></a>Cglib 动态代理技术</h3><p>JDK代理要求被代理的类必须实现接口，有很强的局限性。而CGLIB动态代理则没有此类强制性要求。简单的说，CGLIB会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。在CGLIB底层，其实是借助了ASM这个非常强大的Java字节码生成框架。</p><h4 id="生成代理类对象"><a href="#生成代理类对象" class="headerlink" title="生成代理类对象"></a>生成代理类对象</h4><p>代理类对象是由<strong>Enhancer</strong>类创建的。Enhancer是CGLIB的字节码增强器，可以很方便的对类进行拓展，如图1.3中的为类设置Superclass。</p><p><em>创建代理对象的几个步骤:</em></p><ul><li>生成代理类的二进制字节码文件；</li><li>加载二进制字节码，生成Class对象( 例如使用Class.forName()方法 )；</li><li>通过反射机制获得实例构造，并创建代理类对象</li></ul><h4 id="对委托类进行代理"><a href="#对委托类进行代理" class="headerlink" title="对委托类进行代理"></a>对委托类进行代理</h4><p>下面总结一下CGLIB在进行代理的时候都进行了哪些工作</p><ul><li>生成的代理类<em>HelloServiceImpl$$EnhancerByCGLIB$$82ef2d06</em>继承被代理类<em>HelloServiceImpl</em>。在这里我们需要注意一点：如果委托类被final修饰，那么它不可被继承，即不可被代理；同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理；</li><li>代理类会为委托方法生成两个方法，一个是重写的<em>sayHello</em>方法，另一个是<em>CGLIB$sayHello$0</em>方法，我们可以看到它是直接调用父类的<em>sayHello</em>方法；</li><li>当执行代理对象的<em>sayHello</em>方法时，会首先判断一下是否存在实现了<em>MethodInterceptor</em>接口的CGLIB$CALLBACK_0;，如果存在，则将调用<em>MethodInterceptor</em>中的<em>intercept</em>方法，</li></ul><p>在JDK动态代理中方法的调用是通过反射来完成的。但是<strong>在CGLIB中，方法的调用并不是通过反射来完成的，而是直接对方法进行调用 </strong>:底层将方法全部存入一个数组中，通过数组索引直接进行方法调用。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSR 303 校验</title>
      <link href="/2017/11/24/JSR-303-%E6%A0%A1%E9%AA%8C/"/>
      <url>/2017/11/24/JSR-303-%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="JSR-303-校验"><a href="#JSR-303-校验" class="headerlink" title="JSR 303 校验"></a>JSR 303 校验</h1><h3 id="首先添加maven库。"><a href="#首先添加maven库。" class="headerlink" title="首先添加maven库。"></a>首先添加maven库。</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;mvc:annotation-driven/&gt;</code>会默认装配一个LocalValidatorFactoryBean ,通过在处理方法的入参上标注@Valid注解，即可让SpringMVC在完成数据绑定后执行数据校验工作。</p><a id="more"></a><p>在表单对象类的属性中标准校验注解，在处理方法对应的入参前添加@Valid，SpringMVC就会实施校验并将校验结果保存在被校验入参对象之后的BindingResult或者Errors中。</p><p>pojo</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/171124.png" alt=""></p><p>controller</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/17112401.png" alt=""></p><p>view</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/17112402.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC 文件上传与SpringMVC拦截器</title>
      <link href="/2017/11/24/SpringMVC%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2017/11/24/SpringMVC%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>为了能上传文件，必须将表单的method设为POST， 并将enctype设置为multipart/form-data，只有在这种情况下，浏览器才会把用户选择的文件二进制数据发送给服务器。</p><p>SpringMVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。</p><p>SpringMVC会将上传文件绑定到MultipartFile对象中。这个对象提供了上传文件内容，文件名等方法，通过transferTo()方法可以将文件存储在硬件中。</p><a id="more"></a><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getBytes()   <span class="comment">//获取文件数据</span></span><br><span class="line"><span class="function">String <span class="title">getContentType</span><span class="params">()</span> <span class="comment">//获取文件MIME类型</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> <span class="comment">//获取表单中文件组件的名字</span></span></span><br><span class="line"><span class="function">String <span class="title">getOriginalFilename</span><span class="params">()</span><span class="comment">// 获取上传文件的原名。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getSize</span><span class="params">()</span>   <span class="comment">//获取文件的字节大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transferTo</span><span class="params">(File dest)</span>  <span class="comment">/*  将上传文件保存到一个目标文件中*  /</span></span></span><br></pre></td></tr></table></figure><p>SpringMVC 上下文默认没有装配MultipartResolver,因此默认情况下不能处理文件上传工作，若要使用，则需要配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定所上传文件的总大小不能超过20M。注意maxUploadSize属性的限制不是针对单个文件，而是所有文件的容量之和 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"20000000"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>Interceptor拦截器的主要作用是拦截用户的请求并进行相应的处理，比如通过拦截器进行用户权限认证，判断用户是否登录等。</p><p>SpringMVC中的拦截器是拔插式设计，需要某个拦截器，只需在配置文件中应用该拦截器即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--拦截有请求--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**/"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--排除--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mvc:exclde-mapping</span> <span class="attr">path</span>=<span class="string">"/login/"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> =<span class="string">"org.sysu.interceptor.SessionInterceptor"</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HandlerInterceptor接口"><a href="#HandlerInterceptor接口" class="headerlink" title="HandlerInterceptor接口"></a>HandlerInterceptor接口</h3><p>SpringMVC中的拦截器请求通过实现HandlerInterceptor接口来完成，要定义一个拦截器，可以实现HandlerInterceptor接口，或者继承抽象类HandlerInterceptorAdapter。</p><p>HandlerInterceptor中定义了三个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,HttpServletResponse response,Object handle)</span></span></span><br></pre></td></tr></table></figure><p>请求处理前被调用，SpringMVC中的Interceptor 是链式调用，一个应用或者一个请求中可以同时存在多个Interceptor，每个Interceptor 根据声明顺序依次执行，preHandler的返回方法是布尔型的，返回false时，表示请求结束，后续的Interceptor和Controller都不会执行，返回值为true时，就会调用下一个Interceptor的prehandle方法，如果已经是最后一个Interceptor，就会调用当前请求的Controller方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request,HttpServletResponse response,Object handle,ModelAndView mv)</span></span></span><br></pre></td></tr></table></figure><p>该方法和之后的afterCompletion都是只能在当前所属的Interceptor的preHandler方法的返回值为true时才会被调用。postHandler在Controller方法调用之后执行，但是会在DispatcherServlet 进行视图返回渲染之前被调用。所以可以对处理后的ModelAndView对象进行操作。<em>先声明的Interceptor</em>的postHandler反而后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> afterCompletion（HttpServletRequest request,HttpServletResponse response,Object handle，Exception exception）</span><br></pre></td></tr></table></figure><p>在渲染视图之后执行，方法的主要作用是进行资源清理。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TF-IDF 算法</title>
      <link href="/2017/11/24/TF-IDF-%E7%AE%97%E6%B3%95/"/>
      <url>/2017/11/24/TF-IDF-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://www.ruanyifeng.com/blog/2013/03/tf-idf.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/03/tf-idf.html</a></p></blockquote><p>有一篇很长的文章，我要用计算机提取它的关键词（Automatic Keyphrase extraction），完全不加以人工干预，请问怎样才能正确做到？</p><p>下面从一个实例说起</p><p>假定现在有一篇长文《中国的蜜蜂养殖》，我们准备用计算机提取它的关键词。</p><p>一个容易想到的思路，就是找到出现次数最多的词。如果某个词很重要，它应该在这篇文章中多次出现。于是，我们进行”词频”（Term Frequency，缩写为TF）统计。</p><p>结果你肯定猜到了，出现次数最多的词是—-“的”、”是”、”在”—-这一类最常用的词。它们叫做<a href="http://baike.baidu.com/view/3784680.htm" target="_blank" rel="noopener">“停用词”</a>（stop words），表示对找到结果毫无帮助、必须过滤掉的词。</p><a id="more"></a><p>假设我们把它们都过滤掉了，只考虑剩下的有实际意义的词。这样又会遇到了另一个问题，我们可能发现”中国”、”蜜蜂”、”养殖”这三个词的出现次数一样多。这是不是意味着，作为关键词，它们的重要性是一样的？</p><p>显然不是这样。因为”中国”是很常见的词，”蜜蜂”和”养殖”不那么常见。如果这三个词在一篇文章的出现次数一样多，有理由认为，”蜜蜂”和”养殖”的重要程度要大于”中国”，也就是说，在关键词排序上面，”蜜蜂”和”养殖”应该排在”中国”的前面。</p><p>所以，我们需要一个重要性调整系数，衡量一个词是不是常见词。<strong>如果某个词比较少见，但是它在这篇文章中多次出现，那么它很可能就反映了这篇文章的特性，正是我们所需要的关键词。</strong></p><p>用统计学语言表达，就是在词频的基础上，要对每个词分配一个”重要性”权重。最常见的词（”的”、”是”、”在”）给予最小的权重，较常见的词（”中国”）给予较小的权重，较少见的词（”蜜蜂”、”养殖”）给予较大的权重。这个权重叫做”逆文档频率”（Inverse Document Frequency，缩写为IDF），它的大小与一个词的常见程度成反比。</p><p><strong>知道了”词频”（TF）和”逆文档频率”（IDF）以后，将这两个值相乘，就得到了一个词的TF-IDF值。某个词对文章的重要性越高，它的TF-IDF值就越大。所以，排在最前面的几个词，就是这篇文章的关键词</strong>。</p><h3 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h3><p><strong>第一步，计算词频。</strong></p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201303/bg2013031503.png" alt="img"></p><p>考虑到文章有长短之分，为了便于不同文章的比较，进行”词频”标准化。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201303/bg2013031504.png" alt="img"></p><p><strong>第二步，计算逆文档频率。</strong></p><p>这时，需要一个语料库（corpus），用来模拟语言的使用环境。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201303/bg2013031506.png" alt="img"></p><p>如果一个词越常见，那么分母就越大，逆文档频率就越小越接近0。分母之所以要加1，是为了避免分母为0（即所有文档都不包含该词）。log表示对得到的值取对数。</p><p><strong>第三步，计算TF-IDF。</strong></p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201303/bg2013031507.png" alt="img"></p><p><strong>可以看到，TF-IDF与一个词在文档中的出现次数成正比，与该词在整个语言中的出现次数成反比。</strong>所以，自动提取关键词的算法就很清楚了，就是计算出文档的每个词的TF-IDF值，然后按降序排列，取排在最前面的几个词。</p><h3 id="使用TF-IDF-计算文章相似度"><a href="#使用TF-IDF-计算文章相似度" class="headerlink" title="使用TF-IDF 计算文章相似度"></a>使用TF-IDF 计算文章相似度</h3><p>为了找出相似的文章，需要用到<a href="http://en.wikipedia.org/wiki/Cosine_similarity" target="_blank" rel="noopener">“余弦相似性”</a>（cosine similiarity）。下面，我举一个例子来说明，什么是”余弦相似性”。</p><p>为了简单起见，我们先从句子着手。</p><blockquote><p>　　句子A：我喜欢看电视，不喜欢看电影。</p><p>　　句子B：我不喜欢看电视，也不喜欢看电影。</p></blockquote><p>请问怎样才能计算上面两句话的相似程度？</p><p>基本思路是：如果这两句话的用词越相似，它们的内容就应该越相似。因此，可以从词频入手，计算它们的相似程度。</p><p><strong>第一步，分词。</strong></p><blockquote><p>　　句子A：我/喜欢/看/电视，不/喜欢/看/电影。</p><p>　　句子B：我/不/喜欢/看/电视，也/不/喜欢/看/电影。</p></blockquote><p><strong>第二步，列出所有的词。</strong></p><blockquote><p>　　我，喜欢，看，电视，电影，不，也。</p></blockquote><p><strong>第三步，计算词频。</strong></p><blockquote><p>　　句子A：我 1，喜欢 2，看 2，电视 1，电影 1，不 1，也 0。</p><p>　　句子B：我 1，喜欢 2，看 2，电视 1，电影 1，不 2，也 1。</p></blockquote><p><strong>第四步，写出词频向量。</strong></p><blockquote><p>　　句子A：[1, 2, 2, 1, 1, 1, 0]</p><p>　　句子B：[1, 2, 2, 1, 1, 2, 1]</p></blockquote><p>到这里，问题就变成了如何计算这两个向量的相似程度。</p><p>我们可以把它们想象成空间中的两条线段，都是从原点（[0, 0, …]）出发，指向不同的方向。两条线段之间形成一个夹角，如果夹角为0度，意味着方向相同、线段重合；如果夹角为90度，意味着形成直角，方向完全不相似；如果夹角为180度，意味着方向正好相反。<strong>因此，我们可以通过夹角的大小，来判断向量的相似程度。夹角越小，就代表越相似。</strong></p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201303/bg2013032002.png" alt="img"></p><p>以二维空间为例，上图的a和b是两个向量，我们要计算它们的夹角θ。<a href="http://zh.wikipedia.org/zh-cn/%E9%A4%98%E5%BC%A6%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">余弦定理</a>告诉我们，可以用下面的公式求得：</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201303/bg2013032004.png" alt="img"></p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201303/bg2013032003.png" alt="img"></p><p>假定a向量是[x1, y1]，b向量是[x2, y2]，那么可以将余弦定理改写成下面的形式：</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201303/bg2013032006.png" alt="img"></p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201303/bg2013032005.png" alt="img"></p><p>数学家已经证明，余弦的这种计算方法对n维向量也成立。假定A和B是两个n维向量，A是 [A1, A2, …, An] ，B是 [B1, B2, …, Bn] ，则A与B的夹角θ的余弦等于：</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201303/bg2013032007.png" alt="img"></p><p>使用这个公式，我们就可以得到，句子A与句子B的夹角的余弦。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201303/bg2013032008.png" alt="img"></p><p><strong>余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似，这就叫”余弦相似性”。</strong>所以，上面的句子A和句子B是很相似的，事实上它们的夹角大约为20.3度。</p><p>由此，我们就得到了”找出相似文章”的一种算法：</p><blockquote><p>　　（1）使用TF-IDF算法，找出两篇文章的关键词；</p><p>　　（2）每篇文章各取出若干个关键词（比如20个），合并成一个集合，计算每篇文章对于这个集合中的词的词频（为了避免文章长度的差异，可以使用相对词频）；</p><p>　　（3）生成两篇文章各自的词频向量；</p><p>　　（4）计算两个向量的余弦相似度，值越大就表示越相似。</p></blockquote><p>“余弦相似度”是一种非常有用的算法，只要是计算两个向量的相似程度，都可以采用它。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC @RequestBody 接收Json 对象字符串</title>
      <link href="/2017/11/24/SpringMVC-@RequestBody-%E6%8E%A5%E6%94%B6Json-%E5%AF%B9%E8%B1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2017/11/24/SpringMVC-@RequestBody-%E6%8E%A5%E6%94%B6Json-%E5%AF%B9%E8%B1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC-RequestBody-接收Json-对象字符串"><a href="#SpringMVC-RequestBody-接收Json-对象字符串" class="headerlink" title="SpringMVC @RequestBody 接收Json 对象字符串"></a>SpringMVC @RequestBody 接收Json 对象字符串</h2><p>@RequestBody接收的是一个json对象的字符串，而不是一个接送对象，但是ajax请求中往往传的是json对象，通过使用JSON.stringify(data)的方式就能将对象变为字符串，同时ajax请求的时候也要指定dataType: “json”,contentType:”application/json” 这样就可以轻易的将一个对象或者List传到Java端，使用@RequestBody即可绑定对象或者List.</p><a id="more"></a><h4 id="json对象和json字符串的js变化。"><a href="#json对象和json字符串的js变化。" class="headerlink" title="json对象和json字符串的js变化。"></a>json对象和json字符串的js变化。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">parse用于从一个字符串中解析出json对象,如</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'&#123;"name":"huangxiaojian","age":"23"&#125;'</span></span><br><span class="line">结果：</span><br><span class="line"><span class="built_in">JSON</span>.parse(str)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span></span><br><span class="line">age: <span class="string">"23"</span></span><br><span class="line">name: <span class="string">"huangxiaojian"</span></span><br><span class="line">__proto__: <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">注意：单引号写在&#123;&#125;外，每个属性名都必须用双引号，否则会抛出异常。</span><br><span class="line">stringify()用于从一个对象解析出字符串，如</span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line">结果：</span><br><span class="line"><span class="built_in">JSON</span>.stringify(a)</span><br><span class="line"><span class="string">"&#123;"</span>a<span class="string">":1,"</span>b<span class="string">":2&#125;"</span></span><br></pre></td></tr></table></figure><h4 id="Ajax传递json字符串到后台"><a href="#Ajax传递json字符串到后台" class="headerlink" title="Ajax传递json字符串到后台"></a>Ajax传递json字符串到后台</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;  </span><br><span class="line">    $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> DataArray=[];  </span><br><span class="line">        <span class="keyword">var</span> data1=&#123;<span class="string">"userName"</span>:<span class="string">"wangkangning"</span>,<span class="string">"address"</span>:<span class="string">"guangzhou"</span>&#125;;  </span><br><span class="line">        <span class="keyword">var</span> data2=&#123;<span class="string">"userName"</span>:<span class="string">"wangchao"</span>,<span class="string">"address"</span>:<span class="string">"chengdu"</span>&#125;;  </span><br><span class="line">        DataArray.push(data1);  </span><br><span class="line">        DataArray.push(data2);         </span><br><span class="line">        $.ajax(&#123; </span><br><span class="line">            type:<span class="string">"POST"</span>, </span><br><span class="line">            url:<span class="string">"user/saveUser"</span>, </span><br><span class="line">            dataType:<span class="string">"json"</span>,      </span><br><span class="line">            contentType:<span class="string">"application/json"</span>,<span class="comment">//发送至服务器时的内容编码格式。             </span></span><br><span class="line">            data:<span class="built_in">JSON</span>.stringify(DataArray), </span><br><span class="line">            success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;                <span class="comment">//请求成功后的回调函数。</span></span><br><span class="line">            &#125;</span><br><span class="line">          error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">          </span>&#123;alert(<span class="string">"error"</span>);&#125;</span><br><span class="line">         &#125;); </span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="RequestBody-接收Json字符串并绑定（相同名称进行绑定）"><a href="#RequestBody-接收Json字符串并绑定（相同名称进行绑定）" class="headerlink" title="RequestBody 接收Json字符串并绑定（相同名称进行绑定）"></a>RequestBody 接收Json字符串并绑定（相同名称进行绑定）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"user/saveUser"</span>, method = RequestMethod.POST) </span><br><span class="line">    <span class="meta">@ResponseBody</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(@RequestBody List&lt;User&gt; users)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//使用Jackson库进行处理</span></span><br><span class="line">      ObjectMapper mapper =<span class="keyword">new</span> ObjectMapper();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;user.size();i++)</span><br><span class="line">      &#123;</span><br><span class="line">          String json =mapper.writeValueAsString(users[i]); <span class="comment">//将user对象转换为json输出。</span></span><br><span class="line">      &#125;</span><br><span class="line">      User user =  <span class="keyword">new</span> User();</span><br><span class="line">    user = mapper.readValue(json,User.class);  <span class="comment">//将json转换为json对象。</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC原理</title>
      <link href="/2017/11/24/SpringMVC%E5%8E%9F%E7%90%86/"/>
      <url>/2017/11/24/SpringMVC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。</p><p>Spring MVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/4D64C854-442E-4850-A591-C4FFF7A1228E.png"></p><h5 id="整体过程"><a href="#整体过程" class="headerlink" title="整体过程"></a>整体过程</h5><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-24%2020-40-06.png" alt=""></p><h5 id="组件说明："><a href="#组件说明：" class="headerlink" title="组件说明："></a>组件说明：</h5><p>以下组件通常使用框架提供实现：</p><ul><li>DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。</li></ul><ul><li>HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 </li></ul><p>HandlerMapping 配置了不同的映射方式,如注解方式,xml方式等.可将HandlerMapping看作路由控制器,通过HandlerMapping 可以得到当前对应的控制器. </p><ul><li>HandlerAdapter：通过扩展处理器适配器，支持更多类型的处理器。</li></ul><p>HandlerAdapter 会对Handler进行封装,就是第一张图中4的过程,包括数据转换,数据格式化,数据验证等.再以统一的适配器接口调用Handler.</p><ul><li>ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2017/11/22/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/11/22/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式——适配器模式"><a href="#设计模式——适配器模式" class="headerlink" title="设计模式——适配器模式"></a>设计模式——适配器模式</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> 适配器模式，将一个类的接口转换成客户希望的另外一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><h3 id="针对的问题"><a href="#针对的问题" class="headerlink" title="针对的问题"></a>针对的问题</h3><p>简单的说，就是需要的东西就在面前，但是却不能使用，而短时间内又无法改造它，于是我们就想办法适配它。</p><p>适配器的意思就是使得一个东西适合另一个东西的东西。</p><p>在软件开发中，在系统的数据和行为都正确，但是接口不符时，就应该考虑用适配器，目的是使控制范围之外的一个原有对象和某个接口匹配，适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。</p><a id="more"></a><h3 id="角色构成"><a href="#角色构成" class="headerlink" title="角色构成"></a>角色构成</h3><p><img src="http://blog-1252095801.cosgz.myqcloud.com/171122.png" alt=""></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>代码中有两个接口，分别为德标接口和国标接口，分别命名为DBSocketInterface和GBSocketInterface，此外还有两个实现类，分别为德国插座和中国插座，分别为DBSocket和GBSocket。为了提供两套接口之间的适配，我们提供了一个适配器，叫做SocketAdapter。除此之外，还有一个客户端，比如是我们去德国旅游时住的一家宾馆，叫Hotel，在这个德国旅馆中使用德国接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//德标接口 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DBSocketInterface</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这个方法的名字叫做：使用两项圆头的插口供电 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">powerWithTwoRound</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//德标插座实现德标接口</span></span><br><span class="line"><span class="comment">// 德国插座</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBSocket</span> <span class="keyword">implements</span> <span class="title">DBSocketInterface</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerWithTwoRound</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"使用两项圆头的插孔供电"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个德国的宾馆，里面只有德国插口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hotel</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//旅馆中有一个德标的插口  </span></span><br><span class="line">    <span class="keyword">private</span> DBSocketInterface dbSocket;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hotel</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hotel</span><span class="params">(DBSocketInterface dbSocket)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.dbSocket = dbSocket;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//旅馆中有一个充电的功能  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span></span>&#123;      </span><br><span class="line">        <span class="comment">//使用德标插口充电  </span></span><br><span class="line">        dbSocket.powerWithTwoRound();  </span><br><span class="line">    &#125;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSocket</span> <span class="params">(DBSocketInterface dbSocket)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.dbSocket = dbSocket;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//初始化一个德国插座对象， 用一个德标接口引用它  </span></span><br><span class="line">        DBSocketInterface dbSoket = <span class="keyword">new</span> DBSocket();  </span><br><span class="line">        <span class="comment">//创建一个旅馆对象  </span></span><br><span class="line">        Hotel hotel = <span class="keyword">new</span> Hotel(dbSoket);  </span><br><span class="line">        <span class="comment">//在旅馆中给手机充电  </span></span><br><span class="line">        hotel.charge();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我去德国旅游，带去的三项扁头的手机充电器。如果没有带电源适配器，我是不能充电的，因为人家德国人一直这么使用，所以我就要自己想办法来解决问题。对应到我们的代码中，也就是说，上面的Hotel类，DBSocket类，DBSocketInterface接口都是不可变的（由德国的客户提供），如果我想使用这一套API，那么只能自己写代码解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//国标接口 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GBSocketInterface</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这个方法的名字叫做：使用三项扁头的插口供电 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">powerWithThreeFlat</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中国插座实现国标接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GBSocket</span> <span class="keyword">implements</span> <span class="title">GBSocketInterface</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerWithThreeFlat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"使用三项扁头插孔供电"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以认为这两个东西是我带到德国去的，目前他们还不能使用，因为接口不一样。那么我必须创建一个适配器，这个适配器必须满足以下条件：</p><p>1    必须符合德国标准的接口，否则的话还是没办法插到德国插座中；</p><p>2    在调用上面实现的德标接口进行充电时，提供一种机制，将这个调用转到对国标接口的调用 。</p><p>这就要求：</p><p>1 适配器必须实现原有的旧的接口</p><p>2 适配器对象中持有对新接口的引用，当调用旧接口时，将这个调用委托给实现新接口的对象来处理，也就是在适配器对象中组合一个新接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketAdapter</span> <span class="keyword">implements</span> <span class="title">DBSocketInterface</span></span>&#123;   <span class="comment">//实现旧接口  </span></span><br><span class="line">    <span class="comment">//组合新接口  </span></span><br><span class="line">    <span class="keyword">private</span> GBSocketInterface gbSocket;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 在创建适配器对象时，必须传入一个新接口的实现类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gbSocket </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketAdapter</span><span class="params">(GBSocketInterface gbSocket)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.gbSocket = gbSocket;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 将对旧接口的调用适配到新接口 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  ××××××××关键方法××××××××</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerWithTwoRound</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        gbSocket.powerWithThreeFlat();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAdapter</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        GBSocketInterface gbSocket = <span class="keyword">new</span> GBSocket();  </span><br><span class="line">        Hotel hotel = <span class="keyword">new</span> Hotel();  </span><br><span class="line">        SocketAdapter socketAdapter = <span class="keyword">new</span> SocketAdapter(gbSocket);  </span><br><span class="line">        hotel.setSocket(socketAdapter);  </span><br><span class="line">        hotel.charge();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="关键-适配器类在内部包装一个适合原来接口的类。"><a href="#关键-适配器类在内部包装一个适合原来接口的类。" class="headerlink" title="关键 适配器类在内部包装一个适合原来接口的类。"></a>关键 适配器类在内部包装一个适合原来接口的类。</h5><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>适配器模式的三个特点：</p><p>1    适配器对象实现原有接口</p><p>2    适配器对象组合一个实现新接口的对象（这个对象也可以不实现一个接口，只是一个单纯的对象）</p><p>3    对适配器原有接口方法的调用被委托给新接口的实例的特定方法</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/2017/11/21/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/11/21/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式——抽象工厂模式"><a href="#设计模式——抽象工厂模式" class="headerlink" title="设计模式——抽象工厂模式"></a>设计模式——抽象工厂模式</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>抽象工厂模式是工厂方法模式的升级版本，它用来创建一组相关或者相互依赖的对象。</p><p>抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口，而无需指定他们具体的类。</p><p>就是一个工厂里放一些相关的类，使工厂数减少。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/17112102.png" alt=""></p><h2 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h2><p>最大的好处便是易于交换产品系列，其次是让具体的创建实例过程与客户端分离，<em>客户端通过他们的抽象接口操纵实例</em>，产品的具体类名也被具体工厂的实现分离。不会出现在客户代码中。</p><a id="more"></a><h3 id="抽象工厂模式与工厂方法模式的区别"><a href="#抽象工厂模式与工厂方法模式的区别" class="headerlink" title="抽象工厂模式与工厂方法模式的区别"></a>抽象工厂模式与工厂方法模式的区别</h3><p>​        抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的<em>多个产品等级结构</em>。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。</p><p>​        在抽象工厂模式中，有一个<strong>产品族</strong>的概念：所谓的产品族，是指<strong>位于不同产品等级结构中功能相关联的产品组成的家族</strong>。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。*也就是说，工厂模式中每个工厂造出来的东西都是同一个类别的，<strong>抽象工厂模式中，一个工厂可以造不同类别的东西。</strong></p><p>我们依然拿生产汽车的例子来说明他们之间的区别。</p><p>奔驰车和宝马称为两个不同的等级结构（两种不同的车）；而A空调车和B空调车则称为两个不同的产品族（车的属性）A引擎和B引擎也是不同的产品族。再具体一点，A空调宝马车和B空调宝马车属于同一个等级结构，A空调奔驰车和B空调奔驰车属于另一个等级结构；而A空调轿车和A空调越野车属于同一个产品族(同一个零部件)，B空调车轿车和B空调越野车属于另一个产品族(同一个零部件)。</p><p>​        明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了.</p><p><strong>抽象工厂方法就是一个工厂里生产不同等级结构中的一个（其中一种车）中的不同的配件（不同的车的属性）。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产品类</span></span><br><span class="line"><span class="comment">//发动机以及型号    </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;    </span><br><span class="line">  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EngineA</span> <span class="keyword">extends</span> <span class="title">Engine</span></span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EngineA</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;EngineA"</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EngineB</span> <span class="keyword">extends</span> <span class="title">Engine</span></span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EngineB</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;EngineB"</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//空调以及型号    </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aircondition</span> </span>&#123;    </span><br><span class="line">  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirconditionA</span> <span class="keyword">extends</span> <span class="title">Aircondition</span></span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirconditionA</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;AirconditionA"</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirconditionB</span> <span class="keyword">extends</span> <span class="title">Aircondition</span></span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirconditionB</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;AirconditionB"</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="comment">//创建工厂的接口    </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;    </span><br><span class="line">    <span class="comment">//制造发动机  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="comment">//制造空调   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Aircondition <span class="title">createAircondition</span><span class="params">()</span></span>;   </span><br><span class="line">&#125;    </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//为奔驰生产配件    </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 奔驰工厂 <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span>&#123;    </span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EngineA();    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Aircondition <span class="title">createAircondition</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AirconditionA();    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//为宝马车生产配件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 宝马工厂 <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;    </span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EngineB();    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Aircondition <span class="title">createAircondition</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AirconditionB();    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    </span><br><span class="line">        <span class="comment">//奔驰生产配件</span></span><br><span class="line">        奔驰 j = <span class="keyword">new</span> 奔驰();    </span><br><span class="line">        j.createEngine();  </span><br><span class="line">        j.createAircondition();  </span><br><span class="line">            </span><br><span class="line">        <span class="comment">//宝马生产配件</span></span><br><span class="line">        宝马 y = <span class="keyword">new</span> 宝马();    </span><br><span class="line">        y.createEngine();  </span><br><span class="line">        y.createAircondition();  </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂模式也就是不仅生产引擎，同时生产空调。<br>也就是车工厂是个父类，有生产引擎，生产空调两个接口。<br>戴尔工厂，惠普工厂继承它，可以分别生产戴尔引擎+戴尔空调，和惠普引擎+惠普空调。<br>创建小米工厂时，小米工厂的引擎生产小米引擎,小米工厂的空调生产空调.</p><p>假设要多出来生产耳机这个产品,则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。<br>之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式和简单工厂模式</title>
      <link href="/2017/11/21/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/11/21/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式——工厂方法模式和简单工厂模式"><a href="#设计模式——工厂方法模式和简单工厂模式" class="headerlink" title="设计模式——工厂方法模式和简单工厂模式"></a>设计模式——工厂方法模式和简单工厂模式</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>工厂设计模式是一种创建型模式，它提供了一种创建对象的最佳方式。</p><p>在工厂模式中，我们创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>简单工厂模式是工场方法模式的一种特例。</p><h5 id="关键-工厂返回创建的对象"><a href="#关键-工厂返回创建的对象" class="headerlink" title="关键 工厂返回创建的对象"></a>关键 工厂返回创建的对象</h5><h3 id="针对的问题"><a href="#针对的问题" class="headerlink" title="针对的问题"></a>针对的问题</h3><p>在面向对象编程中，最常用的方法是new一个操作符产生一个对象实例，new对象操作符就是用来构造对象实例的，但是在一些情况下，new操作符直接生成对象会带来一些问题，举例说，许多类型对象的创建都需要一系列的步骤，可能需要计算或取得对象的初始设置，选择生成哪个子对象实例，或者在生成需要的对象之前必须先生成一些辅助功能的对象，这些情况下，<em>对象的建立就是一个过程，不仅是一个操作</em>。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/171121.png" alt=""></p><p>上图就是没有工厂模式时，用户需要自己new一辆车，这样，车和人就耦合在了一起。</p><p>那么怎么能够方便的构建对象实例，而不关心构造对象实例的细节和复杂过程呢，那就是建立一个工厂来创建对象。<strong>把创建的过程封装到工厂里</strong>。</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到灵活性的目的。</p><p>工厂模式一共三类</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><p>一般将简单工厂模式看为工厂方法模式的一种特例，二者归为一类。</p><h3 id="角色组成（简单工厂模式）"><a href="#角色组成（简单工厂模式）" class="headerlink" title="角色组成（简单工厂模式）"></a>角色组成（简单工厂模式）</h3><p>1）工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，用来创建产品<br>2) 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。<br>3) 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。 </p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>1）还没有工厂时代：假如还没有工业革命，如果一个客户要一款宝马车,一般的做法是客户去创建一款宝马车，然后拿来用。<br>​    2）简单工厂模式：后来出现工业革命。用户不用去创建宝马车。因为客户有一个工厂来帮他创建宝马.想要什么车，这个工厂就可以建。比如想要320i系列车。工厂就创建这个系列的车。即工厂可以创建产品。<br>​    3）工厂方法模式时代：为了满足客户，宝马车系列越来越多，如320i，523i,30li等系列一个工厂无法创建所有的宝马系列。于是由单独分出来多个具体的工厂。每个具体工厂创建一种系列。即具体工厂类只能创建一个具体产品。但是宝马工厂还是个抽象。你需要指定某个具体的工厂才能生产车出来。</p><p>   4）抽象工厂模式时代：随着客户的要求越来越高，宝马车必须配置空调。于是这个工厂开始生产宝马车和需要的空调。</p><p>   最终是客户只要对宝马的销售员说：我要523i空调车，销售员就直接给他523i空调车了。而不用自己去创建523i空调车宝马车.</p><p>   这就是工厂模式。</p><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>使用简单工厂模式</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/17112101.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产品类</span></span><br><span class="line">abstruct <span class="class"><span class="keyword">class</span> <span class="title">BMW</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BMW</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW100</span> <span class="keyword">extends</span> <span class="title">BMW</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BMW100</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"this is BMW100"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW200</span> <span class="keyword">extends</span> <span class="title">BMW</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BMW200</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"this is BMW200"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BMW <span class="title">createBMW</span><span class="params">(<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">100</span>) <span class="keyword">return</span> <span class="keyword">new</span> BMW100();</span><br><span class="line">      <span class="keyword">if</span>(type==<span class="number">200</span>) <span class="keyword">return</span> <span class="keyword">new</span> BMW200();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringp[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Factory factory =<span class="keyword">new</span> Factory();</span><br><span class="line">      BMW bmw100 =factory.createBMW(<span class="number">100</span>);</span><br><span class="line">      BMW bmw200 =factory.createBMW(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单工厂类的缺陷以及工厂方法模式的提出"><a href="#简单工厂类的缺陷以及工厂方法模式的提出" class="headerlink" title="简单工厂类的缺陷以及工厂方法模式的提出"></a>简单工厂类的缺陷以及工厂方法模式的提出</h3><p>在简单工厂中，当客户不再满足现有的车型号时，想要一种更快的车，只要这种车满足抽象产品指定的规则，只要通知工厂类增加相应的逻辑就好了，但是每增加一种车，都要在工厂类中增加相应的逻辑，工厂类十分被动，这样的工厂类成为全能类或者上帝类。</p><p>实际中，产品可能是一种多层次的树状结构，由于简单工厂模式只有一个工厂类，所以好多代码都放在一个工厂类里</p><p>于是提出了工厂方法模式</p><h3 id="工厂方法模式概念"><a href="#工厂方法模式概念" class="headerlink" title="工厂方法模式概念"></a>工厂方法模式概念</h3><p>工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。也就是在所有工厂中抽象出一个接口。当增加功能时，直接增加相应的物品类和工厂类就行了。</p><p>工厂方法模式去掉了简单工厂模式中工厂方法的静态属性，使得它可以被子类继承。这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分担。 (一个类一个工厂)</p><h3 id="角色构成（工厂方法模式）"><a href="#角色构成（工厂方法模式）" class="headerlink" title="角色构成（工厂方法模式）"></a>角色构成（工厂方法模式）</h3><p>1)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。<br>2)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。<br>3)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。<br>4)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 </p><p>工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的上帝类，分担了对象承受的压力。</p><h3 id="举例-（工厂方法模式）"><a href="#举例-（工厂方法模式）" class="headerlink" title="举例 （工厂方法模式）"></a>举例 （工厂方法模式）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产品类 四种车，宝马1系，(两种),2系(两种)</span></span><br><span class="line"><span class="function">abstruct class <span class="title">BMW</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BMW</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">pubblic <span class="class"><span class="keyword">class</span> <span class="title">BMW100</span> <span class="keyword">extends</span> <span class="title">BMW</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BMW100</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"this is BMW100"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pubblic <span class="class"><span class="keyword">class</span> <span class="title">BMW109</span> <span class="keyword">extends</span> <span class="title">BMW</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BMW109</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"this is BMW100"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pubblic <span class="class"><span class="keyword">class</span> <span class="title">BMW200</span> <span class="keyword">extends</span> <span class="title">BMW</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BMW200</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"this is BMW200"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pubblic <span class="class"><span class="keyword">class</span> <span class="title">BMW209</span> <span class="keyword">extends</span> <span class="title">BMW</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BMW209</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"this is BMW209"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">BMW <span class="title">createBMW</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBMW1</span> <span class="keyword">implements</span> <span class="title">FactoryBMW</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> BMW100 <span class="title">createBMW</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BMW100();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBMW2</span> <span class="keyword">implements</span> <span class="title">FactoryBMW</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> BMW200 <span class="title">createBMW</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BMW200();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;   <span class="comment">//分为100的工厂和200的工厂(省略了两个工厂)。都实现了工厂的接口。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      Factory f =<span class="keyword">new</span> FactoryBMW1(); <span class="comment">// 实例化一个1系工厂。</span></span><br><span class="line">     BMW b = f.createBMW(); <span class="comment">//实例化一个100车。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想加一辆车，就单独加车的类，这个车的工厂，然后只修改客户端的代码即可。</p><p>工厂方法模式实现时，客户端需要决定实例化哪一个工厂来创建对象，工厂方法把简单工厂的内部逻辑移到了客户端代码来执行。</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread的中断机制</title>
      <link href="/2017/11/20/Thread%E7%9A%84%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6(interrupt)/"/>
      <url>/2017/11/20/Thread%E7%9A%84%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6(interrupt)/</url>
      
        <content type="html"><![CDATA[<h2 id="Thread的中断机制-interrupt"><a href="#Thread的中断机制-interrupt" class="headerlink" title="Thread的中断机制(interrupt)"></a>Thread的中断机制(interrupt)</h2><p>一个线程在未正常结束之前, 被强制终止是很危险的事情. 因为它可能带来完全预料不到的严重后果比如会带着自己所持有的锁而永远的休眠，迟迟不归还锁等。 所以你看到Thread.suspend, Thread.stop等方法都被Deprecated了.</p><h5 id="中断线程的使用场景"><a href="#中断线程的使用场景" class="headerlink" title="中断线程的使用场景:"></a>中断线程的使用场景:</h5><p>在某个子线程中为了等待一些特定条件的到来, 你调用了Thread.sleep(10000), 预期线程睡10秒之后自己醒来, 但是如果这个特定条件提前到来的话, 来通知一个处于Sleep的线程。又比如说.线程通过调用子线程的join方法阻塞自己以等待子线程结束, 但是子线程运行过程中发现自己没办法在短时间内结束, 于是它需要想办法告诉主线程别等我了. 这些情况下, 就需要中断.</p><p>线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下停止当前工作，并转而执行其他的工作。</p><p><strong>中断是通过调用Thread.interrupt()方法来做的. 这个方法通过修改了被调用线程的中断状态来告知那个线程, 说它被中断了. 对于非阻塞中的线程, 只是改变了中断状态, 即Thread.isInterrupted()将返回true; 对于可取消的阻塞状态中的线程, 比如等待在这些函数上的线程, Thread.sleep(), Object.wait(), Thread.join(), 这个线程收到中断信号后, 会抛出InterruptedException, 同时会把中断状态置回为true.但调用Thread.interrupted()会对中断状态进行复位。</strong></p><p>每个线程都有一个boolean类型的中断状态，当中断线程时，这个线程的中断状态将被置为true，在Thread中包含了中断线程以及查询线程中断状态的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>&#123;...&#125; <span class="comment">//对象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span>&#123;...&#125; <span class="comment">// 对象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span>&#123;...&#125; <span class="comment">//静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interrupt方法能中断线程，isInterrupted方法能返回目标线程的中断状态，静态的interrupted方法能消除当前线程的中断状态并返回它之前的值。这也是清除中断状态的唯一方法。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread3</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Someone interrupted me."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread is Going..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread3 t = <span class="keyword">new</span> Thread3();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">        System.out.println(Thread.interrupted());</span><br><span class="line">        <span class="comment">//Thread.interrupted()等于 Thread.currentThread().isInterrupted().</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程的t.interrupt()方法是中断线程，将会设置该线程的中断状态位，即设置为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。它并不像stop方法那样会中断一个正在运行的线程。</p><h4 id="判断线程是否被中断"><a href="#判断线程是否被中断" class="headerlink" title="判断线程是否被中断"></a>判断线程是否被中断</h4><p>判断某个线程是否已被发送过中断请求，请使用Thread.currentThread().isInterrupted()方法（因为它将线程中断标示位设置为true后，不会立刻清除中断标示位，即不会将中断标设置为false），而不要使thread.interrupted()（该方法调用后会将中断标示位清除，即重新设置为false）方法来判断，下面是线程在循环中时的中断方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>)&#123;</span><br><span class="line">    <span class="keyword">do</span> more work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--more--><h4 id="如何中断线程"><a href="#如何中断线程" class="headerlink" title="如何中断线程"></a>如何中断线程</h4><p>如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait、1.5中的condition.await、以及可中断的通道上的 I/O 操作方法后可进入阻塞状态），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法（sleep、join、wait、1.5中的condition.await及可中断的通道上的 I/O 操作方法）调用处抛出InterruptedException异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为false。<strong>抛出异常是为了线程从阻塞状态醒过来，并在结束线程前让程序员有足够的时间来处理中断请求</strong>。</p><p><em>调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的信息。</em></p><h3 id="对中断操作的正确理解"><a href="#对中断操作的正确理解" class="headerlink" title="对中断操作的正确理解"></a>对中断操作的正确理解</h3><p><strong>中断操作并不会真正的中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己，这些时刻也被称为取消点，有些方法，例如wait，sleep，join等，将严格的处理这种请求，当他们收到中断请求或者在开始执行时发现某个已经设置好的中断状态时，将抛出一个异常。</strong></p><p>没有任何语言方面的需求一个被中断的线程应该终止。中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断。某些线程非常重要，以至于它们应该不理会中断，而是在处理完抛出的异常之后继续执行，但是更普遍的情况是，一个线程将把中断看作一个终止请求，这种线程的run方法遵循如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;    </span><br><span class="line">            <span class="keyword">try</span>&#123;    </span><br><span class="line">                 ....    </span><br><span class="line">                 <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()&amp;&amp; more work to <span class="keyword">do</span>)&#123;    </span><br><span class="line">                        <span class="comment">// do more work;    </span></span><br><span class="line">                 &#125;    </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;    </span><br><span class="line">                        <span class="comment">// thread was interrupted during sleep or wait</span></span><br><span class="line">              <span class="comment">//如果线程在sleep或者其他运行过程中被其他线程中断了,执行异常.</span></span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">finally</span>&#123;    </span><br><span class="line">                       <span class="comment">// cleanup, if required    </span></span><br><span class="line">            &#125;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面是while循环在try块里，如果try在while循环里时，因该在catch块里重新设置一下中断标示，因为抛出InterruptedException异常后，中断标示位会自动清除，此时应该这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()&amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            sleep(delay);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();<span class="comment">//重新设置中断标示!!!!!!!!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">implements</span> <span class="title">Runnbable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"进入run方法"</span>)；</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      System.out.println(<span class="string">"已经完成休眠"</span>)；</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception)</span><br><span class="line">    &#123;</span><br><span class="line">      System.out.println(<span class="string">"休眠被终止"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"run 方法正常结束"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">ThreadInterruptDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Mythread mt =<span class="keyword">new</span> Mythread();</span><br><span class="line">      Thread t =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      t.start();</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);<span class="comment">//暂停两秒继续中断。</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">catch</span>(Exception e)</span><br><span class="line">      &#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      t.interrupt(); <span class="comment">//主线程给t一个中断信号.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">进入run方法</span><br><span class="line">休眠被终止</span><br></pre></td></tr></table></figure><p><strong>上述程序中，一个线程启动之后就进入了休眠状态，原本是要休眠10s再继续执行，但是主方法在线程启动之后的两秒就将其中断，休眠一旦中断之后将执行catch中的代码。catch中的代码就是线程自己决定应该做一些什么操作，是继续执行还是什么都由自己决定。</strong></p><p>Thread.sleep() ,  。Thread.wait() ,   t.join() 都要用trycatch包起来。进行中断的处理。</p><blockquote><p><a href="http://blog.csdn.net/canot/article/details/51087772" target="_blank" rel="noopener">http://blog.csdn.net/canot/article/details/51087772</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2017/11/20/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/11/20/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式——代理模式"><a href="#设计模式——代理模式" class="headerlink" title="设计模式——代理模式"></a>设计模式——代理模式</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在代理模式中，一个类代表另一个类的功能，在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。主要为其他对象提供一种代理以控制对这个对象的访问。</p><h3 id="针对的问题"><a href="#针对的问题" class="headerlink" title="针对的问题"></a>针对的问题</h3><p>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p><p><strong>何时使用：</strong>想在访问一个类时做一些控制。</p><p><strong>如何解决：</strong>增加中间层。</p><p>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p><a id="more"></a><h3 id="涉及角色"><a href="#涉及角色" class="headerlink" title="涉及角色"></a>涉及角色</h3><p>抽象角色：声明真实对象和代理对象的共同接口； </p><p>代理角色：<em>代理对象角色内部含有对真实对象的引用</em>，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 </p><p>真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>周杰伦想说话，代理类代理周杰伦说话，表面上是经纪人说话，实际说话的周杰伦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Star</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shuohua</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真实角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jay</span> <span class="keyword">implements</span> <span class="title">Star</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shuohua</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">" 我是周杰伦"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jinjiren</span> <span class="keyword">implements</span> <span class="title">Star</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">//代理角色里有 star的引用，</span></span><br><span class="line">  <span class="keyword">private</span> Star star;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">jingjiren</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="comment">//默认的话就是周杰伦的经纪人。 </span></span><br><span class="line">    <span class="keyword">this</span>.star =<span class="keyword">new</span> Jay();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">jingjiren</span><span class="params">(Star star)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//也可以是任何明星的经纪人</span></span><br><span class="line">    <span class="keyword">this</span>.star = star;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shuohua</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="comment">//经纪人说话就是代理明星说话。</span></span><br><span class="line">    <span class="keyword">this</span>.star.shuohua();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        jinjiren proxy =<span class="keyword">new</span> jinjiren(); <span class="comment">//默认是周杰伦的经纪人（代理类）</span></span><br><span class="line">      <span class="comment">//虽然说话的经纪人，但是实际是周杰伦在说话。</span></span><br><span class="line">      proxy.shuohua();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理模式主要使用了java的多态，实际说话的是被代理类，代理类主要是接活，你让我干活，好，我交给幕后的类去干，你满意就成，那怎么知道被代理类能不能说话呢？只要继承同一个接口就好。</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式</title>
      <link href="/2017/11/19/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/11/19/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式——装饰模式（Decorator）"><a href="#设计模式——装饰模式（Decorator）" class="headerlink" title="设计模式——装饰模式（Decorator）"></a>设计模式——装饰模式（Decorator）</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>  装饰模式又名包装(Wrapper)模式。装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。它是作为现有的类的一个包装。这种模式创建了一个<em>装饰类</em>，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><h3 id="针对的问题"><a href="#针对的问题" class="headerlink" title="针对的问题"></a>针对的问题</h3><p>动态的给一个对象添加一些额外的职责，就增加功能来说，Decorator模式相比生成子类更为灵活。不改变接口的前提下，增强所考虑的类的性能。</p><p>何时使用：</p><ul><li>需要扩展一个类的功能，或给一个类增加附加责任。</li><li>需要动态的给一个对象增加功能，这些功能可以再动态地撤销。</li><li><strong>需要增加一些基本功能的排列组合而产生的非常大量的功能</strong>，从而使继承变得不现实。</li></ul><p>总的来说，就是给原有的类增加新的功能，假如有5种咖啡，4种配料（糖和牛奶，蜂蜜，巧克力），如果要生成子类的话就会有5×4=20个子类，这样就太多了，通过装饰器模式就只用写5+4+装饰器类这么多就好，装饰器的意思就是给原来的咖啡加入装饰（这里的装饰指的就是配料）。</p><a id="more"></a><h3 id="角色构成"><a href="#角色构成" class="headerlink" title="角色构成"></a>角色构成</h3><p>抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。</p><p>具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。</p><p>装饰角色(Decorator)：持有一个构件(Component)对象的实例，<strong>并定义一个与抽象构件接口一致的接口</strong>，也就是要有原来抽象构件中的全部方法。</p><p>具体装饰角色(ConcreteDecorator)：负责给构件对象“贴上”附加的责任。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/2017-11-19%2022-34-07.png" alt="1"></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>还是刚才的咖啡的例子，</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/1119.png" alt=""></p><p>这里的抽象构件(Component)角色就是饮料，饮料接口对各种咖啡进行限制。</p><p>具体构件(ConcreteComponent)角色 就是各种咖啡。</p><p><em>现在要往咖啡中加入配料了</em></p><p>装饰器(Decorator)  加了一种配料的咖啡，但是具体加了什么配料不知道，由具体的子类决定。</p><p>具体装饰角色 就是各种咖啡以及加了配料的类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 饮料接口 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Beverage</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//返回商品描述  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="comment">//返回价格  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeBean1</span> <span class="keyword">implements</span> <span class="title">Beverage</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String description = <span class="string">"选了第一种咖啡豆"</span>;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> description;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">50</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeBean2</span> <span class="keyword">implements</span> <span class="title">Beverage</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String description = <span class="string">"第二种咖啡豆！"</span>;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> description;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Beverage</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String description = <span class="string">"我只是装饰器，不知道具体的描述"</span>;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> description;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">//价格由子类来决定  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String description = <span class="string">"加了牛奶！"</span>;  </span><br><span class="line">    <span class="keyword">private</span> Beverage beverage = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="comment">// 注意milk的构造方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Beverage beverage)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription()+<span class="string">"\n"</span>+description;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> beverage.getPrice()+<span class="number">20</span>;  <span class="comment">//20表示牛奶的价格  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String description = <span class="string">"加了摩卡！"</span>;  </span><br><span class="line">    <span class="keyword">private</span> Beverage beverage = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription()+<span class="string">"\n"</span>+description;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> beverage.getPrice()+<span class="number">49</span>;  <span class="comment">//30表示摩卡的价格  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soy</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String description = <span class="string">"加了豆浆！"</span>;  </span><br><span class="line">    <span class="keyword">private</span> Beverage beverage = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soy</span><span class="params">(Beverage beverage)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription()+<span class="string">"\n"</span>+description;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> beverage.getPrice()+<span class="number">30</span>;  <span class="comment">//30表示豆浆的价格  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Beverage beverage = <span class="keyword">new</span> CoffeeBean1();  <span class="comment">//选择了第一种咖啡豆磨制的咖啡  </span></span><br><span class="line">        beverage = <span class="keyword">new</span> Mocha(beverage);     <span class="comment">//为咖啡加了摩卡（装饰的意思）因为都继承了饮料接口。 </span></span><br><span class="line">        beverage = <span class="keyword">new</span> Milk(beverage);  </span><br><span class="line">        System.out.println(beverage.getDescription()+<span class="string">"\n加了摩卡和牛奶的咖啡价格："</span>+beverage.getPrice());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>79. Word Search</title>
      <link href="/2017/11/19/leetcode79/"/>
      <url>/2017/11/19/leetcode79/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>For example,<br>Given <strong>board</strong> =</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>word =”ABCCED” return true;</p><p>word= “SEE  return true;</p><p>word=”ABCB” return false;</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>从一个位置走到另一个位置，看能不能拼成给定的字符串，走过的不能重复。</p><a id="more"></a><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = board.size();</span><br><span class="line">        <span class="keyword">if</span>(h==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> w = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> l = word.size();</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(h, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(w, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, visited, <span class="number">0</span>, i, j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//idx 记录遍历到第几个单词了。,i j记录遍历的位置。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>&amp; word, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> idx, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == word.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=board.size() || j&gt;=board[<span class="number">0</span>].size() || visited[i][j] || board[i][j] != word[idx]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfs(board, word, visited, idx+<span class="number">1</span>, i, j+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfs(board, word, visited, idx+<span class="number">1</span>, i, j<span class="number">-1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfs(board, word, visited, idx+<span class="number">1</span>, i+<span class="number">1</span>, j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfs(board, word, visited, idx+<span class="number">1</span>, i<span class="number">-1</span>, j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用深度优先搜索，同时再使用相同大小的visited用来标记是否访问过。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>63. Unique Paths II</title>
      <link href="/2017/11/17/leetcode63/"/>
      <url>/2017/11/17/leetcode63/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>How many possible unique paths are there?</p><p><img src="https://leetcode.com/static/images/problemset/robot_maze.png" alt="img"></p><p>Above is a 3 x 7 grid. How many possible unique paths are there?</p><p>Follow up for “Unique Paths”:</p><p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p><p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p><p>For example,</p><p>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>The total number of unique paths is <code>2</code>.</p><p><strong>Note:</strong> <em>m</em> and <em>n</em> will be at most 100.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>从一个位置走到另一个位置，中间有障碍，问一共有多少种走法。62题的升级版。<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hang=grid.size();</span><br><span class="line">        <span class="keyword">int</span> lie=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(hang, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(lie,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;hang;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[k][<span class="number">0</span>]!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[k][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;k&lt;hang;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[k][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;lie;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[<span class="number">0</span>][k]!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[<span class="number">0</span>][k]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">for</span>(;k&lt;lie;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][k]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;hang;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;lie;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]!=<span class="number">1</span>) <span class="comment">// 去掉障碍物。</span></span><br><span class="line">                &#123;</span><br><span class="line">                     dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[hang<span class="number">-1</span>][lie<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用动态规划，声明一个hang <em> lie大小的数组，每个位置表示到这个位置有多少种走法，没有障碍物的时候，可以知道对于一个 hang</em> lie 大小的矩阵，第一行所有数都是1,第一列所有数都是1,因为都是只有一种走法，对于其他位置，状态转移方程是<code>dp[i][j]=dp[i][j-1]+dp[i-1][j]</code>,也就是说每一个点的位置等于它上面的数加上左边的数的和，通过这样写出状态转移方程，然后从头遍历到尾即可。</p><h5 id="加强版"><a href="#加强版" class="headerlink" title="加强版"></a>加强版</h5><p>添加了障碍后，有了一个变化，那就是在第一列或者第一行中，只要有一个障碍物，那个障碍物的那个点能到的步数为0，<strong>这个点后面的所有地方能到的也为0，所以在赋值的时候需要特殊处理。 </strong></p><p>然后在遍历的时候也要去掉障碍物。</p><h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><p>声明一个n个大小的vector&lt;vector<int> &gt;<br>vector&lt;vector<int> &gt; res( n, vector<int>(n) );</int></int></int></p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. Merge Intervals</title>
      <link href="/2017/11/16/leetcode56/"/>
      <url>/2017/11/16/leetcode56/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a collection of intervals, merge all overlapping intervals.</p><p>For example,<br>Given <code>[1,3],[2,6],[8,10],[15,18]</code>,<br>return <code>[1,6],[8,10],[15,18]</code>.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>合并所有的片段。<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义排序函数 按照每个片段的start的大小从小到大排序。</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Interval a,Interval b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.start&lt;b.start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(intervals.begin(),intervals.end(),cmp);</span><br><span class="line">        res.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.back().end&gt;=intervals[i].start)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                Interval temp(res.back().start,max(res.back().end,intervals[i].end));</span><br><span class="line">                res.pop_back();</span><br><span class="line">                res.push_back(temp);<span class="comment">//注意pop和push的顺序，第一次这里的顺序浪费了一些时间。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先将所有的片段按照start的大小进行排序，考虑 13 24 56 这种情况，先将第一个片段放入result，然后比较第二个片段的开始大小和第一个片段的结束大小的关系，若第一个结束的大小小于第二个开始的大小，直接将第二个片段放入result即可。若第一个结束的大小大于第二个结束的大小，则去求应该把哪个的结束作为这个片段的结束，就像 13 24 比时，比较3 和4 哪个作为结束，所以把上一个片段退出来，重新生成一个新的片段，然后加入result中。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类图</title>
      <link href="/2017/11/16/UML%E7%B1%BB%E5%9B%BE/"/>
      <url>/2017/11/16/UML%E7%B1%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>看深入理解Java Web技术内幕时遇到好多类图，忘记了具体什么意思，现在进行总结学习。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/uml1.png" alt=""></p><a id="more"></a><h4 id="类与接口表示方法"><a href="#类与接口表示方法" class="headerlink" title="类与接口表示方法"></a>类与接口表示方法</h4><p><img src="http://blog-1252095801.cosgz.myqcloud.com/uml2.png" alt="2"></p><p>如上图所示，动物框就代表一个类，类图分三类，第一层显示类的名称，如果是抽象类，就用斜体表示，第二层是类的特性，通常是字段和属性，第三类是类的操作，通常是方法和行为。+代表public，-表示private,# 表示protected.</p><p>两种接口表示方法</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/uml3.png" alt="3"></p><h4 id="类与类，类与接口的关系"><a href="#类与类，类与接口的关系" class="headerlink" title="类与类，类与接口的关系"></a>类与类，类与接口的关系</h4><h5 id="继承关系（空心三角形加实线）"><a href="#继承关系（空心三角形加实线）" class="headerlink" title="继承关系（空心三角形加实线）"></a>继承关系（空心三角形加实线）</h5><p><img src="http://blog-1252095801.cosgz.myqcloud.com/uml4.png" alt="4"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现接口（空心三角型加虚线）"><a href="#实现接口（空心三角型加虚线）" class="headerlink" title="实现接口（空心三角型加虚线）"></a>实现接口（空心三角型加虚线）</h5><p><img src="http://blog-1252095801.cosgz.myqcloud.com/uml5.png" alt="5"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WideGoose</span> <span class="keyword">implements</span> <span class="title">IFly</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="关联关系（实线箭头）"><a href="#关联关系（实线箭头）" class="headerlink" title="关联关系（实线箭头）"></a>关联关系（实线箭头）</h5><p>企鹅需要直到气候的变化，需要了解气候的规律，当一个类直到另一个类时，可以用关联关系。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/uml6.png" alt="6"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">extends</span> <span class="title">Bird</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Climate climate; <span class="comment">//在企鹅中引用气候对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="聚合关系（空心菱形加实线箭头）"><a href="#聚合关系（空心菱形加实线箭头）" class="headerlink" title="聚合关系（空心菱形加实线箭头）"></a>聚合关系（空心菱形加实线箭头）</h5><p>每个大雁属于一个雁群，一个雁群可以有许多大雁，所以他们之间满足聚合关系，聚合是一种弱的拥有关系，体现的是A对象可以包含B对象，但是B对象不是A对象的一部分。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/uml7.png" alt="7"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WideGoose_qun</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WideGoose[] wideGooses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="合成关系（实心菱形加箭头）"><a href="#合成关系（实心菱形加箭头）" class="headerlink" title="合成关系（实心菱形加箭头）"></a>合成关系（实心菱形加箭头）</h5><p>合成是一种强的拥有关系，体现了严格的部分与整体的关系，部分和整体的生命周期一样。连线两端的数字1和2代表基数，表明这一端可以有多少个实例。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/uml8.png" alt="8"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Wing wing；</span><br><span class="line">    <span class="keyword">public</span> Bird（）</span><br><span class="line">    &#123;</span><br><span class="line">        wing =<span class="keyword">new</span> Wing();<span class="comment">//在鸟类中，初始化时，实例化翅膀，二者同时生成。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="依赖关系（虚线箭头）"><a href="#依赖关系（虚线箭头）" class="headerlink" title="依赖关系（虚线箭头）"></a>依赖关系（虚线箭头）</h5><p>动物需要水，氧气，他们间是依赖关系。用虚线箭头。<br><img src="http://blog-1252095801.cosgz.myqcloud.com/uml9.png" alt="9"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">live</span><span class="params">(生活)</span>（Oxygen oxygen，Water water）</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55. Jump Game</title>
      <link href="/2017/11/14/leetcode55/"/>
      <url>/2017/11/14/leetcode55/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p>For example:<br>A = <code>[2,3,1,1,4]</code>, return <code>true</code>.</p><p>A = <code>[3,2,1,0,4]</code>, return <code>false</code>.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>每一个数字代表可以往前走几步，看能不能走到最后。<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> reach =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> len =nums.size();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len&amp;&amp;reach&gt;=i;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            reach =max(reach,i+nums[i]);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i==len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>设置一个reach，代表可以走到最远的距离，遍历数组，不断更新最远的距离，同时，假如有一个序列 32104，在第四个数卡住，所以reach至少要大于遍历的序号，走到最后时，reach是3，所以走不到第四个位置，就结束循环，能走到最后就返回true，否则返回false。因为最极端的情况就是全1走完（其中有一个0都不行），所以第i个数字，他的reach至少是i。也就是走完第一个数字，至少能到第二个数字，走完第二个，至少能到第三个数字…依次类推。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap解析</title>
      <link href="/2017/11/14/HashMap/"/>
      <url>/2017/11/14/HashMap/</url>
      
        <content type="html"><![CDATA[<p>了解hashMap前，首先直到Object类中的两个方法。hashCode 和equals.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//直接比较对象</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>==obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>String类中重写了equals方法，比较的是字符串的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;  </span><br><span class="line">        String anotherString = (String) anObject;  </span><br><span class="line">        <span class="keyword">int</span> n = value.length;  </span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;  </span><br><span class="line">            <span class="keyword">char</span> v1[] = value;  </span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;  </span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">            <span class="comment">// 逐个判断字符是否相等  </span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])  </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当equals被重写时，通常有必要重写hashCode方法，以满足hashCode方法的常规规定，该规定声明相等的对象必须要具有相等的哈希码。</p><p>hashCode方法是为哈希家族的集合类框架（HashMap，HashSet，HashTable）提供的服务，hashCode协定：</p><p>在同一个对象上多次调用hashCode方法时，必须一致的返回相同的整数。</p><p>如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。</p><h4 id="HashMap工作原理说明"><a href="#HashMap工作原理说明" class="headerlink" title="HashMap工作原理说明"></a>HashMap工作原理说明</h4><p><strong>工作原理</strong>：通过hash算法，通过put和get存储和获取对象。</p><ol><li>存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Factor则resize为原来的2倍)。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来。<strong>如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</strong></li><li>获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。</li></ol><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap是最常用的集合类框架之一，它实现了Map接口，所以存储的元素也是键值对映射的结构，并允许使用null值和null键，其内元素是无序的，如果要保证有序，可以使用LinkedHashMap。HashMap是线程不安全的。</p><p> HashMap中我们最长用的就是put(K, V)和get(K)。我们都知道，HashMap的K值是唯一的，那如何保证唯一性呢？我们首先想到的是用equals比较，没错，这样可以实现，但随着内部元素的增多，put和get的效率将越来越低，这里的时间复杂度是O(n)，假如有1000个元素，put时需要比较1000次。实际上，HashMap很少会用到equals方法，因为其内通过一个哈希表管理所有元素，也可以称为散列表，哈希算法可以快速的存取元素，当我们调用put存值时，HashMap首先会调用K的hashCode方法，获取哈希码，通过哈希码快速找到某个存放位置，这个位置可以被称之为<strong>bucketIndex</strong>，通过上面所述hashCode的协定可以知道，<strong>如果hashCode不同，equals一定为false，如果hashCode相同，equals不一定为true。</strong>所以理论上，hashCode可能存在冲突的情况，有个专业名词叫<strong>碰撞</strong>，当碰撞发生时，计算出的bucketIndex也是相同的，这时会取到<strong>bucketIndex</strong>位置已存储的元素，最终通过equals来比较，<strong>equals方法就是哈希码碰撞时才会执行的方法</strong>，所以前面说HashMap很少会用到equals。HashMap通过hashCode和equals最终判断出K是否已存在，如果已存在，则使用新V值替换旧V值，并返回旧V值，如果不存在 ，则存放新的键值对&lt;K, V&gt;到bucketIndex位置。</p><h4 id="HashMap-中put方法的源码"><a href="#HashMap-中put方法的源码" class="headerlink" title="HashMap 中put方法的源码"></a>HashMap 中put方法的源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 处理key为null，HashMap允许key和value为null  </span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);  </span><br><span class="line">    <span class="comment">// 得到key的哈希码  </span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);  </span><br><span class="line">    <span class="comment">// 通过哈希码计算出bucketIndex  </span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);  </span><br><span class="line">    <span class="comment">// 取出bucketIndex位置上的元素，并循环单链表，判断key是否已存在  </span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="comment">// 哈希码相同并且对象相同时  </span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">            <span class="comment">// 新值替换旧值，并返回旧值  </span></span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// key不存在时，加入新元素  </span></span><br><span class="line">    modCount++;  </span><br><span class="line">    addEntry(hash, key, value, i);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HashMap的初始长度"><a href="#HashMap的初始长度" class="headerlink" title="HashMap的初始长度"></a>HashMap的初始长度</h4><p>首先明确，hashmap的默认初始长度是16，并且每次自动扩展或者手动扩展时，长度必须是2的幂。</p><p>之所以选择16，是为了服务于从key映射到index的hash算法。</p><p>从key映射到hashMap数组的对应位置，会用到一个hash函数，为了实现一个尽量均匀分布的hash函数，通过key的hashCode值来做运算。</p><p>为了实现高效的Hash算法，采用了位运算的方法。</p><p><code>index = HashCode(Key) &amp; (Length-1)</code></p><p>以Book为key演示过程。</p><ul><li>计算book的hashCode,为10进制的3029737，二进制的1011100011101011101001</li><li>假定HashMap长度默认16，计算Length-1 为10进制15，二进制1111</li><li>两个结果做<em>与运算</em>，1011100011101011101001&amp;1111 = 1001 十进制是9，所以index=9.</li><li>所以Hash算法最终得到的index结果，完全取决于Key的HashCode的最后几位。</li></ul><p>这样做不但效果上等同于取模，还大大提高了性能。</p><p>要是其他的话，就不平均了，</p><p>由于取16，这样index的结果完全等同于HashCode最后几位的值，只要输入的HashCode平均，Hash算法结果就是平均的。</p><h4 id="高并发下的HashMap"><a href="#高并发下的HashMap" class="headerlink" title="高并发下的HashMap"></a>高并发下的HashMap</h4><p>首先要明白rehash，rehash是HashMap在扩容时候的一个步骤。</p><p>HashMap的容量是有限的，当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会越来越高，这时候，就需要扩展长度，resize。</p><p>Resize并不是简单的把长度扩大，而是经过下面两个步骤。</p><ul><li>扩容  创建一个新的Entry空数组，长度是原数组的2倍。</li><li>reHash 遍历原Entry数组，把所有Entry重新Hash到新数组。重新Hash是因为长度扩大后，Hash规则也随之改变。</li></ul><h5 id="多线程下HashMap的rehash操作带来的问题"><a href="#多线程下HashMap的rehash操作带来的问题" class="headerlink" title="多线程下HashMap的rehash操作带来的问题"></a>多线程下HashMap的rehash操作带来的问题</h5><p>可能会形成链表环。</p><p><a href="https://mp.weixin.qq.com/s/dzNq50zBQ4iDrOAhM4a70A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dzNq50zBQ4iDrOAhM4a70A</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54.Maximum Spiral Matrix</title>
      <link href="/2017/11/13/leetcode54/"/>
      <url>/2017/11/13/leetcode54/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a matrix of <em>m</em> x <em>n</em> elements (<em>m</em> rows, <em>n</em> columns), return all elements of the matrix in spiral order.</p><p>For example,<br>Given the following matrix:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>You should return <code>[1,2,3,6,9,8,7,4,5]</code>.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>将一个矩阵以螺旋式的方式输出出来。<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hang = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> lie =matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> hangbegin=<span class="number">0</span>,hangend=hang<span class="number">-1</span>,liebegin=<span class="number">0</span>,lieend=lie<span class="number">-1</span>;</span><br><span class="line">      <span class="comment">//设置四个指针，分别指向行的开始，行的结束，列的开始，列的结束。</span></span><br><span class="line">      <span class="comment">//大的循环条件就是行开始小于等于行结束，列开始要小于等于列结束。</span></span><br><span class="line">      <span class="comment">//然后以上，右，下，左的顺序依次输出每个元素。输出完以后修改指针的位置。</span></span><br><span class="line">        <span class="keyword">while</span>(hangbegin&lt;=hangend &amp;&amp; liebegin&lt;=lieend)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=liebegin;i&lt;=lieend;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[hangbegin][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            hangbegin++;</span><br><span class="line">          <span class="comment">//输出完上面后，行的开始要加1.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=hangbegin;i&lt;=hangend;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[i][lieend]);</span><br><span class="line">            &#125;</span><br><span class="line">            lieend--;</span><br><span class="line">          <span class="comment">//输出完右边后，列的结束要减1.</span></span><br><span class="line">            <span class="keyword">if</span> (hangbegin &lt;= hangend) </span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> i=lieend;i&gt;=liebegin;i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(matrix[hangend][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//这个if条件和下面的if条件不能去掉，因为在大的while循环里面，hangbegin已经加1了，这样在//循环中，是有可能hangbegin&gt;hangend的，所以要再加上条件进行判断。下面的if同理。</span></span><br><span class="line">            hangend--;</span><br><span class="line">          <span class="comment">//输出完下面后行的结束要减1.</span></span><br><span class="line">            <span class="keyword">if</span>(liebegin&lt;=lieend)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=hangend;i&gt;=hangbegin;i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(matrix[i][liebegin]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            liebegin++;</span><br><span class="line">          <span class="comment">//输出完左边后，列的开始要加1.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>This is a very simple and easy to understand solution. I traverse right and increment rowBegin, then traverse down and decrement colEnd, then I traverse left and decrement rowEnd, and finally I traverse up and increment colBegin.</p><p>The only tricky part is that when I traverse down or left I have to check whether the row or col still exists to prevent duplicates. </p><h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><p>声明一个n个大小的vector&lt;vector<int> &gt;<br>vector&lt;vector<int> &gt; res( n, vector<int>(n) );</int></int></int></p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48. Rotate Image</title>
      <link href="/2017/11/12/leetcode48/"/>
      <url>/2017/11/12/leetcode48/</url>
      
        <content type="html"><![CDATA[<p>You are given an <em>n</em> x <em>n</em> 2D matrix representing an image.</p><p>Rotate the image by 90 degrees (clockwise)..</p><p><strong>Note:</strong><br>You have to rotate the image <strong>in-place</strong>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h5><p>顺时针90度旋转一个矩阵。</p><h5 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                swap(matrix[i][j],matrix[n<span class="number">-1</span>-j][n-i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(matrix[i][j],matrix[n-i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><img src="http://blog-1252095801.cosgz.myqcloud.com/2017-11-12%2020-01-07.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53.Maximum Subarray</title>
      <link href="/2017/11/12/leetcode53/"/>
      <url>/2017/11/12/leetcode53/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p><p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>找出给定的数字串中值最小的序列的最小值。<br><a id="more"></a></p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length =nums.size();</span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN; <span class="comment">// 表示最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)                 <span class="comment">// 1</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum =<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum =sum+nums[i];         <span class="comment">// 2</span></span><br><span class="line">          </span><br><span class="line">            res =max(res,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用SUM记录相加的和，用res记录最后的结果，也就是最大的SUM。将序列中的数字不断的进行相加，如果相加的和小于０,则将则把SUM置为0，重新进行相加，（因为此时前面的都是小于0的，后面的数不管怎么加都是肯定越加越小的，所以把前面的置为0.）</p><p>还有就是代码中1的判断要放在2的前面，这样当序列里都是负数的时候，才可以找到最大的负数。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 泛型的总结与复习</title>
      <link href="/2017/11/11/%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E5%A4%8D%E4%B9%A0/"/>
      <url>/2017/11/11/%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型的总结与复习"><a href="#泛型的总结与复习" class="headerlink" title="泛型的总结与复习"></a>泛型的总结与复习</h2><p>在1.5之前是没有泛型的，而通常使用object来泛化我们所有的对象，这样做也可以让我们达到泛型的目的，但是在代码编写的过程中很容易出现类型转换的错误，这种错误在编译期间是不知道的，只有到运行期间才知道。 </p><p> java语言的泛型基本上完全是在编译器中实现的，有编译器执行类型检测和类型推断，然后生成普通的非泛型的字节码，就是虚拟机完全无感知泛型的存在。这种实现技术称为擦除（erasure）。编译器使用泛型类型信息保证类型安全，然后在生成字节码之前将其清除。所以使用了泛型后在编译期便可知道是否有错。</p><p>泛型可以解决数据类型的安全性问题，主要原理就是在类声明时通过一个标识表示类中某个属性的类型或者某个方法的返回值及参数类型。这样在类声明或者实例化时只要指定好需要的类型即可。</p><p>泛型类定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> T name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(T1 name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fruit类在声明的时候使用了<code>&lt;T&gt;</code>的形式，<strong>T表示此类型由外部调用本类时指定</strong>的。实例化对象时可以使用</p><p><code>Fruit&lt;String&gt; f =new Fruit&lt;String&gt;();</code></p><p>加入泛型后的最大好处实际上是避免了类转换异常的发生，这样使得程序的操作更加安全。</p><h4 id="泛型中的构造方法"><a href="#泛型中的构造方法" class="headerlink" title="泛型中的构造方法"></a>泛型中的构造方法</h4><p>构造方法可以为类中的属性初始化，那么如果类中的属性通过泛型指定，而又需要通过构造设置属性内容时，构造方法的定义与之前并无不同，不需要像声明1类那样指定泛型，具体格式如下：</p><p><code>public Fruit(T name){this.name=name}</code></p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>泛型操作中可以通过通配符接收任意指定泛型类型的对象。</p><p>在开发中对象的引用传递是最常见的，但是如果在泛型类中的操作中，在进行引用传递时泛型类型必须匹配才可以传递，否则是无法传递的，下面是一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  Info&lt;String&gt; i =<span class="keyword">new</span> Info&lt;&gt;();</span><br><span class="line">      i.setVar(<span class="string">"wkn"</span>);</span><br><span class="line">      fun(i);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Info&lt;Object&gt; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  System.out.println(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个类的子类可以通过对象多态性为其父类实例化，但是在泛型操作中，子类的泛型类型是无法使用父类的泛型类型接收的</strong></p><p>上述程序会出现编译时错误，尽管String 是Object 类的子类，但是在进行引用传递时也同样无法进行操作，如果此时想让程序正确执行，可以将fun()方法中定义的<code>Info&lt;Object&gt;</code> 修改为<code>Info</code>，即不指定泛型。</p><p>但是，这样并不推荐，所以最好采用通配符的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;        </span><br><span class="line">    Info&lt;String&gt; i =<span class="keyword">new</span> Info&lt;&gt;();        </span><br><span class="line">    i.setVar(<span class="string">"wkn"</span>);</span><br><span class="line">    fun(i);</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Info&lt;?&gt; temp)</span></span></span><br><span class="line"><span class="function">  </span>&#123;        </span><br><span class="line">    System.out.println(temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Info&lt;?&gt;</code>表示可以使用任意的泛型类型对象。</p><p>在引用传递中，在泛型操作中也可以设置一个泛型对象范围上限和范围下限，范围上限使用extends关键字声明，表示参数化的类型可能是所指定的类型或者此类型的子类，而范围下限使用super进行声明，表示参数化的类型可能是所指定的1类型，或者是此类型的父类型，或者Object类。</p><p>声明对象（设置上限）：<code>Fruit&lt;? extends 类&gt; fruit</code></p><p>声明对象（设置下限）：<code>Fruit&lt;? super 类&gt; fruit</code></p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>在JDK1.5后，不仅可以声明泛型类，还可以声明泛型接口，声明泛型接口和声明泛型类的语法类似，也是在接口名称后面加上<code>&lt;T&gt;</code>,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">子类实现</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> T var;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InfoImpl</span><span class="params">(T var)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setVar(var);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T var)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.var =var;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.var;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法的定义与其所在的类是否是泛型类是没有任何关系的。所在的类可以是泛型类，也可以不是。</p><h5 id="泛型方法定义"><a href="#泛型方法定义" class="headerlink" title="泛型方法定义"></a>泛型方法定义</h5><p><code>[访问权限] &lt;泛型标识&gt; 泛型标识(返回值类型) 方法名称([泛型标识 参数名称])</code></p><p>第二部分的泛型标识标识了这是一个泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">fun</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mdemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  Demo d =<span class="keyword">new</span> Demo();</span><br><span class="line">      String str =d.fun(<span class="string">"wkn"</span>);</span><br><span class="line">      <span class="keyword">int</span> i =d.fun(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h3><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong></p><p>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>在java中是<strong>”不能创建一个确切的泛型类型的数组”</strong>的。</p><p>下面采用通配符的方式是被允许的:<strong>数组的类型不可以是类型变量，除非是采用通配符的方式</strong>，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python zip</title>
      <link href="/2017/11/10/Python-zip/"/>
      <url>/2017/11/10/Python-zip/</url>
      
        <content type="html"><![CDATA[<p>zip函数的原型为：<strong>zip([iterable, …])</strong></p><p>参数iterable为可迭代的对象，并且可以有多个参数。该函数返回一个以元组为元素的列表，其中第 i 个元组包含每个参数序列的第 i 个元素。返回的列表长度被截断为最短的参数序列的长度。只有一个序列参数时，它返回一个1元组的列表。没有参数时，它返回一个空的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">b=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">c=np.arange(<span class="number">5</span>)</span><br><span class="line">d=<span class="string">"zhang"</span></span><br><span class="line">zz=zip(a,b,c,d)</span><br><span class="line">print(zz)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">'z'</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">'h'</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">'a'</span>), (<span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="string">'n'</span>), (<span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="string">'g'</span>)]</span><br></pre></td></tr></table></figure><p>当没有参数的时候</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">zz=zip()</span><br><span class="line">print(zz)</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>当只有一个参数的时候</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">zz=zip(a)</span><br><span class="line">print(zz)</span><br><span class="line">输出：[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,)]</span><br></pre></td></tr></table></figure><p>当多个参数长度不同的时候</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">c=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">zz=zip(a,b,c)</span><br><span class="line">print(zz)</span><br><span class="line">输出：[(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure><p>zip() 和 * 操作符一起操作可以用来 unzip 一个列表，看下面的代码：(其实就是前面的反向操作,把一个列表拆成几个)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c=[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">zz=zip(a,b,c)</span><br><span class="line">print(zz)</span><br><span class="line">输出:[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>)]</span><br><span class="line"></span><br><span class="line">x,y,z=zip(*zz)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(z)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>注意这里输出的每个都是元组，而不一定是原来的类型，但是值不会发生变化（除非原来的参数列表长度不一样，看下面的代码）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">c=[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">zz=zip(a,b,c)</span><br><span class="line">print(zz)</span><br><span class="line"></span><br><span class="line">x,y,z=zip(*zz)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(z)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>)]</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">(<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>unzip后的列表b和c的值都少了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. Trapping Rain Water</title>
      <link href="/2017/11/10/leetcode42/"/>
      <url>/2017/11/10/leetcode42/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><p>For example,<br>Given <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>, return <code>6</code>.</p><p><img src="http://www.leetcode.com/static/images/problemset/rainwatertrap.png" alt="img"></p><p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. <strong>Thanks Marcos</strong> for contributing this image!</p><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一系列的非负整数，把他们看成坐标轴上的数，如上图所示，黑色的就是用数字围成的墙，求这个容器可以装下多少水，也就是蓝色的部分可以有多少.</p><a id="more"></a><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length =height.size();</span><br><span class="line">        <span class="keyword">int</span> left =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right =length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftmax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightmax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            leftmax =max(height[left],leftmax);</span><br><span class="line">            rightmax =max(height[right],rightmax);</span><br><span class="line">            <span class="keyword">if</span>(leftmax&lt;rightmax)</span><br><span class="line">            &#123;</span><br><span class="line">                res = res+leftmax-height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res =res+rightmax-height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>使用twopoint的思想，(使用twopoint的时候，貌似循环条件都是left&lt;right 或者left&lt;= right吧。。。)</p><p>首先应该知道，每个Bar上装的水的量取决于 <strong>左边最高的Bar和右边最高的bar中的较小值</strong>。</p><p>用left和right来指向本次循环处理哪个Bar（两边是交替着进行的，不像一个循环一样从左到右进行循环）, leftmax和rightmax 分别来记录左边最大的Bar和右边最大的bar。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vector的分析</title>
      <link href="/2017/11/08/Vector%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2017/11/08/Vector%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Vector的分析"><a href="#Vector的分析" class="headerlink" title="Vector的分析"></a>Vector的分析</h2><p>vector是线程安全的，实际上并不是。</p><p>原因可能是因为 Vector 的所有方法加上了 synchronized 关键字，从而保证访问 vector 的任何方法都必须获得对象的 <strong>intrinsic lock</strong> (或叫 <strong>monitor lock</strong>)，也即，在vector内部，其所有方法不会被多线程所访问。</p><p>考虑以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!vector.contains(element)) </span><br><span class="line">    vector.add(element); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>这是经典的 <strong>put-if-absent</strong> 情况，尽管 contains, add 方法都正确地同步了，但作为 vector 之外的使用环境，仍然存在  <strong>race condition</strong>: 因为虽然条件判断 if (!vector.contains(element))与方法调用 vector.add(element);  都是原子性的操作 (<strong>atomic</strong>)，但在 if 条件判断为真后，那个用来访问vector.contains 方法的锁已经释放，在即将的 vector.add 方法调用 之间有间隙，在多线程环境中，完全有可能被其他线程获得 vector的 lock 并改变其状态, 此时当前线程的vector.add(element);  正在等待（只不过我们不知道而已）。只有当其他线程释放了 vector 的 lock 后，vector.add(element); 继续，但此时它已经基于一个错误的假设了。</p><p><strong>Vector 和 ArrayList 实现了同一接口 List, 但所有的 Vector 的方法都具有 synchronized 关键修饰。但对于复合操作，Vector 仍然需要进行同步处理。 </strong></p><p>另一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector=<span class="keyword">new</span> Vector();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                vector.add(i); <span class="comment">//往vector中添加元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            Thread removeThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;         </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//获取vector的大小</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vector.size();i++)&#123;</span><br><span class="line">                        <span class="comment">//当前线程让出CPU,使例子中的错误更快出现</span></span><br><span class="line">                        Thread.yield();</span><br><span class="line">                        <span class="comment">//移除第i个数据</span></span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">           Thread printThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;          </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//获取vector的大小</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vector.size();i++)&#123;</span><br><span class="line">                        <span class="comment">//当前线程让出CPU,使例子中的错误更快出现</span></span><br><span class="line">                        Thread.yield();</span><br><span class="line">                        <span class="comment">//获取第i个数据并打印</span></span><br><span class="line">                        System.out.println(vector.get(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);         </span><br><span class="line">            removeThread.start();</span><br><span class="line">           printThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Vector类中对get以及remove，size方法都加了synchronized关键字来保证同步，也就说当一个线程调用了这些方法时，其他线程不能再同时调用这些方法。换言之，<strong>不能出现两个及两个以上的线程在同时调用这些同步方法</strong>。<br>那么为什么例子中会出现问题呢？这是因为 <strong>例子中有些线程连续调用了两个或两个以上的同步方法</strong>。<br>例子中 removeThread线程先调用了vector.size()方法获得vector的大小，接着调用vector.remove(i)移除第i个元素；而printThread线程也先调用vector.size()方法获得vector的大小，接着调用vector.get()获得第i个元素。</p><p>假设此时vector大小为5，此时printThread线程执行到 i=4 ，进入for循环但在 <code>System.out.println(vector.get(i));之前</code>printThread线程的CPU时间片已到，线程printThread转入就绪状态；<br>此时removeThread线程获得CPU开始执行，把vector的5个元素全删除了，这是removeThreadCPU时间片已到；<br>接着printThread获得CPU进行执行，由于之前printThread中的i==4，于是调用vector.get(4)获取元素，此时由于vector中的元素已被removeThread线程全部删除，因此报错。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>同步方法之间也是有间隙的，所以虽然每个方法的执行是原子的，但是复合操作就还是可能会出现问题。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁 ,ForkJoin</title>
      <link href="/2017/11/08/%E9%94%81%E5%92%8Cforkjoin/"/>
      <url>/2017/11/08/%E9%94%81%E5%92%8Cforkjoin/</url>
      
        <content type="html"><![CDATA[<h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>大多数类都将内置锁作为一种有效的加锁机制,但是对象的域并不一定要通过内置锁来保护,之所以每个对象都有一个内置锁,只是为了免去显示的创建锁对象.</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>当互斥同步的时候（悲观锁），互斥同步对性能影响最大的就是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。同时，在实际应用中，共享数据的锁定状态只会持续很短的一断时间，为了让这段时间去恢复和挂起线程并不值得，如果物理机器有一个以上处理器，能让两个线程同时并行执行，就可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快的会释放锁。为了让线程等待，我们需要让线程执行一个忙循环（自旋）这就是自旋锁。</p><p>自旋等待本身虽然避免了线程切换的开销，但是是要占用处理器时间的，因此。如果锁占用时间很短，则效果很好，反之，锁占用时间很长，自旋就会白白消耗处理器资源，带来性能上的浪费。</p><p>jdk1.6引入了自适应的自旋锁，意味着自旋的时间不再苦丁，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><a id="more"></a><h2 id="监视器锁"><a href="#监视器锁" class="headerlink" title="监视器锁"></a>监视器锁</h2><p>Java中实现同步的一种机制就是利用Synchronized关键字来修饰同步代码块，他的本质是对对象进行枷锁来达到同步的目的，称这种锁为对象监视器锁。</p><p>根据java虚拟机规范，被synchronized关键字修饰的代码块在被编译成字节码的时候 会在该代码块开始和结束的时候插入monitorenter 和 moniterexist指令,虚拟机在执行这两个指令的时候会检查对象的锁状态是否为空或当前线程是否已经拥有该对象锁 如果是 则将对象锁的计数器加1 直接进入同步代码执行。如果不是当前线程就要阻塞等待 等到锁释放 。</p><p>java的线程是映射到OS原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到核心态，因此状态转换需要花费很多的处理器时间，对于代码简单的同步块（如被synchronized修饰的get 或set方法）状态转换消耗的时间有可能比用户代码执行的时间还要长，所以说synchronized是java语言中一个重量级的操纵。</p><h2 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h2><p>有时候，你希望创建一个线程来执行一些辅助工作，但是又不希望这个线程阻碍JVM的关闭，这种情况下就需要使用守护线程。</p><p>线程可以分为两种，普通线程和守护线程。在JVM启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程（例如垃圾回收器以及其他执行辅助工作的线程）当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。</p><p>普通线程与守护线程的区别仅在于当线程退出时发生的操作，当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM就会正常退出，当JVM停止时，所有守护线程既不会执行finally，也不会执行回卷栈，而JVM只是直接退出。</p><h2 id="Fork-join"><a href="#Fork-join" class="headerlink" title="Fork/join"></a>Fork/join</h2><p>分而治之是有效处理大量数据的方法,</p><p>fork有分叉的意思,也就是创建子进程, join表示等待</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202018-01-17%2020-13-03.png" width="50%"></p><p>实际使用线程池执行的时候,一个物理线程需要处理多个逻辑任务,因此,一个线程必然要拥有一个任务队列,因此,线程A可能执行完了自己的任务,线程B还有一堆任务等着执行,这时,A就会帮助B.从B的任务队列中拿过来任务帮助B</p><p>需要注意的是,当线程试图帮助别人的时候,总是从任务队列的底部开始拿数据,而线程执行自己的任务时,总是从顶部拿数据</p><p>ForkJoinPool的一个重要接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span> <span class="params">(ForkJoinTask&lt;T&gt; task)</span></span></span><br></pre></td></tr></table></figure><p>可以向forkJoinPool线程池提交一个ForkJoinTask任务,ForkJoinTask任务就是支持fork分解和join等待的任务,</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39.Combination Sum</title>
      <link href="/2017/11/08/leetcode39/"/>
      <url>/2017/11/08/leetcode39/</url>
      
        <content type="html"><![CDATA[<p>Given a <strong>set</strong> of candidate numbers (<strong>C</strong>) <strong>(without duplicates)</strong> and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p><p>The <strong>same</strong> repeated number may be chosen from <strong>C</strong> unlimited number of times.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set <code>[2, 3, 6, 7]</code> and target <code>7</code>,<br>A solution set is: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2, 2, 3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h5><p>给出一系列数字，和一个总和target，给出所有的排列使得和等于target，返回所有的序列。</p><h5 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> nums_len;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        nums_len = candidates.size();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, target, candidates);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> sum, <span class="keyword">int</span> target,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidates)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">//一般DFS中需要有一个index，用来标记现在把那个节点遍历过了，所以为了不重复，前面先进行了排序。</span></span><br><span class="line">         <span class="keyword">if</span>(sum==target) <span class="comment">//死胡同</span></span><br><span class="line">         &#123;</span><br><span class="line">             res.push_back(ans);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)   <span class="comment">//死胡同</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">         <span class="comment">// 因为每个岔路口不止一种情况，而是candidates.size()情况，所以用 循环把每种情况都进行遍历。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;nums_len;i++)   <span class="comment">//岔道口</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(candidates[i]);</span><br><span class="line">                dfs(i,sum+candidates[i],target,candidates);</span><br><span class="line">                ans.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h4><p>深度优先搜索是一种枚举所有完整路径以遍历所有情况的搜索方法。</p><p>方法是：</p><p>​    先对问题进行分析，得到岔路口和死胡同，再定义一个栈，以深度为关键词访问这些岔道口和死胡同，并将他们入栈，而当离开这些岔道口和死胡同时，再将他们入栈。</p><p>​    当用递归进行实现时，递归中的递归式就是岔道口，而递归边界就是死胡同。</p><p>​    使用递归时，系统会调用一个叫系统栈的东西来存放递归中每一层的状态，因此用递归实现的dfs的本质还是栈。</p><h4 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h4><p>回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。可以认为回溯算法一个”通用解题法“，这是由他试探性的行为决定的，就好比求一个最优解，我可能没有很好的概念知道怎么做会更快的求出这个最优解，但是我可以尝试所有的方法，先试探性的尝试每一个组合，看看到底通不通，如果不通，则折回去，由最近的一个节点继续向前尝试其他的组合，如此反复。这样所有解都出来了，在做一下比较，能求不出最优解吗？</p><h5 id="基本概念与定义"><a href="#基本概念与定义" class="headerlink" title="基本概念与定义"></a>基本概念与定义</h5><p>约束函数：约束函数是根据题意定出的。通过描述合法解的一般特征用于去除不合法的解，从而避免继续搜索出这个不合法解的剩余部分。因此，约束函数是对于任何状态空间树上的节点都有效、等价的。</p><p>状态空间树：刚刚已经提到，状态空间树是一个对所有解的图形描述。树上的每个子节点的解都只有一个部分与父节点不同。</p><p>扩展节点、活结点、死结点：所谓扩展节点，就是当前正在求出它的子节点的节点，在DFS中，只允许有一个扩展节点。活结点就是通过与约束函数的对照，节点本身和其父节点均满足约束函数要求的节点；死结点反之。由此很容易知道死结点是不必求出其子节点的（没有意义）。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volatile 关键字</title>
      <link href="/2017/11/07/Volatile/"/>
      <url>/2017/11/07/Volatile/</url>
      
        <content type="html"><![CDATA[<h2 id="volatile-解析"><a href="#volatile-解析" class="headerlink" title="volatile 解析"></a>volatile 解析</h2><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p>计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p><p>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p><p>在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存。</p><p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p><p>为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p><ul><li>通过在总线加LOCK#锁的方式</li><li>通过缓存一致性协议</li></ul><p>这2种方式都是硬件层面上提供的方式。</p><h4 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h4><p>原子性 可见性 有序性</p><ul><li>原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就不执行</li><li>可见性：可见性是指多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看的到修改的值。</li><li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li></ul><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p><p>主要来看有序性，</p><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>在Java里面，<strong>可以通过volatile关键字来保证一定的“有序性”</strong>。另外可以通过<strong>synchronized和Lock来保证有序性</strong>，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p>另外，<font color="ofofof">Java内存模型具有一些先天的有序性，即不需要任何手段就能够保证的有序性，也就是happens-before规则，他是JMM对程序员的一种承诺。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<font color="ofofof"></font></font></p><p>下面就来具体介绍下happens-before原则（先行发生原则）：</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序次序规则就是一段程序代码的执行在单个线程中看起来是有序的，这个规则只能用来保证程序在单线程中执行结果的正确性，但是无法确保程序在多线程中执行的正确性。</span><br></pre></td></tr></table></figure><ul><li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无论在单线程还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，才能继续进行lock操作。</span><br></pre></td></tr></table></figure><ul><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</span><br></pre></td></tr></table></figure><ul><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">happens-before规则具有传递性</span><br></pre></td></tr></table></figure><h4 id="分析volatile-关键字"><a href="#分析volatile-关键字" class="headerlink" title="分析volatile 关键字"></a>分析volatile 关键字</h4><h5 id="volatile关键字的两层语义"><a href="#volatile关键字的两层语义" class="headerlink" title="volatile关键字的两层语义"></a>volatile关键字的两层语义</h5><p>一旦一个共享变量被volatile 修饰之后，那么就具备了两层语义</p><ul><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的</li><li>禁止进行指令重排序。</li></ul><p>禁止指令重排序有两层意思，</p><ul><li><p>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行。</p></li><li><p>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p><p>一个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x、y为非volatile变量</span></span><br><span class="line"><span class="comment">//flag为volatile变量</span></span><br><span class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></span><br><span class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></span><br><span class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3</span></span><br><span class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></span><br><span class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></span><br></pre></td></tr></table></figure><p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p><p>　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p><h4 id="volatile-的实现原理"><a href="#volatile-的实现原理" class="headerlink" title="volatile 的实现原理"></a>volatile 的实现原理</h4><p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p><p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><ul><li>1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</li><li>2）它会强制将对缓存的修改操作立即写入主存。</li><li>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized 关键字</title>
      <link href="/2017/11/07/Synchronized-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2017/11/07/Synchronized-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="synchronized关键字的作用域有二种："><a href="#synchronized关键字的作用域有二种：" class="headerlink" title="synchronized关键字的作用域有二种："></a>synchronized关键字的作用域有二种：</h3><ul><li>是某个对象实例内，synchronized  Method(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法； </li><li>是某个类的范围，synchronized static  aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。</li></ul><p>2、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: <code>synchronized(this){/* 区块 */}</code>，它的作用域是当前对象；</p><p>3、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法；</p><a id="more"></a><p>Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p><ul><li>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</li><li>然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</li><li>尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</li><li>第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</li><li>以上规则对其它对象锁同样适用.</li></ul><h4 id="synchronized-关键字，它包括两种用法：synchronized-方法和-synchronized-块。"><a href="#synchronized-关键字，它包括两种用法：synchronized-方法和-synchronized-块。" class="headerlink" title="synchronized 关键字，它包括两种用法：synchronized 方法和 synchronized 块。"></a>synchronized 关键字，它包括两种用法：synchronized 方法和 synchronized 块。</h4><ul><li>synchronized 方法：通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如：  <code>public synchronized void accessVal(int newVal);</code>synchronized 方法控制对类成员变量的访问：每个<strong>类实例</strong>对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）</li></ul><p><strong>在 Java 中，不光是类实例，每一个类也对应一把锁</strong>，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。  </p><ul><li><p>Synchronized 块 通过 synchronized关键字来声明synchronized 块。语法如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronized(syncObject) &#123;  //允许访问控制的代码  &#125;</span><br></pre></td></tr></table></figure><p>synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且<strong>可任意指定上锁的对象</strong>，故灵活性较高。</p></li></ul><p><strong>对象锁也就是监视器，</strong><font color="red" size="3">任意一个对象都有自己的监视器</font><strong>，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，没有获取到监视器的线程被阻塞在同步块或者同步方法入口，进入阻塞状态。</strong></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>进入synchronized方法或者代码块需要拿锁，第一个线程进去后，其他线程都不能进了，在一个对象中，所有Synchronized标注的方法或者代码块需要的是同一把对象锁（只有一个监视器对象），所以一个进程拿锁后，这个对象中其他所以Synchronized标注的方法或者代码块就都进不去了。</p><p>但是若是同一个类，不同的对象，则不同的线程就可以同时执行。</p><p>同样的，类自己也是一种对象，所以类自己也有锁。锁住了类，并不代表锁住了类所在的对象。</p><h3 id="一个典型错误"><a href="#一个典型错误" class="headerlink" title="一个典型错误"></a>一个典型错误</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">      increase();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Thread t1 =<span class="keyword">new</span> Thread(<span class="keyword">new</span> Mythread());</span><br><span class="line">    Thread t2 =<span class="keyword">new</span> Thread(<span class="keyword">new</span> Mythread());</span><br><span class="line">    t1.start();t2.start();</span><br><span class="line">    t1.join();t2.join();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在increase中声明了这是一个同步方法,但是两个线程t1,t2指向了两个不同的runnable实例, 这两个实例并不是同一个对象,(没有加到同一个对象上,)也就是说,使用的是两把不同的锁,所以无法保证线程安全性.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 3 Sum</title>
      <link href="/2017/11/03/leetcode15/"/>
      <url>/2017/11/03/leetcode15/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For example, given <span class="built_in">array</span> S = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>],</span><br><span class="line"></span><br><span class="line">A solution <span class="built_in">set</span> is:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>题目大意：</p><p>在一个给出的序列中找出三个数，使三个数字的和加一起为0。</p><p>思路：</p><p>1首先先对数组排序</p><p>2枚举每个数，对每一个数a[i]，若想条件成立，后面的两个数加起来都等于a[i]的负数，所以固定a[i]进行循环</p><p>3设立两个指针left，right，分别指向a[i]的下一个数和整个序列的最后一个数，因为数组已经排序，所以根据a[left]+a[right]的大小不断调整left right的位置。</p><p>4 需要注意的地方有因为不能重复，所以需要判断重复的元素情况，包括a[i]的重复情况 a[left]的重复情况a[right]的重复情况。</p><a id="more"></a><p>我的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> len= nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left =i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right =len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> result= -nums[i];</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left]+nums[right]&gt;result)</span><br><span class="line">                &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[left]+nums[right]&lt;result)</span><br><span class="line">                &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">                    <span class="keyword">int</span> front =nums[left];</span><br><span class="line">                    <span class="keyword">int</span> end =nums[right];</span><br><span class="line">                    a.push_back(nums[i]);</span><br><span class="line">                    a.push_back(nums[left]);</span><br><span class="line">                    a.push_back(nums[right]);</span><br><span class="line">                    res.push_back(a);</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;front==nums[left]) left++;</span><br><span class="line">                  <span class="comment">// 判断下一个left数是否重复，重复直接跳过。</span></span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;end==nums[right]) right--;</span><br><span class="line">                  <span class="comment">// 判断下一个right数是否重复，重复直接跳过。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">while</span> (i + <span class="number">1</span> &lt; nums.size() &amp;&amp; nums[i + <span class="number">1</span>] == nums[i]) i++;</span><br><span class="line">          <span class="comment">// 判断下一个a[i]数是否重复，重复直接跳过。</span></span><br><span class="line">        &#125;<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考了discuss的<a href="https://discuss.leetcode.com/topic/8107/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments方法。" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/8107/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments方法。</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中的转发和重定向</title>
      <link href="/2017/10/27/Java%20%E4%B8%AD%E7%9A%84%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2017/10/27/Java%20%E4%B8%AD%E7%9A%84%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">转发：</span><br><span class="line">request.getRequestDispatcher(&quot;success.jsp&quot;).forward(request,response);</span><br><span class="line"></span><br><span class="line">在服务器组件收到用户请求后。经过它的处理后有传递给了另一个组件。不修改用户的请求码。各组件处理完之后在返回给用户，例如主页面的框架。</span><br><span class="line"></span><br><span class="line">          用户请求----&gt;服务器----&gt;组件1----&gt;组件2----&gt;服务器----&gt;用户</span><br><span class="line"></span><br><span class="line">                                                          （请求不变）</span><br><span class="line"></span><br><span class="line">重定向：</span><br><span class="line">response.sendRedirect(&quot;success.jsp&quot;);</span><br><span class="line"></span><br><span class="line">在服务器组件收到用户请求后。经过处理修改用户请求。在返回给用户。这样用户再次使用这个请求就会被动的使用新的请求了。（重定向一般是为了防止用户提交完数据后点浏览器刷新或点后退之后产生重复提交）</span><br><span class="line"></span><br><span class="line">用户请求----&gt;服务器----&gt;组件----&gt;服务器----&gt;用户----&gt;新的请求</span><br><span class="line"></span><br><span class="line">                                                    （修改用户请求）</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="springMVC-中的应用"><a href="#springMVC-中的应用" class="headerlink" title="springMVC 中的应用"></a>springMVC 中的应用</h2><p>springMVC中常用到redirect来实现重定向，但是使用场景各有需求，重定向中可能需要在url中拼接参数，可能需要返回model。springMVC用RedirectAttributes 解决问题。</p><p>首先，在controller中重定向用以下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>  “redirect：/index”；</span><br></pre></td></tr></table></figure><p>此时只是重定向到简单的地址；</p><p>使用RedirectAttributes 来设置重定向页面的参数。 springMVC会自动拼接URL。</p><p>该对象的两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：addAttribute</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"save"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(User user, RedirectAttributes redirectAttributes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    redirectAttributes.addAttribute(<span class="string">"param"</span>,<span class="string">"value1"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"redirect:/index"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//跳转到index时，会在URL拼接 ？ param=value1.</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>：addFlashAttribute</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(User user,RedirectAttributes redirectAttributes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    redirectAttribute.addFlashAttributes(<span class="string">"param"</span>,<span class="string">"value1"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"redirect:/index"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//跳转save后，可以在index对应的模板中通过表达式，比如jsp中jstl的$&#123;param&#125; ，获取返回值，该值实际上保存在session中，并且会在下次重定向时删除。</span></span><br></pre></td></tr></table></figure><h3 id="服务端跳转和客户端跳转"><a href="#服务端跳转和客户端跳转" class="headerlink" title="服务端跳转和客户端跳转"></a>服务端跳转和客户端跳转</h3><p>服务端跳转指的是地址栏内容不变，客户端浏览器的地址栏不会显示目标地址的URL。 所以跳转与否，客户端是不知道的，属于一次request。</p><p>客户端跳转指的是地址栏的内容发生了改变，客户端向服务器发送请求后，服务端再给客户端一个响应，然后客户端根据服务端给的响应中的URL再次向服务端发送请求，所以是两次请求。第二次跳转的时候，已经出了request的属性范围了。</p><p>如果使用的是服务器端跳转，则执行到跳转语句时会立刻进行跳转，如果是客户端跳转，则是在整个页面执行完后才执行跳转。</p><h4 id="java中的服务端跳转"><a href="#java中的服务端跳转" class="headerlink" title="java中的服务端跳转"></a>java中的服务端跳转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"sucess.jsp"</span>).forward(request,response)</span><br><span class="line">&lt;jsp:forward&gt;</span><br></pre></td></tr></table></figure><h4 id="客户端跳转"><a href="#客户端跳转" class="headerlink" title="客户端跳转"></a>客户端跳转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"fail.jsp"</span>) 所有页面执行完之后再进行跳转</span><br></pre></td></tr></table></figure><h4 id="跳转方法"><a href="#跳转方法" class="headerlink" title="跳转方法"></a>跳转方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>： redirect方式</span><br><span class="line">response.sendRedirect(<span class="string">"/a.jsp"</span>) 页面路径是相对路径，可以将页面跳转到任何页面，不局限在本web应用中。</span><br><span class="line"><span class="number">2</span>： forward方式</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/a.jsp"</span>).forward(request,response) 只能跳转到本应用页面。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 常见注解</title>
      <link href="/2017/10/26/SpringBoot%20%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/"/>
      <url>/2017/10/26/SpringBoot%20%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot-常见注解"><a href="#SpringBoot-常见注解" class="headerlink" title="SpringBoot 常见注解"></a>SpringBoot 常见注解</h2><h4 id="RestController和-RequestMapping注解"><a href="#RestController和-RequestMapping注解" class="headerlink" title="@RestController和@RequestMapping注解"></a>@RestController和@RequestMapping注解</h4><p>第一个注解是 @RestController 。这被称为一个构造型（stereotype）注解。它为阅读代码的人们提供建议。对于Spring，该类扮演了一个特殊角色。在本示例中，我们的类是一个web @Controller ，所以当处理进来的web请求时，Spring会询问它。@RequestMapping 注解提供路由信息。它告诉Spring任何来自”/“路径的HTTP请求都应该被映射到 home 方法。 @RestController 注解告诉Spring以字符串的形式渲染结果，并直接返回给调用者。</p><h4 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title="@EnableAutoConfiguration注解"></a>@EnableAutoConfiguration注解</h4><p>类级别的注解@EnableAutoConfiguration 。这个注解告诉Spring Boot根据添加的jar依赖猜测你想如何配置Spring。由于 spring-boot-starter-web 添加了Tomcat和Spring MVC，所以auto-configuration将假定你正在开发一个web应用并相应地对Spring进行设置。Starter POMs和Auto-Configuration：设计auto-configuration的目的是更好的使用”Starter POMs”，但这两个概念没有直接的联系。你可以自由地挑选starter POMs以外的jar依赖，并且Spring Boot将仍旧尽最大努力去自动配置你的应用。</p><p>可以通过将 @EnableAutoConfiguration 或 @SpringBootApplication 注解添加到一个 @Configuration 类上来选择自动配置。</p><blockquote><p>只需要添加一个 @EnableAutoConfiguration 注解。我们建议你将它添加到主 @Configuration 类上。</p></blockquote><p>如果发现应用了你不想要的特定自动配置类，你可以使用 @EnableAutoConfiguration 注解的排除属性来禁用它们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>(exclude=&#123;DataSourceAutoConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="放置应用的main类"><a href="#放置应用的main类" class="headerlink" title="放置应用的main类"></a>放置应用的main类</h4><p>通常建议将应用的main类放到其他类所在包的顶层(root    package),并将<code>@EnableAutoConfiguration</code>    注解到你的<code>main</code>类上,这样就隐式地定义了一个基础的包搜索路径(search    package),以搜索某些特定的注解实体(比如<code>@Service</code>,<code>@Component</code>等)    。例如,如果你正在编写一个JPA应用,Spring将搜索<code>@EnableAutoConfiguration</code>注解的类所在包下的<code>@Entity</code>实体。采用<code>root package</code>方式,你就可以使用<code>@ComponentScan</code>注解而不需要指定<code>basePackage</code>属性,也可以使用<code>@SpringBootApplication</code>注解,只要将main类放到<code>rootpackage</code>中。</p><h4 id="使用-SpringBootApplication注解"><a href="#使用-SpringBootApplication注解" class="headerlink" title="使用@SpringBootApplication注解"></a>使用@SpringBootApplication注解</h4><p>很多<code>SpringBoot</code>开发者经常使用<code>@Configuration</code>,<code>@EnableAutoConfiguration</code>,<code>@ComponentScan</code>注解他们的main类,由于这些注解如此频繁地一块使用(特别是遵循以上最佳实践的时候),<code>SpringBoot</code>就提供了一个方便的<code>@SpringBootApplication</code>注解作为代替。<br><code>@SpringBootApplication</code>注解等价于以默认属性使用<code>@Configuration</code>,<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code> <code>@Configuration</code>配置的文件就是一个<code>JavaConfig</code>。</p><p><code>@EnableAutoConfiguration</code>也是借助<code>@import</code>的帮助，将所有符合自动配置条件的bean定义加载到IoC容器。其本身也是一个复合注解。</p><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><p>Spring Boot提倡基于Java的配置。尽管你可以使用一个XML源来调用 SpringApplication.run() ，但是通常建议使用 @Configuration 类作为主要源。一般定义 main 方法的类也是主要 @Configuration 的一个很好候选。你不需要将所有的 @Configuration 放进一个单独的类。 @Import 注解可以用来导入其他配置类。另外，你也可以使用 @ComponentScan 注解自动收集所有的Spring组件，包括 @Configuration 类。</p><p>如果绝对需要使用基于XML的配置，建议仍旧从一个 @Configuration 类开始。你可以使用附加的 @ImportResource 注解加载XML配置文件。</p><p>@Configuration注解该类，等价 与XML中配置beans；用@Bean标注方法等价于XML中配置bean。</p><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>你可以自由地使用任何标准的Spring框架技术去定义beans和它们注入的依赖。简单起见，我们经常使用 @ComponentScan 注解搜索beans，并结合 @Autowired 构造器注入。<br>如果使用上面建议的结构组织代码（将应用类放到根包下），你可以添加 @ComponentScan 注解而不需要任何参数。你的所有应用程序组件（ @Component , @Service , @Repository , @Controller 等）将被自动注册为Spring Beans。</p><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><p>很多开发者总是使用 @Configuration ， @EnableAutoConfiguration 和 @ComponentScan 注解他们的main类。由于这些注解被如此频繁地一块使用（特别是你遵循以上最佳实践时），Spring Boot提供一个方便的 @SpringBootApplication 选择。<br>该 @SpringBootApplication 注解等价于以默认属性使用 @Configuration，@EnableAutoConfiguration 和 @ComponentScan。</p><h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h4><p>有时候有这样子的情景，我们想把配置文件的信息，读取并自动封装成实体类，这样子，我们在代码里面使用就轻松方便多了，这时候，我们就可以使用@ConfigurationProperties，它可以把同类的配置信息自动封装成实体类</p><p>首先在配置文件里面，这些信息是这样子滴</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.username=admin</span><br><span class="line">connection.password=kyjufskifas2jsfs</span><br><span class="line">connection.remoteAddress=192.168.1.1</span><br></pre></td></tr></table></figure><p>这时候我们可以定义一个实体类在装载配置文件信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"connection"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionSettings</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String remoteAddress;</span><br><span class="line">    <span class="keyword">private</span> String password ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRemoteAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remoteAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRemoteAddress</span><span class="params">(String remoteAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.remoteAddress = remoteAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以把@ConfigurationProperties还可以直接定义在@bean的注解上，这是bean实体类就不用@Component和@ConfigurationProperties了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"connection"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionSettings <span class="title">connectionSettings</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConnectionSettings();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要使用的时候就直接这样子注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/task"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line">ConnectionSettings conn;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = &#123;<span class="string">"/"</span>,<span class="string">""</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hellTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String userName = conn.getUsername();     </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello task !!"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果发现@ConfigurationPropertie不生效，有可能是项目的目录结构问题，可以通过@EnableConfigurationProperties(ConnectionSettings.class)来明确指定需要用哪个实体类来装载配置信息。</p><h4 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a>@EnableConfigurationProperties</h4><p>当@EnableConfigurationProperties注解应用到你的@Configuration时，任何被@ConfigurationProperties注解的beans将自动被Environment属性配置</p><p>你可以通过在@EnableConfigurationProperties注解中直接简单的列出属性类来快捷的注册@ConfigurationProperties bean的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ConnectionSettings.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Component和-Bean"><a href="#Component和-Bean" class="headerlink" title="@Component和@Bean"></a>@Component和@Bean</h4><p>@Component被用在要被自动扫描和装配的类上。@Component类中使用方法或字段时不会使用CGLIB增强(及不使用代理类：调用任何方法，使用任何变量，拿到的是原始对象)Spring 注解@Component等效于@Service,@Controller,@Repository<br>@Bean主要被用在方法上，来显式声明要用生成的类;用@Configuration注解该类，等价 与XML中配置beans；用@Bean标注方法等价于XML中配置bean。</p><p>现在项目上，本工程中的类，一般都使用<code>@Component</code>来生成bean。在把通过web service取得的类，生成Bean时，使用<code>@Bean</code>和getter方法来生成bean。</p><h4 id="Profiles"><a href="#Profiles" class="headerlink" title="@Profiles"></a>@Profiles</h4><p>Spring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。任何@Component或@Configuration都能被@Profile标记，从而限制加载它的时机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"production"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionConfiguration</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以正常的Spring方式，你可以使用一个spring.profiles.active的Environment属性来指定哪个配置生效。你可以使用平常的任何方式来指定该属性，例如，可以将它包含到你的application.properties中：</p><blockquote><p> spring.profiles.active=dev,hsqldb</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="/2017/10/26/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2017/10/26/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p>又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>它有3个基本性质：</p><p>根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。</p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>查找、插入和删除,当然删除操作比较少见。</p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>搜索字典项目的方法为：</p><p>(1) 从根结点开始一次搜索；</p><p>(2) 取得要查找关键词的第一个字母，并根据该字母选择对应的子树并转到该子树继续进行检索；</p><p>(3) 在相应的子树上，取得要查找关键词的第二个字母,并进一步选择对应的子树进行检索。</p><p>(4) 迭代过程……</p><p>(5) 在某个结点处，关键词的所有字母已被取出，则读取附在该结点上的信息，即完成查找。</p><p>其他操作类似处理</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>串的快速检索</li></ul><p>给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。</p><p>在这道题中，我们可以用数组枚举，用哈希，用字典树，先把熟词建一棵树，然后读入文章进行比较，这种方法效率是比较高的。</p><ul><li>“串”排序</li></ul><p>给定N个互不相同的仅由一个单词构成的英文名，让你将他们按字典序从小到大输出</p><p>用字典树进行排序，采用数组的方式创建字典树，这棵树的每个结点的所有儿子很显然地按照其字母大小排序。对这棵树进行先序遍历即可。</p><ul><li>最长公共前缀</li></ul><p>对所有串建立字典树，对于两个串的最长公共前缀的长度即他们所在的结点的公共祖先个数，于是，问题就转化为当时公共祖先问题。</p><h3 id="下面是一些字典树可以解决的面试题"><a href="#下面是一些字典树可以解决的面试题" class="headerlink" title="下面是一些字典树可以解决的面试题"></a>下面是一些字典树可以解决的面试题</h3><ul><li>3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。（字典树当做hash表的作用，用来统计词频。）</li><li>9、1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？</li><li>10、 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</li><li>13、寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。<br>​</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>霍夫曼编码</title>
      <link href="/2017/10/26/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
      <url>/2017/10/26/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="霍夫曼编码"><a href="#霍夫曼编码" class="headerlink" title="霍夫曼编码"></a>霍夫曼编码</h2><p><strong>霍夫曼编码的具体步骤如下：</strong></p><blockquote><p>1）将信源符号的概率按减小的顺序排队。</p><p>2）把两个最小的概率相加，并继续这一步骤，始终将较高的概率分支放在右边，直到最后变成概率１。</p><p>3）画出由概率１处到每个信源符号的路径，顺序记下沿路径的０和１，所得就是该符号的霍夫曼码字。   </p><p>4）将每对组合的左边一个指定为0，右边一个指定为1（或相反）。</p></blockquote><p>例：现有一个由5个不同符号组成的30个符号的字符串：</p><p>BABACAC ADADABB CBABEBE DDABEEEBB</p><p>1首先计算出每个字符出现的次数（概率）：</p><p><img src="https://img-blog.csdn.net/20160922215513341?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>2把出现次数（概率）最小的两个相加，并作为左右子树，重复此过程，直到概率值为1</p><p><img src="https://img-blog.csdn.net/20160922213612031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>第一次：将概率最低值3和4相加，组合成7：</p><p><img src="https://img-blog.csdn.net/20160922215103413?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>第二次：将最低值5和7相加，组合成12：</p><p><img src="https://img-blog.csdn.net/20160922213643422?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>第三次：将8和10相加，组合成18：</p><p><img src="https://img-blog.csdn.net/20160922215137429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>第四次：将最低值12和18相加，结束组合：</p><p><img src="https://img-blog.csdn.net/20160922213722297?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>3 将每个二叉树的左边指定为0，右边指定为1</p><p><img src="https://img-blog.csdn.net/20160922213735251?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>4 沿二叉树顶部到每个字符路径，获得每个符号的编码</p><p><img src="https://img-blog.csdn.net/20160922213840657?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>我们可以看到出现次数（概率）越多的会越在上层，编码也越短，出现频率越少的就越在下层，编码也越长。当我们编码的时候，我们是按“bit”来编码的，解码也是通过bit来完成，如果我们有这样的bitset “10111101100″ 那么其解码后就是 “ABBDE”。所以，我们需要通过这个二叉树建立我们Huffman编码和解码的字典表。</p><p>这里需要注意的是，Huffman编码使得每一个字符的编码都与另一个字符编码的前一部分不同，不会出现像’A’：00，  ’B’：001，这样的情况，解码也不会出现冲突。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="/2017/10/24/Servlet/"/>
      <url>/2017/10/24/Servlet/</url>
      
        <content type="html"><![CDATA[<p>servlet</p><p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p><a id="more"></a><p>servlet的架构如下:</p><p><img src="http://one-1252095801.cosgz.myqcloud.com/Screenshot%20from%202017-12-23%2010-23-12.png" alt=""></p><p>servlet的任务主要有</p><p>读取客户端发送的显示的数据,读取客户端发送的隐式的HTTP请求数据,处理数据并生成结果,发送显示的数据到客户端,发送隐式的HTTP响应到客户端.</p><h5 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a>servlet的生命周期</h5><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p><ul><li>Servlet 通过调用 <strong>init ()</strong> 方法进行初始化。</li><li>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li><li>Servlet 通过调用 <strong>destroy()</strong> 方法终止（结束）。</li><li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li></ul><p>service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">                    ServletResponse response)</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                  HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Servlet 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                   HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Servlet 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个servlet实例"><a href="#一个servlet实例" class="headerlink" title="一个servlet实例"></a>一个servlet实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入必需的 java 库</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="comment">// 扩展 HttpServlet 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String message;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// 执行必需的初始化</span></span><br><span class="line">      message = <span class="string">"Hello World"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// 设置响应内容类型</span></span><br><span class="line">      response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">      <span class="comment">// 实际的逻辑是在这里</span></span><br><span class="line">      PrintWriter out = response.getWriter();</span><br><span class="line">      out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// 什么也不做</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="servlet的部署"><a href="#servlet的部署" class="headerlink" title="servlet的部署"></a>servlet的部署</h4><p>默认情况下，Servlet 应用程序位于路径<code>&lt;Tomcat-installation-directory&gt;/webapps/ROOT</code>下，且类文件放在<code>&lt;Tomcat-installation-directory&gt;/webapps/ROOT/WEB-INF/classes</code>中。</p><p>如果有一个完全合格的类名称 <strong>com.myorg.MyServlet</strong>，那么这个 Servlet 类必须位于 WEB-INF/classes/com/myorg/MyServlet.class 中。</p><p>然后在web.xml中创建以下条目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/HelloWorld<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="servlet-表单数据"><a href="#servlet-表单数据" class="headerlink" title="servlet 表单数据"></a>servlet 表单数据</h4><p>Servlet 处理表单数据，这些数据会根据不同的情况使用不同的方法自动解析：</p><ul><li><strong>getParameter()：</strong>您可以调用 request.getParameter() 方法来获取表单参数的值。</li><li><strong>getParameterValues()：</strong>如果参数出现一次以上，则调用该方法，并返回多个值，例如复选框。</li><li><strong>getParameterNames()：</strong>如果您想要得到当前请求中的所有参数的完整列表，则调用该方法。</li></ul><h4 id="servlet客户端HTTP请求"><a href="#servlet客户端HTTP请求" class="headerlink" title="servlet客户端HTTP请求"></a>servlet客户端HTTP请求</h4><p><strong>Cookie[] getCookies()</strong>返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</p><p><strong>HttpSession getSession()</strong><br>返回与该请求关联的当前 session 会话，或者如果请求没有 session 会话，则创建一个。</p><p><strong>String getCharacterEncoding()</strong>返回请求主体中使用的字符编码的名称。  </p><p><strong>String getMethod()</strong><br>返回请求的 HTTP 方法的名称，例如，GET、POST 或 PUT。</p><p><strong>String getParameter(String name)</strong><br>以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</p><p><strong>String getRequestURI()</strong><br>从协议名称直到 HTTP 请求的第一行的查询字符串中，返回该请求的 URL 的一部分</p><h3 id="servlet服务端HTTP相应"><a href="#servlet服务端HTTP相应" class="headerlink" title="servlet服务端HTTP相应"></a>servlet服务端HTTP相应</h3><p><strong>String encodeRedirectURL(String url)</strong><br>为 sendRedirect 方法中使用的指定的 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</p><p><strong>boolean containsHeader(String name)</strong><br>返回一个布尔值，指示是否已经设置已命名的响应报头。</p><p><strong>void addCookie(Cookie cookie)</strong><br>把指定的 cookie 添加到响应。</p><p><strong>void reset()</strong><br>清除缓冲区中存在的任何数据，包括状态码和头。</p><h3 id="servlet-状态码"><a href="#servlet-状态码" class="headerlink" title="servlet 状态码"></a>servlet 状态码</h3><p>下面的方法可用于在 Servlet 程序中设置 HTTP 状态码。这些方法通过 <em>HttpServletResponse</em> 对象可用。</p><table><thead><tr><th>序号</th><th>方法 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public void setStatus ( int statusCode )</strong>该方法设置一个任意的状态码。setStatus 方法接受一个 int（状态码）作为参数。如果您的反应包含了一个特殊的状态码和文档，请确保在使用 <em>PrintWriter</em> 实际返回任何内容之前调用 setStatus。</td></tr><tr><td>2</td><td><strong>public void sendRedirect(String url)</strong>该方法生成一个 302 响应，连同一个带有新文档 URL 的 <em>Location</em> 头。</td></tr><tr><td>3</td><td><strong>public void sendError(int code, String message)</strong>该方法发送一个状态码（通常为 404），连同一个在 HTML 文档内部自动格式化并发送到客户端的短消息。</td></tr></tbody></table><h3 id="servlet-过滤器"><a href="#servlet-过滤器" class="headerlink" title="servlet 过滤器"></a>servlet 过滤器</h3><p>Servlet 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。可以将一个或多个 Servlet 过滤器附加到一个 Servlet 或一组 Servlet。Servlet 过滤器也可以附加到 JavaServer Pages (JSP) 文件和 HTML 页面。调用 Servlet 前调用所有附加的 Servlet 过滤器。</p><p>Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的：</p><ul><li>在客户端的请求访问后端资源之前，拦截这些请求。</li><li>在服务器的响应发送回客户端之前，处理这些响应。</li></ul><p>过滤器通过 Web 部署描述符（web.xml）中的 XML 标签来声明，然后映射到您的应用程序的部署描述符中的 Servlet 名称或 URL 模式。</p><p>当 Web 容器启动 Web 应用程序时，它会为部署描述符中声明的每一个过滤器创建一个实例。</p><p>Filter的执行顺序与在web.xml配置文件中的配置顺序一致，一般把Filter配置在所有的Servlet之前。</p><h5 id="Servlet-过滤器方法"><a href="#Servlet-过滤器方法" class="headerlink" title="Servlet 过滤器方法"></a>Servlet 过滤器方法</h5><p>过滤器是一个实现了 javax.servlet.Filter 接口的 Java 类。javax.servlet.Filter 接口定义了三个方法：</p><table><thead><tr><th>序号</th><th>方法 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public void doFilter (ServletRequest, ServletResponse, FilterChain)</strong>该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器(此参数的意思是把请求传回过滤链)。</td></tr><tr><td>2</td><td><strong>public void init(FilterConfig filterConfig)</strong>web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。</td></tr><tr><td>3</td><td><strong>public void destroy()</strong>Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。</td></tr></tbody></table><h3 id="servlet-session"><a href="#servlet-session" class="headerlink" title="servlet session"></a>servlet session</h3><p>Servlet 还提供了 HttpSession 接口，该接口提供了一种跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式。</p><p>Servlet 容器使用这个接口来创建一个 HTTP 客户端和 HTTP 服务器之间的 session 会话。会话持续一个指定的时间段，跨多个连接或页面请求。通过调用 HttpServletRequest 的公共方法 <strong>getSession()</strong> 来获取 HttpSession 对象，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession sessin =request.getSession();</span><br></pre></td></tr></table></figure><p>HttpSession 中的常用方法:</p><p><strong>public Object getAttribute(String name)</strong><br>该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。</p><p><strong>public void setAttribute(String name, Object value) </strong><br>该方法使用指定的名称绑定一个对象到该 session 会话。</p><p><strong>public Enumeration getAttributeNames()</strong><br>该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。</p><p><strong>public long getCreationTime()</strong><br>该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</p><p><strong>public String getId()</strong><br>该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。</p><p><strong>public void invalidate()</strong><br>该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/2017/10/21/%E9%9B%86%E5%90%88/"/>
      <url>/2017/10/21/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>集合框架体系如图所示:</p><p><img src="http://four-1252095801.cosbj.myqcloud.com/img/20190922150741.png" alt=""></p><a id="more"></a><h4 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h4><ul><li>Collection 接口</li></ul><p>Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。</p><ul><li>List 接口</li></ul><p>List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。</p><ul><li>Set 接口</li></ul><p>Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。</p><ul><li>SortedSet</li></ul><p>继承自Set保存有序的集合</p><ul><li>Map</li></ul><p>将唯一的键映射到值</p><ul><li>Map.Entry</li></ul><p>描述在Map中的一个元素(键值对),是一个Map的内部类</p><ul><li>SortedMap</li></ul><p>继承于Map,使Key 保持在升序排列.</p><p>集合类中的基本接口是 collection 接口 有两个基本方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span> <span class="params">(E element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list 是collection 的子接口定义如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>list 接口扩充了许多其他方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>;<span class="comment">//指定位置添加元素。</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 返回指定位置的元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexof</span><span class="params">(E element)</span></span>;<span class="comment">//查找指定元素的位置。</span></span><br></pre></td></tr></table></figure></p><p>iterator()方法用于返回一个实现了Iterator 接口的对象。可以使用这个对象依次访问集合中的元素。</p><p>Iterator接口包含三个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasNext;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在调用next之前调用hasNext方法。在集合中，查找一个元素唯一的方法就是调用next，在执行查找操作的同时，迭代器的位置向前移动。因此，应该将Java迭代器认为是位于两个元素之间，当调用next时，迭代器就越过下一个元素，并返回刚刚越过的元素的引用。</p><h2 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h2><p>除了以map结尾的类之外，其他类都实现了collection接口，map结尾的实现了map接口。</p><p>一个例子</p><h4 id="LinkedList-双向链表实现"><a href="#LinkedList-双向链表实现" class="headerlink" title="LinkedList(双向链表实现)"></a>LinkedList(双向链表实现)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list =<span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"A"</span>);</span><br><span class="line">list.add(<span class="string">"B"</span>);</span><br><span class="line">list.add(<span class="string">"C"</span>);</span><br><span class="line">Iterator it = list.iterator();</span><br><span class="line">String first =it.next(); <span class="comment">//visit first element</span></span><br><span class="line">String second =it.next();<span class="comment">//visit second element</span></span><br><span class="line">it.remove() <span class="comment">//remove second element</span></span><br></pre></td></tr></table></figure><p>链表是一个有序集合，由于迭代器是描述集合中位置的，所以这种依赖于位置的add方法将由迭代器负责，只有对自然有序的集合使用迭代器添加元素才有实际意义。因此iterator接口中没有add方法，在子接口ListIterator中包含了add方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">iterator ListIterator&lt;E&gt; extends Iterator&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E elements)</span></span>;</span><br><span class="line">    <span class="comment">// 还有两个方法用来反向遍历链表。</span></span><br><span class="line">    <span class="function">E <span class="title">previous</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">staff.add(<span class="string">"A"</span>);</span><br><span class="line">staff.add(<span class="string">"B"</span>);</span><br><span class="line">staff.add(<span class="string">"C"</span>);</span><br><span class="line">ListIterator&lt;String&gt; it = staff.listIterator();</span><br><span class="line">it.next();</span><br><span class="line">it.add(<span class="string">"J"</span>);   <span class="comment">//AJBC</span></span><br></pre></td></tr></table></figure></p><p>set() 方法用一个新元素取代调用next或者previous方法返回的上个元素。例如下面面代码用新值取代链表第一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">Iterator&lt;String&gt; it =list.Linkediterator();</span><br><span class="line">String oldvalue = it.next(); </span><br><span class="line">it.set(newvalue);</span><br></pre></td></tr></table></figure><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>arraylist 封装了一个动态再分配的对象数组。</p><p>ArrayList底层以数组实现，允许重复，默认第一次插入元素时创建数组的大小为10，超出限制时会增加50%的容量，每次扩容都底层采用System.arrayCopy()复制到新的数组，初始化时最好能给出数组大小的预估值。</p><h4 id="散列集"><a href="#散列集" class="headerlink" title="散列集"></a>散列集</h4><p>散列表为每个对象计算一个整数，成为散列码 Java中，散列表用链表数组实现，每个列表称为桶。</p><h4 id="树集"><a href="#树集" class="headerlink" title="树集"></a>树集</h4><p>树集是一个有序集合，可以以任意顺序将元素插入到集合中，在对集合进行遍历时，每个值将自动的按照排序后的顺序呈现，</p><h4 id="映射表"><a href="#映射表" class="headerlink" title="映射表"></a>映射表</h4><p>映射表的两个实现，HashMap,TreeMap,两个类都实现了Map接口。</p><p>散列映射表对键进行散列，树映射表用键的整体顺序对元素进行排列，并将其组织成搜索树。 散列或者比较函数都只能作用于键，与键关联的值不能进行散列或者比较。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Employee&gt; staff  = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Emplloyee harry =  <span class="keyword">new</span> Employee(<span class="string">"H"</span>);</span><br><span class="line">staff.put(<span class="string">"123"</span>,harry);</span><br></pre></td></tr></table></figure></p><p>要想检索一个对象，必须提供一个键<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"123"</span>;</span><br><span class="line">e = staff.get(s);</span><br></pre></td></tr></table></figure></p><p>如果在映射表中没有给定键对应的信息，get将返回NUll。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下列方法返回三个视图。</span><br><span class="line"><span class="function">set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">Values</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举映射表中所有的键：</span></span><br><span class="line">Set&lt;String&gt; keys = map.keyset();</span><br><span class="line"><span class="keyword">for</span>(String s:keys)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举键值对：</span></span><br><span class="line"> Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">"1"</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">"2"</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">"3"</span>);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; i:map.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p>框架是一个类的集，奠定了创建高级功能的基础。</p><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map =<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"1"</span>,<span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="string">"2"</span>,<span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="string">"3"</span>,<span class="string">"three"</span>);</span><br><span class="line">map.put(<span class="string">"4"</span>,<span class="string">"four"</span>);</span><br><span class="line">map.put(<span class="string">"5"</span>,<span class="string">"five"</span>);</span><br><span class="line">map.put(<span class="string">"6"</span>,<span class="string">"six"</span>);</span><br><span class="line">map.put(<span class="string">"1"</span>,<span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="string">"2"</span>,<span class="string">"one"</span>);</span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; s = map.entrySet();</span><br><span class="line">System.out.println(s);</span><br><span class="line">Iterator&lt;Map.Entry&lt;String,String&gt; &gt; it =s.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">  System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>=one, <span class="number">2</span>=one, <span class="number">3</span>=three, <span class="number">4</span>=four, <span class="number">5</span>=five, <span class="number">6</span>=six]</span><br><span class="line"><span class="number">1</span>=one</span><br><span class="line"><span class="number">2</span>=one</span><br><span class="line"><span class="number">3</span>=three</span><br><span class="line"><span class="number">4</span>=four</span><br><span class="line"><span class="number">5</span>=five</span><br><span class="line"><span class="number">6</span>=six</span><br></pre></td></tr></table></figure><p>先定义一个hashMap，加了八个元素，map.set的意思是把map变成set,且set里的元素类型都是满足<code>Map.Entry&lt;String,String&gt;</code> 接口的，然后声明一个迭代器，进行迭代输出，打印出每一个元素。</p><p><code>Map.Entry&lt;String,String&gt;</code> 是一个Map内部定义的接口，专门用来保存key-value的内容，简单说就是Map中的每一个元素（每一个键值对）都是实现了Map.Entry&lt;&gt;接口的。</p><h4 id="Iterator-和ListIterator-之间有什么区别"><a href="#Iterator-和ListIterator-之间有什么区别" class="headerlink" title="Iterator 和ListIterator 之间有什么区别"></a>Iterator 和ListIterator 之间有什么区别</h4><ul><li>我们可以使用Iterator来遍历Set和List集合，而ListIterator只能遍历List。</li><li>Iterator只可以向前遍历，而LIstIterator可以双向遍历。</li><li>ListIterator从Iterator接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h4 id="HashMap-和HashTable-有何不同"><a href="#HashMap-和HashTable-有何不同" class="headerlink" title="HashMap 和HashTable 有何不同"></a>HashMap 和HashTable 有何不同</h4><p>（1）HashMap允许key和value为null，而HashTable不允许。</p><p>（2）HashTable是同步的，而HashMap不是。所以HashMap适合单线程环境，HashTable适合多线程环境。</p><p>（3）在Java1.4中引入了LinkedHashMap，HashMap的一个子类，假如你想要遍历顺序，你很容易从HashMap转向LinkedHashMap，但是HashTable不是这样的，它的顺序是不可预知的。</p><p>（4）HashMap提供对key的Set进行遍历，因此它是fail-fast的，但HashTable提供对key的Enumeration进行遍历，它不支持fail-fast。</p><p>（5）HashTable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java NIO</title>
      <link href="/2017/10/18/Java%20NIO/"/>
      <url>/2017/10/18/Java%20NIO/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/xdp-gacl/p/3634409.html" target="_blank" rel="noopener">http://www.cnblogs.com/xdp-gacl/p/3634409.html</a></p><p>NIO 提供了一个全新的底层IO 模型，与最初Java.io包中面向流的概念不同，NIO采用了面向块的概念，在尽可能的情况下，将以大的数据块为单位进行操作，而不是每次一个字节或者一个字符。</p><p>NIO 提供了与平台无关的非阻塞IO，与面向线程，阻塞式的IO 方式相比，多道通信，非阻塞IO可以使程序更有效的处理大量连接的情况。</p><a id="more"></a><h3 id="IO-与NIO"><a href="#IO-与NIO" class="headerlink" title="IO 与NIO"></a>IO 与NIO</h3><p>IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p><h2 id="常见I-O模型对比"><a href="#常见I-O模型对比" class="headerlink" title="常见I/O模型对比"></a>常见I/O模型对比</h2><p>所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p><p>需要说明的是等待就绪的阻塞是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在”干活”，而且这个过程非常快，属于memory copy，带宽通常在1GB/s级别以上，可以理解为基本不耗时。</p><p>下图是几种常见I/O模型的对比：</p><p><img src="https://pic2.zhimg.com/80/v2-f47206d5b5e64448744b85eaf568f92d_hd.jpg" alt="img"></p><p>以socket.read()为例子：</p><p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</p><p>对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。</p><p>最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。</p><p>换句话说，BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。</p><p>NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。</p><p>##缓冲区与Buffer</p><p>基本IO 操作中所有操作都是直接以流的形式完成的，而<strong>在NIO中，所有操作都要使用到缓冲区处理</strong>，且所有的读写操作都是通过缓冲区完成的，缓冲区是一个线性的，有序的数据集，只能容纳某种特定的数据类型。可以把换冲区想象成一个水桶，总是水满了再进行和通道，内存交互，这样就减少了IO.详见<a href="http://www.cnblogs.com/xdp-gacl/p/3634409.html。" target="_blank" rel="noopener">http://www.cnblogs.com/xdp-gacl/p/3634409.html。</a></p><p>NIO中针对每一种基本数据类型都有一种对应的缓冲区操作类.</p><h5 id="buffer的基本操作"><a href="#buffer的基本操作" class="headerlink" title="buffer的基本操作"></a>buffer的基本操作</h5><p>Java.io.Buffer本身是一个抽象类</p><p>buffer 类常用方法</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/17101801.png" alt="buffer"></p><p>新IO 针对每一种数据类型都有一种对应的缓冲区操作类，Java.nio.ByteBuffer java.nio.CharBuffer java.nio.ShortBuffer java.nio.IntBuffer java.nio.LongBuffer java.nio.FloatBuffer java.nio.DoubleBuffer</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/17101802.png" alt="1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.IntBuffer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">BufferDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IntBuffer buf  = InBuffer.allocate(<span class="number">10</span>);<span class="comment">//开辟10个大小缓冲区</span></span><br><span class="line">        System.out.println(<span class="string">"写入数据前的position limit capacity"</span>)     System.out.println(buf.position()+buf.limit()+buf.capacity())</span><br><span class="line">        <span class="keyword">int</span> temp[]=&#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        buf.put(<span class="number">3</span>);<span class="comment">// 向缓冲区写入数据</span></span><br><span class="line">        buf.put(temp）;<span class="comment">//向缓冲区写入一组数据</span></span><br><span class="line">        System.out.println(<span class="string">"写入数据后的position limit capacity"</span>);   System.out.println(buf.position()+buf.limit()+buf.capacity();)</span><br><span class="line">        buf.flip();<span class="comment">// 重设缓冲区 执行后，limit设为position，position设为0</span></span><br><span class="line">        System.out.println(<span class="string">"准备输出数据时的position limit capacity"</span>);  System.out.println(buf.position()+buf.limit()+buf.capacity();)</span><br><span class="line">        System.out.println(<span class="string">"缓冲区的内容"</span>);</span><br><span class="line">        <span class="keyword">while</span>(buf.hasReamining())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = buf.get();</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在每次写入之后position会有变化。而当调用flip()方法时，position 和limit发生变化。</strong></p><h4 id="深入缓冲区操作"><a href="#深入缓冲区操作" class="headerlink" title="深入缓冲区操作"></a>深入缓冲区操作</h4><p>position 表示下一个缓冲区读取或者写入的操作指针，写入数据时，此指针就会改变。 limit 表示还有多少数据需要存储或者读取。limit指的是缓冲区中第一个不能读写的元素的数组下标索引，也可以认为是缓冲区中实际元素的数量(也就是上界)。position&lt;=limit。 capacity 表示缓冲区的最大容量。在分配缓冲区时设置，一般不会改变。</p><h5 id="创建子缓冲区"><a href="#创建子缓冲区" class="headerlink" title="创建子缓冲区"></a>创建子缓冲区</h5><p>可以使用各个缓冲区类的slice() 方法从一个缓冲区创建一个新的子缓冲区，子缓冲区与原缓冲区中部分数据可以共享。</p><h5 id="创建只读缓冲区"><a href="#创建只读缓冲区" class="headerlink" title="创建只读缓冲区"></a>创建只读缓冲区</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntBuffer buf =IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">read =buf.asReadOnlyBuffer();</span><br></pre></td></tr></table></figure><h3 id="通道-NIO把它支持的I-O对象抽象为Channel"><a href="#通道-NIO把它支持的I-O对象抽象为Channel" class="headerlink" title="通道(NIO把它支持的I/O对象抽象为Channel)"></a>通道(NIO把它支持的I/O对象抽象为Channel)</h3><p>(通道和流的区别之处在于通道是双向的,流是单向的.)</p><p>通道可以用来读取和写入数据，通道类似于之前的输入输出流，程序不会直接操作通道，所有的内容都是先读到或者写入到缓冲区中，再通过缓冲区中取得或者写入的通道本身是双向操作的，既可以完成输入也可以输出。</p><p>Channel 本身是一个接口,</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/17101803.png" alt="12"></p><h4 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h4><p>FileChannel 是Channel的子类，可以进行文件的读写操作，如果要使用FileChannel，则要依靠FileInputStream 或者FileOutputStream 类中的getChannel() 方法取得输入或者输出的通道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String info[] = &#123;<span class="string">"c"</span>,<span class="string">"python"</span>,<span class="string">"javascript"</span>,<span class="string">"markdown"</span>&#125;;<span class="comment">//待输出的数据</span></span><br><span class="line">        File  f =<span class="keyword">new</span> File(<span class="string">"/home/brett/Desktop/1.txt"</span>);</span><br><span class="line">        FileOutputStream output = <span class="keyword">new</span> FileOutputStream(File);<span class="comment">//实例化输出流</span></span><br><span class="line">        FileChannel fout =<span class="keyword">null</span>;<span class="comment">//声明输出的通道对象</span></span><br><span class="line">        fout = output.getChannel();<span class="comment">//得到输出的文件通道</span></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);<span class="comment">//开辟缓存。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;info.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buf.put(info[i].getBytes());<span class="comment">//向缓存写入数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        buf.flip(); <span class="comment">//重设缓冲区，准备输出</span></span><br><span class="line">        fout.write(buf);<span class="comment">//输出</span></span><br><span class="line">        fout.close(); <span class="comment">//关闭输出通道</span></span><br><span class="line">        output.close() <span class="comment">//关闭输出流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//以上程序使用输出通道将内容全部放到缓冲中，一次性写入到文件中的。</span></span><br></pre></td></tr></table></figure><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>原来使用Io和socket构造网络服务时，所有的网络服务将使用阻塞的方式进行客户端的连接，而如果使用了新IO则可以构造一个非阻塞的网络服务。</p><p><strong>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</strong></p><hr><p>NIO中的处理流程一般为</p><p>由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。</p><p>一般情况下，使用NIO,主要包括了下面三种要用到的线程。</p><ol><li>事件分发器，单线程选择就绪的事件。</li><li>I/O处理器，包括connect、read、write等，这种纯CPU操作，一般开启CPU核心个线程就可以。</li><li>业务线程，在处理完I/O后，业务一般还会有自己的业务逻辑，有的还会有其他的阻塞I/O，如DB操作，RPC等。只要有阻塞，就需要单独的线程。</li></ol><p>其中，事件分发器的作用，即 将那些读写事件源分发给各读写事件的处理者，就像送快递的在楼下喊: 谁谁谁的快递到了， 快来拿吧！开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的处理者（event handler)，或者是回调函数；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。</p><hr><h1 id="Java-NIO-Channels-and-Buffers"><a href="#Java-NIO-Channels-and-Buffers" class="headerlink" title="Java NIO (Channels and Buffers)"></a>Java NIO (Channels and Buffers)</h1><p>标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和 缓冲区（Buffer） 进行操作，数据总是从通道读到缓冲区，或者从缓冲区读写到通道中。NIO 还可以让你使用非阻塞的IO。NIO还引入了选择器的概念，选择器用于监听多个通道的事件。NIO的核心API就是Channel Buffer Selector </p><h4 id="Channel-和-Buffer"><a href="#Channel-和-Buffer" class="headerlink" title="Channel 和 Buffer"></a>Channel 和 Buffer</h4><p>基本上，所有的NIO都是从一个Channel开始，<em>Channel 有点像流</em>，数据可以从Channel读到Buffer中，也可以从Buffer写到Channel 中，</p><h4 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h4><p>selector 允许单线程处理多个Channel，如果一个应用打开了多个Channel，但是每个Channel的流量都很低。使用Selector会很方便。下图是一个单线程中使用一个Selector处理三个Channel的图示</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/17101804.png" alt="12"></p><h4 id="Channel-流要写具体的流-才有getChannel方法-Channel-也是"><a href="#Channel-流要写具体的流-才有getChannel方法-Channel-也是" class="headerlink" title="Channel(流要写具体的流,才有getChannel方法,Channel 也是)"></a>Channel(流要写具体的流,才有getChannel方法,Channel 也是)</h4><p>通道类似于流，但又有些不同。既可以从通道中读取数据，又可以写数据到通道，而流的读写通常是单向的。通道可以异步的读写，通道中的数据总是要先读到一个Buffer，或者从一个Buffer中写入。具体的实现类有 FileChannel，DatagramChannel通过UDP读写网络中的数据,  SocketChannel 能通过TCP 读写网络中的数据，ServerSocketChannel 以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel inChannel = aFile.getChannel();</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line">        <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Read "</span> + bytesRead);</span><br><span class="line">        buf.flip();</span><br><span class="line">        <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">        &#125;</span><br><span class="line">        buf.clear();</span><br><span class="line">        bytesRead = inChannel.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        aFile.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>NIO 中的Buffer用于和NIO通道进行交互，缓冲区本质上是一块可以写入数据，然后可以从中读取数据的<strong>内存</strong>。这块内存被包装为NIO Buffer 对象，并提供一组方法，进行方便的访问。</p><p>使用Buffer 读写数据一般需要遵循以下四个步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 写入数据到Buffer </span><br><span class="line">2. 调用flip() 方法，</span><br><span class="line">3. 从buffer中读取数据，</span><br><span class="line">4 .调用clear() 方法或者compact()方法。</span><br></pre></td></tr></table></figure><p>当向Buffer写入数据时，buffer会记录写入了多少数据，一旦需要读取数据，就<strong>需要通过flip()方法将Buffer从写模式切换为读模式，在读模式下，就可以读取之前写入到Buffer的所有数据。</strong></p><p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方法可以清空缓冲区，调用clear() 或者compact() 方法，clear() 方法会清空整个缓冲区，compact()方法只会清除已经读过的数据。任何未读的数据都会被移到缓冲区的起始处，新写入的数据会放到缓冲区未读数据的后面。</p><p>Buffer的三个工作属性 capacity position limit</p><p>Position 和limit的含义取决于Buffer在读模式还是写模式，</p><h5 id="position-指向下一个可以读或者可以写的位置"><a href="#position-指向下一个可以读或者可以写的位置" class="headerlink" title="position(指向下一个可以读或者可以写的位置)"></a>position(指向下一个可以读或者可以写的位置)</h5><p>当你写数据到Buffer中时，position表示当前的位置。初始的position值为0写数据后，position会移动到下一个可以写的位置。当切换到读模式的时候，position会被重置为0.当从Buffer的position出读取数据时，position向前移动到下一个可读的位置。</p><h5 id="limit-读模式下表示最多能读的数据-写模式下最多能写的数据"><a href="#limit-读模式下表示最多能读的数据-写模式下最多能写的数据" class="headerlink" title="limit(读模式下表示最多能读的数据,写模式下最多能写的数据)"></a>limit(读模式下表示最多能读的数据,写模式下最多能写的数据)</h5><p>写模式下，Buffer的limit表示最多可以往里面写多少数据，所以写模式下，limit等于capacity。当切换到读模式时，limit表示你最多能读多少数据，因此，当切换到读模式时，limit设置成写模式的position。换句话说，你可以读到之前写入的所有数据。</p><h5 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h5><p>要想获得一个Buffer首先要分配，每一个Buffer都有一个allocate方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);<span class="comment">//分配一个48字节的Buffer。</span></span><br></pre></td></tr></table></figure><h5 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h5><p>两种方式，从Channel写到Buffer 、通过Buffer的put()方法写到Buffer里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);<span class="comment">//从Channel写待Buffer</span></span><br><span class="line">buf.put(<span class="number">127</span>);</span><br></pre></td></tr></table></figure><h5 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip() 方法"></a>flip() 方法</h5><p>flip将写模式转换为读模式，调用flip()方法将会将position设回0，limit设置成原来的position。</p><h5 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h5><p>两种方式，1，从Buffer读数据到Channel 2. 使用get() 从Buffer读取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> byteWritten =inChannel.write(buf);</span><br><span class="line"><span class="keyword">byte</span> abyte =buf.get();</span><br></pre></td></tr></table></figure><h5 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h5><p>Buffer.rewind()将position设回0，所以可以重读Buffer中的所有数据limit保持不变，仍然表示能从Buffer中读取多少元素。</p><h5 id="clear-和compact"><a href="#clear-和compact" class="headerlink" title="clear() 和compact()"></a>clear() 和compact()</h5><h3 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h3><p>Java NIO开始支持scatter/gather.</p><p>Scatter/gather用于描述从Channel中读取或者写入到channel的操作</p><p>分散scatter 从Channel中读取是指在读操作时将读取的数据写入到多个Buffer中。</p><p>聚集 gather 写入Channel指在写操作时将多个Buffer的数据写到同一个Channel，因此，Channel将多个Buffer中的数据聚集后发送到Channel。</p><p>scatter/gather 经常用于需要将传输的数据分开处理的场合，例如传输一个消息头消息体组成的消息，这样将消息体消息头分散到不同的Buffer中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scatter read</span></span><br><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">Byteuffer body =ByteBuffer.allocate(<span class="number">256</span>);</span><br><span class="line">ByteBuffer[] bytes =&#123;header,body&#125;;</span><br><span class="line">channel.read(bytes)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gather write</span></span><br><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure><h4 id="通道之间的数据传输"><a href="#通道之间的数据传输" class="headerlink" title="通道之间的数据传输"></a>通道之间的数据传输</h4><p>在NIO中，如果两个通道中一个是FileChannel，那你可以直接将数据从一个Channel传输到另外一个Channel中。</p><p>FileChannel的<code>transferFrom()</code>方法可以将数据从源通道传输到FileChannel中。</p><p><code>transferTo()</code>方法将数据从FileChannel传输到其它Channel中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line">toChannel.transferFrom(fromChannel,position,count);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line">fromChannel.transferTo(,position, count,toChannel);</span><br></pre></td></tr></table></figure><h4 id="Selector-2"><a href="#Selector-2" class="headerlink" title="Selector"></a>Selector</h4><blockquote><p><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html</a></p></blockquote><p>Selector是NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程就可以管理多个Channel，从而管理多个网络连接。</p><p><strong>Selector提供选择已经就绪的任务的能力</strong></p><p>一个Selector实例可以同时检查一组信道的I/O状态。用专业术语来说，选择器就是一个多路开关选择器，因为一个选择器能够管理多个信道上的I/O操作。然而如果用传统的方式来处理这么多客户端，使用的方法是循环地一个一个地去检查所有的客户端是否有I/O操作，如果当前客户端有I/O操作，则可能把当前客户端扔给一个线程池去处理，如果没有I/O操作则进行下一个轮询，当所有的客户端都轮询过了又接着从头开始轮询；这种方法是非常笨而且也非常浪费资源，因为大部分客户端是没有I/O操作，我们也要去检查；而Selector就不一样了，它在内部可以同时管理多个I/O，当一个信道有I/O操作的时候，他会通知Selector，Selector就是记住这个信道有I/O操作，并且知道是何种I/O操作，是读呢？是写呢？还是接受新的连接；所以如果使用Selector，它返回的结果只有两种结果，一种是0，即在你调用的时刻没有任何客户端需要I/O操作，另一种结果是一组需要I/O操作的客户端，这是你就根本不需要再检查了，<strong>因为它返回给你的肯定是你想要的</strong>。这样一种通知的方式比那种主动轮询的方式要高效得多！</p><p>简单的说,selector就是多路复用器.Selector 会不断的轮询注册在其上的Channel,如果某个channel上面发生读或者写事件,这个Channel就会处于就绪状态,会被selector轮询出来,然后通过selectionKey可以获取到就绪Channel的集合,进行后续的IO操作.</p><p>一个多路复用器selector可以同时轮询多个Channel,由于JDK使用了epoll()代替传统的select实现,所以它没有最大连接句柄1024/2048的限制,这意味着只需要一个线程负责selector的轮询,就可以接入成千上万客户端.</p><h5 id="使用Selector的原因"><a href="#使用Selector的原因" class="headerlink" title="使用Selector的原因"></a>使用Selector的原因</h5><p>用单个线程来处理多个channel的好处是 只需要更少的线程来处理通道。所以使用selector 能够处理多个通道。</p><p>一个线程轮询selector ,当有IO时,从线程池中取出线程进行处理.</p><p>并且不必为每个连接都创建一个线程，不用去维护多个线程，</p><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>我们需要做的第一件事就是创建一个 <code>Selector</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p>然后，我们将对不同的通道对象调用 <code>register()</code> 方法，以便注册我们对这些对象中发生的 I/O 事件的兴趣。<code>register()</code> 的第一个参数总是这个 <code>Selector</code>。</p><p>为了接收连接，我们需要一个 <code>ServerSocketChannel</code>。事实上，我们要监听的每一个端口都需要有一个 <code>ServerSocketChannel</code> 。对于每一个端口，我们打开一个 <code>ServerSocketChannel</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking( <span class="keyword">false</span> );</span><br><span class="line"> </span><br><span class="line">ServerSocket ss = ssc.socket();</span><br><span class="line">InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress( ports[i] );</span><br><span class="line">ss.bind( address );</span><br></pre></td></tr></table></figure><p>第一行创建一个新的 <code>ServerSocketChannel</code> ，最后三行将它绑定到给定的端口。第二行将 <code>ServerSocketChannel</code> 设置为 <em>非阻塞的 </em>。我们必须对每一个要使用的套接字通道调用这个方法，否则异步 I/O 就不能工作。</p><p>下一步是将新打开的 <code>ServerSocketChannels</code> 注册到 <code>Selector</code>上。为此我们使用 ServerSocketChannel.register() 方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT );</span><br></pre></td></tr></table></figure><p><code>register()</code> 的第一个参数总是这个 <code>Selector</code>。第二个参数是 <code>OP_ACCEPT</code>，这里它指定我们想要监听 <em>accept</em> 事件，也就是在新的连接建立时所发生的事件。这是适用于 <code>ServerSocketChannel</code> 的唯一事件类型。</p><p>请注意对 <code>register()</code> 的调用的返回值。 <code>SelectionKey</code> 代表这个通道在此 <code>Selector</code> 上的这个注册。当某个 <code>Selector</code> 通知您某个传入事件时，它是通过提供对应于该事件的 <code>SelectionKey</code> 来进行的。<code>SelectionKey</code> 还可以用于取消通道的注册。</p><p>现在已经注册了我们对一些 I/O 事件的兴趣，下面将进入主循环。使用 <code>Selectors</code> 的几乎每个程序都像下面这样使用内部循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br><span class="line">Set selectedKeys = selector.selectedKeys(); <span class="comment">//!!!!关键在这里,直接返回的都是有IO请求的,所以就不用像IO一样一个一个轮询,只用轮询有请求的通道.</span></span><br><span class="line">Iterator it = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">     SelectionKey key = (SelectionKey)it.next();</span><br><span class="line">     <span class="comment">// ... deal with I/O event ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们调用 <code>Selector</code> 的 <code>select()</code> 方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时， <code>select()</code> 方法将返回所发生的事件的数量。</p><p>接下来，我们调用 <code>Selector</code> 的 <code>selectedKeys()</code> 方法，它返回发生了事件的 <code>SelectionKey</code> 对象的一个 <code>集合</code>。</p><p>我们通过迭代 <code>SelectionKeys</code> 并依次处理每个 <code>SelectionKey</code> 来处理事件。对于每一个 <code>SelectionKey</code>，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。</p><h4 id="FileChannel-1"><a href="#FileChannel-1" class="headerlink" title="FileChannel"></a>FileChannel</h4><p>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。<strong>FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</strong>所以无法使用selector</p><h5 id="打开FileChannel"><a href="#打开FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h5><p>使用FileChannel前，必须先打开它，但是无法直接打开，必须通过使用一个InputStream OutputStream RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br></pre></td></tr></table></figure><h5 id="从FileChannel读取数据"><a href="#从FileChannel读取数据" class="headerlink" title="从FileChannel读取数据"></a>从FileChannel读取数据</h5><p>调用多个read()方法从FileChannel读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesread =inChannel.read(buf);</span><br></pre></td></tr></table></figure><p>首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1，表示到了文件末尾。</p><h5 id="从FileChannel写数据"><a href="#从FileChannel写数据" class="headerlink" title="从FileChannel写数据"></a>从FileChannel写数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</p><h5 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure><h5 id="fileChannel的position-方法"><a href="#fileChannel的position-方法" class="headerlink" title="fileChannel的position 方法"></a>fileChannel的position 方法</h5><p>特定位置进行读写，也可以调用position(Long pos)方法 设置FileChannel当前位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> pos = channel.position();</span><br><span class="line">channel.position(pos +<span class="number">123</span>);</span><br></pre></td></tr></table></figure><h5 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h5><p>FileChannel实例的size()方法将返回该实例所关联文件的大小。如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> filesize = channel.size();</span><br></pre></td></tr></table></figure><h5 id="force"><a href="#force" class="headerlink" title="force()"></a>force()</h5><p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logback 常用配置</title>
      <link href="/2017/10/17/logback/"/>
      <url>/2017/10/17/logback/</url>
      
        <content type="html"><![CDATA[<p>logback 是一套日志框架。<br>Logback 最常用的就是在classpath 定义一个logback.xml 配置文件 从而对日志进行输出。<br><a id="more"></a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"false"</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"1 seconds"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>logback<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.path"</span> <span class="attr">value</span>=<span class="string">"F:\\logback.log"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--下面class表示往控制台输出日志--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"console"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;filter class="com.example.logback.filter.MyFilter" /&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"file"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;.%d&#123;yyyy-MM-dd&#125;.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%date %level [%thread] %logger&#123;36&#125; [%file : %line] %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.example.logback"</span> <span class="attr">level</span>=<span class="string">"warn"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>现分析每个节点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 根节点 configuration </span><br><span class="line">a scan 为true时，配置文件若发生改变，将会被重新加载。</span><br><span class="line">    b scanPeriod 设置监测配置文件是否有修改的时间间隔。</span><br><span class="line">    c debug 为 true时，打印出Logback内部日志信息。</span><br><span class="line">2 contextName 设置日志上下文名称，可以通过%contextName 来打印日志上下文名称。</span><br><span class="line">3 property 可以用来设置变量 通过 $&#123;name&#125; 访问</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">file</span>=<span class="string">"/configuration/variables.properties"</span> /&gt;</span></span><br><span class="line">resource作用和file一样，但是可以直接从classpath路径下引入配置文件。</span><br><span class="line">4. appender格式化日志输出节点，有name 和 class 属性。class 用来指定哪种输出策略。appender有以下子节点。</span><br><span class="line">  a. encoder和pattern节点组合用于具体输出的日志格式</span><br><span class="line">  b. file节点用来指明日志文件的输出位置，可以是绝对路径也可以是相对路径</span><br><span class="line">  c. rollingPolicy日志回滚策略，在这里我们用了TimeBasedRollingPolicy，基于时间的回滚策略,有以下子节点</span><br><span class="line">  d.fileNamePattern，必要节点，可以用来设置指定时间的日志归档，例如我们上面的例子是每天将日志归档成一个zip包</span><br><span class="line">5 root 节点 用来指定最基础的日志输出级别</span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ref中间的 console file 都是前面appender 的名字，表示选择输出到哪里 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO</title>
      <link href="/2017/10/16/Java%20IO/"/>
      <url>/2017/10/16/Java%20IO/</url>
      
        <content type="html"><![CDATA[<p>Java 所有的文件操作类都在Java.io 包中。 注意五个类和一个接口。File OutputStream InputStream Writer Reader 一个接口是serializable</p><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span><span class="comment">// file 类构造方法</span></span></span><br></pre></td></tr></table></figure><a id="more"></a><p>要使用一个File类，需要传递一个文件路径</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/10122.png" alt="1"> </p><p>创建一个新文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">          f.createNewFile();</span><br><span class="line">        <span class="comment">//if(f.exists())   judge exist</span></span><br><span class="line">        <span class="comment">//f.delete() 删除文件</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span>(IOException e)</span><br><span class="line">      &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// windows 使用\ 表示目录</span></span><br><span class="line"><span class="comment">// linux 使用/ 表示目录</span></span><br></pre></td></tr></table></figure><p>创建文件夹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"/home/brett/java/io"</span>);</span><br><span class="line">f.mkdir() &amp;&amp; f.mkdirs()</span><br></pre></td></tr></table></figure><h3 id="RandomAccessFile-类"><a href="#RandomAccessFile-类" class="headerlink" title="RandomAccessFile 类"></a>RandomAccessFile 类</h3><p>要对文件内容进行操作，使用randomAccessFile类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFile</span> <span class="keyword">implements</span> <span class="title">DataOutput</span>, <span class="title">DataInput</span>, <span class="title">Closeable</span> </span></span><br><span class="line"><span class="class"></span>&#123;<span class="comment">//下面是常用API.</span></span><br><span class="line"><span class="comment">//两个构造函数,指定操作文件.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RandomAccessFile</span><span class="params">(String name, String mode)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="title">RandomAccessFile</span><span class="params">(File file, String mode)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">long</span> pos)</span> <span class="keyword">throws</span> IOException <span class="comment">//设置读指针的位置</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">random_access_file</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//写操作</span></span><br><span class="line">        File f =<span class="keyword">new</span> File(<span class="string">"2.txt"</span>);<span class="comment">//指定要操作的文件</span></span><br><span class="line">        RandomAccessFile rdf =<span class="keyword">new</span> RandomAccessFile(f,<span class="string">"rw"</span>);<span class="comment">// 读写方式打开文件,会自动创建新文件</span></span><br><span class="line">        String name =<span class="string">"wkn     "</span>;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">23</span>;</span><br><span class="line">        rdf.writeBytes(name);</span><br><span class="line">        rdf.write(<span class="number">23</span>);</span><br><span class="line">        rdf.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读操作</span></span><br><span class="line">        File f1 =<span class="keyword">new</span> File(<span class="string">"2.txt"</span>);</span><br><span class="line">        RandomAccessFile rdf2 =<span class="keyword">new</span> RandomAccessFile(f1,<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] b =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i]=rdf2.readByte();</span><br><span class="line">        &#125;</span><br><span class="line">        String name1 =<span class="keyword">new</span> String(b);</span><br><span class="line">        System.out.printf(name1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> String s = <span class="string">"wkn123王康宁"</span>;<span class="comment">//String变量</span></span><br><span class="line"> <span class="keyword">byte</span> b[] = s.getBytes();<span class="comment">//String转换为byte[]</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">byte</span> b1:b)</span><br><span class="line"> &#123;</span><br><span class="line">     System.out.println(b1);</span><br><span class="line"> &#125;</span><br><span class="line"> String t = <span class="keyword">new</span> String(b);<span class="comment">//byte[]转换为String</span></span><br><span class="line"> System.out.println(t);</span><br><span class="line"><span class="comment">// 所有字符都是以byte[]数组的形式传递的，默认utf8</span></span><br><span class="line"><span class="comment">// 英语和数字都是原来的ascll(utf8的英语数字和ascll一样)</span></span><br><span class="line"><span class="comment">// 其他字符可能是不同的编码，比如汉字就是三个数字一个编码。</span></span><br><span class="line"><span class="comment">//所以任何字符串都是可以转换为byte[]的形式的，</span></span><br><span class="line"><span class="comment">//byte[]也可以再转换为字符串。</span></span><br><span class="line"><span class="comment">// 一切“字符”都必定用数字+编码表表示</span></span><br><span class="line"><span class="comment">//当用UTF-8时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个.当然最多不能超过3个字节了.反正是根据字符对应的数字大小来确定.</span></span><br></pre></td></tr></table></figure><p>可以参考<a href="http://www.cnblogs.com/fuzhaoyang56/archive/2013/05/24/3096471.html" target="_blank" rel="noopener">http://www.cnblogs.com/fuzhaoyang56/archive/2013/05/24/3096471.html</a></p><hr><h3 id="字节流于字符流基本操作"><a href="#字节流于字符流基本操作" class="headerlink" title="字节流于字符流基本操作"></a>字节流于字符流基本操作</h3><p>在程序中所有的数据都是以流的方式进行传输或者保存的，程序需要数据时要使用输入流读取数据，而当程序需要将一些数据保存起来时，就要使用输出流。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/10123.png" alt="1"></p><p>io 包中流的操作主要有字节流，字符流两大类，两类都有输入和输出操作，在字节流中输出数据主要使用OutputStream 类完成，输入使用的是InputStream 类。在字符流中输出主要使用Writer类完成，输入主要使用Reader类完成。</p><p>操作流程如下</p><ul><li>使用file类打开一个文件</li><li>通过字节流或者字符流的子类指定输出的位置</li><li>进行读写操作</li><li>关闭输入输出<br>流在实例化的时候都需要传进去一个文件对象，表示流到哪或者从哪里流。<h4 id="字节流（主要操作byte-类型数据-InputStream-OutputStream）"><a href="#字节流（主要操作byte-类型数据-InputStream-OutputStream）" class="headerlink" title="字节流（主要操作byte[]类型数据 InputStream OutputStream）"></a>字节流（主要操作byte[]类型数据 InputStream OutputStream）</h4></li></ul><p>OutputStream 是整个IO包中字节输出流的最大父类，定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> abstruct <span class="class"><span class="keyword">class</span> <span class="title">OutputStream</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span>// 抽象类</span></span><br><span class="line"><span class="class">里面主要定义了一个抽象方法,<span class="title">write</span>().</span></span><br></pre></td></tr></table></figure><p>InputStream 是整个IO包中字节输入流的最大父类，定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> abstruct <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span>// 抽象类</span></span><br><span class="line"><span class="class">里面主要定义了一个抽象方法,<span class="title">read</span>().</span></span><br></pre></td></tr></table></figure><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>在程序中一个字符相当于两个字节，Java提供了Reader 和Writer 两个专门操作字符流的类。</p><p>Writer 与outputStream 的操作流程并没有什么太大的去别，唯一的好处是，可以直接输出字符串，而不用将字符串变为byte[]数组之后再输出。Reader和Inputstream 也是类似。</p><p><em>reader inputstream 都是从文件（或其他）取数据 writer outputstream 往文件（或其他）写入数据</em></p><p>字节流在操作时本身不会用到缓冲区，是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再进行操作文件。<strong>所以字节流操作时不关闭也会有输入输出,字符流就不行,如果不关闭的话,就都在缓冲区里</strong></p><h5 id="转换流-OutputStreamWriter-和InputStream-Reader"><a href="#转换流-OutputStreamWriter-和InputStream-Reader" class="headerlink" title="转换流 OutputStreamWriter 和InputStream Reader"></a>转换流 OutputStreamWriter 和InputStream Reader</h5><p>这两个流都是转换流。</p><p>outputStreamWriter 是writer的子类，将一个字符流的输出对象变为字节流输出对象。</p><p>inputStreamReader 是reader的子类，将一个字节流的输入对象变为字符流的输入对象。</p><h4 id="System类对IO的支持"><a href="#System类对IO的支持" class="headerlink" title="System类对IO的支持"></a>System类对IO的支持</h4><p>System类定义了三个常量,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out<span class="comment">// 对应系统标准输出,一般是显示器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream err<span class="comment">//错误信息输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InputStream in <span class="comment">// 对应标准输入,一般是键盘</span></span><br></pre></td></tr></table></figure><h4 id="System-out"><a href="#System-out" class="headerlink" title="System.out"></a>System.out</h4><p>System.out 是printStream的对象,在printStream 中定义了一系列print()和println()方法,printStream 又是OutputStream的子类.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStream out = System.out;</span><br><span class="line">out.write(<span class="string">"Helo"</span>.getBytes());</span><br></pre></td></tr></table></figure><h4 id="System-err"><a href="#System-err" class="headerlink" title="System.err"></a>System.err</h4><p>System.err 表示的是错误信息输出,如果程序出现错误,可以直接使用System.err 进行输出.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.print(<span class="string">"hhh"</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    System.err.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="System-in"><a href="#System-in" class="headerlink" title="System.in"></a>System.in</h4><p><strong>System.in 实际上是一个键盘的输入流,其本身是InputStream类型的对象,那么此时就可以利用System.in 完成从键盘读取数据的功能.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStream input =System.in;</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = input.read(b);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,len));</span><br><span class="line"><span class="comment">//此方法不常用,因为要提前申请,更好的方法是将全部输入暂存到内存的一块地方,然后一次性从内存中读取数据</span></span><br></pre></td></tr></table></figure><h4 id="BufferedReader类"><a href="#BufferedReader类" class="headerlink" title="BufferedReader类"></a>BufferedReader类</h4><p>BufferedReader 类用于从缓冲区读取内容,所有的输入字节数据都将放在缓冲区中.详见github IO</p><h4 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a>Scanner 类</h4><p>JDK1.5后提供了专门的输入数据类,不只可以完成输入数据操作,也可以方便的对输入数据进行验证.</p><p>Scanner 可以接收任意的输入流.</p><h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><p>对象序列化是把一个对象变为二进制的数据流的一种方法，通过序列化可以方便的实现对象的传输或者存储。如果一个类想被序列化，则对象所在的类必须实现 Java.io.serializable 接口， 此接口没有定义任何的方法，所以此接口是一个标识接口，表示一个类具备了被序列化的能力。</p><h1 id="并发编程网上的IO总结"><a href="#并发编程网上的IO总结" class="headerlink" title="并发编程网上的IO总结"></a>并发编程网上的IO总结</h1><h1 id="Java-IO-ifeve-com"><a href="#Java-IO-ifeve-com" class="headerlink" title="Java IO (ifeve.com)"></a>Java IO (ifeve.com)</h1><p>Java.io包主要包括文件，网络数据流，内存缓冲等的输入输出。（从CPU的角度来看输入输出）。</p><h3 id="Java-IO-概述"><a href="#Java-IO-概述" class="headerlink" title="Java IO 概述"></a>Java IO 概述</h3><p>Java IO 主要关注的是从原始数据源的读取以及输出原始数据到目标媒介。原始的数据源包括了 文件，管道，网络连接，内存缓存。</p><h5 id="流"><a href="#流" class="headerlink" title="流"></a>流</h5><p>Java IO中，流从概念上说是一个连续的数据流，既可以从流总读取数据，也可以从流中写数据。 Java中流可以是字节流，也可以是字符流。</p><p>一个程序需要InputStream 或者reader 从数据源读取数据，需要outputstream 或者writer 将数据写到目标媒介中。</p><h3 id="Java-IO-文件"><a href="#Java-IO-文件" class="headerlink" title="Java IO 文件"></a>Java IO 文件</h3><h5 id="通过IO-读文件"><a href="#通过IO-读文件" class="headerlink" title="通过IO 读文件"></a>通过IO 读文件</h5><p>根据该文件是二进制文件还是文本文件来选择使用FileInputStream或者FileReader。这两个类允许你从文件开始到文件末尾一次读取一个字节或者字符。或者将读取到的字节或字符写到数组里。</p><h5 id="通过IO-写文件"><a href="#通过IO-写文件" class="headerlink" title="通过IO 写文件"></a>通过IO 写文件</h5><p>如果需要在不同端之间写文件，根据你要写入的数据是二进制型数据还是字符型数据选用FileOutputStream或者FileWriter。</p><h5 id="随机存取文件"><a href="#随机存取文件" class="headerlink" title="随机存取文件"></a>随机存取文件</h5><p>通过RandomAccessFile对文件进行随机存取。</p><h3 id="Java-IO-管道"><a href="#Java-IO-管道" class="headerlink" title="Java IO 管道"></a>Java IO 管道</h3><p>Java IO中的管道为运行在同一个JVM中的两个线程提供了通信的能力。所以管道也可以作为数据源以及目标媒介。</p><h3 id="Java-IO-网络"><a href="#Java-IO-网络" class="headerlink" title="Java IO 网络"></a>Java IO 网络</h3><p>当两个进程之间建立了网络连接之后，他们通信的方式如同操作文件一样：利用InputStream读取数据，利用OutputStream写入数据。换句话来说，Java网络API用来在不同进程之间建立网络连接，而Java IO则用来在建立了连接之后的进程之间交换数据。</p><h3 id="Java-IO-字节和字符数组"><a href="#Java-IO-字节和字符数组" class="headerlink" title="Java IO 字节和字符数组"></a>Java IO 字节和字符数组</h3><h5 id="从inputstream-或者reader中读取数组。"><a href="#从inputstream-或者reader中读取数组。" class="headerlink" title="从inputstream 或者reader中读取数组。"></a>从inputstream 或者reader中读取数组。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">把数据写入数组</span><br><span class="line">InputStream  InputStream = <span class="keyword">new</span> InputStream(bytes);</span><br><span class="line"><span class="comment">// 读取一个字节</span></span><br><span class="line"><span class="keyword">int</span> data = InputStream.read();</span><br><span class="line"><span class="comment">//读取下一个字节</span></span><br><span class="line"><span class="keyword">int</span> data2 = InputStream.read();</span><br></pre></td></tr></table></figure><p>同样的方式也可以读取字符数组，把字符数组封装在charArrayReader上就行。</p><h5 id="从Outputstream-或者writer写数组"><a href="#从Outputstream-或者writer写数组" class="headerlink" title="从Outputstream 或者writer写数组"></a>从Outputstream 或者writer写数组</h5><p>同样，也可以把数据写到ByteArrayOutputStream或者CharArrayWriter中。你只需要创建ByteArrayOutputStream或者CharArrayWriter，把数据写入。</p><p>当所有的数据都写进去了以后，只要调用toByteArray()或者toCharArray，所有写入的数据就会以数组的形式返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStram output =  <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">output.write(<span class="string">"this is a text"</span>.toBytes(<span class="string">'UTF-8'</span>));</span><br><span class="line"><span class="keyword">byte</span>[] bytes = output.toByteArray();</span><br></pre></td></tr></table></figure><h3 id="Java-IO-流"><a href="#Java-IO-流" class="headerlink" title="Java IO: 流"></a>Java IO: 流</h3><p>流和数组不一样，不能通过索引读写数据，在流中，也不能像数组那样前后移动读取数据，除非使用randomaccessFile 处理文件。流仅仅是一个连续的数据流。</p><h5 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h5><p>InputStream 是所有JavaIO  输入流的基类，通常使用输入流中的read()方法读取数据，read方法返回一个整数，代表了读取到的字节的内容，当到达流的末尾没有更多数据可以读时，返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-file.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> data = input.read(); </span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">        data = input.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="outputstream"><a href="#outputstream" class="headerlink" title="outputstream"></a>outputstream</h5><p>OutputStream是Java IO中所有输出流的基类.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-file.txt"</span>);</span><br><span class="line">output.write(<span class="string">"Hello World"</span>.getBytes());</span><br><span class="line">output.close();</span><br></pre></td></tr></table></figure><h5 id="组合流"><a href="#组合流" class="headerlink" title="组合流"></a>组合流</h5><p>可以将流整合起来以便实现更高级的输入和输出操作。比如，一次读取一个字节是很慢的，所以可以从磁盘中一次读取一大块数据，然后从读到的数据块中获取字节。为了实现缓冲，可以把InputStream包装到BufferedInputStream中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-file.txt"</span>));</span><br></pre></td></tr></table></figure><h5 id="reader"><a href="#reader" class="headerlink" title="reader"></a>reader</h5><p>Reader类是Java IO中所有Reader的基类。子类包括BufferedReader，PushbackReader，InputStreamReader，StringReader和其他Reader.这并不意味着Reade只会从数据源中一次读取2个字节，Reader会根据文本的编码，一次读取一个或者多个字节。</p><h3 id="并发IO"><a href="#并发IO" class="headerlink" title="并发IO"></a>并发IO</h3><p>在同一时刻不能有多个线程同时InputStream 或者 Reader 中读取数据，也不能同时往outputStream 或者writer里写数据，你没有办法保证每个线程读取多少数据，以及多个线程写数据时的顺序。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>流与reader writer 使用结束的时候，需要正确的关闭它们，通常调用close() </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> data = input.read();</span><br><span class="line">    <span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//do something with data...</span></span><br><span class="line">        doSomethingWithData(data);</span><br><span class="line">        data = input.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    <span class="comment">//do something with e... log, perhaps rethrow etc.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="keyword">null</span>)</span><br><span class="line">            input.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        <span class="comment">//do something, or ignore.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fileinputstream"><a href="#Fileinputstream" class="headerlink" title="Fileinputstream"></a>Fileinputstream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> data = input.read();<span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something with data...</span></span><br><span class="line">    doSomethingWithData(data);</span><br><span class="line">    data = input.read();</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line"><span class="comment">//中一个FileInputStream构造函数取一个File对象替代String对象作为参数。这里是一个使用该构造函数的例子：</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(file);</span><br></pre></td></tr></table></figure><p>FileInputStream的read()方法返回读取到的包含一个字节内容的int变量(译者注：0~255)。如果read()方法返回-1，意味着程序已经读到了流的末尾，此时流内已经没有多余的数据可供读取了，你可以关闭流。-1是一个int类型，不是byte类型，这是不一样的。</p><h3 id="FileOutputstream"><a href="#FileOutputstream" class="headerlink" title="FileOutputstream"></a>FileOutputstream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>);</span><br><span class="line"><span class="keyword">while</span>(moreData) &#123;</span><br><span class="line">    <span class="keyword">int</span> data = getMoreData();</span><br><span class="line">    output.write(data);</span><br><span class="line">&#125;</span><br><span class="line">output.close();</span><br></pre></td></tr></table></figure><p>当你创建了一个指向已存在文件的FileOutputStream，你可以选择覆盖整个文件，或者在文件末尾追加内容。通过使用不同的构造函数可以实现不同的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>);</span><br><span class="line">另外一个构造函数取<span class="number">2</span>个参数：文件名和一个布尔值，布尔值表明你是否需要覆盖文件。这是构造函数的例子：</span><br><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>, <span class="keyword">true</span>); <span class="comment">//appends to file </span></span><br><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>, <span class="keyword">false</span>); <span class="comment">//overwrites file</span></span><br></pre></td></tr></table></figure><h4 id="flush"><a href="#flush" class="headerlink" title="flush()"></a>flush()</h4><p>当你往FileOutputStream里写数据的时候，这些数据有可能会缓存在内存中。在之后的某个时间，比如，每次都只有X份数据可写，或者FileOutputStream关闭的时候，才会真正地写入磁盘。当FileOutputStream没被关闭，而你又想确保写入到FileOutputStream中的数据写入到磁盘中，可以调用flush()方法，该方法可以保证所有写入到FileOutputStream的数据全部写入到磁盘中。</p><h3 id="File-1"><a href="#File-1" class="headerlink" title="File"></a>File</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">'/home/brett/2.txt'</span>);</span><br><span class="line">上句相当于获得了一个门把手，但是不知道门是否存在，若不存在的话就可以使用</span><br><span class="line">f.createNewFile()创建文件。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis 映射</title>
      <link href="/2017/10/12/Mybatis%20%E6%98%A0%E5%B0%84/"/>
      <url>/2017/10/12/Mybatis%20%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Very Complex Result Map --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"detailedBlogResultMap"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> <span class="attr">javaType</span>=<span class="string">"int"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">column</span>=<span class="string">"blog_author_id"</span> <span class="attr">javaType</span>=<span class="string">" Author"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"author_password"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"email"</span> <span class="attr">column</span>=<span class="string">"author_email"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bio"</span> <span class="attr">column</span>=<span class="string">"author_bio"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"favouriteSection"</span> <span class="attr">column</span>=<span class="string">"author_favourite_section"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">column</span>=<span class="string">"post_author_id"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"comments"</span> <span class="attr">column</span>=<span class="string">"post_id"</span> <span class="attr">ofType</span>=<span class="string">" Comment"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"comment_id"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"tags"</span> <span class="attr">column</span>=<span class="string">"post_id"</span> <span class="attr">ofType</span>=<span class="string">" Tag"</span> &gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"tag_id"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">"int"</span> <span class="attr">column</span>=<span class="string">"draft"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">resultType</span>=<span class="string">"DraftPost"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span> <span class="tag">&lt;<span class="name">wbr</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="resultmap"><a href="#resultmap" class="headerlink" title="resultmap"></a>resultmap</h3><ul><li>constructor 实例化的时候通过构造器将结果集注入类中</li><li>ID 结果集ID 方便全局调用</li><li>result 注入一个字段或者Javabean属性的结果。</li><li>association 一对一嵌套</li><li>collection 一对多嵌套</li><li>discriminator 使用一个结果值以决定使用哪个resultMap</li></ul><p>Id result 元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Association 元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">column</span>=<span class="string">"blog_author_id"</span> <span class="attr">javaType</span>=<span class="string">" Author"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br></pre></td></tr></table></figure><p>association 元素处理一对一类型关系 这时需要告诉mybatis 如何加载一个联合查询，mybatis使用两种方式加载1 通过执行另一个返回预期复杂类型的映射SQL语句2.通过嵌套结果映射来处理连接结果集的重复子集。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1<span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">”blogResult”</span> <span class="attr">type</span>=<span class="string">”Blog”</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">column</span>=<span class="string">"blog_author_id"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">select</span>=<span class="string">”selectAuthor”/</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>   </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectAuthor”</span> <span class="attr">parameterType</span>=<span class="string">”int”</span> <span class="attr">resultType</span>=<span class="string">"Author"</span>&gt;</span>  </span><br><span class="line">SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">”blog_id”</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">column</span>=<span class="string">"blog_author_id"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">resultMap</span>=<span class="string">”authorResult”/</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"authorResult"</span> <span class="attr">type</span>=<span class="string">"Author"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"author_password"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"email"</span> <span class="attr">column</span>=<span class="string">"author_email"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bio"</span> <span class="attr">column</span>=<span class="string">"author_bio"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以直接把id 标签 result 标签写到<association></association>里面。</p><p>collection 元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"domain.blog.Post"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"body"</span> <span class="attr">column</span>=<span class="string">"post_body"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">”blogResult”</span> <span class="attr">type</span>=<span class="string">”Blog”</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">javaType</span>=<span class="string">”ArrayList”</span> <span class="attr">column</span>=<span class="string">"blog_id"</span>  <span class="attr">ofType</span>=<span class="string">"Post"</span>   <span class="attr">select</span>=<span class="string">”selectPostsForBlog”/</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectBlog”</span> <span class="attr">parameterType</span>=<span class="string">”int”</span> <span class="attr">resultMap</span>=<span class="string">”blogResult”</span>&gt;</span>  </span><br><span class="line">SELECT * FROM BLOG WHERE ID = #&#123;id&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectPostsForBlog”</span> <span class="attr">parameterType</span>=<span class="string">”int”</span> <span class="attr">resultType</span>=<span class="string">"Author"</span>&gt;</span>  </span><br><span class="line">SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时会有一个新的属性oftype 这个元素是用来区别JavaBean属性类型和集合类型所包括的类型。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 网络编程</title>
      <link href="/2017/10/11/Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2017/10/11/Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-网络编程"><a href="#Java-网络编程" class="headerlink" title="Java 网络编程"></a>Java 网络编程</h1><p>InetAddress 类表示IP地址,有两个子类,Inet4Address,Inet6Address,一个表示v4,一个表示v6,常用方法有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title">getByName</span><span class="params">(String host)</span> <span class="comment">//通过主机名称得到InetAddress对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title">getLocalHost</span><span class="params">()</span> <span class="comment">//通过本机得到InetAddress</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHostName</span><span class="params">()</span> <span class="comment">//得到IP地址</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReachable</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="comment">//判断地址是否可达.</span></span></span><br></pre></td></tr></table></figure><a id="more"></a><p>URL是统一资源定位符,可以直接使用此类找到互联网上的资源,常用方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(String spec)</span> <span class="keyword">throws</span> MalformedURLException <span class="comment">//根据指定地址实例化URL对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(String protocol,String host,<span class="keyword">int</span> port,String file)</span> <span class="comment">//实例化URL对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URLConnection <span class="title">openConnection</span><span class="params">()</span> <span class="comment">//取得一个URLConnection对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> InputStream <span class="title">openStream</span><span class="params">()</span> <span class="comment">//取得输入流</span></span></span><br></pre></td></tr></table></figure><h3 id="TCP开发"><a href="#TCP开发" class="headerlink" title="TCP开发"></a>TCP开发</h3><p>在Java中使用Socket完成TCP程序的开发,使用此类可以方便的建立可靠的,双向的,持续,点对点的通信连接.</p><p>在Socket的程序开发中,服务端使用ServerSocket等待客户端的连接,对于Java的网络程序来讲,每一个客户端都是用一个Socket对象表示.</p><p>ServerSocket类主要用在服务端程序的开发上,用于接收客户端的连接请求,常见方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="comment">//构造函数创建ServerSocket实例,并监听指定端口.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span> <span class="comment">//等待客户端连接,此方法连接前一直阻塞</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InetAddress <span class="title">getInetAddress</span><span class="params">()</span> <span class="comment">// 返回服务器的IP地址</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> <span class="comment">//返回ServerSocket的关闭状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="comment">// 关闭ServerSocket</span></span></span><br></pre></td></tr></table></figure><p>Sokcet类的常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host,<span class="keyword">int</span> port)</span> <span class="comment">//构造函数,构造Socket对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="comment">//返回此套接字的输入流</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="comment">// 返回此套接字的输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="comment">// 关闭此Socket</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> <span class="comment">//判断此套接字是否被关闭</span></span></span><br></pre></td></tr></table></figure><p>在客户端,程序通过Socket类的getInputStream()方法取得服务器的输出信息,在服务端可以通过getOutputStream()方法取得客户端的输出信息.</p><h3 id="UDP开发"><a href="#UDP开发" class="headerlink" title="UDP开发"></a>UDP开发</h3><p>在Java中使用DatagramSocket和DatagramPacket类完成UDP程序开发</p><p>在UDP开发中使用DatagramPacket类包装一条要发送的信息,之后使用DatagramSocket类用于完成信息的发送操作.</p><p>DatagramPacket</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatagramPacket</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length)</span> <span class="comment">//实例化DatagramPacket</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatagramPacket</span><span class="params">(<span class="keyword">byte</span>[] buf,<span class="keyword">int</span> length, InetAddress address,<span class="keyword">int</span> port)</span><span class="comment">//实例化DatagramPacket对象时指定发送的数据,数据的长度,目标地址及端口</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">getData</span><span class="params">()</span> <span class="comment">//返回接收的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="comment">// 返回要发送或接收数据的长度</span></span></span><br></pre></td></tr></table></figure><p>DatagramSocket </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatagramSocket</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="comment">// 创建DatagramSocket对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(DatagramPacket p)</span> <span class="comment">//发送数据报</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(DatagramPacket p)</span> <span class="comment">//接收数据报</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 枚举类的使用</title>
      <link href="/2017/10/11/Java%20%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/10/11/Java%20%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>enum 的全称是enumeration。存放在java.lang 包中。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Weekday</span><br><span class="line">&#123;</span><br><span class="line"> SUN,</span><br><span class="line">  MON,</span><br><span class="line">  TUS,</span><br><span class="line">  WED,</span><br><span class="line">  THU,</span><br><span class="line">  FRI,</span><br><span class="line">  SAT</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//use</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>()</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Weekday sun = Weekday.SUN;</span><br><span class="line">      System.out.println(sun);<span class="comment">//print SUN</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><p>Weekday 有两个方法分别是value() 和valueOf()。还有我们定义的七个变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Weekday.valueOf()</span><br><span class="line"><span class="comment">//它的作用是传来一个字符串，然后将它转变为对应的枚举变量。前提是你传的字符串和定义枚举变量的字符串一抹一样，区分大小写。如果你传了一个不存在的字符串，那么会抛出异常。</span></span><br><span class="line">Weekday.values()</span><br><span class="line"><span class="comment">//这个方法会返回包括所有枚举变量的数组。在该例中，返回的就是包含了七个星期的Weekday[]。可以方便的用来做循环。</span></span><br><span class="line">枚举变量的toString()方法。</span><br><span class="line"><span class="comment">//该方法直接返回枚举定义枚举变量的字符串，比如MON就返回【”MON”】。</span></span><br><span class="line">枚举变量的.ordinal()方法。</span><br><span class="line">默认请款下，枚举类会给所有的枚举变量一个默认的次序，该次序从<span class="number">0</span>开始，类似于数组的下标。而.ordinal()方法就是获取这个次序（或者说下标).</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 常用使用技巧总结</title>
      <link href="/2017/10/10/Python%20%E5%B8%B8%E7%94%A8%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2017/10/10/Python%20%E5%B8%B8%E7%94%A8%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="Python-字典按照-key-value进行排序"><a href="#Python-字典按照-key-value进行排序" class="headerlink" title="Python 字典按照 key,value进行排序"></a>Python 字典按照 key,value进行排序</h4><p>只需要一行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(d.items(),key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse = <span class="keyword">True</span>)<span class="comment"># 按照value进行排序</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(d.items(),key = <span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse = <span class="keyword">True</span>) <span class="comment"># 按照key进行排序</span></span><br></pre></td></tr></table></figure><h4 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h4><p><strong>map()</strong> 会根据提供的函数对指定序列做映射。第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p><ul><li>语法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map(function,iterable,...) <span class="comment"># function是函数,iterable 是一个或者多个序列</span></span><br><span class="line"><span class="comment"># 对iterable中的每个元素施加function.</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span> :</span>            <span class="comment"># 计算平方数</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   <span class="comment"># 计算列表各个元素的平方</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])  <span class="comment"># 使用 lambda 匿名函数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 提供了两个列表，对相同位置的列表数据进行相加</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line">[<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B 树与B+ 树</title>
      <link href="/2017/10/10/B%20%E6%A0%91%E4%B8%8EB+%20%E6%A0%91/"/>
      <url>/2017/10/10/B%20%E6%A0%91%E4%B8%8EB+%20%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h4 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h4><p>数据库结构使用树的结构索引，从算法逻辑上看，二叉查找树的查找速度和比较次数都是最小的。数据库的索引存储在磁盘上，当数据量比较大的时候，索引的大小可能有几个G 甚至更多。</p><p>当我们利用索引查询的时候，不可能把整个索引加载到内存，能做的只有逐一加载每一个磁盘页，磁盘页对应索引树的节点。<br><a id="more"></a><br>当利用二叉查找树时，每一层都是进行一次IO操作（即把对应的索引装入内存），因此最坏的情况下，磁盘的IO次数就等于索引树的高度。</p><p>为了减少IO次数，就需要把层数降低，也就是B-树</p><p>B树是一种多路平衡查找树，</p><p>m阶b树具有以下的特征。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每个结点至多拥有m棵子树；</span><br><span class="line">根结点至少拥有两颗子树（存在子树的情况下）；</span><br><span class="line">除了根结点以外，其余每个分支结点至少拥有 m/2 棵子树；</span><br><span class="line">所有的叶结点都在同一层上；</span><br><span class="line">有 k 棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；</span><br><span class="line">关键字数量需要满足ceil(m/2)-1 &lt;= n &lt;= m-1；</span><br></pre></td></tr></table></figure><p>可以知道，b树在查询中的比较次数其实不比二叉查找树少，尤其当单一节点中元素数量很多时，但是相比磁盘IO的速度，内存中的比较耗时几乎可以忽略，所以只要树足够低，IO次数就足够少，就可以提升性能。</p><p>b树主要应用于文件系统以及部分数据库索引（MongoDB）</p><h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B + 树"></a>B + 树</h4><p>B+ 树是B 树的一种变体，比B树的查询性能更高。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</span><br><span class="line">2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</span><br><span class="line">3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</span><br></pre></td></tr></table></figure><p><img src="http://blog-1252095801.cosgz.myqcloud.com/10121.png" alt="shu"></p><p>B+ 树中每个父节点的元素都出现在子节点中，是子节点的最大（最小）元素。根节点的最大元素也就等同于整个B+树的最大元素，以后无论插入删除多少元素，始终要保持最大元素在根节点中。由于父节点的元素出现在叶子节点中，因此所有的叶子节点包括了所有的信息。并且每一个叶子节点都带有一个指向下一个节点的指针，形成了一个有序链表。</p><p>在B树种，无论父节点还是子节点都带有数据，在b+ 树中，只有叶子节点带有数据，中间节点仅仅是索引，没有任何数据。</p><p>需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。</p><p>B+树的好处主要体现在查询性能上，单点查询时，由于B+树中间节点没有数据，所有同样的磁盘页可以容纳更多的节点，也就是说，在数据量相同的情况下，b+ 树的结构比b树更加矮胖，IO次数也就更少。B+ 树的查询必须查到叶子节点，B树查询到匹配元素即可，所以B树查询性能不稳定。范围查询时，B 树只能中序遍历，而B+树只需要在链表中做遍历即可。所以B+ 树范围查询更加方便。</p><p>综合起来，B+ 树IO 次数少，查询性能稳定，范围查询更加方便。</p><h4 id="m阶b-树和m阶B树的区别"><a href="#m阶b-树和m阶B树的区别" class="headerlink" title="m阶b+树和m阶B树的区别"></a>m阶b+树和m阶B树的区别</h4><ol><li>所有叶子节点包含全部关键字信息，及指向含有这些关键字记录的指针，且叶子节点中关键字进行有序链接</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li></ol><p>B+树比B树更适合操作系统的文件索引和数据库索引的原因：</p><ul><li>B+树的磁盘读写代价更低，B+树的内部节点没有指向关键字具体信息的指针，因此内部节点相对B树更小。如果把所有同一内部节点的关键字放在同一块磁盘中，盘块所能容纳的关键字数量也就越多，一次性读入内存中的需要查找的关键字也就越多，相对IO读写次数降低</li><li>B+树的查询效率更加稳定<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ul><p><strong>总结</strong></p><ul><li>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</li><li>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</li></ul><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561244&amp;idx=1&amp;sn=df3abafd3aa2f5a3abfe507bfc26982f&amp;chksm=f1feec5fc6896549f89cbb82ee3d8010c63da76814030b285fa29322795de512ccca207064ee&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561244&amp;idx=1&amp;sn=df3abafd3aa2f5a3abfe507bfc26982f&amp;chksm=f1feec5fc6896549f89cbb82ee3d8010c63da76814030b285fa29322795de512ccca207064ee&amp;scene=21#wechat_redirect</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 问题总结</title>
      <link href="/2017/10/08/Java%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2017/10/08/Java%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="http://blog-1252095801.cosgz.myqcloud.com/1010.png" alt="restful"></p><p>想在表单中实现put 和 delete 方法，就埋一个hidden，name为 _method， 值为delete。 然后在控制器中使用RequestMethod.PUT 就可以了。</p><a id="more"></a><p>再在web.xml中配置filter:org.springframework.web.filter.HiddenHttpMethodFilter 就可以了。</p><p>Springmvc 上传图片达到指定位置，并能够用Tomcat 访问</p><p>勾上 IDEA 的 deploy applications configured in tomcat instance.</p><h2 id="Static-关键字"><a href="#Static-关键字" class="headerlink" title="Static 关键字"></a>Static 关键字</h2><p>如果现在有些属性希望被所有对象共享，则必须将其声明为static 属性，如果一个类中的方法想由类调用，则可以声明为static 方法。</p><p>1 使用static 声明属性，成为全局属性，所有对象共用。类名直接调用。</p><p>2 使用static 声明方法 可以用类名直接调用。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在继承的操作中，对于子类对象的实例化，首先调用父类的构造方法，再调用子类的构造方法，</p><h4 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h4><p>方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载Overloading是一个类中多态性的一种表现。重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。</p><p>在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。</p><p><img src="http://blog-1252095801.cosgz.myqcloud.com/171015.png" alt="21"></p><h3 id="Super关键字"><a href="#Super关键字" class="headerlink" title="Super关键字"></a>Super关键字</h3><p>使用super 关键字可以从子类中调用父类中的构造方法，普通方法和属性。</p><h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>final在Java中表示的意思是最终，可以用final 关键字声明类，属性，方法。</p><ul><li>final声明的类不能有子类</li><li>final 声明方法不能被子类所覆写</li><li>final 声明的变量即成为常量，不能被修改。</li></ul><p>使用final 声明时，要求全部的字母大写。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>Java中创建一种类专门当作父类，这种类被称为抽象类。不能由抽象类直接创建对象，只能通过抽象类派生出新的类，再由新的类创建对象。抽象类中同样有单继承的缺陷。</p><ul><li>包含一个抽象方法的类必须是抽象类。</li><li>抽象类和抽象方法都要用abstract 声明。</li><li>抽象方法只需声明不需要实现</li><li>抽象类必须被子继承，子类如果不是抽象类就必须覆写抽象类中全部抽象方法。</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口中可以有变量和方法，但是要注意，接口中变量会被隐式的指定为 public static final 变量。方法会被隐式的指定为public abstract 方法。一般情况下不在接口中定义变量。</p><h3 id="对象的多态性"><a href="#对象的多态性" class="headerlink" title="对象的多态性"></a>对象的多态性</h3><p>对象的多态性有两种类型</p><p>向上转型 子类——&gt; 父类         向下转型 父类——&gt; 子类</p><p>向上转型，程序自动完成，向下转型，需要明确指出子类类型。</p><h3 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a>instanceof 关键字</h3><p>判断到底是哪个类的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象 <span class="keyword">instanceof</span> 类 ----&gt;  返回Boolean值</span><br></pre></td></tr></table></figure><h3 id="抽象类-接口的具体应用"><a href="#抽象类-接口的具体应用" class="headerlink" title="抽象类 接口的具体应用"></a>抽象类 接口的具体应用</h3><h5 id="抽象类-模板"><a href="#抽象类-模板" class="headerlink" title="抽象类-模板"></a>抽象类-模板</h5><p>人可以说话，人有姓名，学生和老师各自说的话不一样，这时人就可以设为抽象类，当做模板。</p><p>接口-制定标准</p><p>对行为的抽象。比如一个电脑要USB的设备才可以插入，那么鼠标，键盘都实现了USB 接口，就可以插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">computer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">plugin</span><span class="params">(USB usb)</span>  <span class="comment">// 只要USB 就可以插入</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flash</span> <span class="keyword">implements</span> <span class="title">USB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"  flash start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"  flash stop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disk</span> <span class="keyword">implements</span> <span class="title">USB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"  disk start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"  disk stop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        computer.plugin(<span class="keyword">new</span> Falsh()); <span class="comment">//插入 flash </span></span><br><span class="line">        computer.plugin(<span class="keyword">new</span> Disk); <span class="comment">// 插入 disk</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常-try-catch-finally"><a href="#异常-try-catch-finally" class="headerlink" title="异常 (try catch finally)"></a>异常 (try catch finally)</h3><p>在Java 异常结构中，有两个最常用的类，分别是Exception 和 Error 。这两个类都是Throwable的子类，</p><h4 id="throws-和-throw"><a href="#throws-和-throw" class="headerlink" title="throws 和 throw"></a>throws 和 throw</h4><p>在定义一个方法时可以用throws 关键字进行声明。使用throws 声明的方法表示此方法不处理异常，而交给方法的调用进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> <span class="keyword">throws</span> Exception<span class="comment">//方法不处理异常 </span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=i/j;</span><br><span class="line">      <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为除法操作可能产生异常，也可能不产生，所以使用了 throws 关键字，表示不论是否有异常，在调用方法处都必须进行异常处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Math m =<span class="keyword">new</span> Math();</span><br><span class="line">      <span class="comment">// 因为throws 所以必须处理异常</span></span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;m.div(<span class="number">10</span>,<span class="number">2</span>);&#125;</span><br><span class="line">      <span class="keyword">catch</span>(Exception e)</span><br><span class="line">      &#123;e.printStackTrace();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主方法中抛出异常，那么就交给JVM 处理，自己不用处理异常了。</p><p>与throws 不同的是，可以直接使用throw抛出一个异常，抛出时直接抛出异常类的实例化对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"自己抛出的异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">catch</span>(Exception e)</span><br><span class="line">      &#123;</span><br><span class="line">          System.out.println(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Exception-类与-RuntimeException"><a href="#Exception-类与-RuntimeException" class="headerlink" title="Exception 类与 RuntimeException"></a>Exception 类与 RuntimeException</h3><p>Exception 在程序中必须使用try catch 进行处理</p><p>RuntimeException 可以不用try catch 进行处理，有异常发生的话，交给JVM.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery</title>
      <link href="/2017/10/07/jQuery/"/>
      <url>/2017/10/07/jQuery/</url>
      
        <content type="html"><![CDATA[<p>基础语法 ${selecttor}.action()</p><p>所有的jQuery函数位于一个document ready 函数中<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//jquery 代码。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h3><ol><li><p>元素选择器</p><p>$(“p”) 在页面中选择所有<code>&lt;p&gt;</code>元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(funcion()&#123;</span><br><span class="line">            $(<span class="string">"button"</span>).click(funcion()&#123;</span><br><span class="line">            $(<span class="string">"p"</span>).hide();</span><br><span class="line">                              &#125;);</span><br><span class="line">                  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>id选择器</p><p>$(“#test”)在页面中选择Id 为 test 的元素。</p></li><li><p>.class (泪点)   .class 选择器</p><p>$(“.text”) 选择所有class=”text”的元素。</p></li></ol><h3 id="jQuery-事件"><a href="#jQuery-事件" class="headerlink" title="jQuery 事件"></a>jQuery 事件</h3><p><img src="http://blog-1252095801.cosgz.myqcloud.com/QQ20171007-145159.png" alt="shijian"></p><p>mouseenter() 当鼠标指针穿过元素时，会发生mouseenter事件。</p><p>mouseleave() 当鼠标离开元素时，会发生 mouseleave事件。</p><p>mousedown()当鼠标指针移动到元素上方，并按下鼠标按键时，会发生</p><p>focus()  当元素获得焦点时，会发生focus事件。</p><p>Blur()当元素失去焦点时，会发生blur事件。</p><h3 id="jQuery-获取内容和属性"><a href="#jQuery-获取内容和属性" class="headerlink" title="jQuery 获取内容和属性"></a>jQuery 获取内容和属性</h3><p>三个用于dom操作的jQuery方法</p><p>text() 设置或返回所选元素的文本内容。html() 设置或返回所选元素的内容 （包括HTML标记）val() 设置或返回表单字段的值</p><p>attr()方法用于获取属性值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  $(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    alert($(<span class="string">"#a"</span>).attr(<span class="string">"href"</span>));</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.222.com"</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span>菜鸟教程<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>显示 href 属性的值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">// 显示 http://www.222.com</span><br></pre></td></tr></table></figure><h3 id="jQuery-设置内容和属性"><a href="#jQuery-设置内容和属性" class="headerlink" title="jQuery 设置内容和属性"></a>jQuery 设置内容和属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test1"</span>).text(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">"#btn2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test2"</span>).html(<span class="string">"&lt;b&gt;Hello world!&lt;/b&gt;"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">"#btn3"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test3"</span>).val(<span class="string">"RUNOOB"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>text()、html() 以及 val()，同样拥有回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。</p><p>jQuery attr() 方法也用于设置/改变属性值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"#runoob"</span>).attr(<span class="string">"href"</span>,<span class="string">"http://www.runoob.com/jquery"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>jQuery 方法 attr()，也提供回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。</p><h3 id="jQuery-添加元素"><a href="#jQuery-添加元素" class="headerlink" title="jQuery 添加元素"></a>jQuery 添加元素</h3><ul><li>append() - 在被选元素的结尾插入内容</li><li>prepend() - 在被选元素的开头插入内容</li><li>after() - 在被选元素之后插入内容</li><li>before() - 在被选元素之前插入内容</li></ul><h3 id="jQuery-删除元素"><a href="#jQuery-删除元素" class="headerlink" title="jQuery 删除元素"></a>jQuery 删除元素</h3><ul><li>remove() - 删除被选元素（及其子元素）</li><li>empty() - 从被选元素中删除子元素</li></ul><h3 id="jQuery-操作css"><a href="#jQuery-操作css" class="headerlink" title="jQuery 操作css"></a>jQuery 操作css</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.important</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="attribute">font-weight</span>:bold;</span><br><span class="line">        <span class="attribute">font-size</span>:xx-large;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.blue</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addclass()方法 添加css样式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"h1,h2,p"</span>).addClass(<span class="string">"blue"</span>);</span><br><span class="line">  $(<span class="string">"div"</span>).addClass(<span class="string">"important"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>removeclass()方法 删除css 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"h1,h2,p"</span>).removeClass(<span class="string">"blue"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="css-方法"><a href="#css-方法" class="headerlink" title="css() 方法"></a>css() 方法</h3><h5 id="返回css-属性-返回首个匹配元素的background-color-值。"><a href="#返回css-属性-返回首个匹配元素的background-color-值。" class="headerlink" title="返回css 属性 返回首个匹配元素的background-color 值。"></a>返回css 属性 返回首个匹配元素的background-color 值。</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"background-color"</span>);</span><br></pre></td></tr></table></figure><h5 id="设置css属性"><a href="#设置css属性" class="headerlink" title="设置css属性"></a>设置css属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;);</span><br></pre></td></tr></table></figure><h3 id="jQuery-遍历"><a href="#jQuery-遍历" class="headerlink" title="jQuery 遍历"></a>jQuery 遍历</h3><p>指根据其他元素的关系来查找HTML元素。</p><p><em>向上遍历DOM树。parernt() parents() parentsUntil()</em></p><p>parent() 方法返回被选元素的直接父元素。</p><p>parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (<html>)。</html></p><p>parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"span"</span>).parentsUntil(<span class="string">"div"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><em>向下遍历DOM 树 children() find()</em></p><p>children() 方法返回被选元素的所有直接子元素</p><p>find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。</p><p>下面的例子返回属于 <code>&lt;div&gt;</code> 后代的所有 <code>&lt;span&gt;</code> 元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"div"</span>).find(<span class="string">"span"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><em>水平遍历DOM树 siblings() next() mextAll() nextUtil() prev() prevAll() prevUntil()</em></p><h3 id="jquery-AJAX"><a href="#jquery-AJAX" class="headerlink" title="jquery AJAX"></a>jquery AJAX</h3><h5 id="jquery-load-方法-selector-load-URL-data-callback"><a href="#jquery-load-方法-selector-load-URL-data-callback" class="headerlink" title="jquery load() 方法   $(selector).load(URL,data,callback);"></a>jquery load() 方法   $(selector).load(URL,data,callback);</h5><p>load方法从服务器加载数据，并把返回的数据放入到被选的元素中。必须的URL 参数规定希望加载的URL。可选的data参数规定与请求一同发送的查询字符串键值对集合。可选的callback参数是load()方法完成后所执行的函数名称。</p><p>回调函数的参数可以设置不同的参数</p><p>Responsetxt 包含调用成功时的结果内容</p><p>statusTXT 包含调用的状态</p><p>xhr 包含XMLHttpRequest对象。</p><h5 id="get-方法和post-方法"><a href="#get-方法和post-方法" class="headerlink" title="get() 方法和post() 方法"></a>get() 方法和post() 方法</h5><p>get() 和post() 请求从服务器请求数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$.get(URL,callback);</span><br><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $.get(<span class="string">"demo_test.php"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data,status</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"数据: "</span> + data + <span class="string">"\n状态: "</span> + status);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $.post(<span class="string">"/try/ajax/demo_test_post.php"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        name:<span class="string">"菜鸟教程"</span>,</span><br><span class="line">        url:<span class="string">"http://www.runoob.com"</span></span><br><span class="line">    &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">data,status</span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"数据: \n"</span> + data + <span class="string">"\n状态: "</span> + status);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS总结</title>
      <link href="/2017/10/07/CSS/"/>
      <url>/2017/10/07/CSS/</url>
      
        <content type="html"><![CDATA[<p>css 规则通常由两个主要部分组成，选择器，以及一条或者多条声明。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red ;<span class="attribute">text-align</span>:center;&#125;</span><br></pre></td></tr></table></figure><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>id选择器和class选择器</p><p>id选择器用#来定义，class选择器用. 来定义</p><a id="more"></a><h3 id="样式的创建"><a href="#样式的创建" class="headerlink" title="样式的创建"></a>样式的创建</h3><p>外部样式表、内部样式表、内联样式</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-ccolor</span> 背景颜色</span><br><span class="line"><span class="selector-tag">background-image</span><span class="selector-pseudo">:url("")</span> 背景图像</span><br><span class="line"><span class="selector-tag">background-repeat</span><span class="selector-pseudo">:no-repeat</span> 设置图片不进行平铺</span><br><span class="line"><span class="selector-tag">background-position</span><span class="selector-pseudo">:right</span> <span class="selector-tag">top</span> 图片起始位置</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">text-align</span><span class="selector-pseudo">:center(right</span> <span class="selector-tag">justify</span>) 文本对齐方式</span><br><span class="line"><span class="selector-tag">text-decoration</span><span class="selector-pseudo">:none</span>:设置删除文本的装饰 如 删除下划线 加一条上线 中间划线</span><br><span class="line"><span class="selector-tag">text-indent</span> <span class="selector-pseudo">:50px</span> 指定文本第一行的缩进。</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">font-family</span><span class="selector-pseudo">:"Times"</span> 设置字体</span><br><span class="line"><span class="selector-tag">font-style</span><span class="selector-pseudo">:normal(italic</span>倾斜)</span><br><span class="line"><span class="selector-tag">font-size</span><span class="selector-pseudo">:40px</span> 字体大小</span><br><span class="line"><span class="selector-tag">font-weight</span>:字体粗细</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:<span class="number">#000000</span>; <span class="attribute">text-decoration</span>:none;&#125;      <span class="comment">/* 未访问链接*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>:<span class="number">#00FF00</span>; <span class="attribute">text-decoration</span>:none&#125;  <span class="comment">/* 已访问链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#FF00FF</span>;<span class="attribute">text-decoration</span>:underline&#125;  <span class="comment">/* 鼠标移动链接上*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>:<span class="number">#0000FF</span>;&#125;  <span class="comment">/* 鼠标点击时 */</span></span><br><span class="line"></span><br><span class="line">ul.a &#123;list-style-type: circle;&#125;//list-style-type</span><br><span class="line">ul.b &#123;list-style-type: square;&#125;//属性指定列表项标记的</span><br><span class="line">ol.c &#123;list-style-type: upper-roman;&#125;//类型</span><br><span class="line"><span class="selector-tag">ol</span><span class="selector-class">.d</span> &#123;<span class="attribute">list-style-type</span>: lower-alpha;&#125;</span><br><span class="line"><span class="selector-tag">border-collapse</span>：表格边框</span><br><span class="line">border-collapse:collapse; //表格的边框设置成单一的</span><br><span class="line"></span><br><span class="line">h1.hidden&#123;visibility:hidden;&#125;// 隐藏某个元素，但占据空间</span><br><span class="line">h1.hidden&#123;display:none;&#125;//隐藏且不占用空间</span><br></pre></td></tr></table></figure><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p><img src="http://blog-1252095801.cosgz.myqcloud.com/1008.png" alt="hezi"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">border-style:none//边框样式</span><br><span class="line">//dotted点线边框 dashed 虚线边框 solid 实线边框 double两个边框 </span><br><span class="line">border-width:5px//边框宽度</span><br><span class="line">border-color:red //边框颜色</span><br><span class="line">单<span class="selector-tag">border-top-style</span><span class="selector-pseudo">:dotted</span>; </span><br><span class="line">独<span class="selector-tag">border-right-style</span><span class="selector-pseudo">:solid</span>;</span><br><span class="line">设<span class="selector-tag">border-bottom-style</span><span class="selector-pseudo">:dotted</span>;</span><br><span class="line">置<span class="selector-tag">border-left-style</span><span class="selector-pseudo">:solid</span>;</span><br><span class="line">轮廓（<span class="selector-tag">outline</span>）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。<span class="selector-tag">outline</span> 属性规定元素轮廓的样式、颜色和宽度。</span><br></pre></td></tr></table></figure><h3 id="块与内联元素"><a href="#块与内联元素" class="headerlink" title="块与内联元素"></a>块与内联元素</h3><p>块元素 h1 p div</p><p>内联元素  span a </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li &#123;display:inline;&#125; // 列表项变为内联元素。</span><br><span class="line">span &#123;display:block;&#125;// span元素作为块元素。</span><br></pre></td></tr></table></figure><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>position 属性指定了元素的定位类型。</p><p>position：static relative fixed absolute</p><p>static 是html 默认值，即没有定位，元素出现在正常的流中。静态定位的元素不会受到top,bottom,left,right 影响。</p><p>fixed 定位是相对于浏览器窗口的固定位置，即使窗口滚动也不移动。fixed定位的元素与文档流无关，因此不占据空间。会与其他元素重叠。</p><p>relative 定位是相对其正常的位置。与绝对定位不同的是，相对定位不会把该元素从原文档删除掉，而是在原文档的位置的基础上，移动一定的距离</p><p>absolute 定位是相对于最近的已定位父元素，若没有，就相对于html.设置了绝对定位的元素，相当于该元素被从原文档中删除了。</p><p>通过绝对定位可以把一个元素放在另一个元素上，这样位置就重复了。重复了，就存在一个谁掩盖谁的问题。 这个时候就可以使用z-index属性， 当z-index的值越大，就表示放上面，z-index:越小就表示放下面。</p><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>浮动会使元素向左或者向右浮动，周围元素也会重新排列。一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。浮动元素之后的元素将围绕它。浮动元素之前的元素将不会受到影响。</p><p>浮动后，原来的坑就让出来了。</p><p>文字向左浮动 首先，向左浮动后，会把“坑”让出来，这个时候”正常的文字4“ 就会过来试图占这个坑，但是，发现 “浮动的文字”并没有走，结果，就只好排在它后面了</p><p>默认的div排列是会换行的 如果使用float就可以达到水平排列的效果，通常会用在菜单，导航栏等地方 。如果超出了父容器，还会有自动换行的效果。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX</title>
      <link href="/2017/10/07/AJAX/"/>
      <url>/2017/10/07/AJAX/</url>
      
        <content type="html"><![CDATA[<p>AJAX 是Asynchronous JavaScript and XML 异步的JavaScript 和 XML. 是一种用于创建快速动态网页的技术，通过在后台与服务器进行少量数据交换，使网页实现异步更新。<br><a id="more"></a></p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="http://blog-1252095801.cosgz.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20171006152455.png" alt="ajax"></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;submit&quot; onclick=&quot;loadXMLDoc()&quot;&gt;change &lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function loadXMLDoc()</span><br><span class="line">&#123;</span><br><span class="line">  AJAX 执行</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="创建XMLHttpRequest-对象"><a href="#创建XMLHttpRequest-对象" class="headerlink" title="创建XMLHttpRequest 对象"></a>创建XMLHttpRequest 对象</h4><p>XMLHttpRequest 是Ajax的基础</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// IE6, IE5 浏览器执行代码</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h4><p>XMLHttpRequest 对象用于和服务器交换数据</p><p>如需将请求发送到服务器，使用XMLHttpRequest对象的open() 和 send() 方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open("GET","ajax_info.txt",true);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">//open(method,url,async) method 是请求的类型，url 是文件在服务器上的位置 async true为异步，false 是同步。</span><br><span class="line">//send(string)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">loadXMLDoc</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> xmlhttp;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span></span><br><span class="line"><span class="javascript">    xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">else</span></span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// IE6, IE5 浏览器执行代码</span></span></span><br><span class="line"><span class="javascript">    xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=xmlhttp.responseText;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  xmlhttp.open(<span class="string">"POST"</span>,<span class="string">"/try/ajax/demo_post.php"</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="undefined">  xmlhttp.send();</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>AJAX<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"loadXMLDoc()"</span>&gt;</span>请求数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="jQuery-Ajax"><a href="#jQuery-Ajax" class="headerlink" title="jQuery Ajax"></a>jQuery Ajax</h3><p>jQuery在全局对象jQuery(也就是$)绑定了ajax()函数,可以处理AJAX请求, ajax(url, settings)函数需要接收一个URL和一个可选的settings对象.常用选项如下:</p><ul><li>async：是否异步执行AJAX请求，默认为<code>true</code>，千万不要指定为<code>false</code>；</li><li>method：发送的Method，缺省为<code>&#39;GET&#39;</code>，可指定为<code>&#39;POST&#39;</code>、<code>&#39;PUT&#39;</code>等；</li><li>contentType：发送POST请求的格式，默认值为<code>&#39;application/x-www-form-urlencoded; charset=UTF-8&#39;</code>，也可以指定为<code>text/plain</code>、<code>application/json</code>；</li><li>data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据contentType把data序列化成合适的格式；</li><li>headers：发送的额外的HTTP头，必须是一个object；</li><li>dataType：接收的数据格式，可以指定为<code>&#39;html&#39;</code>、<code>&#39;xml&#39;</code>、<code>&#39;json&#39;</code>、<code>&#39;text&#39;</code>等，缺省情况下根据响应的<code>Content-Type</code>猜测。</li></ul><p>下面的例子发送一个GET请求,并返回一个JSON格式的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.ajax(<span class="string">'/wkn'</span>,&#123;</span><br><span class="line">    dataType:<span class="string">'json'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="jQuery-load-是强大的AJAX方法"><a href="#jQuery-load-是强大的AJAX方法" class="headerlink" title="jQuery load() 是强大的AJAX方法,"></a>jQuery load() 是强大的AJAX方法,</h5><p>load()方法从服务器加载数据,并把返回的数据放入被选元素中.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).load(URL,data,callback);</span><br></pre></td></tr></table></figure><p>必需的 <em>URL</em> 参数规定您希望加载的 URL。</p><p>可选的 <em>data</em> 参数规定与请求一同发送的查询字符串键/值对集合。</p><p>可选的 <em>callback</em> 参数是 load() 方法完成后所执行的函数名称。</p><h5 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h5><p>$.get(<em>URL</em>,<em>callback</em>);</p><p>必需的 <em>URL</em> 参数规定您希望请求的 URL。</p><p>可选的 <em>callback</em> 参数是请求成功后所执行的函数名。</p><h5 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h5><p>$.post() 方法通过 HTTP POST 请求从服务器上请求数据。</p><p><strong>语法:</strong></p><p>$.post(<em>URL,data,callback</em>);</p><p>必需的 <em>URL</em> 参数规定您希望请求的 URL。</p><p>可选的 <em>data</em> 参数规定连同请求发送的数据。</p><p>可选的 <em>callback</em> 参数是请求成功后所执行的函数名。</p><h5 id="getJSON"><a href="#getJSON" class="headerlink" title="getJSON"></a>getJSON</h5><p>$(<em>selector</em>).getJSON(<em>url,data,success(data,status,xhr))</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $.getJSON(<span class="string">"demo_ajax_json.js"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">            $.each(result, <span class="function"><span class="keyword">function</span>(<span class="params">i, field</span>)</span>&#123;</span><br><span class="line">                $(<span class="string">"div"</span>).append(field + <span class="string">" "</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript总结</title>
      <link href="/2017/10/06/JS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2017/10/06/JS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>number</li></ul><p>不区分整数和浮点数,统一用number (NaN表示not a number,Infinity 表示无限大)</p><ul><li>字符串</li></ul><a id="more"></a><p>单引号或者双引号括起来的任意文本,如果有单引号和双引号可以用\来转义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模板字符串</span><br><span class="line"><span class="keyword">var</span> name =<span class="string">'小明'</span> </span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`hello,<span class="subst">$&#123;name&#125;</span>.`</span>  反点号用来表示多行字符串</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">操作字符串</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"hello,world"</span> </span><br><span class="line">s.length; <span class="comment">//13</span></span><br><span class="line">indexOf函数会搜索指定字符串出现的位置 .substring()返回指定索引区间的子串.</span><br></pre></td></tr></table></figure><ul><li>布尔值</li><li>null和undefined</li></ul><p>null表示空,undefined表示未定义</p><ul><li>数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">'Hello'</span>, <span class="literal">null</span>,<span class="literal">true</span>]</span><br><span class="line"><span class="comment">//(不建议)或者用Array()函数创建数组    new Array(1,2,3);</span></span><br><span class="line">数组用索引来访问</span><br><span class="line">常见方法有indexOf(),slice(截取部分元素),push(末尾添加元素),pop(删除最后一个元素),sort(排序),reverse(反转)</span><br></pre></td></tr></table></figure><ul><li>对象</li></ul><p>键值对组成的无序集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ｐｅｒｓｏｎ=</span><br><span class="line">&#123;</span><br><span class="line">    name:<span class="string">'Wkn'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  tags: [<span class="string">'NLP'</span>,<span class="string">'Java'</span>,<span class="string">'Python'</span>],</span><br><span class="line">  city：　<span class="string">'Beijing'</span>,</span><br><span class="line">  zipＣｏｄｅ: <span class="literal">null</span>,</span><br><span class="line">  hasgirlfriend:<span class="literal">false</span></span><br><span class="line">  <span class="comment">//如果包含特殊字符,用引号括起来</span></span><br><span class="line">  <span class="string">'school'</span>:<span class="string">'eighteen school'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要获取对象的属性，用对象变量.属性名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.name <span class="comment">//'wkn'</span></span><br><span class="line">person[<span class="string">'school'</span>]<span class="comment">// 'eighteen school'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用<span class="keyword">in</span>判断一个属性是否存在</span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> person; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>变量</li></ul><p>申请一个变量用 var语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b =<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>使用var申明的变量不是全局变量,它的范围被限制在该变量被申明的函数体中.</p><h4 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h4><p>Map是一组键值对的结构，具有极快的查找速度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'w'</span>,<span class="number">95</span>],[<span class="string">'b'</span>,<span class="number">1</span>],[<span class="string">'t'</span>,<span class="number">5</span>]]);</span><br><span class="line">m.get(<span class="string">'w'</span>) <span class="comment">//95</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">'Bob'</span>, <span class="number">59</span>);</span><br><span class="line">m.has(<span class="string">'Adam'</span>); <span class="comment">// 是否存在key 'Adam': true</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>); <span class="comment">// 删除key 'Adam'</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>Set是一组key的集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 =<span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s.delete(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h4><p>遍历<code>Array</code>可以采用下标循环，遍历<code>Map</code>和<code>Set</code>就无法使用下标。为了统一集合类型，ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。</p><p>具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abs(<span class="number">10</span>) <span class="comment">//返回10</span></span><br></pre></td></tr></table></figure><h5 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h5><p>它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。<code>arguments</code>类似<code>Array</code>但它不是一个<code>Array</code>：利用<code>arguments</code>，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line">abs(); <span class="comment">// 0</span></span><br><span class="line">abs(<span class="number">10</span>); <span class="comment">// 10</span></span><br><span class="line">abs(<span class="number">-9</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>不在任何函数内定义的变量就具有全局作用域,实际上,Javascript默认有一个全局对象window,全局作用域的变量实际上被绑定到window的一个属性</p><p>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量：</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person =</span><br><span class="line">&#123;</span><br><span class="line">    name:<span class="string">'wkn'</span>,</span><br><span class="line">  a:<span class="number">22</span>,</span><br><span class="line">  age: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y =<span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">      <span class="keyword">return</span> y -<span class="keyword">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个<code>this</code>关键字.在一个方法内部，<code>this</code>是一个特殊变量，它始终指向当前对象，也就是<code>person</code>这个变量。所以，<code>this.a</code>可以拿到<code>xiaoming</code>的<code>a</code>属性。</p><h3 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h3><h5 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h5><p>Date 对象用来表示日期和时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure><p>创建一个指定日期和时间的Date对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">123</span>);</span><br><span class="line">d; <span class="comment">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure><h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><p>在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。</p><p>序列化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person =</span><br><span class="line">    &#123;</span><br><span class="line">        name:<span class="string">'wkn'</span>,</span><br><span class="line">      age:<span class="number">14</span>,</span><br><span class="line">      gender:<span class="string">'nan'</span>,</span><br><span class="line">      height:<span class="number">1.75</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> s =<span class="built_in">JSON</span>.stringify(person);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line">要输出好看一些,带上一些参数</span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, <span class="literal">null</span>, <span class="string">'  '</span>);</span><br></pre></td></tr></table></figure><p>反序列化</p><p>拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'[1,2,3,true]'</span>); <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>); <span class="comment">// Object &#123;name: '小明', age: 14&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'true'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'123.45'</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><p><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">'Robot'</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is running...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.__proto__ = Student;</span><br></pre></td></tr></table></figure><p>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</p><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。当我们用<code>obj.xxx</code>访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到<code>Object.prototype</code>对象，最后，如果还没有找到，就只能返回<code>undefined</code>。</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><h4 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h4><ul><li>window</li></ul><p>window对象不但充当全局作用域,还表示浏览器窗口.</p><ul><li>navigator</li></ul><p>navigator对象表示浏览器的信息.</p><ul><li>screen </li></ul><p>screen 对象表示屏幕的信息.</p><ul><li>location</li></ul><p>location 对象表示当前页面的URL信息</p><ul><li>document</li></ul><p>document对象表示当前页面.用<code>document</code>对象提供的<code>getElementById()</code>和<code>getElementsByTagName()</code>可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点.</p><p><strong>document 对象还有一个cookie属性,可以获取当前页面的cookie </strong>通过docement.cookie读取当前页的cookie</p><ul><li>history</li></ul><p>history 对象保存了浏览器的历史记录,JavaScript可以调用history对象的back()或者forward(),相当于用户点击了后退或者前进.</p><h4 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h4><p>首先拿到节点,最常用的方法就是<code>document.getElementById()和documment.getElementsByTagName()</code>以及CSS选择器<code>document.getElementByClassName()</code>.</p><h5 id="更新DOM"><a href="#更新DOM" class="headerlink" title="更新DOM"></a>更新DOM</h5><p>一种是修改<code>innerHTML</code>属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树,第二种是修改<code>innerText</code>或<code>textContent</code>属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签.</p><p>还可以设置CSS </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置CSS:</span></span><br><span class="line">p.style.color = <span class="string">'#ff0000'</span>;</span><br><span class="line">p.style.fontSize = <span class="string">'20px'</span>;</span><br><span class="line">p.style.paddingTop = <span class="string">'2em'</span>;</span><br></pre></td></tr></table></figure><h4 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h4><p>HTML表单的输入控件主要有以下几种：</p><ul><li>文本框，对应的<code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li><li>口令框，对应的<code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li><li>单选框，对应的<code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li><li>复选框，对应的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li><li>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</li><li>隐藏文本，对应的<code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li></ul><p>如果我们获得了一个<code>&lt;input&gt;</code>节点的引用，就可以直接调用<code>value</code>获得对应的用户输入值.</p><p>这种方式可以应用于<code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>。但是，对于单选框和复选框，<code>value</code>属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用<code>checked</code>判断.</p><h4 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h4><p>js两种方式提交表单,方式一是通过<code>&lt;form&gt;</code>元素的<code>submit()</code>方法提交一个表单，例如，响应一个<code>&lt;button&gt;</code>的<code>click</code>事件，在JavaScript代码中提交表单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=<span class="string">"test-form"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"test"</span>&gt;</span><br><span class="line">    &lt;button type=<span class="string">"button"</span> onclick=<span class="string">"doSubmitForm()"</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</span><br><span class="line">    <span class="comment">// 可以在此修改form的input...</span></span><br><span class="line">    <span class="comment">// 提交form:</span></span><br><span class="line">    form.submit();</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击<code>&lt;button type=&quot;submit&quot;&gt;</code>时提交表单，或者用户在最后一个输入框按回车键。</p><p>因此，第二种方式是响应<code>&lt;form&gt;</code>本身的<code>onsubmit</code>事件，在提交form时作修改.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=<span class="string">"test-form"</span> onsubmit=<span class="string">"return checkForm()"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"test"</span>&gt;</span><br><span class="line">    &lt;button type=<span class="string">"submit"</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</span><br><span class="line">    <span class="comment">// 可以在此修改form的input...</span></span><br><span class="line">    <span class="comment">// 继续下一步:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2017/10/05/js/"/>
      <url>/2017/10/05/js/</url>
      
        <content type="html"><![CDATA[<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x =<span class="number">1</span>; <span class="comment">// 赋值语句</span></span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><ul><li><p>number</p></li><li><p>字符串</p></li><li><p>布尔值（始终坚持使用===运算符）</p></li><li><p>null 和 undefined</p></li><li><p>数组 [1, 2, 3.14, ‘hello’, null, true];</p></li><li><p>对象 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = </span><br><span class="line">    &#123;</span><br><span class="line">  name:<span class="string">'wkn'</span>,</span><br><span class="line">      age:<span class="number">22</span>,</span><br><span class="line">      tags:[<span class="string">'java'</span>,<span class="string">'python'</span>,<span class="string">'javascript'</span>],</span><br><span class="line">      city:<span class="string">'guangzhou'</span>,</span><br><span class="line">      <span class="string">'has-girlfriend'</span>:<span class="literal">false</span>,<span class="comment">//有特殊字符要圈起来</span></span><br><span class="line">      zipcode:<span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取时使用 person.name //wkn</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>用单引号或者双引号引起来的。如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\</code>来标识。</p><p>多行字符串可以用反引号引起来 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"hello javascript"</span>;</span><br><span class="line">s.length=<span class="number">20</span>;</span><br><span class="line">s[<span class="number">0</span>]=<span class="string">'h'</span>;</span><br><span class="line">s.toUpperCase() = <span class="string">"HELLO JAVASCRIPT"</span>  s.toLowerCase()</span><br><span class="line">s.substring(<span class="number">0</span>,<span class="number">4</span>) = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">'Hello'</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br><span class="line">arr.length; <span class="comment">// 6</span></span><br><span class="line"><span class="comment">//push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉</span></span><br></pre></td></tr></table></figure><h5 id="Map-和-Set"><a href="#Map-和-Set" class="headerlink" title="Map 和 Set"></a>Map 和 Set</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Tracy'</span>, <span class="number">85</span>]]);</span><br><span class="line">m.get(<span class="string">'Michael'</span>); <span class="comment">// 95</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">'Bob'</span>, <span class="number">59</span>);</span><br><span class="line">m.has(<span class="string">'Adam'</span>); <span class="comment">// 是否存在key 'Adam': true</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>); <span class="comment">// 删除key 'Adam'</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'3'</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, "3"&#125;</span></span><br></pre></td></tr></table></figure><h5 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h5><p>ES6 引入新的iterable 类型，Array,map,set 都属于iterable 类型。具有iterable 类型的集合可以用for of 循环来遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123; <span class="comment">// 遍历Array</span></span><br><span class="line">    alert(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历Set</span></span><br><span class="line">    alert(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123; <span class="comment">// 遍历Map</span></span><br><span class="line">    alert(x[<span class="number">0</span>] + <span class="string">'='</span> + x[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数。</p><h5 id="argument-and-rest"><a href="#argument-and-rest" class="headerlink" title="argument and rest"></a>argument and rest</h5><p>JavaScript还有一个免费赠送的关键字<code>arguments</code>，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。<code>arguments</code>类似<code>Array</code>但它不是一个Array</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    alert(x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        alert(<span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">//为了获得剩下的参数，使用rest 关键字。rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest。</span></span><br></pre></td></tr></table></figure><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>由于JavaScript的变量作用域实际上是函数内部，我们在<code>for</code>循环等语句块中是无法定义具有局部作用域的变量的。为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量。</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// function xiaoming.age().</span></span><br><span class="line">xiaoming.age(); <span class="comment">// 今年调用是25,明年调用就变成26了.</span></span><br></pre></td></tr></table></figure><h3 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h3><h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><p>序列化（将对象转化为JSON 字符串）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'middle-school'</span>: <span class="string">'\"W3C\" Middle School'</span>,</span><br><span class="line">    skills: [<span class="string">'JavaScript'</span>, <span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Lisp'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming); <span class="comment">// '&#123;"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]&#125;'</span></span><br><span class="line"><span class="comment">//调整下格式。</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, <span class="literal">null</span>, <span class="string">'  '</span>);</span><br></pre></td></tr></table></figure><p>反序列化</p><p>JSON 字符串变成js 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'[1,2,3,true]'</span>); <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>); <span class="comment">// Object &#123;name: '小明', age: 14&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'true'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'123.45'</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><h5 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h5><p>window对象不仅充当全局作用域，还标识浏览器窗口。<code>window</code>对象有<code>innerWidth</code>和<code>innerHeight</code>属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。还有一个<code>outerWidth</code>和<code>outerHeight</code>属性，可以获取浏览器窗口的整个宽高。</p><h5 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h5><p><code>navigator</code>对象表示浏览器的信息，最常用的属性包括：</p><ul><li>navigator.appName：浏览器名称；</li><li>navigator.appVersion：浏览器版本；</li><li>navigator.language：浏览器设置的语言；</li><li>navigator.platform：操作系统类型；</li><li>navigator.userAgent：浏览器设定的<code>User-Agent</code>字符串。</li></ul><h5 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h5><p><code>screen</code>对象表示屏幕的信息，常用的属性有：</p><ul><li>screen.width：屏幕宽度，以像素为单位；</li><li>screen.height：屏幕高度，以像素为单位；</li><li>screen.colorDepth：返回颜色位数，如8、16、24。</li></ul><h5 id="location"><a href="#location" class="headerlink" title="location"></a>location</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location.protocol; // &apos;http&apos;</span><br><span class="line">location.host; // &apos;www.example.com&apos;</span><br><span class="line">location.port; // &apos;8080&apos;</span><br><span class="line">location.pathname; // &apos;/path/index.html&apos;</span><br><span class="line">location.search; // &apos;?a=1&amp;b=2&apos;</span><br><span class="line">location.hash; // &apos;TOP&apos;</span><br></pre></td></tr></table></figure><h5 id="document"><a href="#document" class="headerlink" title="document"></a>document</h5><p><code>document</code>对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，<code>document</code>对象就是整个DOM树的根节点。</p><p><code>document</code>的<code>title</code>属性是从HTML文档中的<code>&lt;title&gt;xxx&lt;/title&gt;</code>读取的，但是可以动态改变。</p><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p><code>document</code>对象还有一个<code>cookie</code>属性，可以获取当前页面的Cookie。</p><h4 id="操作dom"><a href="#操作dom" class="headerlink" title="操作dom"></a>操作dom</h4><p>HTML 文档被浏览器解析后就是一颗DOM树。操作ＤＯＭ 节点实际上就是更新，遍历，添加，删除的操作。</p><p>在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是<code>document.getElementById()</code>（返回一个结点）和<code>document.getElementsByTagName()</code>（返回一组），以及CSS选择器<code>document.getElementsByClassName()</code>（返回一组）。</p><h4 id="更新DOM"><a href="#更新DOM" class="headerlink" title="更新DOM"></a>更新DOM</h4><p>修改内容1.修改innerHTML 属性 2.修改innerText 或者textContext属性。</p><p>修改css: DOM节点的<code>style</code>属性对应所有的CSS，可以直接获取或设置。因为CSS允许<code>font-size</code>这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名<code>fontSize</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置CSS:</span></span><br><span class="line">p.style.color = <span class="string">'#ff0000'</span>;</span><br><span class="line">p.style.fontSize = <span class="string">'20px'</span>;</span><br><span class="line">p.style.paddingTop = <span class="string">'2em'</span>;</span><br></pre></td></tr></table></figure><h4 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h4><p>1如果这个DOM节点是空的，例如，<code>&lt;div&gt;&lt;/div&gt;</code>，那么，直接使用<code>innerHTML = &#39;&lt;span&gt;child&lt;/span&gt;&#39;</code>就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。</p><p>2.非空 </p><p>（1） 使用 appendChild</p><p>  (2) 如果我们要把子节点插入到指定的位置怎么办？可以使用<code>parentElement.insertBefore(newElement, referenceElement);</code>，子节点会插入到<code>referenceElement</code>之前。</p><h4 id="删除DOM"><a href="#删除DOM" class="headerlink" title="删除DOM"></a>删除DOM</h4><p>要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的<code>removeChild</code>把自己删掉.</p><h3 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">文本框，对应的<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span>，用于输入文本；</span><br><span class="line"></span><br><span class="line">口令框，对应的<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span>，用于输入口令；</span><br><span class="line"></span><br><span class="line">单选框，对应的<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span>&gt;</span>，用于选择一项；</span><br><span class="line"></span><br><span class="line">复选框，对应的<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span>，用于选择多项；</span><br><span class="line"></span><br><span class="line">下拉框，对应的<span class="tag">&lt;<span class="name">select</span>&gt;</span>，用于选择一项；</span><br><span class="line"></span><br><span class="line">隐藏文本，对应的<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span>&gt;</span>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</span><br></pre></td></tr></table></figure><h4 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h4><p>如果获取了一个input结点的引用，直接调用value 获取对应用户输入值。这种方式可以应用于<code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>。但是，对于单选框和复选框，<code>value</code>属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用<code>checked</code>判断。</p><h4 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h4><ul><li><p>通过<form> 元素的submit（）方法提交一个表单，例如相应一个<button> 的click事件， 在js代码中提交表单。</button></form></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test-form"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"doSubmitForm()"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 提交form:</span></span></span><br><span class="line"><span class="undefined">    form.submit();</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>相应<form> 本身的onsubmit事件，在提交form 时作修改：</form></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test-form"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = <span class="string">'Error code: '</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 新建XMLHttpRequest对象</span></span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果:</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求:</span></span><br><span class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">'请求已发送，请等待响应...'</span>);</span><br></pre></td></tr></table></figure><p>当创建了<code>XMLHttpRequest</code>对象后，要先设置<code>onreadystatechange</code>的回调函数。在回调函数中，通常我们只需通过<code>readyState === 4</code>判断请求是否完成，如果已完成，再根据<code>status === 200</code>判断是否是一个成功的响应。</p><p><code>XMLHttpRequest</code>对象的<code>open()</code>方法有3个参数，第一个参数指定是<code>GET</code>还是<code>POST</code>，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是<code>true</code>，所以不用写.</p><p>最后调用<code>send()</code>方法才真正发送请求。<code>GET</code>请求不需要参数，<code>POST</code>请求需要把body部分以字符串或者<code>FormData</code>对象传进去。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP EL JSTL</title>
      <link href="/2017/10/03/jsp%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2017/10/03/jsp%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;jsp&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    out.println(<span class="string">"hello,world"</span>);</span><br><span class="line">    %&gt;</span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="jsp-处理"><a href="#jsp-处理" class="headerlink" title="jsp 处理"></a>jsp 处理</h4><a id="more"></a><ul><li>浏览器发送HTTP请求给服务器</li><li>服务器识别出这是对JSP的请求，并将该请求传递给JSP引擎，</li><li>JSP引擎从磁盘载入JSP文件，然后将他们转换为Servlet。</li><li>JSP引擎将servlet编译成可执行类，并且将原始请求传递给Servlet引擎。</li><li>Web 服务器的某组件将会调用 Servlet 引擎，然后载入并执行 Servlet 类。在执行过程中，Servlet 产生 HTML 格式的输出并将其内嵌于 HTTP response 中上交给 Web 服务器。</li><li><p>Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中。</p><!-- more--><h4 id="JSP-生命周期"><a href="#JSP-生命周期" class="headerlink" title="JSP 生命周期"></a>JSP 生命周期</h4></li><li><p><strong>编译阶段：</strong></p><p>servlet容器编译servlet源文件，生成servlet类</p></li><li><p>初始化阶段：</p><p>加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</p></li><li><p>执行阶段：</p><p>调用与JSP对应的servlet实例的服务方法</p></li><li><p>销毁阶段：</p><p>调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</p></li></ul><h4 id="属性范围"><a href="#属性范围" class="headerlink" title="属性范围"></a>属性范围</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">page： 只在一个页面中保存属性，跳转之后无效。</span><br><span class="line">request： 只在一次请求中保存，服务器跳转后依然有效。（地址没变就是一次请求）</span><br><span class="line">session： 在一次会话范围内， 无论何种跳转都可以使用，但是新开浏览器就无法使用了。</span><br><span class="line">application： 在整个服务器上保存，所有用户都可以使用。</span><br></pre></td></tr></table></figure><h4 id="JSP-语法"><a href="#JSP-语法" class="headerlink" title="JSP 语法"></a>JSP 语法</h4><p>脚本程序的语法格式&lt;% 代码片段 %&gt;</p><p>如果要正常显示中文，在JSP 文件头添加</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html"</span>; charset=UTF-<span class="number">8</span> pageCoding=<span class="string">"UTF-8"</span>%&gt;</span><br></pre></td></tr></table></figure><h4 id="JSP-声明"><a href="#JSP-声明" class="headerlink" title="JSP 声明"></a>JSP 声明</h4><p>一个声明语句可以声明一个或者多个变量方法，供后面Java代码使用</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! declaration; [ declaration; ]+ ... %&gt;</span><br><span class="line">&lt;%! <span class="keyword">int</span> i=<span class="number">0</span>;%&gt;</span><br><span class="line">&lt;%! Book book = <span class="keyword">new</span> Book(); %&gt;</span><br></pre></td></tr></table></figure><h4 id="JSP-表达式"><a href="#JSP-表达式" class="headerlink" title="JSP 表达式"></a>JSP 表达式</h4><p>JSP的表达式先被转化为String, 然后插入到表达式出现的地方 不用分号结束表式。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= 表达式%&gt;</span><br><span class="line">&lt;%= (<span class="keyword">new</span> java.util.Date()).toString()%&gt;</span><br></pre></td></tr></table></figure><h4 id="JSP注释"><a href="#JSP注释" class="headerlink" title="JSP注释"></a>JSP注释</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--zhushi--%&gt;</span><br></pre></td></tr></table></figure><h4 id="JSP-指令"><a href="#JSP-指令" class="headerlink" title="JSP 指令"></a>JSP 指令</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ directive attribute=<span class="string">"value"</span>%&gt;</span><br><span class="line">&lt;%@ page attribute=<span class="string">"value"</span> %&gt;</span><br><span class="line">&lt;%@ include file=<span class="string">"文件相对 url 地址"</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">"uri"</span> prefix=<span class="string">"prefixOfTag"</span> %&gt;<span class="comment">//URI确定标签库位置，prefix确定标签库前缀。</span></span><br></pre></td></tr></table></figure><h4 id="JSP-行为"><a href="#JSP-行为" class="headerlink" title="JSP 行为"></a>JSP 行为</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:action_name attribute=<span class="string">"value"</span> /&gt;</span><br></pre></td></tr></table></figure><h4 id="JSP-隐藏对象"><a href="#JSP-隐藏对象" class="headerlink" title="JSP 隐藏对象"></a>JSP 隐藏对象</h4><p>七大对象</p><p>Request Response Out Session Application Config PageContext Page Exception</p><h4 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h4><p>(<em>M</em>ultipurpose <em>I</em>nternet <em>M</em>ail <em>E</em>xtensions) 是描述消息内容类型的因特网标准。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。</p><h4 id="JSP-标准标签库-（JSTL）和EL表达式"><a href="#JSP-标准标签库-（JSTL）和EL表达式" class="headerlink" title="JSP 标准标签库 （JSTL）和EL表达式"></a>JSP 标准标签库 （JSTL）和EL表达式</h4><p>EL(Expression Language) 表示式语言</p><h5 id="EL表达式的主要作用"><a href="#EL表达式的主要作用" class="headerlink" title="EL表达式的主要作用"></a>EL表达式的主要作用</h5><ul><li><strong>获取数据</strong> 。EL 表达式主要用于替换JSP页面的脚本表达式，以从各种类型WEB作用域中检索Java对象，获取数据</li><li><em>执行运算</em>。利用EL 表达式进行基本的关系运算，逻辑运算 ，算术运算。</li><li>获取WEB 开发常用对 。EL 表达式定义了一些隐式对象。</li></ul><p>EL表达式以${ }定义 结构如下</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;expression&#125;         $&#123;x+y&#125;</span><br></pre></td></tr></table></figure><p>EL 表达式可以返回任意类型的值，如果返回一个带属性的值，用 .  或者 [ ] 访问其属性。如果 class.propertyName 的propertyname不是Java变量名，则只能使用[]运算符。要访问HTTPSession 可以 /获取HTTpsession的Id</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContext.session&#125;   $&#123;pageContext.session.id&#125;</span><br></pre></td></tr></table></figure><h5 id="EL表达式运算符"><a href="#EL表达式运算符" class="headerlink" title="EL表达式运算符"></a>EL表达式运算符</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ - * / % &amp;&amp;和and ||和or !和not == != &gt;= &lt;= &lt; &gt;  </span><br><span class="line">关系运算符返回<span class="keyword">boolean</span> 值 $&#123;<span class="number">1</span>==<span class="number">2</span>&#125; 返回<span class="keyword">false</span> </span><br><span class="line">$&#123;statement ?A:B&#125; 正确A 错误B</span><br><span class="line">empty 用来检测作用域中该变量是否存在， 例：$&#123;empty  username&#125;</span><br></pre></td></tr></table></figure><h5 id="EL的11个隐式对象"><a href="#EL的11个隐式对象" class="headerlink" title="EL的11个隐式对象"></a>EL的11个隐式对象</h5><ul><li>pageContext JSp的上下文对象</li><li>param 一个包含所有请求参数并用参数名做key的map  ${param.name} 取出参数</li><li>paramValues一个包含所有请求参数并用参数名做key的map 检索一个字符串数组而不是单个的值</li><li>header 包含请求标题 并用标题名做key 的map</li><li>headerValues 包含请求标题 并用标题名做key 的map 是个数组</li><li>cookie 包含当前请求对象cookie对象的map</li><li>initparam 包含所有环境初始化参数</li><li>pagescope map 包含页面域内所有属性</li><li>requestscope map 包含请求域内所有属性</li><li>Sessionscope map 包含会话域内所有属性</li><li>applicationscope map 包含应用程序上下文域内的所有属性</li></ul><h5 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h5><p>有五个类别，分别是 核心标签（包含web常见工作，循环，输入输出等），格式化标签（语言区域，消息，数字，日期格式化），SQL 标签（访问数据库），XML标签（访问xml文件），函数标签（集合长度 字符串操作）</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span>uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span>%&gt;</span><br></pre></td></tr></table></figure><p>通过上述方式引入标签</p><h5 id="Core-标签库"><a href="#Core-标签库" class="headerlink" title="Core 标签库"></a>Core 标签库</h5><p>14个标签被分成4类</p><ul><li>多用途核心标签 &lt;c:out&gt; &lt;c:set&gt; &lt;c:remove&gt; &lt;c:catch&gt; </li><li>条件控制标签 &lt;c:if&gt; &lt;c:choose&gt;&lt;c:when&gt; &lt;c:otherwise&gt;</li><li>循环控制标签 &lt;c:foreach&gt; &lt;c:fortokens&gt;</li><li>URL相关标签 &lt;c:import&gt; &lt;c:url&gt;&lt;c:redirect&gt;&lt;c:param&gt;</li></ul><p>#####&lt;c:out&gt; 用于显示数据</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:out value=$&#123;sessionScope.username&#125; <span class="keyword">default</span>=<span class="string">"游客"</span>&gt;</span><br></pre></td></tr></table></figure><p>&lt;c:set&gt; 为变量赋值</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var 表示创建的变量名 </span><br><span class="line">&lt;c:set var=<span class="string">"username"</span> value=<span class="string">"wkn"</span> scope=<span class="string">"page"</span>/&gt;</span><br><span class="line">target 要被赋值的javabean实例名称 property javabean  属性名称</span><br><span class="line">&lt;c:set target=$&#123;pagescope.user&#125; property=<span class="string">"username"</span> value=<span class="string">"w"</span>&gt;</span><br></pre></td></tr></table></figure><p>&lt;c:remove&gt; 删除scope中的值</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:remove var=<span class="string">"username"</span> scopre=<span class="string">"page"</span>/&gt;</span><br></pre></td></tr></table></figure><p>&lt;c:if&gt; 对条件进行测试</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test 判断条件 var 保存判断结果的变量名为<span class="keyword">true</span>或者<span class="keyword">false</span> scope 范围</span><br><span class="line">&lt;c:<span class="keyword">if</span>  test=<span class="string">"$&#123;param.loginmae=='wkn'&amp;&amp; param.pass=='123'&#125;"</span>&gt;</span><br><span class="line">  成功</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><p>&lt;c:choose&gt;     &lt;c:when&gt;     &lt;c:otherwise&gt;</p><p>复杂的判断条件用上面三个 choose只作为父标签存在，另外两个是子标签</p><p>when标签等价于if标签</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">  &lt;c:when test=<span class="string">"$&#123;param.loignname==‘w’&#125;"</span>&gt;</span><br><span class="line">    success</span><br><span class="line">  &lt;/c:when&gt;</span><br><span class="line">  &lt;c:otherwise&gt;</span><br><span class="line">    fail</span><br><span class="line">  &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure><p>&lt;c:foreach&gt; 循环控制</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">begin 开始条件 end 结束条件  step 步长 items集合的遍历对象</span><br><span class="line">var 循环集合中元素的变量名 </span><br><span class="line">varstatus=<span class="string">'status'</span> 保持循环状态的变量  (该绑定值封装了当前遍历的状态，比如，可以从该对象上查看是遍历到了第几个元素：$&#123;status.count&#125;</span><br><span class="line">$&#123;status.index&#125; 查看序列号$&#123;status.first&#125;返回bool(是否是首个)</span><br><span class="line"></span><br><span class="line">遍历list</span><br><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;c:foreach items=$&#123;requestscope.booklist&#125; var=<span class="string">"book"</span>&gt;</span><br><span class="line">    &lt;td&gt;$&#123;book&#125;&lt;/td&gt;</span><br><span class="line">    &lt;/c:foreach&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr&gt;&lt;td&gt;编号&lt;/td&gt;&lt;td&gt;名字&lt;/td&gt;&lt;td&gt;作者&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">    &lt;c:foreach items=$&#123;requestscope.booklist&#125; var=<span class="string">"book"</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt;&lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;&lt;td&gt;book.au&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/c:foreach&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr&gt;&lt;td&gt;key&lt;/td&gt;&lt;td&gt;编号&lt;/td&gt;&lt;td&gt;名字&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">    &lt;c:foreach items=$&#123;requestscope.bookmap&#125; var=<span class="string">"book"</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td&gt;$&#123;book.key&#125;&lt;/td&gt;&lt;td&gt;$&#123;book.value.id&#125;&lt;/td&gt;&lt;td&gt;book.value.name&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/c:foreach&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>&lt;c:fortokens&gt;使用分隔符分隔指定的字符串</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delims 分隔符</span><br><span class="line">&lt;c:fortokens items=<span class="string">"aa,bb,cc,dd"</span> delims=<span class="string">","</span> var=<span class="string">"s"</span>&gt;</span><br><span class="line">$&#123;s&#125;</span><br><span class="line">&lt;/c:fortokens&gt;</span><br></pre></td></tr></table></figure><p>&lt;c:import&gt;包含另一个标签</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">import</span> url=<span class="string">"title.jsp"</span>/&gt;</span><br></pre></td></tr></table></figure><p>c:url 组合一个正确的url地址</p><h5 id="核心标签"><a href="#核心标签" class="headerlink" title="核心标签"></a>核心标签</h5><p>是最常用的JSTL 标签， 引用核心标签库的语法如下</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:out&gt; 在JSP 中显示数据 &lt;c:set&gt; 用于保存数据 &lt;c:remove&gt; 删除数据</span><br><span class="line">&lt;c:<span class="keyword">catch</span>&gt;处理异常  &lt;c:<span class="keyword">import</span>&gt;检索URI,并传给页面&lt;c:forEach&gt; 基础迭代标签 &lt;c:param&gt;给包含或重定向的页面传递参数&lt;c:redirect&gt;重定向一个新的URL &lt;c:url&gt;使用可选参数创造一个URL</span><br></pre></td></tr></table></figure><h5 id="格式化标签"><a href="#格式化标签" class="headerlink" title="格式化标签"></a>格式化标签</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"fmt"</span> </span><br><span class="line">           uri=<span class="string">"http://java.sun.com/jsp/jstl/fmt"</span> %&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Static和 Final 关键字</title>
      <link href="/2017/10/02/Static%E5%92%8C-Final-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2017/10/02/Static%E5%92%8C-Final-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Static和-Final-关键字"><a href="#Static和-Final-关键字" class="headerlink" title="Static和 Final 关键字"></a>Static和 Final 关键字</h1><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Java中主要有三种，成员变量（实例变量，属性），本地变量（局部变量）类变量（静态属性）成员变量就是类或者对象中的属性，局部变量就是方法的形式参数以及在方法中定义的变量。类变量就是被static修饰的属性。</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final 可以声明成员变量，方法，类，以及本地变量，一旦将引用声明为final，就不能改变这个引用了，编译器会检查代码，如果试图将变量再次初始化的话，编译器会报编译错误。</p><h5 id="final-变量"><a href="#final-变量" class="headerlink" title="final 变量"></a>final 变量</h5><p>凡是对成员变量或者本地变量声明为final的都叫做final变量，final变量经常和static关键字一起使用，作为常量。</p><h5 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法"></a>final 方法</h5><p>final 声明的方法不能被子类的方法重写，如果你认为一个方法的功能已经足够完善了，子类中不需要改变的话，可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了。不需要运行时动态绑定。</p><h5 id="final-类"><a href="#final-类" class="headerlink" title="final 类"></a>final 类</h5><p>使用final 来修饰的类叫做final类，final 类不能被继承。Java中有许多类都是final的，比如String，Integer以及其他包装类等。</p><p>接口声明中所有变量本身是final的。</p><a id="more"></a><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>Java中不存在全局变量的概念，但是可以通过static实现一个伪全局的概念，Java中static表示全局或者静态的意思，用来修饰成员变量或者成员方法。也可以修饰代码块。</p><p>在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量或者成员方法在固定的位置开辟一个固定大小的内存区域，这样JVM就可以方便的进行访问static蕴含的静态表示是不可恢复的，修改了是不会变为原样的。</p><p>同时，static修饰的成员变量和成员方法被该类的所有实例共享。所有实例的引用都指向同一个地方。任何一个实例对其的修改都会导致其他实例的变化。</p><h3 id="static-final"><a href="#static-final" class="headerlink" title="static final"></a>static final</h3><p>static 修饰强调只有一个，final修饰的属性表明是一个常数，static final 修饰就表示一旦给值，就不可修改，并且可以通过类名访问。</p><p>final可以修饰：属性，方法，类，局部变量（方法中的变量）</p><p>​     final修饰的属性的初始化可以在编译期，也可以在运行期，初始化后不能被改变。</p><p>​     final修饰的属性跟具体对象有关，在运行期初始化的final属性，不同对象可以有不同的值。</p><p>​     final修饰的属性表明是一个常数（创建后不能被修改）。</p><p>​     final修饰的方法表示该方法在子类中不能被重写，final修饰的类表示该类不能被继承。</p><p>​     对于基本类型数据，final会将值变为一个常数（创建后不能被修改）；但是对于对象句柄（亦可称作引用或者指针），final会将句柄变为一个常数（进行声明时，必须将句柄初始化到一个具体的对象。而且不能再将句柄指向另一个对象。但是，对象的本身是可以修改的。这一限制也适用于数组，数组也属于对象，数组本身也是可以修改的。方法参数中的final句柄，意味着在该方法内部，我们不能改变参数句柄指向的实际东西，也就是说在方法内部不能给形参句柄再另外赋值）。</p><p>static可以修饰：属性，方法，代码段，内部类（静态内部类或嵌套内部类）</p><p>​     static修饰的属性的初始化在编译期（类加载的时候），初始化后能改变。</p><p>​     static修饰的属性所有对象都只有一个值。</p><p>​     static修饰的属性强调它们只有一个。</p><p>​     static修饰的属性、方法、代码段跟该类的具体对象无关，不创建对象也能调用static修饰的属性、方法等</p><p>​     static和“this、super”势不两立，static跟具体对象无关，而this、super正好跟具体对象有关。</p><p>​     static不可以修饰局部变量。</p><p>static final和final static没什么区别，一般static写在前面。</p><p>static修饰的属性强调它们只有一个，final修饰的属性表明是一个常数（创建后不能被修改）。static final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。</p><p>static final也可以修饰方法，表示该方法不能重写，可以在不new对象的情况下调用。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux程序安装</title>
      <link href="/2017/10/01/%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F/"/>
      <url>/2017/10/01/%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h1><h4 id="包管理基础"><a href="#包管理基础" class="headerlink" title="包管理基础"></a>包管理基础</h4><p>各种主流Linux发行版都采用了某种形式的包管理系统来控制软件和库的安装。包管理系统利用一个数据库来记录各种相关内容:</p><p>软件包存储在服务器上,可以利用本地Linux系统上的PMS工具通过互联网访问。这些服务器称为仓库(repository)。可以用PMS(包管理系统)工具来搜索新的软件包,或者是更新系统上已安装软件包。<br>软件包通常会依赖其他的包,为了前者能够正常运行,被依赖的包必须提前安装在系统中。PMS工具将会检测这些依赖关系,并在安装需要的包之前先安装好所有额外的软件包。</p><p>LInux中广泛使用的两种主要的PMS基础工具时dpkg 和 rpm.</p><a id="more"></a><p><strong>ubuntu使用的时dpkg 其他工具还有apt-get apt-cache aptitude</strong></p><p>命令行下使用aptitude 命令有助于避免常见的软件安装问题,如软件依赖关系缺失、系统环境不稳定及其他一些不必要的麻烦。本节将会介绍如何在命令行下使用aptitude命令工具。</p><p>直接输入命令aptitude进入包管理全屏界面。按q退出。</p><p>快速显示某个包的特定信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aptitude show packagename</span><br></pre></td></tr></table></figure><p>得到所有跟某个软件包相关的所有文件的列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -L packagename</span><br></pre></td></tr></table></figure><p>反向操作，查找某个特定文件属于哪个软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --search absolute_file_name  必须时决定路径</span><br></pre></td></tr></table></figure><p>####　安装软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aptitude search packagename</span><br></pre></td></tr></table></figure><p>search选项的妙处在于你无需在package_name周围加通配符。通配符会隐式添加。</p><p>在每个包名字前都有一个p或者i，如果看到一个i,说明这个包已经按到系统上了。</p><p>安装软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aptitude install package_name</span><br></pre></td></tr></table></figure><h4 id="更新软件"><a href="#更新软件" class="headerlink" title="更新软件"></a>更新软件</h4><p>尽管aptitude可以帮忙解决安装软件时遇到的问题,但解决有依赖关系的多个包的更新会比较烦琐。要用软件仓库中的新版本妥善地更新系统上所有的软件包,可用safe-upgrade选项。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更新所有软件包   aptitude safe-upgrade</span><br></pre></td></tr></table></figure><h4 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h4><p>要想只删除软件包而不删除数据和配置文件,可以使用aptitude的remove选项。要删除软件包和相关的数据和配置文件,可用purge选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo aptitude purge wine</span><br></pre></td></tr></table></figure><h3 id="apt-cache"><a href="#apt-cache" class="headerlink" title="apt-cache"></a>apt-cache</h3><p>1.apt-cache showpkg<br>显示软件包的一些常规信息<br>例: apt-cache showpkg openssh</p><p>2.apt-cache stats<br>显示相关的统计信息顯示相關的統計資訊</p><p>3.apt-cache dump<br>显示缓存中的每个软件包的简要描述信息</p><p>4.apt-cache unmet<br>显示不符合一致性的依赖关系</p><p>5.apt-cache show<br>显示指定软件包的记录信息。类似于rpm -qi</p><p>6.apt-cache search<br>查找软件包，类似于rpm -qa|grep package_name<br>例: apt-cache search openssh</p><p>7.apt-cache depends<br>显示软件包的依赖性关系<br>8.apt-cache pkgnames<br>列出所有的软件包</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件权限</title>
      <link href="/2017/10/01/Linux%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
      <url>/2017/10/01/Linux%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-文件权限"><a href="#Linux-文件权限" class="headerlink" title="Linux 文件权限"></a>Linux 文件权限</h1><h3 id="Linux安全性"><a href="#Linux安全性" class="headerlink" title="Linux安全性"></a>Linux安全性</h3><p>用户权限是通过创建用户时分配的用户ID(User ID,通常缩写为UID)来跟踪的。UID是数值,每个用户都有唯一的UID,但在登录系统时用的不是UID,而是登录名。登录名是用户用来登录系统的最长八字符的字符串(字符可以是数字或字母),同时会关联一个对应的密码。</p><p>/etc/passwd文件保存了登录用户名，密码，用户UID，组ID,账户文本描述等</p><p>现在密码都单独保存在/etc/shadow中。</p><a id="more"></a><h4 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> useradd -m wkn  //创建账户wkn。m是根据模板创建新用户的home目录。</span><br></pre></td></tr></table></figure><h4 id="删除新用户"><a href="#删除新用户" class="headerlink" title="删除新用户"></a>删除新用户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> userdel -r wkn //删除账户wkn.home目录也一并删除。</span><br></pre></td></tr></table></figure><p>####　修改账户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod  passwd  chpasswd chage chfn chsh</span><br></pre></td></tr></table></figure><h3 id="使用用户组"><a href="#使用用户组" class="headerlink" title="使用用户组"></a>使用用户组</h3><p>每个组都有唯一的GID——跟UID类似,在系统上这是个唯一的数值。除了GID,每个组还有唯一的组名。Linux系统上有一些组工具可以创建和管理你自己的组。本节将细述组信息是如何保存的,以及如何用组工具创建新组和修改已有的组。</p><p>与用户账户类似,组信息也保存在系统的一个文件中。/etc/group文件包含系统上用到的每个组的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd　wkn　创建新组</span><br><span class="line">groupmod   修改组</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux环境变量</title>
      <link href="/2017/10/01/Linux%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2017/10/01/Linux%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-环境变量"><a href="#Linux-环境变量" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h1><p>很多程序和脚本都通过环境变量来获取系统信息，存储临时数据和配置信息。</p><p>Ubuntu配置文件在 <code>/etc/profile/</code></p><h3 id="什么是环境变量"><a href="#什么是环境变量" class="headerlink" title="什么是环境变量"></a>什么是环境变量</h3><p>bash shell 用一个叫做环境变量的特性来存储有关shell对话和工作环境的信息。这项特性允许你在内存存储数据，以便程序或者shell中运行的脚本能够轻松访问到他们。这也是存储持久数据的一种简便方法。</p><p>两类环境变量</p><ul><li>全局变量</li><li>局部变量</li></ul><a id="more"></a><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>全局环境变量对于shell会话和所有生成的子shell都是可见的，局部变量则只对创建他们的shell可见。</p><p>系统在开始bash会话时就设置了一些全局环境变量，系统全局变量基本全是大写字母以进行区分。</p><p>查看全部变量，可以使用<code>env</code>或者<code>printenv</code> 命令。显示特定的某个环境变量 <code>printenv 变量</code>。</p><p>也可以使用echo 显示变量的值，这种方式必须在变量前加$. 这种方式还可以让变量变成参数。所以可以这样用<code>ls \$ HOME</code>  (没有反斜杠)</p><h4 id="局部环境变量"><a href="#局部环境变量" class="headerlink" title="局部环境变量"></a>局部环境变量</h4><p>局部环境变量只能在定义他们的进程中可见。系统也默认定义了标准的局部环境变量，不过也可以定义自己的局部变量，这些变量被称为用户定义局部变量。</p><p>set命令会显示为某个特定进程设置的所有环境变量，包括局部变量，全局变量以及用户定义变量。</p><h3 id="设置用户定义变量"><a href="#设置用户定义变量" class="headerlink" title="设置用户定义变量"></a>设置用户定义变量</h3><h4 id="设置局部用户自定义变量"><a href="#设置局部用户自定义变量" class="headerlink" title="设置局部用户自定义变量"></a>设置局部用户自定义变量</h4><p>一旦启动了bash shell(或者执行一个shell脚本),就能创建在这个shell进程内可见的局部变量了。可以通过<em>等号</em>给环境变量赋值,值可以是数值或字符串。变量名、等号和值之间没有空格。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> echo $my_variable</span><br><span class="line"><span class="meta">$</span> my_variable="Hello" //有空格的时候必须加引号。</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> echo $my_variable</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><h4 id="设置全局环境变量"><a href="#设置全局环境变量" class="headerlink" title="设置全局环境变量"></a>设置全局环境变量</h4><p>创建全局变量的方法时先创建一个局部环境变量，然后再把它导入到全局环境中。这个过程使用export命令来完成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> my_variable="I am Global now"</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> export my_variable</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> echo $my_variable</span><br><span class="line">I am Global now</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> bash</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> echo $my_variable</span><br><span class="line">I am Global now</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> exit</span><br><span class="line">exit</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> echo $my_variable</span><br><span class="line">I am Global now</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><h4 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h4><p>使用unset命令删除环境变量。使用unset时，不使用$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> echo $my_variable</span><br><span class="line">I am Global now</span><br><span class="line"><span class="meta">$</span> unset my_variable</span><br><span class="line"><span class="meta">$</span> echo $my_variable</span><br></pre></td></tr></table></figure><h3 id="设置PATH环境变量"><a href="#设置PATH环境变量" class="headerlink" title="设置PATH环境变量"></a>设置PATH环境变量</h3><p>当你在shell命令行界面中输入一个外部命令时(参见第5章),shell必须搜索系统来找到对应的程序。PATH环境变量定义了用于进行命令和程序查找的目录。</p><h5 id="添加新目录到path环境变量中"><a href="#添加新目录到path环境变量中" class="headerlink" title="添加新目录到path环境变量中"></a>添加新目录到path环境变量中</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">考下面的例子。</span><br><span class="line"><span class="meta">$</span> echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:</span><br><span class="line">/sbin:/bin:/usr/games:/usr/local/games</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> PATH=$PATH:/home/christine/Scripts</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/ games:/usr/local/games:/home/christine/Scripts</span><br><span class="line"><span class="meta">$</span></span><br><span class="line">要想一直有，还是要导出。</span><br></pre></td></tr></table></figure><p>注销或者重启可以使修改生效，如果要使添加的环境变量马上生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="环境变量文件的更改"><a href="#环境变量文件的更改" class="headerlink" title="环境变量文件的更改"></a>环境变量文件的更改</h3><p>可以直接添加到环境变量<code>PATH</code>中。<code>$PATH</code>表示变量<code>PATH</code>的值，包含已有的目录</p><p>这种方法需要注意路径的顺序，如果遇到有同名的命令，那么<code>PATH</code>里面哪个目录先被查询，则那个目录下的命令就会被先执行<code>:表示分隔符</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 加到PATH末尾</span><br><span class="line">export PATH=$PATH:/path/to/your/dir</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 加到PATH开头</span><br><span class="line">export PATH=/path/to/your/dir:$PATH</span><br></pre></td></tr></table></figure><h3 id="环境变量持久化"><a href="#环境变量持久化" class="headerlink" title="环境变量持久化"></a>环境变量持久化</h3><p>可以利用这些文件创建自己的永久性全局变量或局部变量。对全局环境变量来说(Linux系统中所有用户都需要使用的变量) ,可能更倾向于将新的或修改过的变量设置放在/etc/profile文件中,但这可不是什么好主意。如果你升级了所用的发行版。这个文件也会跟着更新,那你所有定制过的变量设置可就都没有了。<br>最好是在/etc/profile.d目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中。</p><p>在大多数发行版中，存储个人用户永久性bash shell变量的地方是 HOME/.bashrc文件。这一点适用于所有类型的shell进程。但如果设置了 BASH_ENV 变量，那么记住，除非它指向的是$HOME/.bashrc,否则你应该将非交互式shell的用户变量放在别的地方。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Shell</title>
      <link href="/2017/10/01/%E7%90%86%E8%A7%A3Shell/"/>
      <url>/2017/10/01/%E7%90%86%E8%A7%A3Shell/</url>
      
        <content type="html"><![CDATA[<h2 id="理解Shell"><a href="#理解Shell" class="headerlink" title="理解Shell"></a>理解Shell</h2><h4 id="shell类型"><a href="#shell类型" class="headerlink" title="shell类型"></a>shell类型</h4><p>系统启动什么样的shell取决于个人ID配置，在/etc/passwd文件中,在用户ID记<br>录的第7个字段中列出了默认的shell程序。只要用户登录到某个虚拟控制台终端或是在GUI中启动终端仿真器,默认的shell程序就会开始运行。</p><p>可以直接出入命令/bin/dash 启动dash shell . exit 返回。<br><a id="more"></a></p><h3 id="shell的父子关系"><a href="#shell的父子关系" class="headerlink" title="shell的父子关系"></a>shell的父子关系</h3><p>在CLI提示符后输入 /bin/bash 命令或其他等效的 bash 命令时,会创建一个新的shell程序。这个shell程序被称为子shell。子shell也拥有CLI提示符,同样会等待命令输入。</p><p>使用ps -f 命令来查看shell的进程。</p><p>在生成子shell进程时，只有部分父进程的环境被复制到子shell中。</p><h3 id="判断是否生成子shell"><a href="#判断是否生成子shell" class="headerlink" title="判断是否生成子shell"></a>判断是否生成子shell</h3><p>要想知道是否生成了子shell,得借助一个使用了环境变量的命令。这个命令就是echo $BASH_SUBSHELL。如果该命令返回0,就表明没有子shell。如果返回<br>1或者其他更大的数字,就表明存在子shell。</p><h3 id="探索后台模式"><a href="#探索后台模式" class="headerlink" title="探索后台模式"></a>探索后台模式</h3><p>在后台模式中运行命令可以在处理命令的同时让出CLI,以供他用。演示后台模式的一个经典命令就是sleep。典命令就是sleep。sleep命令接受一个参数,该参数是你希望进程等待(睡眠)的秒数。这个命令在脚本中常用于引入一段时间的暂停。命令sleep 10会将会话暂停10秒钟,然后返回shell CLI提示符。</p><p>要想将命令置入后台模式,<em>可以在命令末尾加上字符&amp;</em>。把sleep命令置入后台模式</p><p>使用jobs命令来显示后台作业信息。jobs可以显示当前运行在后台模式中所有用户进程。jobs -i 还可以显示进程的PID。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程可以同时做两件事。它在后台生成一个子shell,并在这个子shell中执行命令。<br>要进行协程处理,得使用coproc命令,还有要在子shell中执行的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> coproc sleep 10</span></span><br><span class="line">[1] 2544</span><br></pre></td></tr></table></figure><p>除了会创建子shell之外,协程基本上就是将命令置入后台模式。当输入coproc命令及其参数之后,你会发现启用了一个后台作业。屏幕上会显示出后台作业号(1)以及进程ID(2544)。<br>jobs命令能够显示出协程的处理状态。</p><h3 id="理解shell内建命令"><a href="#理解shell内建命令" class="headerlink" title="理解shell内建命令"></a>理解shell内建命令</h3><h4 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h4><p>也称为文件系统命令，是存在于bash shell之外的程序，他们并不是shell程序的一部分，外部命令程序通常位于/bin . /usr/bin /sbin/ 或者/usr/sbin中。</p><p>ps 就是一个外部命令，可以使用which或者type找到它。</p><p>当外部命令执行时,会创建出一个子进程。这种操作被称为衍生(forking)。外部命令ps很方便显示出它的父进程以及自己所对应的衍生子进程。</p><p>作为外部命令，PS在执行时会创建出一个子进程。</p><h4 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h4><p>内建命令和外部命令的区别在于前者不需要使用子进程来执行，他们已经和shell编译成了一体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。</p><p>cd 和 exit 命令都内建于bash shell 可以利用type命令来了解某个命令是否时内建的。因为既不需要通过衍生出子进程来执行,也不需要打开程序文件,内建命令的执行速度要更快,效率也更高。要注意,有些命令有多种实现。例如echo和pwd 既有内建命令也有外部命令。两种实现略有不同。要查看命令的不同实现,使用type命令的-a选项。</p><h5 id="history"><a href="#history" class="headerlink" title="history"></a>history</h5><p>一个有用的内建命令是history命令。bash shell会跟踪你用过的命令。你可以唤回这些命令并重新使用。</p><h5 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h5><p>alias命令是另一个shell的内建命令。命令别名允许你为常用的命令(及其参数)创建另一个名称,从而将输入量减少到最低。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias li ='ls -li'</span><br></pre></td></tr></table></figure><p>Linux发行版已经为你设置好了一些常用命令的别名。要查看当前可用的别名,使用alias命令以及选项-p。</p><p>在定义好别名之后,你随时都可以在shell中使用它,就算在shell脚本中也没问题。因为命令别名属于内部命令,一个别名仅在它所被定义的shell进程中才有效。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些bash shell命令</title>
      <link href="/2017/10/01/%E6%9B%B4%E5%A4%9A%E7%9A%84bash%20shell%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/10/01/%E6%9B%B4%E5%A4%9A%E7%9A%84bash%20shell%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="一些bash-shell命令"><a href="#一些bash-shell命令" class="headerlink" title="一些bash shell命令"></a>一些bash shell命令</h2><h3 id="监测程序"><a href="#监测程序" class="headerlink" title="监测程序"></a>监测程序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps命令 查看进程信息。（显示某个特定时间点的信息）</span><br><span class="line">ps -ef 查看系统中运行的所有进程。e显示所有进程 f扩展输出。</span><br><span class="line">ps -l 采用长模式输出</span><br><span class="line"></span><br><span class="line">top命令 查看实时信息</span><br><span class="line">kill 进程pid </span><br><span class="line">killall 支持痛处进程名而不是pid来结束进程。也支持通配符。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="监测磁盘空间"><a href="#监测磁盘空间" class="headerlink" title="监测磁盘空间"></a>监测磁盘空间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Linux文件系统将所有的磁盘都并入一个虚拟目录下，在使用新的存储媒体前，需要把它放到虚拟目录下，这项工作称为挂载。</span><br><span class="line">mount 输出当前系统上挂载的设备列表。</span><br><span class="line">umount 删除一个可移动设备时。</span><br><span class="line">df 查看所有已挂载磁盘的使用情况。</span><br><span class="line">df -h 以易读形式输出。</span><br><span class="line"></span><br><span class="line">du 显示某个特定目录的磁盘使用情况。</span><br></pre></td></tr></table></figure><h3 id="处理数据文件"><a href="#处理数据文件" class="headerlink" title="处理数据文件"></a>处理数据文件</h3><ul><li><p>排序数据</p><p>sort命令对数据进行排序，默认情况下，sort命令会按照会话指定的默认语言的排序规则对文本文件中的数据行排序。-n 参数可以排序数字。-M按月排序。</p></li><li><p>搜索数据</p></li></ul><p>在大文件中找一行数据，可以用grep命令来帮助查找，用法是</p><p>grep[options] pattern [file]</p><p>grep命令会在输入或指定的文件中查找包含匹配指定模式的字符的行。 grep的输出就是包含了匹配模式的行。</p><ul><li>压缩数据</li></ul><p>gzip是Linux上最流行的压缩工具，这个软件包含三个工具（gzip 用来压缩文件 gzcat 用来查看压缩过的文本文件的内容 gunzip用来解压文件）</p><p>gzip 文件名 用来压缩单个文件</p><ul><li>归档数据</li></ul><p>最广泛使用的归档工具是tar命令，</p><p>首先创建一个归档文件，tar -cvf test.tar  test/  test2/，（如果要压缩加上z参数）这条命令创建了名为test.tar的归档文件，含有test和test2目录内容，c是create，v是在处理文件时显示文件，z将输出重定向给gzip命令来压缩内容。f是输出结果到文件或设备file。</p><p>提取时使用 tar -xvf test.tar</p><p><em>以.tgz结尾的文件，是用gzip压缩过的tar文件，用命令 tar -zxvf filename.tgz解压。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql 语句总结 </title>
      <link href="/2017/10/01/sql/"/>
      <url>/2017/10/01/sql/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>; 显示所有数据库</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>; 显示一个数据库中的列表</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> 用于显示服务器状态信息</span><br></pre></td></tr></table></figure><h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h2><h4 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> product; 检索单个列</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> product;检索多个列 </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product; 检索所有列</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">id</span> <span class="keyword">from</span> product 检索不同的行 </span><br><span class="line"></span><br><span class="line">限制结果</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">5</span>;limit 5 指示返回不多于5行</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">5</span>,<span class="number">5</span>;表示从行5开始的接下来5行</span><br><span class="line"></span><br><span class="line">使用完全限定的表名</span><br><span class="line"><span class="keyword">select</span> product.name <span class="keyword">from</span> products;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> product <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>; 根据一个列排序</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,price <span class="keyword">name</span> <span class="keyword">from</span> product <span class="keyword">order</span> <span class="keyword">by</span> price,<span class="keyword">name</span>;根据多个列排序</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,price,<span class="keyword">name</span> <span class="keyword">from</span> prodct <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">DESC</span>, <span class="keyword">name</span>; 指定排序方向</span><br><span class="line"></span><br><span class="line">在给出order by 子句时，应该保证它位于from之后，如果使用limit，则limit位于order by 之后</span><br></pre></td></tr></table></figure><h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,price <span class="keyword">from</span> product <span class="keyword">where</span> price=<span class="number">20</span>; 使用where子句</span><br></pre></td></tr></table></figure><p>where 子句操作符 &lt;&gt;和！= 标识不等于。between 标识指定两个值之间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,price <span class="keyword">from</span> prodct <span class="keyword">where</span> price <span class="keyword">between</span> <span class="number">5</span> <span class="keyword">and</span> <span class="number">10</span>;     between</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="keyword">is</span> <span class="literal">NULL</span>; 空值检查 </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,price,<span class="keyword">name</span> <span class="keyword">from</span> products <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">30</span> <span class="keyword">and</span> price=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,pricee <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">or</span> price=<span class="number">1</span>; 多个where语句用and or 连接。可以用（）改变计算顺序。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,price <span class="keyword">from</span> products <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>;圆括号在where子句的另一种用法</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,price <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">or</span> <span class="keyword">id</span>=<span class="number">2</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>; in 操作符用来指定条件的范围。</span><br><span class="line">上面两句含义相同。</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">in</span> product <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>; not 操作符用来否定后面跟的条件。</span><br></pre></td></tr></table></figure><h2 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h2><p>通配符是用来匹配值的一部分特殊字符。</p><h3 id="like操作符"><a href="#like操作符" class="headerlink" title="like操作符"></a>like操作符</h3><h4 id="通配符"><a href="#通配符" class="headerlink" title="%通配符"></a>%通配符</h4><p>% 表示任何字符出现任意次数(包括0次)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> prodcut <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'jet%'</span>;找出以jet开头的产品。</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> ‘%jet%’; 找出包含jet的产品</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> prodct <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'a%z'</span>; 找出以 a 开头,以 z 结尾的字段。</span><br></pre></td></tr></table></figure><h4 id="通配符-1"><a href="#通配符-1" class="headerlink" title="_通配符"></a>_通配符</h4><p>_用来匹配单个字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'_ jet'</span> 返回了 <span class="number">1</span> jet, <span class="number">2</span> jet 。 （注意空格）</span><br></pre></td></tr></table></figure></p><h2 id="使用正则表达式进行搜索"><a href="#使用正则表达式进行搜索" class="headerlink" title="使用正则表达式进行搜索"></a>使用正则表达式进行搜索</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有 wkn wkn1 wkn2 wkn3 4个数据</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> person <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span><span class="string">'wkn'</span> 找到一个wkn</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> person <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'wkn'</span></span><br><span class="line">找到四个. </span><br><span class="line">所以<span class="keyword">Like</span> 匹配整个列，regexp 在列值内进行匹配。</span><br></pre></td></tr></table></figure><h4 id="基本字符匹配"><a href="#基本字符匹配" class="headerlink" title="基本字符匹配"></a>基本字符匹配</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>，<span class="keyword">name</span> <span class="keyword">from</span> prodct <span class="keyword">where</span> <span class="keyword">name</span> REGEXP <span class="string">'a'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>;检索name中包含a 的所有行</span><br><span class="line">此句子告诉mysql regexp 后跟的东西作为正则表达式</span><br></pre></td></tr></table></figure><p>.在正则表达式中表示匹配任意一个字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">name</span> REGEXP <span class="string">'.0'</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>; 返回了 10，20 两个name.</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">name</span> REGEXP <span class="string">'1000|2000'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>;| 用于搜索两个串之一。</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">name</span> REGEXP ‘[<span class="number">123</span>]<span class="keyword">on</span>’;[]用来匹配中括号中的单一字符。匹配1on,2on,3on;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> priduct <span class="keyword">where</span> <span class="keyword">name</span> REGEXP <span class="string">'[1-3]on'</span>; 相当于 1on,2on,3on; </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> prodcut <span class="keyword">where</span> <span class="keyword">name</span> regep <span class="string">'\\.'</span> 表示查找. 类似，\\- 标识-</span><br></pre></td></tr></table></figure></p><h4 id="匹配多个实例"><a href="#匹配多个实例" class="headerlink" title="匹配多个实例"></a>匹配多个实例</h4><h5 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h5><p>[:alnum:] 任意字母和数字<br>[:alpha:]任意字符<br>[:dight:]任意数字</p><h5 id="重复元字符（匹配前面一个字符）"><a href="#重复元字符（匹配前面一个字符）" class="headerlink" title="重复元字符（匹配前面一个字符）"></a>重复元字符（匹配前面一个字符）</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 0个或者多个匹配</span><br><span class="line"></span><br><span class="line">+ 1个或多个匹配</span><br><span class="line"></span><br><span class="line">？ 0个或者1个匹配</span><br><span class="line"></span><br><span class="line">&#123;n&#125;指定数目的匹配</span><br><span class="line"></span><br><span class="line">&#123;n,&#125;不少于指定数目的匹配</span><br><span class="line"></span><br><span class="line">&#123;n,m&#125;指定的范围</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'\\([0-9] sticks?\\)'</span></span><br><span class="line">\\(匹配（ [<span class="number">0</span><span class="number">-9</span>]匹配任意数字，sticks? 匹配stick 和sticks s后的？使s可选。</span><br></pre></td></tr></table></figure><h5 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h5><p>^ 文本的开始</p><p>$ 文本的结尾</p><p>[[:&lt;:]]词的开始</p><p>[[:&lt;:]]词的结尾<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'^[0-9\\.]'</span></span><br><span class="line">找出以数字或者以.开头的所有信息。</span><br></pre></td></tr></table></figure></p><h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><p>字段 基本与列的意思相同，数据库一般成为列，字段通常用在计算字段的连接上。</p><h3 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h3><p>在mysql的select语句总，可以使用concat()函数来拼接两个列。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="keyword">name</span>, <span class="string">'('</span>, country,<span class="string">')'</span>) <span class="keyword">from</span> prodcut <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>concat((name, ‘(‘, country,’)’)</th></tr></thead><tbody><tr><td>ACE(USA)</td></tr><tr><td>Brett(CHA)</td></tr></tbody></table><h3 id="使用别名AS"><a href="#使用别名AS" class="headerlink" title="使用别名AS"></a>使用别名AS</h3><p>别名是一个字段或者值的替换名，使用as 进行赋予。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="keyword">name</span>, <span class="string">'('</span>, country,<span class="string">')'</span>) <span class="keyword">as</span> aaa <span class="keyword">from</span> prodcut <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,aprice，a*aprice <span class="keyword">as</span> bprice <span class="keyword">from</span> orders <span class="keyword">where</span> <span class="keyword">name</span>=<span class="number">11</span>; 使用算术运算</span><br></pre></td></tr></table></figure><h2 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h2><h4 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">upper</span>(<span class="keyword">name</span>)<span class="keyword">as</span> uname <span class="keyword">from</span> products;</span><br></pre></td></tr></table></figure><ul><li>Left()返回串左边的字符</li><li>length() 返回长度</li><li>locate() 找出串的一个子串</li><li>lower() 将串转换为小写</li><li>ltrim() 去掉左边空格</li><li>upper()转换为大写</li></ul><h4 id="日期时间处理函数-数值处理函数"><a href="#日期时间处理函数-数值处理函数" class="headerlink" title="日期时间处理函数/数值处理函数"></a>日期时间处理函数/数值处理函数</h4><h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><h4 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h4><p>聚集函数运行在行组上，计算和返回单个值的函数。</p><ul><li>AVG() 返回某列的平均值</li><li>COUNT() 返回某列的行数</li><li>MAX() 返回某列的最大值</li><li>MIN() 返回某列的最小值</li><li>SUM() 返回某列值之和</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(price) <span class="keyword">as</span> aprice <span class="keyword">from</span> product ;//返回所有产品的平均价格。</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(price) <span class="keyword">as</span> aprice <span class="keyword">from</span> prodcut <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">3</span>) //返回<span class="number">2</span>和<span class="number">3</span>的平均值</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">as</span> num_cust <span class="keyword">from</span> customers //返回表中的条目数。</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(email) <span class="keyword">as</span> num_email <span class="keyword">from</span> customers//统计有电子邮件的人数</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(price) <span class="keyword">from</span> <span class="keyword">as</span> maxprice <span class="keyword">from</span> product;</span><br><span class="line"><span class="keyword">select</span> sun(quantity) <span class="keyword">from</span> prodcut <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>;//返回指定列值的和。</span><br></pre></td></tr></table></figure><h4 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(<span class="keyword">distinct</span> price) <span class="keyword">as</span> avg_price <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1003</span>;//此平均值只考虑不同的价格。</span><br></pre></td></tr></table></figure><h4 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) ,<span class="keyword">MIN</span>(price),<span class="keyword">MAX</span>(price) <span class="keyword">from</span> product;</span><br></pre></td></tr></table></figure><h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><p>把数据分为多个逻辑组，以便对每个组进行聚集计算。</p><h4 id="创建分组-group-by"><a href="#创建分组-group-by" class="headerlink" title="创建分组 group by"></a>创建分组 group by</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">count</span>(*) <span class="keyword">as</span> num_p <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">num_p</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">8</td></tr></tbody></table><p>使用group by 后，就可以对每个组进行聚集了。</p><h4 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h4><p>where不能完成过滤分组的任务，因为where筛选的行。应该使用having,having 专门用来过滤分组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">count</span>() <span class="keyword">as</span> orders <span class="keyword">from</span> priduct <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>，<span class="keyword">count</span>() <span class="keyword">from</span> product <span class="keyword">where</span> price&gt;<span class="number">10</span> <span class="keyword">group</span> <span class="keyword">by</span> price <span class="keyword">having</span> <span class="keyword">count</span>()&gt;<span class="number">2</span>;//合在一起</span><br></pre></td></tr></table></figure><h2 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h2><p>子查询 即嵌套在其他查询中的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, contanct <span class="keyword">from</span> customers <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span>(<span class="keyword">select</span> cust_id <span class="keyword">from</span> orders <span class="keyword">where</span> order_num <span class="keyword">in</span> (<span class="keyword">select</span> order_num  <span class="keyword">from</span> orderitems <span class="keyword">where</span> pro_id=<span class="number">2</span>));//</span><br><span class="line">利用子查询进行过滤&lt;主要使用IN关键字进行配合&gt;</span><br><span class="line">加入列出订购物品2的所有客户</span><br><span class="line">1）检索包含物品2的所有订单的编号</span><br><span class="line">2）检索具有前一步骤列出订单编号的所有客户ID</span><br><span class="line">3)检索前一步骤返回的所有客户ID的客户信息。</span><br><span class="line">利用子查询组合成一个语句。</span><br></pre></td></tr></table></figure><p>在select语句中，子查询总是从内向外处理。</p><h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><p>关系表的设计就是要保证把信息分解成多个表，一类数据一个表。</p><blockquote><p>外键 ： 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p></blockquote><p>现在有两个表 一个供应商表vend，一个产品表product。供应商表存储供应商信息，每个供应商占一行，唯一的标识就成为主键。产品表只存储产品信息，它除了存储供应商的ID外不存储供应商的其他信息供应商表的主键在产品表中又称为外键。利用供应商ID可以从产品表中找出相应供应商的详细信息。</p><p>如果数据存储在多个表中，怎么用单条select 语句检索出数据。答案是使用联结。<br>1)创建联结 规定要联结的表以及它们如何关联即可。 此处必须使用完全限定列名 ，因为两个表中都有vend_id; (下面的也称为等值联结)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name, pro_name,pro_price <span class="keyword">from</span> vend,products <span class="keyword">where</span> vend.vendid=product.vendid <span class="keyword">order</span> <span class="keyword">by</span> vend_name, pro_name;</span><br></pre></td></tr></table></figure><p>下面的结果同上 两个表的关系是from 子句的组成部分，以INNER JOIN 指定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name,pro_name,pro_price <span class="keyword">from</span> vend <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products <span class="keyword">ON</span> vend.vendid=product.vendid;</span><br></pre></td></tr></table></figure><h4 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pro_name,vend_name,pro_price,quantity <span class="keyword">from</span> orderitems,prodct,vends <span class="keyword">where</span> product.vendid = vend.vendid <span class="keyword">and</span> orderitem.proid=product.proid <span class="keyword">and</span> order_num=<span class="number">25</span>;//此法优于子查询</span><br></pre></td></tr></table></figure><h2 id="高级联结"><a href="#高级联结" class="headerlink" title="高级联结"></a>高级联结</h2><p>除了给列名和计算字段起别名外，还允许对表名起别名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_name ,cust_contact <span class="keyword">from</span> customers <span class="keyword">as</span> c,orders <span class="keyword">as</span> o,orderitems <span class="keyword">as</span> oi <span class="keyword">where</span> c.cust_id=o.cust_id <span class="keyword">and</span> oi.order_num=o.order_num <span class="keyword">and</span> pro_id =<span class="string">'t'</span>;</span><br></pre></td></tr></table></figure><h4 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h4><p>假如你发现某商品(Id为1001) 存在问题，因此想知道生产该商品的生产商生产的其他商品是否存在问题，此查询要求首先找到生产Id为1001 的生产商，然后找出这个供应商生产的其他商品。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pro_id,pro_name <span class="keyword">from</span> product <span class="keyword">where</span> vend_id=(<span class="keyword">select</span> vend_id <span class="keyword">from</span> products <span class="keyword">where</span> pro_id = <span class="number">1001</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> p1.pro_id,p1.pro_name <span class="keyword">from</span> product <span class="keyword">as</span> p1,product <span class="keyword">as</span> p2, <span class="keyword">where</span> p1.vend_id =p2.vend_id <span class="keyword">and</span> p2.pro_id=<span class="number">1001</span>;//使用自联结。一个相同的表两个名称。</span><br></pre></td></tr></table></figure><h4 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h4><p>标准的内部联结返回所有数据，甚至相同的列多次出现，自然联结排序多次出现，使每个列只返回一次。</p><h4 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h4><p>许多联结将一个表中的行与另一个表中的行进行关联，但有时候会需要包含哪些没有关联行的那些行。包含了相关表中没有关联行的联结称为外部联结。</p><p>例如 列出所有产品及订购数量，包括没有人订购的产品。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> customers.cust_id,orders.order_num <span class="keyword">from</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> customers.cust_id=order.cust_id;</span><br></pre></td></tr></table></figure><p>类似内部联结，这条语句使用outer join 指定联结的类型，外部联结还包含了没有关联行的行。在使用outer join时，必须用right或者left指定其所有行的表（right指出的是outer join右边的表，left指出的是outer join 左边的表）上面例子是哦那个left从customer表选择所有行。</p><table><thead><tr><th>a</th><th>id</th><th>name</th><th>b</th><th>id</th><th>job</th><th>parent_id</th></tr></thead><tbody><tr><td></td><td>1</td><td>张三</td><td></td><td>1</td><td>23</td><td>1</td></tr><tr><td></td><td>2</td><td>李四</td><td></td><td>2</td><td>34</td><td>2</td></tr><tr><td></td><td>3</td><td>王五</td><td></td><td>3</td><td>34</td><td>4</td></tr></tbody></table><p>a.id 和 b.parent_id存在关系。</p><p>内联结</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.* ,b.* <span class="keyword">from</span> a <span class="keyword">inner</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id=b.parent_id</span><br></pre></td></tr></table></figure><table><thead><tr><th>张三</th><th>1</th><th>23</th><th>1</th></tr></thead><tbody><tr><td>李四</td><td>2</td><td>34</td><td>2</td></tr></tbody></table><p>左联结(指向a a 是完整的)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,b.* <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id=b.parennt_id</span><br></pre></td></tr></table></figure><table><thead><tr><th>张三</th><th>1</th><th>23</th><th>1</th></tr></thead><tbody><tr><td>李四</td><td>2</td><td>34</td><td>2</td></tr><tr><td>王五</td><td>null</td><td>null</td><td>nill</td></tr></tbody></table><p>右联结（指向b b 是完整的）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,b.* <span class="keyword">from</span> a <span class="keyword">right</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id=b.paren_id</span><br></pre></td></tr></table></figure><table><thead><tr><th>张三</th><th>1</th><th>23</th><th>1</th></tr></thead><tbody><tr><td>李四</td><td>2</td><td>34</td><td>2</td></tr><tr><td>null</td><td>3</td><td>34</td><td>4</td></tr></tbody></table><h2 id="Mysql-NULL-值处理"><a href="#Mysql-NULL-值处理" class="headerlink" title="Mysql NULL 值处理"></a>Mysql NULL 值处理</h2><p>MySQL 使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。</p><p>为了处理这种情况，MySQL提供了三大运算符:</p><ul><li><strong>IS NULL:</strong> 当列的值是 NULL,此运算符返回 true。</li><li><strong>IS NOT NULL:</strong> 当列的值不为 NULL, 运算符返回 true。</li><li><strong>&lt;=&gt;:</strong> 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。</li></ul><p>关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。</p><p>应该使用IS NULL 和 IS NOT NULL 运算符。</p><h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>允许执行多个select语句，并将结果作为单个查询结果集返回。这些组合查询通常成为union 或者复合查询。</p><h4 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h4><p>使用UNION组合数条sql查询 简单组合在一起即可。<br>UNION 从查询结果中自动去除了重复的行 如果不想，可以使用UNION ALL</p><h2 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h2><h2 id="插入数据-insert"><a href="#插入数据-insert" class="headerlink" title="插入数据 /insert"></a>插入数据 /insert</h2><h4 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'wkn'</span>,<span class="string">'Los angeles'</span>)</span><br></pre></td></tr></table></figure><p>每个必须提供一个值，如果没有值的话必须使用NULL。<br>第一列为id,也为NULL,因为该列mysql会自动增量。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers(<span class="keyword">name</span>,address,city) <span class="keyword">values</span>(<span class="string">'wkn'</span>,<span class="string">'sysu'</span>,<span class="string">'GZ'</span>);</span><br></pre></td></tr></table></figure></p><p>&nbsp;此法在表名后面明确的列出了列名，插入行时，会对应的进行插入。这样即使表的结构改变，仍然可以正常工作。</p><h4 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers(<span class="keyword">name</span>,address,city) <span class="keyword">values</span>(<span class="string">'wkn'</span>,<span class="string">'qqq'</span>,<span class="string">'ddd'</span>),(<span class="string">'mmm'</span>,<span class="string">'ds'</span>,<span class="string">'er'</span>);</span><br></pre></td></tr></table></figure><h4 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h4><p>insert 还可以将select 语句的结果直接插入到表中，也就是insert select.</p><h2 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h2><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><ul><li>更新特定行</li><li>更行所有行</li></ul><p>更新由三部分组成，要更新的表，列名和他们的新植，确定要更新行的过滤条件。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> customers <span class="keyword">set</span> email=<span class="string">'www@qq.com'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1005</span>;</span><br></pre></td></tr></table></figure></p><p>update语句总是以要更新的表的名字开始， set命令用来将新值赋给被更新的列。update语句以where子句结束，告诉mysql更新哪一行。没有where子句，就会更新所有行。</p><p>更新多列的语法稍有不同<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> customers <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'wkn'</span>,address=<span class="string">'Golden state'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1005</span>;</span><br></pre></td></tr></table></figure></p><p>为删除某列，可以把值直接置为null.</p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul><li>删除特定行</li><li>删除所有行</li></ul><p>删一行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> customers <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1006</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础积累</title>
      <link href="/2017/09/29/Java%20%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2017/09/29/Java%20%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-常用基础知识"><a href="#Java-常用基础知识" class="headerlink" title="Java 常用基础知识"></a>Java 常用基础知识</h1><p>各种数字类型转换成字符串型： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = String.valueOf( value); <span class="comment">// 其中 value 为任意一种数字类型。</span></span><br></pre></td></tr></table></figure><p>字符串型转换成各种数字类型： </p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"169"</span>; </span><br><span class="line"><span class="keyword">byte</span> b = Byte.parseByte( s ); </span><br><span class="line"><span class="keyword">short</span> t = Short.parseShort( s ); </span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt( s ); </span><br><span class="line"><span class="keyword">long</span> l = Long.parseLong( s ); </span><br><span class="line">Float f = Float.parseFloat( s ); </span><br><span class="line">Double d = Double.parseDouble( s );</span><br></pre></td></tr></table></figure><h5 id="Java中阻塞和等待的区别"><a href="#Java中阻塞和等待的区别" class="headerlink" title="Java中阻塞和等待的区别"></a>Java中阻塞和等待的区别</h5><h5 id="阻塞与等待的区别"><a href="#阻塞与等待的区别" class="headerlink" title="阻塞与等待的区别"></a>阻塞与等待的区别</h5><p>阻塞：当一个线程试图获取对象锁（非java.util.concurrent库中的锁，即synchronized），而该锁被其他线程持有，则该线程进入阻塞状态。它的特点是<strong>使用简单，由JVM调度器来决定唤醒自己，而不需要由另一个线程来显式唤醒自己，不响应中断</strong>。<br>等待：当一个线程等待另一个线程通知调度器一个条件时，该线程进入等待状态。它的特点是<strong>需要等待另一个线程显式地唤醒自己，实现灵活，语义更丰富，可响应中断</strong>。例如调用：Object.wait()、Thread.join()以及等待Lock或Condition。</p><p>　　需要强调的是虽然synchronized和JUC里的Lock都实现锁的功能，但线程进入的状态是不一样的。<strong>synchronized会让线程进入阻塞态，而JUC里的Lock是用LockSupport.park()/unpark()来实现阻塞/唤醒的，会让线程进入等待态</strong>。但话又说回来，虽然等锁时进入的状态不一样，但被唤醒后又都进入runnable态，从行为效果来看又是一样的。</p><h3 id="Java-抽象类"><a href="#Java-抽象类" class="headerlink" title="Java 抽象类"></a>Java 抽象类</h3><p>包含抽象方法的类成为抽象类,但是并不意味着抽象类中只能有抽象方法,它和普通类一样,同样可以拥有成员变量和普通的成员方法 抽象类和普通类的区别主要有三种:</p><ul><li>抽象方法必须为public或者protect,(如果是private,则子类不能继承)</li><li>抽象类不能用来创建对象</li><li>如果一个类继承于一个抽象类,则子类必须实现父类的抽象方法,如果子类没有实现父类的抽象方法,则必须将子类也定义为抽象类.</li></ul><h3 id="Java-泛型类"><a href="#Java-泛型类" class="headerlink" title="Java 泛型类"></a>Java 泛型类</h3><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span></span><br><span class="line">Generic&lt;String&gt; genericString = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"key_vlaue"</span>);</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericInteger.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericString.getKey());</span><br></pre></td></tr></table></figure><p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> Generic(<span class="string">"111111"</span>);</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> Generic(<span class="number">4444</span>);</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> Generic(<span class="number">55.55</span>);</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> Generic(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic1.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic2.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic3.getKey());</span><br><span class="line"></span><br><span class="line">D/泛型测试: key is <span class="number">111111</span></span><br><span class="line">D/泛型测试: key is <span class="number">4444</span></span><br><span class="line">D/泛型测试: key is <span class="number">55.55</span></span><br><span class="line">D/泛型测试: key is <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h2 id="Java中String-StringBuilder-StringBuffer的区别"><a href="#Java中String-StringBuilder-StringBuffer的区别" class="headerlink" title="Java中String,StringBuilder,StringBuffer的区别"></a>Java中String,StringBuilder,StringBuffer的区别</h2><p>这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。</p><h4 id="运行速度"><a href="#运行速度" class="headerlink" title="运行速度"></a>运行速度</h4><ol><li><strong>这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</strong></li></ol><p>String最慢的原因：String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。以下面一段代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str =<span class="string">"abc"</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">str =str+<span class="string">"de"</span>;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</p><p>而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。</p><p>另外，有时候我们会这样对字符串进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"abc"</span>+<span class="string">"de"</span>;</span><br><span class="line">StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder().append(<span class="string">"abc"</span>).append(<span class="string">"de"</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure><p>　　这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和 <code>String str=&quot;abcde&quot;</code>;是完全一样的，所以会很快，而如果写成下面这种形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">"abc"</span>;</span><br><span class="line">String str2=<span class="string">"de"</span>;</span><br><span class="line">String str=str1+str2;</span><br></pre></td></tr></table></figure><p>　　那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。</p><ul><li>线程安全</li></ul><p><strong>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的</strong></p><p>如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p><ol start="3"><li>总结一下</li></ol><p>String：适用于少量的字符串操作的情况</p><p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p><p>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 提交方法</title>
      <link href="/2017/09/26/git%E4%B8%8A%E4%BC%A0/"/>
      <url>/2017/09/26/git%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-配置-git客户端"><a href="#1-配置-git客户端" class="headerlink" title="1 配置 git客户端"></a>1 配置 git客户端</h3><p>git config –global user.name “You Name”<br>git config –global user.email <a href="mailto:yourmail@server.com" target="_blank" rel="noopener">yourmail@server.com</a></p><h3 id="2-注册github密钥"><a href="#2-注册github密钥" class="headerlink" title="2 注册github密钥"></a>2 注册github密钥</h3><p>ssh-keygen -C <a href="mailto:&#39;yourmail@server.com" target="_blank" rel="noopener">&#39;yourmail@server.com</a>‘ -t rsa </p><p>Linux系统的密钥在根目录.ssh 文件夹中。<br><a id="more"></a></p><h3 id="3-github上验证"><a href="#3-github上验证" class="headerlink" title="3 github上验证"></a>3 github上验证</h3><p>回到 GitHub 个人首页，点击 Account Settings -&gt; SSH Public Keys -&gt; Add another public key。title 可以随便取名字，Key 里面添加的内容为 id_rsa.pub 文件内所有的代码。然后点击 Apply 即可。<br>测试与 GitHub 是否连接成功：SSH -v <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p><h3 id="4-github-中创建仓库"><a href="#4-github-中创建仓库" class="headerlink" title="4 github 中创建仓库"></a>4 github 中创建仓库</h3><h3 id="5-本地创建文件"><a href="#5-本地创建文件" class="headerlink" title="5 本地创建文件"></a>5 本地创建文件</h3><h3 id="6-初始化本地git-仓库"><a href="#6-初始化本地git-仓库" class="headerlink" title="6 初始化本地git 仓库"></a>6 初始化本地git 仓库</h3><p>使用 git init 命令</p><h3 id="7-提交到版本库"><a href="#7-提交到版本库" class="headerlink" title="7 提交到版本库"></a>7 提交到版本库</h3><p>git add  git commit -m ‘注释’</p><h3 id="8-关联远程仓库"><a href="#8-关联远程仓库" class="headerlink" title="8 关联远程仓库"></a>8 关联远程仓库</h3><p>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:youusername/test.git</p><h3 id="9-上传到github"><a href="#9-上传到github" class="headerlink" title="9 上传到github"></a>9 上传到github</h3><p>git push -u origin master</p><h3 id="question"><a href="#question" class="headerlink" title="question"></a>question</h3><p>error: failed to push some refs to <a href="mailto:&#39;git@github.com" target="_blank" rel="noopener">&#39;git@github.com</a>:brett427/java.git’</p><p>出现错误的主要原因是github中的README.md文件不在本地代码目录中</p><p>使用git pull – rebase origin master进行合并。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>questions of install hexo </title>
      <link href="/2017/09/22/questions-of-install-hexo/"/>
      <url>/2017/09/22/questions-of-install-hexo/</url>
      
        <content type="html"><![CDATA[<p>重启电脑后hexo 命令找不到：</p><p>解决方法：<br>linux的执行命令都放在 /usr/local/bin<br><a id="more"></a><br>使用 whereis 命令找到npm 的安装位置，找打hexo 使用ln -s 源文件 目标文件 设置软链接 到 usr/local/bin 文件中，就能找到命令了。 </p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> QA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/09/22/hello-world/"/>
      <url>/2017/09/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
